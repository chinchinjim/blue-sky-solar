(()=>{"use strict";var __webpack_modules__={316:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval("\n;// CONCATENATED MODULE: ./node_modules/@firebase/util/dist/index.esm2017.js\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.\r\n */\r\nconst CONSTANTS = {\r\n    /**\r\n     * @define {boolean} Whether this is the client Node.js SDK.\r\n     */\r\n    NODE_CLIENT: false,\r\n    /**\r\n     * @define {boolean} Whether this is the Admin Node.js SDK.\r\n     */\r\n    NODE_ADMIN: false,\r\n    /**\r\n     * Firebase SDK Version\r\n     */\r\n    SDK_VERSION: '${JSCORE_VERSION}'\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Throws an error if the provided assertion is falsy\r\n */\r\nconst index_esm2017_assert = function (assertion, message) {\r\n    if (!assertion) {\r\n        throw assertionError(message);\r\n    }\r\n};\r\n/**\r\n * Returns an Error object suitable for throwing.\r\n */\r\nconst assertionError = function (message) {\r\n    return new Error('Firebase Database (' +\r\n        CONSTANTS.SDK_VERSION +\r\n        ') INTERNAL ASSERT FAILED: ' +\r\n        message);\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst stringToByteArray$1 = function (str) {\r\n    // TODO(user): Use native implementations if/when available\r\n    const out = [];\r\n    let p = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n        let c = str.charCodeAt(i);\r\n        if (c < 128) {\r\n            out[p++] = c;\r\n        }\r\n        else if (c < 2048) {\r\n            out[p++] = (c >> 6) | 192;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n        else if ((c & 0xfc00) === 0xd800 &&\r\n            i + 1 < str.length &&\r\n            (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {\r\n            // Surrogate Pair\r\n            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);\r\n            out[p++] = (c >> 18) | 240;\r\n            out[p++] = ((c >> 12) & 63) | 128;\r\n            out[p++] = ((c >> 6) & 63) | 128;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n        else {\r\n            out[p++] = (c >> 12) | 224;\r\n            out[p++] = ((c >> 6) & 63) | 128;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n    }\r\n    return out;\r\n};\r\n/**\r\n * Turns an array of numbers into the string given by the concatenation of the\r\n * characters to which the numbers correspond.\r\n * @param bytes Array of numbers representing characters.\r\n * @return Stringification of the array.\r\n */\r\nconst byteArrayToString = function (bytes) {\r\n    // TODO(user): Use native implementations if/when available\r\n    const out = [];\r\n    let pos = 0, c = 0;\r\n    while (pos < bytes.length) {\r\n        const c1 = bytes[pos++];\r\n        if (c1 < 128) {\r\n            out[c++] = String.fromCharCode(c1);\r\n        }\r\n        else if (c1 > 191 && c1 < 224) {\r\n            const c2 = bytes[pos++];\r\n            out[c++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));\r\n        }\r\n        else if (c1 > 239 && c1 < 365) {\r\n            // Surrogate Pair\r\n            const c2 = bytes[pos++];\r\n            const c3 = bytes[pos++];\r\n            const c4 = bytes[pos++];\r\n            const u = (((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63)) -\r\n                0x10000;\r\n            out[c++] = String.fromCharCode(0xd800 + (u >> 10));\r\n            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));\r\n        }\r\n        else {\r\n            const c2 = bytes[pos++];\r\n            const c3 = bytes[pos++];\r\n            out[c++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\r\n        }\r\n    }\r\n    return out.join('');\r\n};\r\n// We define it as an object literal instead of a class because a class compiled down to es5 can't\r\n// be treeshaked. https://github.com/rollup/rollup/issues/1691\r\n// Static lookup maps, lazily populated by init_()\r\nconst base64 = {\r\n    /**\r\n     * Maps bytes to characters.\r\n     */\r\n    byteToCharMap_: null,\r\n    /**\r\n     * Maps characters to bytes.\r\n     */\r\n    charToByteMap_: null,\r\n    /**\r\n     * Maps bytes to websafe characters.\r\n     * @private\r\n     */\r\n    byteToCharMapWebSafe_: null,\r\n    /**\r\n     * Maps websafe characters to bytes.\r\n     * @private\r\n     */\r\n    charToByteMapWebSafe_: null,\r\n    /**\r\n     * Our default alphabet, shared between\r\n     * ENCODED_VALS and ENCODED_VALS_WEBSAFE\r\n     */\r\n    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',\r\n    /**\r\n     * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\r\n     */\r\n    get ENCODED_VALS() {\r\n        return this.ENCODED_VALS_BASE + '+/=';\r\n    },\r\n    /**\r\n     * Our websafe alphabet.\r\n     */\r\n    get ENCODED_VALS_WEBSAFE() {\r\n        return this.ENCODED_VALS_BASE + '-_.';\r\n    },\r\n    /**\r\n     * Whether this browser supports the atob and btoa functions. This extension\r\n     * started at Mozilla but is now implemented by many browsers. We use the\r\n     * ASSUME_* variables to avoid pulling in the full useragent detection library\r\n     * but still allowing the standard per-browser compilations.\r\n     *\r\n     */\r\n    HAS_NATIVE_SUPPORT: typeof atob === 'function',\r\n    /**\r\n     * Base64-encode an array of bytes.\r\n     *\r\n     * @param input An array of bytes (numbers with\r\n     *     value in [0, 255]) to encode.\r\n     * @param webSafe Boolean indicating we should use the\r\n     *     alternative alphabet.\r\n     * @return The base64 encoded string.\r\n     */\r\n    encodeByteArray(input, webSafe) {\r\n        if (!Array.isArray(input)) {\r\n            throw Error('encodeByteArray takes an array as a parameter');\r\n        }\r\n        this.init_();\r\n        const byteToCharMap = webSafe\r\n            ? this.byteToCharMapWebSafe_\r\n            : this.byteToCharMap_;\r\n        const output = [];\r\n        for (let i = 0; i < input.length; i += 3) {\r\n            const byte1 = input[i];\r\n            const haveByte2 = i + 1 < input.length;\r\n            const byte2 = haveByte2 ? input[i + 1] : 0;\r\n            const haveByte3 = i + 2 < input.length;\r\n            const byte3 = haveByte3 ? input[i + 2] : 0;\r\n            const outByte1 = byte1 >> 2;\r\n            const outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);\r\n            let outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);\r\n            let outByte4 = byte3 & 0x3f;\r\n            if (!haveByte3) {\r\n                outByte4 = 64;\r\n                if (!haveByte2) {\r\n                    outByte3 = 64;\r\n                }\r\n            }\r\n            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\r\n        }\r\n        return output.join('');\r\n    },\r\n    /**\r\n     * Base64-encode a string.\r\n     *\r\n     * @param input A string to encode.\r\n     * @param webSafe If true, we should use the\r\n     *     alternative alphabet.\r\n     * @return The base64 encoded string.\r\n     */\r\n    encodeString(input, webSafe) {\r\n        // Shortcut for Mozilla browsers that implement\r\n        // a native base64 encoder in the form of \"btoa/atob\"\r\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\r\n            return btoa(input);\r\n        }\r\n        return this.encodeByteArray(stringToByteArray$1(input), webSafe);\r\n    },\r\n    /**\r\n     * Base64-decode a string.\r\n     *\r\n     * @param input to decode.\r\n     * @param webSafe True if we should use the\r\n     *     alternative alphabet.\r\n     * @return string representing the decoded value.\r\n     */\r\n    decodeString(input, webSafe) {\r\n        // Shortcut for Mozilla browsers that implement\r\n        // a native base64 encoder in the form of \"btoa/atob\"\r\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\r\n            return atob(input);\r\n        }\r\n        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));\r\n    },\r\n    /**\r\n     * Base64-decode a string.\r\n     *\r\n     * In base-64 decoding, groups of four characters are converted into three\r\n     * bytes.  If the encoder did not apply padding, the input length may not\r\n     * be a multiple of 4.\r\n     *\r\n     * In this case, the last group will have fewer than 4 characters, and\r\n     * padding will be inferred.  If the group has one or two characters, it decodes\r\n     * to one byte.  If the group has three characters, it decodes to two bytes.\r\n     *\r\n     * @param input Input to decode.\r\n     * @param webSafe True if we should use the web-safe alphabet.\r\n     * @return bytes representing the decoded value.\r\n     */\r\n    decodeStringToByteArray(input, webSafe) {\r\n        this.init_();\r\n        const charToByteMap = webSafe\r\n            ? this.charToByteMapWebSafe_\r\n            : this.charToByteMap_;\r\n        const output = [];\r\n        for (let i = 0; i < input.length;) {\r\n            const byte1 = charToByteMap[input.charAt(i++)];\r\n            const haveByte2 = i < input.length;\r\n            const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\r\n            ++i;\r\n            const haveByte3 = i < input.length;\r\n            const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\r\n            ++i;\r\n            const haveByte4 = i < input.length;\r\n            const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\r\n            ++i;\r\n            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\r\n                throw new DecodeBase64StringError();\r\n            }\r\n            const outByte1 = (byte1 << 2) | (byte2 >> 4);\r\n            output.push(outByte1);\r\n            if (byte3 !== 64) {\r\n                const outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);\r\n                output.push(outByte2);\r\n                if (byte4 !== 64) {\r\n                    const outByte3 = ((byte3 << 6) & 0xc0) | byte4;\r\n                    output.push(outByte3);\r\n                }\r\n            }\r\n        }\r\n        return output;\r\n    },\r\n    /**\r\n     * Lazy static initialization function. Called before\r\n     * accessing any of the static map variables.\r\n     * @private\r\n     */\r\n    init_() {\r\n        if (!this.byteToCharMap_) {\r\n            this.byteToCharMap_ = {};\r\n            this.charToByteMap_ = {};\r\n            this.byteToCharMapWebSafe_ = {};\r\n            this.charToByteMapWebSafe_ = {};\r\n            // We want quick mappings back and forth, so we precompute two maps.\r\n            for (let i = 0; i < this.ENCODED_VALS.length; i++) {\r\n                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\r\n                this.charToByteMap_[this.byteToCharMap_[i]] = i;\r\n                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\r\n                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\r\n                // Be forgiving when decoding and correctly decode both encodings.\r\n                if (i >= this.ENCODED_VALS_BASE.length) {\r\n                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\r\n                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n/**\r\n * An error encountered while decoding base64 string.\r\n */\r\nclass DecodeBase64StringError extends Error {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = 'DecodeBase64StringError';\r\n    }\r\n}\r\n/**\r\n * URL-safe base64 encoding\r\n */\r\nconst base64Encode = function (str) {\r\n    const utf8Bytes = stringToByteArray$1(str);\r\n    return base64.encodeByteArray(utf8Bytes, true);\r\n};\r\n/**\r\n * URL-safe base64 encoding (without \".\" padding in the end).\r\n * e.g. Used in JSON Web Token (JWT) parts.\r\n */\r\nconst base64urlEncodeWithoutPadding = function (str) {\r\n    // Use base64url encoding and remove padding in the end (dot characters).\r\n    return base64Encode(str).replace(/\\./g, '');\r\n};\r\n/**\r\n * URL-safe base64 decoding\r\n *\r\n * NOTE: DO NOT use the global atob() function - it does NOT support the\r\n * base64Url variant encoding.\r\n *\r\n * @param str To be decoded\r\n * @return Decoded result, if possible\r\n */\r\nconst base64Decode = function (str) {\r\n    try {\r\n        return base64.decodeString(str, true);\r\n    }\r\n    catch (e) {\r\n        console.error('base64Decode failed: ', e);\r\n    }\r\n    return null;\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Do a deep-copy of basic JavaScript Objects or Arrays.\r\n */\r\nfunction deepCopy(value) {\r\n    return deepExtend(undefined, value);\r\n}\r\n/**\r\n * Copy properties from source to target (recursively allows extension\r\n * of Objects and Arrays).  Scalar values in the target are over-written.\r\n * If target is undefined, an object of the appropriate type will be created\r\n * (and returned).\r\n *\r\n * We recursively copy all child properties of plain Objects in the source- so\r\n * that namespace- like dictionaries are merged.\r\n *\r\n * Note that the target can be a function, in which case the properties in\r\n * the source Object are copied onto it as static properties of the Function.\r\n *\r\n * Note: we don't merge __proto__ to prevent prototype pollution\r\n */\r\nfunction deepExtend(target, source) {\r\n    if (!(source instanceof Object)) {\r\n        return source;\r\n    }\r\n    switch (source.constructor) {\r\n        case Date:\r\n            // Treat Dates like scalars; if the target date object had any child\r\n            // properties - they will be lost!\r\n            const dateValue = source;\r\n            return new Date(dateValue.getTime());\r\n        case Object:\r\n            if (target === undefined) {\r\n                target = {};\r\n            }\r\n            break;\r\n        case Array:\r\n            // Always copy the array source and overwrite the target.\r\n            target = [];\r\n            break;\r\n        default:\r\n            // Not a plain Object - treat it as a scalar.\r\n            return source;\r\n    }\r\n    for (const prop in source) {\r\n        // use isValidKey to guard against prototype pollution. See https://snyk.io/vuln/SNYK-JS-LODASH-450202\r\n        if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {\r\n            continue;\r\n        }\r\n        target[prop] = deepExtend(target[prop], source[prop]);\r\n    }\r\n    return target;\r\n}\r\nfunction isValidKey(key) {\r\n    return key !== '__proto__';\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Polyfill for `globalThis` object.\r\n * @returns the `globalThis` object for the given environment.\r\n * @public\r\n */\r\nfunction getGlobal() {\r\n    if (typeof self !== 'undefined') {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined') {\r\n        return window;\r\n    }\r\n    if (typeof __webpack_require__.g !== 'undefined') {\r\n        return __webpack_require__.g;\r\n    }\r\n    throw new Error('Unable to locate global object.');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__;\r\n/**\r\n * Attempt to read defaults from a JSON string provided to\r\n * process(.)env(.)__FIREBASE_DEFAULTS__ or a JSON file whose path is in\r\n * process(.)env(.)__FIREBASE_DEFAULTS_PATH__\r\n * The dots are in parens because certain compilers (Vite?) cannot\r\n * handle seeing that variable in comments.\r\n * See https://github.com/firebase/firebase-js-sdk/issues/6838\r\n */\r\nconst getDefaultsFromEnvVariable = () => {\r\n    if (typeof process === 'undefined' || typeof process.env === 'undefined') {\r\n        return;\r\n    }\r\n    const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;\r\n    if (defaultsJsonString) {\r\n        return JSON.parse(defaultsJsonString);\r\n    }\r\n};\r\nconst getDefaultsFromCookie = () => {\r\n    if (typeof document === 'undefined') {\r\n        return;\r\n    }\r\n    let match;\r\n    try {\r\n        match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);\r\n    }\r\n    catch (e) {\r\n        // Some environments such as Angular Universal SSR have a\r\n        // `document` object but error on accessing `document.cookie`.\r\n        return;\r\n    }\r\n    const decoded = match && base64Decode(match[1]);\r\n    return decoded && JSON.parse(decoded);\r\n};\r\n/**\r\n * Get the __FIREBASE_DEFAULTS__ object. It checks in order:\r\n * (1) if such an object exists as a property of `globalThis`\r\n * (2) if such an object was provided on a shell environment variable\r\n * (3) if such an object exists in a cookie\r\n * @public\r\n */\r\nconst getDefaults = () => {\r\n    try {\r\n        return (getDefaultsFromGlobal() ||\r\n            getDefaultsFromEnvVariable() ||\r\n            getDefaultsFromCookie());\r\n    }\r\n    catch (e) {\r\n        /**\r\n         * Catch-all for being unable to get __FIREBASE_DEFAULTS__ due\r\n         * to any environment case we have not accounted for. Log to\r\n         * info instead of swallowing so we can find these unknown cases\r\n         * and add paths for them if needed.\r\n         */\r\n        console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);\r\n        return;\r\n    }\r\n};\r\n/**\r\n * Returns emulator host stored in the __FIREBASE_DEFAULTS__ object\r\n * for the given product.\r\n * @returns a URL host formatted like `127.0.0.1:9999` or `[::1]:4000` if available\r\n * @public\r\n */\r\nconst getDefaultEmulatorHost = (productName) => { var _a, _b; return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName]; };\r\n/**\r\n * Returns emulator hostname and port stored in the __FIREBASE_DEFAULTS__ object\r\n * for the given product.\r\n * @returns a pair of hostname and port like `[\"::1\", 4000]` if available\r\n * @public\r\n */\r\nconst getDefaultEmulatorHostnameAndPort = (productName) => {\r\n    const host = getDefaultEmulatorHost(productName);\r\n    if (!host) {\r\n        return undefined;\r\n    }\r\n    const separatorIndex = host.lastIndexOf(':'); // Finding the last since IPv6 addr also has colons.\r\n    if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {\r\n        throw new Error(`Invalid host ${host} with no separate hostname and port!`);\r\n    }\r\n    // eslint-disable-next-line no-restricted-globals\r\n    const port = parseInt(host.substring(separatorIndex + 1), 10);\r\n    if (host[0] === '[') {\r\n        // Bracket-quoted `[ipv6addr]:port` => return \"ipv6addr\" (without brackets).\r\n        return [host.substring(1, separatorIndex - 1), port];\r\n    }\r\n    else {\r\n        return [host.substring(0, separatorIndex), port];\r\n    }\r\n};\r\n/**\r\n * Returns Firebase app config stored in the __FIREBASE_DEFAULTS__ object.\r\n * @public\r\n */\r\nconst getDefaultAppConfig = () => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config; };\r\n/**\r\n * Returns an experimental setting on the __FIREBASE_DEFAULTS__ object (properties\r\n * prefixed by \"_\")\r\n * @public\r\n */\r\nconst getExperimentalSetting = (name) => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a[`_${name}`]; };\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass index_esm2017_Deferred {\r\n    constructor() {\r\n        this.reject = () => { };\r\n        this.resolve = () => { };\r\n        this.promise = new Promise((resolve, reject) => {\r\n            this.resolve = resolve;\r\n            this.reject = reject;\r\n        });\r\n    }\r\n    /**\r\n     * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around\r\n     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\r\n     * and returns a node-style callback which will resolve or reject the Deferred's promise.\r\n     */\r\n    wrapCallback(callback) {\r\n        return (error, value) => {\r\n            if (error) {\r\n                this.reject(error);\r\n            }\r\n            else {\r\n                this.resolve(value);\r\n            }\r\n            if (typeof callback === 'function') {\r\n                // Attaching noop handler just in case developer wasn't expecting\r\n                // promises\r\n                this.promise.catch(() => { });\r\n                // Some of our callbacks don't expect a value and our own tests\r\n                // assert that the parameter length is 1\r\n                if (callback.length === 1) {\r\n                    callback(error);\r\n                }\r\n                else {\r\n                    callback(error, value);\r\n                }\r\n            }\r\n        };\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction createMockUserToken(token, projectId) {\r\n    if (token.uid) {\r\n        throw new Error('The \"uid\" field is no longer supported by mockUserToken. Please use \"sub\" instead for Firebase Auth User ID.');\r\n    }\r\n    // Unsecured JWTs use \"none\" as the algorithm.\r\n    const header = {\r\n        alg: 'none',\r\n        type: 'JWT'\r\n    };\r\n    const project = projectId || 'demo-project';\r\n    const iat = token.iat || 0;\r\n    const sub = token.sub || token.user_id;\r\n    if (!sub) {\r\n        throw new Error(\"mockUserToken must contain 'sub' or 'user_id' field!\");\r\n    }\r\n    const payload = Object.assign({ \r\n        // Set all required fields to decent defaults\r\n        iss: `https://securetoken.google.com/${project}`, aud: project, iat, exp: iat + 3600, auth_time: iat, sub, user_id: sub, firebase: {\r\n            sign_in_provider: 'custom',\r\n            identities: {}\r\n        } }, token);\r\n    // Unsecured JWTs use the empty string as a signature.\r\n    const signature = '';\r\n    return [\r\n        base64urlEncodeWithoutPadding(JSON.stringify(header)),\r\n        base64urlEncodeWithoutPadding(JSON.stringify(payload)),\r\n        signature\r\n    ].join('.');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns navigator.userAgent string or '' if it's not defined.\r\n * @return user agent string\r\n */\r\nfunction getUA() {\r\n    if (typeof navigator !== 'undefined' &&\r\n        typeof navigator['userAgent'] === 'string') {\r\n        return navigator['userAgent'];\r\n    }\r\n    else {\r\n        return '';\r\n    }\r\n}\r\n/**\r\n * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.\r\n *\r\n * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap\r\n * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally\r\n * wait for a callback.\r\n */\r\nfunction isMobileCordova() {\r\n    return (typeof window !== 'undefined' &&\r\n        // @ts-ignore Setting up an broadly applicable index signature for Window\r\n        // just to deal with this case would probably be a bad idea.\r\n        !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) &&\r\n        /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA()));\r\n}\r\n/**\r\n * Detect Node.js.\r\n *\r\n * @return true if Node.js environment is detected or specified.\r\n */\r\n// Node detection logic from: https://github.com/iliakan/detect-node/\r\nfunction isNode() {\r\n    var _a;\r\n    const forceEnvironment = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.forceEnvironment;\r\n    if (forceEnvironment === 'node') {\r\n        return true;\r\n    }\r\n    else if (forceEnvironment === 'browser') {\r\n        return false;\r\n    }\r\n    try {\r\n        return (Object.prototype.toString.call(__webpack_require__.g.process) === '[object process]');\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Detect Browser Environment\r\n */\r\nfunction index_esm2017_isBrowser() {\r\n    return typeof window !== 'undefined' || index_esm2017_isWebWorker();\r\n}\r\n/**\r\n * Detect Web Worker context\r\n */\r\nfunction index_esm2017_isWebWorker() {\r\n    return (typeof WorkerGlobalScope !== 'undefined' &&\r\n        typeof self !== 'undefined' &&\r\n        self instanceof WorkerGlobalScope);\r\n}\r\nfunction isBrowserExtension() {\r\n    const runtime = typeof chrome === 'object'\r\n        ? chrome.runtime\r\n        : typeof browser === 'object'\r\n            ? browser.runtime\r\n            : undefined;\r\n    return typeof runtime === 'object' && runtime.id !== undefined;\r\n}\r\n/**\r\n * Detect React Native.\r\n *\r\n * @return true if ReactNative environment is detected.\r\n */\r\nfunction isReactNative() {\r\n    return (typeof navigator === 'object' && navigator['product'] === 'ReactNative');\r\n}\r\n/** Detects Electron apps. */\r\nfunction isElectron() {\r\n    return getUA().indexOf('Electron/') >= 0;\r\n}\r\n/** Detects Internet Explorer. */\r\nfunction isIE() {\r\n    const ua = getUA();\r\n    return ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;\r\n}\r\n/** Detects Universal Windows Platform apps. */\r\nfunction isUWP() {\r\n    return getUA().indexOf('MSAppHost/') >= 0;\r\n}\r\n/**\r\n * Detect whether the current SDK build is the Node version.\r\n *\r\n * @return true if it's the Node SDK build.\r\n */\r\nfunction isNodeSdk() {\r\n    return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;\r\n}\r\n/** Returns true if we are running in Safari. */\r\nfunction isSafari() {\r\n    return (!isNode() &&\r\n        !!navigator.userAgent &&\r\n        navigator.userAgent.includes('Safari') &&\r\n        !navigator.userAgent.includes('Chrome'));\r\n}\r\n/**\r\n * This method checks if indexedDB is supported by current browser/service worker context\r\n * @return true if indexedDB is supported by current browser/service worker context\r\n */\r\nfunction isIndexedDBAvailable() {\r\n    try {\r\n        return typeof indexedDB === 'object';\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject\r\n * if errors occur during the database open operation.\r\n *\r\n * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox\r\n * private browsing)\r\n */\r\nfunction validateIndexedDBOpenable() {\r\n    return new Promise((resolve, reject) => {\r\n        try {\r\n            let preExist = true;\r\n            const DB_CHECK_NAME = 'validate-browser-context-for-indexeddb-analytics-module';\r\n            const request = self.indexedDB.open(DB_CHECK_NAME);\r\n            request.onsuccess = () => {\r\n                request.result.close();\r\n                // delete database only when it doesn't pre-exist\r\n                if (!preExist) {\r\n                    self.indexedDB.deleteDatabase(DB_CHECK_NAME);\r\n                }\r\n                resolve(true);\r\n            };\r\n            request.onupgradeneeded = () => {\r\n                preExist = false;\r\n            };\r\n            request.onerror = () => {\r\n                var _a;\r\n                reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || '');\r\n            };\r\n        }\r\n        catch (error) {\r\n            reject(error);\r\n        }\r\n    });\r\n}\r\n/**\r\n *\r\n * This method checks whether cookie is enabled within current browser\r\n * @return true if cookie is enabled within current browser\r\n */\r\nfunction areCookiesEnabled() {\r\n    if (typeof navigator === 'undefined' || !navigator.cookieEnabled) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @fileoverview Standardized Firebase Error.\r\n *\r\n * Usage:\r\n *\r\n *   // Typescript string literals for type-safe codes\r\n *   type Err =\r\n *     'unknown' |\r\n *     'object-not-found'\r\n *     ;\r\n *\r\n *   // Closure enum for type-safe error codes\r\n *   // at-enum {string}\r\n *   var Err = {\r\n *     UNKNOWN: 'unknown',\r\n *     OBJECT_NOT_FOUND: 'object-not-found',\r\n *   }\r\n *\r\n *   let errors: Map<Err, string> = {\r\n *     'generic-error': \"Unknown error\",\r\n *     'file-not-found': \"Could not find file: {$file}\",\r\n *   };\r\n *\r\n *   // Type-safe function - must pass a valid error code as param.\r\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\r\n *\r\n *   ...\r\n *   throw error.create(Err.GENERIC);\r\n *   ...\r\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\r\n *   ...\r\n *   // Service: Could not file file: foo.txt (service/file-not-found).\r\n *\r\n *   catch (e) {\r\n *     assert(e.message === \"Could not find file: foo.txt.\");\r\n *     if ((e as FirebaseError)?.code === 'service/file-not-found') {\r\n *       console.log(\"Could not read file: \" + e['file']);\r\n *     }\r\n *   }\r\n */\r\nconst ERROR_NAME = 'FirebaseError';\r\n// Based on code from:\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types\r\nclass FirebaseError extends Error {\r\n    constructor(\r\n    /** The error code for this error. */\r\n    code, message, \r\n    /** Custom data for this error. */\r\n    customData) {\r\n        super(message);\r\n        this.code = code;\r\n        this.customData = customData;\r\n        /** The custom name for all FirebaseErrors. */\r\n        this.name = ERROR_NAME;\r\n        // Fix For ES5\r\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, FirebaseError.prototype);\r\n        // Maintains proper stack trace for where our error was thrown.\r\n        // Only available on V8.\r\n        if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(this, ErrorFactory.prototype.create);\r\n        }\r\n    }\r\n}\r\nclass ErrorFactory {\r\n    constructor(service, serviceName, errors) {\r\n        this.service = service;\r\n        this.serviceName = serviceName;\r\n        this.errors = errors;\r\n    }\r\n    create(code, ...data) {\r\n        const customData = data[0] || {};\r\n        const fullCode = `${this.service}/${code}`;\r\n        const template = this.errors[code];\r\n        const message = template ? replaceTemplate(template, customData) : 'Error';\r\n        // Service Name: Error message (service/code).\r\n        const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;\r\n        const error = new FirebaseError(fullCode, fullMessage, customData);\r\n        return error;\r\n    }\r\n}\r\nfunction replaceTemplate(template, data) {\r\n    return template.replace(PATTERN, (_, key) => {\r\n        const value = data[key];\r\n        return value != null ? String(value) : `<${key}?>`;\r\n    });\r\n}\r\nconst PATTERN = /\\{\\$([^}]+)}/g;\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Evaluates a JSON string into a javascript object.\r\n *\r\n * @param {string} str A string containing JSON.\r\n * @return {*} The javascript object representing the specified JSON.\r\n */\r\nfunction jsonEval(str) {\r\n    return JSON.parse(str);\r\n}\r\n/**\r\n * Returns JSON representing a javascript object.\r\n * @param {*} data Javascript object to be stringified.\r\n * @return {string} The JSON contents of the object.\r\n */\r\nfunction index_esm2017_stringify(data) {\r\n    return JSON.stringify(data);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Decodes a Firebase auth. token into constituent parts.\r\n *\r\n * Notes:\r\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nconst decode = function (token) {\r\n    let header = {}, claims = {}, data = {}, signature = '';\r\n    try {\r\n        const parts = token.split('.');\r\n        header = jsonEval(base64Decode(parts[0]) || '');\r\n        claims = jsonEval(base64Decode(parts[1]) || '');\r\n        signature = parts[2];\r\n        data = claims['d'] || {};\r\n        delete claims['d'];\r\n    }\r\n    catch (e) { }\r\n    return {\r\n        header,\r\n        claims,\r\n        data,\r\n        signature\r\n    };\r\n};\r\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\r\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nconst isValidTimestamp = function (token) {\r\n    const claims = decode(token).claims;\r\n    const now = Math.floor(new Date().getTime() / 1000);\r\n    let validSince = 0, validUntil = 0;\r\n    if (typeof claims === 'object') {\r\n        if (claims.hasOwnProperty('nbf')) {\r\n            validSince = claims['nbf'];\r\n        }\r\n        else if (claims.hasOwnProperty('iat')) {\r\n            validSince = claims['iat'];\r\n        }\r\n        if (claims.hasOwnProperty('exp')) {\r\n            validUntil = claims['exp'];\r\n        }\r\n        else {\r\n            // token will expire after 24h by default\r\n            validUntil = validSince + 86400;\r\n        }\r\n    }\r\n    return (!!now &&\r\n        !!validSince &&\r\n        !!validUntil &&\r\n        now >= validSince &&\r\n        now <= validUntil);\r\n};\r\n/**\r\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\r\n *\r\n * Notes:\r\n * - May return null if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nconst issuedAtTime = function (token) {\r\n    const claims = decode(token).claims;\r\n    if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {\r\n        return claims['iat'];\r\n    }\r\n    return null;\r\n};\r\n/**\r\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nconst isValidFormat = function (token) {\r\n    const decoded = decode(token), claims = decoded.claims;\r\n    return !!claims && typeof claims === 'object' && claims.hasOwnProperty('iat');\r\n};\r\n/**\r\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\r\n *\r\n * Notes:\r\n * - May return a false negative if there's no native base64 decoding support.\r\n * - Doesn't check if the token is actually valid.\r\n */\r\nconst isAdmin = function (token) {\r\n    const claims = decode(token).claims;\r\n    return typeof claims === 'object' && claims['admin'] === true;\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction index_esm2017_contains(obj, key) {\r\n    return Object.prototype.hasOwnProperty.call(obj, key);\r\n}\r\nfunction index_esm2017_safeGet(obj, key) {\r\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n        return obj[key];\r\n    }\r\n    else {\r\n        return undefined;\r\n    }\r\n}\r\nfunction index_esm2017_isEmpty(obj) {\r\n    for (const key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction map(obj, fn, contextObj) {\r\n    const res = {};\r\n    for (const key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            res[key] = fn.call(contextObj, obj[key], key, obj);\r\n        }\r\n    }\r\n    return res;\r\n}\r\n/**\r\n * Deep equal two objects. Support Arrays and Objects.\r\n */\r\nfunction deepEqual(a, b) {\r\n    if (a === b) {\r\n        return true;\r\n    }\r\n    const aKeys = Object.keys(a);\r\n    const bKeys = Object.keys(b);\r\n    for (const k of aKeys) {\r\n        if (!bKeys.includes(k)) {\r\n            return false;\r\n        }\r\n        const aProp = a[k];\r\n        const bProp = b[k];\r\n        if (isObject(aProp) && isObject(bProp)) {\r\n            if (!deepEqual(aProp, bProp)) {\r\n                return false;\r\n            }\r\n        }\r\n        else if (aProp !== bProp) {\r\n            return false;\r\n        }\r\n    }\r\n    for (const k of bKeys) {\r\n        if (!aKeys.includes(k)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction isObject(thing) {\r\n    return thing !== null && typeof thing === 'object';\r\n}\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Rejects if the given promise doesn't resolve in timeInMS milliseconds.\r\n * @internal\r\n */\r\nfunction promiseWithTimeout(promise, timeInMS = 2000) {\r\n    const deferredPromise = new index_esm2017_Deferred();\r\n    setTimeout(() => deferredPromise.reject('timeout!'), timeInMS);\r\n    promise.then(deferredPromise.resolve, deferredPromise.reject);\r\n    return deferredPromise.promise;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a\r\n * params object (e.g. {arg: 'val', arg2: 'val2'})\r\n * Note: You must prepend it with ? when adding it to a URL.\r\n */\r\nfunction querystring(querystringParams) {\r\n    const params = [];\r\n    for (const [key, value] of Object.entries(querystringParams)) {\r\n        if (Array.isArray(value)) {\r\n            value.forEach(arrayVal => {\r\n                params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));\r\n            });\r\n        }\r\n        else {\r\n            params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\r\n        }\r\n    }\r\n    return params.length ? '&' + params.join('&') : '';\r\n}\r\n/**\r\n * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object\r\n * (e.g. {arg: 'val', arg2: 'val2'})\r\n */\r\nfunction querystringDecode(querystring) {\r\n    const obj = {};\r\n    const tokens = querystring.replace(/^\\?/, '').split('&');\r\n    tokens.forEach(token => {\r\n        if (token) {\r\n            const [key, value] = token.split('=');\r\n            obj[decodeURIComponent(key)] = decodeURIComponent(value);\r\n        }\r\n    });\r\n    return obj;\r\n}\r\n/**\r\n * Extract the query string part of a URL, including the leading question mark (if present).\r\n */\r\nfunction extractQuerystring(url) {\r\n    const queryStart = url.indexOf('?');\r\n    if (!queryStart) {\r\n        return '';\r\n    }\r\n    const fragmentStart = url.indexOf('#', queryStart);\r\n    return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : undefined);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @fileoverview SHA-1 cryptographic hash.\r\n * Variable names follow the notation in FIPS PUB 180-3:\r\n * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.\r\n *\r\n * Usage:\r\n *   var sha1 = new sha1();\r\n *   sha1.update(bytes);\r\n *   var hash = sha1.digest();\r\n *\r\n * Performance:\r\n *   Chrome 23:   ~400 Mbit/s\r\n *   Firefox 16:  ~250 Mbit/s\r\n *\r\n */\r\n/**\r\n * SHA-1 cryptographic hash constructor.\r\n *\r\n * The properties declared here are discussed in the above algorithm document.\r\n * @constructor\r\n * @final\r\n * @struct\r\n */\r\nclass Sha1 {\r\n    constructor() {\r\n        /**\r\n         * Holds the previous values of accumulated variables a-e in the compress_\r\n         * function.\r\n         * @private\r\n         */\r\n        this.chain_ = [];\r\n        /**\r\n         * A buffer holding the partially computed hash result.\r\n         * @private\r\n         */\r\n        this.buf_ = [];\r\n        /**\r\n         * An array of 80 bytes, each a part of the message to be hashed.  Referred to\r\n         * as the message schedule in the docs.\r\n         * @private\r\n         */\r\n        this.W_ = [];\r\n        /**\r\n         * Contains data needed to pad messages less than 64 bytes.\r\n         * @private\r\n         */\r\n        this.pad_ = [];\r\n        /**\r\n         * @private {number}\r\n         */\r\n        this.inbuf_ = 0;\r\n        /**\r\n         * @private {number}\r\n         */\r\n        this.total_ = 0;\r\n        this.blockSize = 512 / 8;\r\n        this.pad_[0] = 128;\r\n        for (let i = 1; i < this.blockSize; ++i) {\r\n            this.pad_[i] = 0;\r\n        }\r\n        this.reset();\r\n    }\r\n    reset() {\r\n        this.chain_[0] = 0x67452301;\r\n        this.chain_[1] = 0xefcdab89;\r\n        this.chain_[2] = 0x98badcfe;\r\n        this.chain_[3] = 0x10325476;\r\n        this.chain_[4] = 0xc3d2e1f0;\r\n        this.inbuf_ = 0;\r\n        this.total_ = 0;\r\n    }\r\n    /**\r\n     * Internal compress helper function.\r\n     * @param buf Block to compress.\r\n     * @param offset Offset of the block in the buffer.\r\n     * @private\r\n     */\r\n    compress_(buf, offset) {\r\n        if (!offset) {\r\n            offset = 0;\r\n        }\r\n        const W = this.W_;\r\n        // get 16 big endian words\r\n        if (typeof buf === 'string') {\r\n            for (let i = 0; i < 16; i++) {\r\n                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS\r\n                // have a bug that turns the post-increment ++ operator into pre-increment\r\n                // during JIT compilation.  We have code that depends heavily on SHA-1 for\r\n                // correctness and which is affected by this bug, so I've removed all uses\r\n                // of post-increment ++ in which the result value is used.  We can revert\r\n                // this change once the Safari bug\r\n                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and\r\n                // most clients have been updated.\r\n                W[i] =\r\n                    (buf.charCodeAt(offset) << 24) |\r\n                        (buf.charCodeAt(offset + 1) << 16) |\r\n                        (buf.charCodeAt(offset + 2) << 8) |\r\n                        buf.charCodeAt(offset + 3);\r\n                offset += 4;\r\n            }\r\n        }\r\n        else {\r\n            for (let i = 0; i < 16; i++) {\r\n                W[i] =\r\n                    (buf[offset] << 24) |\r\n                        (buf[offset + 1] << 16) |\r\n                        (buf[offset + 2] << 8) |\r\n                        buf[offset + 3];\r\n                offset += 4;\r\n            }\r\n        }\r\n        // expand to 80 words\r\n        for (let i = 16; i < 80; i++) {\r\n            const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\r\n            W[i] = ((t << 1) | (t >>> 31)) & 0xffffffff;\r\n        }\r\n        let a = this.chain_[0];\r\n        let b = this.chain_[1];\r\n        let c = this.chain_[2];\r\n        let d = this.chain_[3];\r\n        let e = this.chain_[4];\r\n        let f, k;\r\n        // TODO(user): Try to unroll this loop to speed up the computation.\r\n        for (let i = 0; i < 80; i++) {\r\n            if (i < 40) {\r\n                if (i < 20) {\r\n                    f = d ^ (b & (c ^ d));\r\n                    k = 0x5a827999;\r\n                }\r\n                else {\r\n                    f = b ^ c ^ d;\r\n                    k = 0x6ed9eba1;\r\n                }\r\n            }\r\n            else {\r\n                if (i < 60) {\r\n                    f = (b & c) | (d & (b | c));\r\n                    k = 0x8f1bbcdc;\r\n                }\r\n                else {\r\n                    f = b ^ c ^ d;\r\n                    k = 0xca62c1d6;\r\n                }\r\n            }\r\n            const t = (((a << 5) | (a >>> 27)) + f + e + k + W[i]) & 0xffffffff;\r\n            e = d;\r\n            d = c;\r\n            c = ((b << 30) | (b >>> 2)) & 0xffffffff;\r\n            b = a;\r\n            a = t;\r\n        }\r\n        this.chain_[0] = (this.chain_[0] + a) & 0xffffffff;\r\n        this.chain_[1] = (this.chain_[1] + b) & 0xffffffff;\r\n        this.chain_[2] = (this.chain_[2] + c) & 0xffffffff;\r\n        this.chain_[3] = (this.chain_[3] + d) & 0xffffffff;\r\n        this.chain_[4] = (this.chain_[4] + e) & 0xffffffff;\r\n    }\r\n    update(bytes, length) {\r\n        // TODO(johnlenz): tighten the function signature and remove this check\r\n        if (bytes == null) {\r\n            return;\r\n        }\r\n        if (length === undefined) {\r\n            length = bytes.length;\r\n        }\r\n        const lengthMinusBlock = length - this.blockSize;\r\n        let n = 0;\r\n        // Using local instead of member variables gives ~5% speedup on Firefox 16.\r\n        const buf = this.buf_;\r\n        let inbuf = this.inbuf_;\r\n        // The outer while loop should execute at most twice.\r\n        while (n < length) {\r\n            // When we have no data in the block to top up, we can directly process the\r\n            // input buffer (assuming it contains sufficient data). This gives ~25%\r\n            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that\r\n            // the data is provided in large chunks (or in multiples of 64 bytes).\r\n            if (inbuf === 0) {\r\n                while (n <= lengthMinusBlock) {\r\n                    this.compress_(bytes, n);\r\n                    n += this.blockSize;\r\n                }\r\n            }\r\n            if (typeof bytes === 'string') {\r\n                while (n < length) {\r\n                    buf[inbuf] = bytes.charCodeAt(n);\r\n                    ++inbuf;\r\n                    ++n;\r\n                    if (inbuf === this.blockSize) {\r\n                        this.compress_(buf);\r\n                        inbuf = 0;\r\n                        // Jump to the outer loop so we use the full-block optimization.\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                while (n < length) {\r\n                    buf[inbuf] = bytes[n];\r\n                    ++inbuf;\r\n                    ++n;\r\n                    if (inbuf === this.blockSize) {\r\n                        this.compress_(buf);\r\n                        inbuf = 0;\r\n                        // Jump to the outer loop so we use the full-block optimization.\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.inbuf_ = inbuf;\r\n        this.total_ += length;\r\n    }\r\n    /** @override */\r\n    digest() {\r\n        const digest = [];\r\n        let totalBits = this.total_ * 8;\r\n        // Add pad 0x80 0x00*.\r\n        if (this.inbuf_ < 56) {\r\n            this.update(this.pad_, 56 - this.inbuf_);\r\n        }\r\n        else {\r\n            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));\r\n        }\r\n        // Add # bits.\r\n        for (let i = this.blockSize - 1; i >= 56; i--) {\r\n            this.buf_[i] = totalBits & 255;\r\n            totalBits /= 256; // Don't use bit-shifting here!\r\n        }\r\n        this.compress_(this.buf_);\r\n        let n = 0;\r\n        for (let i = 0; i < 5; i++) {\r\n            for (let j = 24; j >= 0; j -= 8) {\r\n                digest[n] = (this.chain_[i] >> j) & 255;\r\n                ++n;\r\n            }\r\n        }\r\n        return digest;\r\n    }\r\n}\n\n/**\r\n * Helper to make a Subscribe function (just like Promise helps make a\r\n * Thenable).\r\n *\r\n * @param executor Function which can make calls to a single Observer\r\n *     as a proxy.\r\n * @param onNoObservers Callback when count of Observers goes to zero.\r\n */\r\nfunction createSubscribe(executor, onNoObservers) {\r\n    const proxy = new ObserverProxy(executor, onNoObservers);\r\n    return proxy.subscribe.bind(proxy);\r\n}\r\n/**\r\n * Implement fan-out for any number of Observers attached via a subscribe\r\n * function.\r\n */\r\nclass ObserverProxy {\r\n    /**\r\n     * @param executor Function which can make calls to a single Observer\r\n     *     as a proxy.\r\n     * @param onNoObservers Callback when count of Observers goes to zero.\r\n     */\r\n    constructor(executor, onNoObservers) {\r\n        this.observers = [];\r\n        this.unsubscribes = [];\r\n        this.observerCount = 0;\r\n        // Micro-task scheduling by calling task.then().\r\n        this.task = Promise.resolve();\r\n        this.finalized = false;\r\n        this.onNoObservers = onNoObservers;\r\n        // Call the executor asynchronously so subscribers that are called\r\n        // synchronously after the creation of the subscribe function\r\n        // can still receive the very first value generated in the executor.\r\n        this.task\r\n            .then(() => {\r\n            executor(this);\r\n        })\r\n            .catch(e => {\r\n            this.error(e);\r\n        });\r\n    }\r\n    next(value) {\r\n        this.forEachObserver((observer) => {\r\n            observer.next(value);\r\n        });\r\n    }\r\n    error(error) {\r\n        this.forEachObserver((observer) => {\r\n            observer.error(error);\r\n        });\r\n        this.close(error);\r\n    }\r\n    complete() {\r\n        this.forEachObserver((observer) => {\r\n            observer.complete();\r\n        });\r\n        this.close();\r\n    }\r\n    /**\r\n     * Subscribe function that can be used to add an Observer to the fan-out list.\r\n     *\r\n     * - We require that no event is sent to a subscriber sychronously to their\r\n     *   call to subscribe().\r\n     */\r\n    subscribe(nextOrObserver, error, complete) {\r\n        let observer;\r\n        if (nextOrObserver === undefined &&\r\n            error === undefined &&\r\n            complete === undefined) {\r\n            throw new Error('Missing Observer.');\r\n        }\r\n        // Assemble an Observer object when passed as callback functions.\r\n        if (implementsAnyMethods(nextOrObserver, [\r\n            'next',\r\n            'error',\r\n            'complete'\r\n        ])) {\r\n            observer = nextOrObserver;\r\n        }\r\n        else {\r\n            observer = {\r\n                next: nextOrObserver,\r\n                error,\r\n                complete\r\n            };\r\n        }\r\n        if (observer.next === undefined) {\r\n            observer.next = noop;\r\n        }\r\n        if (observer.error === undefined) {\r\n            observer.error = noop;\r\n        }\r\n        if (observer.complete === undefined) {\r\n            observer.complete = noop;\r\n        }\r\n        const unsub = this.unsubscribeOne.bind(this, this.observers.length);\r\n        // Attempt to subscribe to a terminated Observable - we\r\n        // just respond to the Observer with the final error or complete\r\n        // event.\r\n        if (this.finalized) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this.task.then(() => {\r\n                try {\r\n                    if (this.finalError) {\r\n                        observer.error(this.finalError);\r\n                    }\r\n                    else {\r\n                        observer.complete();\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // nothing\r\n                }\r\n                return;\r\n            });\r\n        }\r\n        this.observers.push(observer);\r\n        return unsub;\r\n    }\r\n    // Unsubscribe is synchronous - we guarantee that no events are sent to\r\n    // any unsubscribed Observer.\r\n    unsubscribeOne(i) {\r\n        if (this.observers === undefined || this.observers[i] === undefined) {\r\n            return;\r\n        }\r\n        delete this.observers[i];\r\n        this.observerCount -= 1;\r\n        if (this.observerCount === 0 && this.onNoObservers !== undefined) {\r\n            this.onNoObservers(this);\r\n        }\r\n    }\r\n    forEachObserver(fn) {\r\n        if (this.finalized) {\r\n            // Already closed by previous event....just eat the additional values.\r\n            return;\r\n        }\r\n        // Since sendOne calls asynchronously - there is no chance that\r\n        // this.observers will become undefined.\r\n        for (let i = 0; i < this.observers.length; i++) {\r\n            this.sendOne(i, fn);\r\n        }\r\n    }\r\n    // Call the Observer via one of it's callback function. We are careful to\r\n    // confirm that the observe has not been unsubscribed since this asynchronous\r\n    // function had been queued.\r\n    sendOne(i, fn) {\r\n        // Execute the callback asynchronously\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.task.then(() => {\r\n            if (this.observers !== undefined && this.observers[i] !== undefined) {\r\n                try {\r\n                    fn(this.observers[i]);\r\n                }\r\n                catch (e) {\r\n                    // Ignore exceptions raised in Observers or missing methods of an\r\n                    // Observer.\r\n                    // Log error to console. b/31404806\r\n                    if (typeof console !== 'undefined' && console.error) {\r\n                        console.error(e);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    close(err) {\r\n        if (this.finalized) {\r\n            return;\r\n        }\r\n        this.finalized = true;\r\n        if (err !== undefined) {\r\n            this.finalError = err;\r\n        }\r\n        // Proxy is no longer needed - garbage collect references\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.task.then(() => {\r\n            this.observers = undefined;\r\n            this.onNoObservers = undefined;\r\n        });\r\n    }\r\n}\r\n/** Turn synchronous function into one called asynchronously. */\r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\nfunction index_esm2017_async(fn, onError) {\r\n    return (...args) => {\r\n        Promise.resolve(true)\r\n            .then(() => {\r\n            fn(...args);\r\n        })\r\n            .catch((error) => {\r\n            if (onError) {\r\n                onError(error);\r\n            }\r\n        });\r\n    };\r\n}\r\n/**\r\n * Return true if the object passed in implements any of the named methods.\r\n */\r\nfunction implementsAnyMethods(obj, methods) {\r\n    if (typeof obj !== 'object' || obj === null) {\r\n        return false;\r\n    }\r\n    for (const method of methods) {\r\n        if (method in obj && typeof obj[method] === 'function') {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction noop() {\r\n    // do nothing\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Check to make sure the appropriate number of arguments are provided for a public function.\r\n * Throws an error if it fails.\r\n *\r\n * @param fnName The function name\r\n * @param minCount The minimum number of arguments to allow for the function call\r\n * @param maxCount The maximum number of argument to allow for the function call\r\n * @param argCount The actual number of arguments provided.\r\n */\r\nconst validateArgCount = function (fnName, minCount, maxCount, argCount) {\r\n    let argError;\r\n    if (argCount < minCount) {\r\n        argError = 'at least ' + minCount;\r\n    }\r\n    else if (argCount > maxCount) {\r\n        argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;\r\n    }\r\n    if (argError) {\r\n        const error = fnName +\r\n            ' failed: Was called with ' +\r\n            argCount +\r\n            (argCount === 1 ? ' argument.' : ' arguments.') +\r\n            ' Expects ' +\r\n            argError +\r\n            '.';\r\n        throw new Error(error);\r\n    }\r\n};\r\n/**\r\n * Generates a string to prefix an error message about failed argument validation\r\n *\r\n * @param fnName The function name\r\n * @param argName The name of the argument\r\n * @return The prefix to add to the error thrown for validation.\r\n */\r\nfunction index_esm2017_errorPrefix(fnName, argName) {\r\n    return `${fnName} failed: ${argName} argument `;\r\n}\r\n/**\r\n * @param fnName\r\n * @param argumentNumber\r\n * @param namespace\r\n * @param optional\r\n */\r\nfunction validateNamespace(fnName, namespace, optional) {\r\n    if (optional && !namespace) {\r\n        return;\r\n    }\r\n    if (typeof namespace !== 'string') {\r\n        //TODO: I should do more validation here. We only allow certain chars in namespaces.\r\n        throw new Error(index_esm2017_errorPrefix(fnName, 'namespace') + 'must be a valid firebase namespace.');\r\n    }\r\n}\r\nfunction validateCallback(fnName, argumentName, \r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\ncallback, optional) {\r\n    if (optional && !callback) {\r\n        return;\r\n    }\r\n    if (typeof callback !== 'function') {\r\n        throw new Error(index_esm2017_errorPrefix(fnName, argumentName) + 'must be a valid function.');\r\n    }\r\n}\r\nfunction validateContextObject(fnName, argumentName, context, optional) {\r\n    if (optional && !context) {\r\n        return;\r\n    }\r\n    if (typeof context !== 'object' || context === null) {\r\n        throw new Error(index_esm2017_errorPrefix(fnName, argumentName) + 'must be a valid context object.');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they\r\n// automatically replaced '\\r\\n' with '\\n', and they didn't handle surrogate pairs,\r\n// so it's been modified.\r\n// Note that not all Unicode characters appear as single characters in JavaScript strings.\r\n// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters\r\n// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first\r\n// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate\r\n// pair).\r\n// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3\r\n/**\r\n * @param {string} str\r\n * @return {Array}\r\n */\r\nconst stringToByteArray = function (str) {\r\n    const out = [];\r\n    let p = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n        let c = str.charCodeAt(i);\r\n        // Is this the lead surrogate in a surrogate pair?\r\n        if (c >= 0xd800 && c <= 0xdbff) {\r\n            const high = c - 0xd800; // the high 10 bits.\r\n            i++;\r\n            index_esm2017_assert(i < str.length, 'Surrogate pair missing trail surrogate.');\r\n            const low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.\r\n            c = 0x10000 + (high << 10) + low;\r\n        }\r\n        if (c < 128) {\r\n            out[p++] = c;\r\n        }\r\n        else if (c < 2048) {\r\n            out[p++] = (c >> 6) | 192;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n        else if (c < 65536) {\r\n            out[p++] = (c >> 12) | 224;\r\n            out[p++] = ((c >> 6) & 63) | 128;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n        else {\r\n            out[p++] = (c >> 18) | 240;\r\n            out[p++] = ((c >> 12) & 63) | 128;\r\n            out[p++] = ((c >> 6) & 63) | 128;\r\n            out[p++] = (c & 63) | 128;\r\n        }\r\n    }\r\n    return out;\r\n};\r\n/**\r\n * Calculate length without actually converting; useful for doing cheaper validation.\r\n * @param {string} str\r\n * @return {number}\r\n */\r\nconst stringLength = function (str) {\r\n    let p = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n        const c = str.charCodeAt(i);\r\n        if (c < 128) {\r\n            p++;\r\n        }\r\n        else if (c < 2048) {\r\n            p += 2;\r\n        }\r\n        else if (c >= 0xd800 && c <= 0xdbff) {\r\n            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.\r\n            p += 4;\r\n            i++; // skip trail surrogate.\r\n        }\r\n        else {\r\n            p += 3;\r\n        }\r\n    }\r\n    return p;\r\n};\n\n/**\r\n * @license\r\n * Copyright 2022 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Copied from https://stackoverflow.com/a/2117523\r\n * Generates a new uuid.\r\n * @public\r\n */\r\nconst uuidv4 = function () {\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\r\n        const r = (Math.random() * 16) | 0, v = c === 'x' ? r : (r & 0x3) | 0x8;\r\n        return v.toString(16);\r\n    });\r\n};\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The amount of milliseconds to exponentially increase.\r\n */\r\nconst DEFAULT_INTERVAL_MILLIS = 1000;\r\n/**\r\n * The factor to backoff by.\r\n * Should be a number greater than 1.\r\n */\r\nconst DEFAULT_BACKOFF_FACTOR = 2;\r\n/**\r\n * The maximum milliseconds to increase to.\r\n *\r\n * <p>Visible for testing\r\n */\r\nconst MAX_VALUE_MILLIS = (/* unused pure expression or super */ null && (4 * 60 * 60 * 1000)); // Four hours, like iOS and Android.\r\n/**\r\n * The percentage of backoff time to randomize by.\r\n * See\r\n * http://go/safe-client-behavior#step-1-determine-the-appropriate-retry-interval-to-handle-spike-traffic\r\n * for context.\r\n *\r\n * <p>Visible for testing\r\n */\r\nconst RANDOM_FACTOR = 0.5;\r\n/**\r\n * Based on the backoff method from\r\n * https://github.com/google/closure-library/blob/master/closure/goog/math/exponentialbackoff.js.\r\n * Extracted here so we don't need to pass metadata and a stateful ExponentialBackoff object around.\r\n */\r\nfunction calculateBackoffMillis(backoffCount, intervalMillis = DEFAULT_INTERVAL_MILLIS, backoffFactor = DEFAULT_BACKOFF_FACTOR) {\r\n    // Calculates an exponentially increasing value.\r\n    // Deviation: calculates value from count and a constant interval, so we only need to save value\r\n    // and count to restore state.\r\n    const currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);\r\n    // A random \"fuzz\" to avoid waves of retries.\r\n    // Deviation: randomFactor is required.\r\n    const randomWait = Math.round(\r\n    // A fraction of the backoff value to add/subtract.\r\n    // Deviation: changes multiplication order to improve readability.\r\n    RANDOM_FACTOR *\r\n        currBaseValue *\r\n        // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines\r\n        // if we add or subtract.\r\n        (Math.random() - 0.5) *\r\n        2);\r\n    // Limits backoff to max to avoid effectively permanent backoff.\r\n    return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provide English ordinal letters after a number\r\n */\r\nfunction ordinal(i) {\r\n    if (!Number.isFinite(i)) {\r\n        return `${i}`;\r\n    }\r\n    return i + indicator(i);\r\n}\r\nfunction indicator(i) {\r\n    i = Math.abs(i);\r\n    const cent = i % 100;\r\n    if (cent >= 10 && cent <= 20) {\r\n        return 'th';\r\n    }\r\n    const dec = i % 10;\r\n    if (dec === 1) {\r\n        return 'st';\r\n    }\r\n    if (dec === 2) {\r\n        return 'nd';\r\n    }\r\n    if (dec === 3) {\r\n        return 'rd';\r\n    }\r\n    return 'th';\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction index_esm2017_getModularInstance(service) {\r\n    if (service && service._delegate) {\r\n        return service._delegate;\r\n    }\r\n    else {\r\n        return service;\r\n    }\r\n}\n\n\n//# sourceMappingURL=index.esm2017.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@firebase/component/dist/esm/index.esm2017.js\n\n\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nclass index_esm2017_Component {\r\n    /**\r\n     *\r\n     * @param name The public service name, e.g. app, auth, firestore, database\r\n     * @param instanceFactory Service factory responsible for creating the public interface\r\n     * @param type whether the service provided by the component is public or private\r\n     */\r\n    constructor(name, instanceFactory, type) {\r\n        this.name = name;\r\n        this.instanceFactory = instanceFactory;\r\n        this.type = type;\r\n        this.multipleInstances = false;\r\n        /**\r\n         * Properties to be added to the service namespace\r\n         */\r\n        this.serviceProps = {};\r\n        this.instantiationMode = \"LAZY\" /* InstantiationMode.LAZY */;\r\n        this.onInstanceCreated = null;\r\n    }\r\n    setInstantiationMode(mode) {\r\n        this.instantiationMode = mode;\r\n        return this;\r\n    }\r\n    setMultipleInstances(multipleInstances) {\r\n        this.multipleInstances = multipleInstances;\r\n        return this;\r\n    }\r\n    setServiceProps(props) {\r\n        this.serviceProps = props;\r\n        return this;\r\n    }\r\n    setInstanceCreatedCallback(callback) {\r\n        this.onInstanceCreated = callback;\r\n        return this;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */\r\nclass index_esm2017_Provider {\r\n    constructor(name, container) {\r\n        this.name = name;\r\n        this.container = container;\r\n        this.component = null;\r\n        this.instances = new Map();\r\n        this.instancesDeferred = new Map();\r\n        this.instancesOptions = new Map();\r\n        this.onInitCallbacks = new Map();\r\n    }\r\n    /**\r\n     * @param identifier A provider can provide mulitple instances of a service\r\n     * if this.component.multipleInstances is true.\r\n     */\r\n    get(identifier) {\r\n        // if multipleInstances is not supported, use the default name\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\r\n            const deferred = new index_esm2017_Deferred();\r\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\r\n            if (this.isInitialized(normalizedIdentifier) ||\r\n                this.shouldAutoInitialize()) {\r\n                // initialize the service if it can be auto-initialized\r\n                try {\r\n                    const instance = this.getOrInitializeService({\r\n                        instanceIdentifier: normalizedIdentifier\r\n                    });\r\n                    if (instance) {\r\n                        deferred.resolve(instance);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // when the instance factory throws an exception during get(), it should not cause\r\n                    // a fatal error. We just return the unresolved promise in this case.\r\n                }\r\n            }\r\n        }\r\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\r\n    }\r\n    getImmediate(options) {\r\n        var _a;\r\n        // if multipleInstances is not supported, use the default name\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\r\n        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\r\n        if (this.isInitialized(normalizedIdentifier) ||\r\n            this.shouldAutoInitialize()) {\r\n            try {\r\n                return this.getOrInitializeService({\r\n                    instanceIdentifier: normalizedIdentifier\r\n                });\r\n            }\r\n            catch (e) {\r\n                if (optional) {\r\n                    return null;\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw\r\n            if (optional) {\r\n                return null;\r\n            }\r\n            else {\r\n                throw Error(`Service ${this.name} is not available`);\r\n            }\r\n        }\r\n    }\r\n    getComponent() {\r\n        return this.component;\r\n    }\r\n    setComponent(component) {\r\n        if (component.name !== this.name) {\r\n            throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\r\n        }\r\n        if (this.component) {\r\n            throw Error(`Component for ${this.name} has already been provided`);\r\n        }\r\n        this.component = component;\r\n        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\r\n        if (!this.shouldAutoInitialize()) {\r\n            return;\r\n        }\r\n        // if the service is eager, initialize the default instance\r\n        if (isComponentEager(component)) {\r\n            try {\r\n                this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });\r\n            }\r\n            catch (e) {\r\n                // when the instance factory for an eager Component throws an exception during the eager\r\n                // initialization, it should not cause a fatal error.\r\n                // TODO: Investigate if we need to make it configurable, because some component may want to cause\r\n                // a fatal error in this case?\r\n            }\r\n        }\r\n        // Create service instances for the pending promises and resolve them\r\n        // NOTE: if this.multipleInstances is false, only the default instance will be created\r\n        // and all promises with resolve with it regardless of the identifier.\r\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\r\n            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\r\n            try {\r\n                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\r\n                const instance = this.getOrInitializeService({\r\n                    instanceIdentifier: normalizedIdentifier\r\n                });\r\n                instanceDeferred.resolve(instance);\r\n            }\r\n            catch (e) {\r\n                // when the instance factory throws an exception, it should not cause\r\n                // a fatal error. We just leave the promise unresolved.\r\n            }\r\n        }\r\n    }\r\n    clearInstance(identifier = DEFAULT_ENTRY_NAME) {\r\n        this.instancesDeferred.delete(identifier);\r\n        this.instancesOptions.delete(identifier);\r\n        this.instances.delete(identifier);\r\n    }\r\n    // app.delete() will call this method on every provider to delete the services\r\n    // TODO: should we mark the provider as deleted?\r\n    async delete() {\r\n        const services = Array.from(this.instances.values());\r\n        await Promise.all([\r\n            ...services\r\n                .filter(service => 'INTERNAL' in service) // legacy services\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                .map(service => service.INTERNAL.delete()),\r\n            ...services\r\n                .filter(service => '_delete' in service) // modularized services\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                .map(service => service._delete())\r\n        ]);\r\n    }\r\n    isComponentSet() {\r\n        return this.component != null;\r\n    }\r\n    isInitialized(identifier = DEFAULT_ENTRY_NAME) {\r\n        return this.instances.has(identifier);\r\n    }\r\n    getOptions(identifier = DEFAULT_ENTRY_NAME) {\r\n        return this.instancesOptions.get(identifier) || {};\r\n    }\r\n    initialize(opts = {}) {\r\n        const { options = {} } = opts;\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\r\n        if (this.isInitialized(normalizedIdentifier)) {\r\n            throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\r\n        }\r\n        if (!this.isComponentSet()) {\r\n            throw Error(`Component ${this.name} has not been registered yet`);\r\n        }\r\n        const instance = this.getOrInitializeService({\r\n            instanceIdentifier: normalizedIdentifier,\r\n            options\r\n        });\r\n        // resolve any pending promise waiting for the service instance\r\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\r\n            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\r\n            if (normalizedIdentifier === normalizedDeferredIdentifier) {\r\n                instanceDeferred.resolve(instance);\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n    /**\r\n     *\r\n     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\r\n     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\r\n     *\r\n     * @param identifier An optional instance identifier\r\n     * @returns a function to unregister the callback\r\n     */\r\n    onInit(callback, identifier) {\r\n        var _a;\r\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\r\n        existingCallbacks.add(callback);\r\n        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\r\n        const existingInstance = this.instances.get(normalizedIdentifier);\r\n        if (existingInstance) {\r\n            callback(existingInstance, normalizedIdentifier);\r\n        }\r\n        return () => {\r\n            existingCallbacks.delete(callback);\r\n        };\r\n    }\r\n    /**\r\n     * Invoke onInit callbacks synchronously\r\n     * @param instance the service instance`\r\n     */\r\n    invokeOnInitCallbacks(instance, identifier) {\r\n        const callbacks = this.onInitCallbacks.get(identifier);\r\n        if (!callbacks) {\r\n            return;\r\n        }\r\n        for (const callback of callbacks) {\r\n            try {\r\n                callback(instance, identifier);\r\n            }\r\n            catch (_a) {\r\n                // ignore errors in the onInit callback\r\n            }\r\n        }\r\n    }\r\n    getOrInitializeService({ instanceIdentifier, options = {} }) {\r\n        let instance = this.instances.get(instanceIdentifier);\r\n        if (!instance && this.component) {\r\n            instance = this.component.instanceFactory(this.container, {\r\n                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\r\n                options\r\n            });\r\n            this.instances.set(instanceIdentifier, instance);\r\n            this.instancesOptions.set(instanceIdentifier, options);\r\n            /**\r\n             * Invoke onInit listeners.\r\n             * Note this.component.onInstanceCreated is different, which is used by the component creator,\r\n             * while onInit listeners are registered by consumers of the provider.\r\n             */\r\n            this.invokeOnInitCallbacks(instance, instanceIdentifier);\r\n            /**\r\n             * Order is important\r\n             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\r\n             * makes `isInitialized()` return true.\r\n             */\r\n            if (this.component.onInstanceCreated) {\r\n                try {\r\n                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\r\n                }\r\n                catch (_a) {\r\n                    // ignore errors in the onInstanceCreatedCallback\r\n                }\r\n            }\r\n        }\r\n        return instance || null;\r\n    }\r\n    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\r\n        if (this.component) {\r\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\r\n        }\r\n        else {\r\n            return identifier; // assume multiple instances are supported before the component is provided.\r\n        }\r\n    }\r\n    shouldAutoInitialize() {\r\n        return (!!this.component &&\r\n            this.component.instantiationMode !== \"EXPLICIT\" /* InstantiationMode.EXPLICIT */);\r\n    }\r\n}\r\n// undefined should be passed to the service factory for the default instance\r\nfunction normalizeIdentifierForFactory(identifier) {\r\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\r\n}\r\nfunction isComponentEager(component) {\r\n    return component.instantiationMode === \"EAGER\" /* InstantiationMode.EAGER */;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nclass index_esm2017_ComponentContainer {\r\n    constructor(name) {\r\n        this.name = name;\r\n        this.providers = new Map();\r\n    }\r\n    /**\r\n     *\r\n     * @param component Component being added\r\n     * @param overwrite When a component with the same name has already been registered,\r\n     * if overwrite is true: overwrite the existing component with the new component and create a new\r\n     * provider with the new component. It can be useful in tests where you want to use different mocks\r\n     * for different tests.\r\n     * if overwrite is false: throw an exception\r\n     */\r\n    addComponent(component) {\r\n        const provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\r\n        }\r\n        provider.setComponent(component);\r\n    }\r\n    addOrOverwriteComponent(component) {\r\n        const provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            // delete the existing provider from the container, so we can register the new component\r\n            this.providers.delete(component.name);\r\n        }\r\n        this.addComponent(component);\r\n    }\r\n    /**\r\n     * getProvider provides a type safe interface where it can only be called with a field name\r\n     * present in NameServiceMapping interface.\r\n     *\r\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n     * themselves.\r\n     */\r\n    getProvider(name) {\r\n        if (this.providers.has(name)) {\r\n            return this.providers.get(name);\r\n        }\r\n        // create a Provider for a service that hasn't registered with Firebase\r\n        const provider = new index_esm2017_Provider(name, this);\r\n        this.providers.set(name, provider);\r\n        return provider;\r\n    }\r\n    getProviders() {\r\n        return Array.from(this.providers.values());\r\n    }\r\n}\n\n\n//# sourceMappingURL=index.esm2017.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@firebase/logger/dist/esm/index.esm2017.js\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A container for all of the Logger instances\r\n */\r\nconst instances = [];\r\n/**\r\n * The JS SDK supports 5 log levels and also allows a user the ability to\r\n * silence the logs altogether.\r\n *\r\n * The order is a follows:\r\n * DEBUG < VERBOSE < INFO < WARN < ERROR\r\n *\r\n * All of the log types above the current log level will be captured (i.e. if\r\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\r\n * `VERBOSE` logs will not)\r\n */\r\nvar LogLevel;\r\n(function (LogLevel) {\r\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\r\n    LogLevel[LogLevel[\"VERBOSE\"] = 1] = \"VERBOSE\";\r\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\r\n    LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\r\n    LogLevel[LogLevel[\"ERROR\"] = 4] = \"ERROR\";\r\n    LogLevel[LogLevel[\"SILENT\"] = 5] = \"SILENT\";\r\n})(LogLevel || (LogLevel = {}));\r\nconst levelStringToEnum = {\r\n    'debug': LogLevel.DEBUG,\r\n    'verbose': LogLevel.VERBOSE,\r\n    'info': LogLevel.INFO,\r\n    'warn': LogLevel.WARN,\r\n    'error': LogLevel.ERROR,\r\n    'silent': LogLevel.SILENT\r\n};\r\n/**\r\n * The default log level\r\n */\r\nconst defaultLogLevel = LogLevel.INFO;\r\n/**\r\n * By default, `console.debug` is not displayed in the developer console (in\r\n * chrome). To avoid forcing users to have to opt-in to these logs twice\r\n * (i.e. once for firebase, and once in the console), we are sending `DEBUG`\r\n * logs to the `console.log` function.\r\n */\r\nconst ConsoleMethod = {\r\n    [LogLevel.DEBUG]: 'log',\r\n    [LogLevel.VERBOSE]: 'log',\r\n    [LogLevel.INFO]: 'info',\r\n    [LogLevel.WARN]: 'warn',\r\n    [LogLevel.ERROR]: 'error'\r\n};\r\n/**\r\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\r\n * messages on to their corresponding console counterparts (if the log method\r\n * is supported by the current log level)\r\n */\r\nconst defaultLogHandler = (instance, logType, ...args) => {\r\n    if (logType < instance.logLevel) {\r\n        return;\r\n    }\r\n    const now = new Date().toISOString();\r\n    const method = ConsoleMethod[logType];\r\n    if (method) {\r\n        console[method](`[${now}]  ${instance.name}:`, ...args);\r\n    }\r\n    else {\r\n        throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);\r\n    }\r\n};\r\nclass Logger {\r\n    /**\r\n     * Gives you an instance of a Logger to capture messages according to\r\n     * Firebase's logging scheme.\r\n     *\r\n     * @param name The name that the logs will be associated with\r\n     */\r\n    constructor(name) {\r\n        this.name = name;\r\n        /**\r\n         * The log level of the given Logger instance.\r\n         */\r\n        this._logLevel = defaultLogLevel;\r\n        /**\r\n         * The main (internal) log handler for the Logger instance.\r\n         * Can be set to a new function in internal package code but not by user.\r\n         */\r\n        this._logHandler = defaultLogHandler;\r\n        /**\r\n         * The optional, additional, user-defined log handler for the Logger instance.\r\n         */\r\n        this._userLogHandler = null;\r\n        /**\r\n         * Capture the current instance for later use\r\n         */\r\n        instances.push(this);\r\n    }\r\n    get logLevel() {\r\n        return this._logLevel;\r\n    }\r\n    set logLevel(val) {\r\n        if (!(val in LogLevel)) {\r\n            throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\r\n        }\r\n        this._logLevel = val;\r\n    }\r\n    // Workaround for setter/getter having to be the same type.\r\n    setLogLevel(val) {\r\n        this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;\r\n    }\r\n    get logHandler() {\r\n        return this._logHandler;\r\n    }\r\n    set logHandler(val) {\r\n        if (typeof val !== 'function') {\r\n            throw new TypeError('Value assigned to `logHandler` must be a function');\r\n        }\r\n        this._logHandler = val;\r\n    }\r\n    get userLogHandler() {\r\n        return this._userLogHandler;\r\n    }\r\n    set userLogHandler(val) {\r\n        this._userLogHandler = val;\r\n    }\r\n    /**\r\n     * The functions below are all based on the `console` interface\r\n     */\r\n    debug(...args) {\r\n        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);\r\n        this._logHandler(this, LogLevel.DEBUG, ...args);\r\n    }\r\n    log(...args) {\r\n        this._userLogHandler &&\r\n            this._userLogHandler(this, LogLevel.VERBOSE, ...args);\r\n        this._logHandler(this, LogLevel.VERBOSE, ...args);\r\n    }\r\n    info(...args) {\r\n        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);\r\n        this._logHandler(this, LogLevel.INFO, ...args);\r\n    }\r\n    warn(...args) {\r\n        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);\r\n        this._logHandler(this, LogLevel.WARN, ...args);\r\n    }\r\n    error(...args) {\r\n        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);\r\n        this._logHandler(this, LogLevel.ERROR, ...args);\r\n    }\r\n}\r\nfunction setLogLevel(level) {\r\n    instances.forEach(inst => {\r\n        inst.setLogLevel(level);\r\n    });\r\n}\r\nfunction index_esm2017_setUserLogHandler(logCallback, options) {\r\n    for (const instance of instances) {\r\n        let customLogLevel = null;\r\n        if (options && options.level) {\r\n            customLogLevel = levelStringToEnum[options.level];\r\n        }\r\n        if (logCallback === null) {\r\n            instance.userLogHandler = null;\r\n        }\r\n        else {\r\n            instance.userLogHandler = (instance, level, ...args) => {\r\n                const message = args\r\n                    .map(arg => {\r\n                    if (arg == null) {\r\n                        return null;\r\n                    }\r\n                    else if (typeof arg === 'string') {\r\n                        return arg;\r\n                    }\r\n                    else if (typeof arg === 'number' || typeof arg === 'boolean') {\r\n                        return arg.toString();\r\n                    }\r\n                    else if (arg instanceof Error) {\r\n                        return arg.message;\r\n                    }\r\n                    else {\r\n                        try {\r\n                            return JSON.stringify(arg);\r\n                        }\r\n                        catch (ignored) {\r\n                            return null;\r\n                        }\r\n                    }\r\n                })\r\n                    .filter(arg => arg)\r\n                    .join(' ');\r\n                if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {\r\n                    logCallback({\r\n                        level: LogLevel[level].toLowerCase(),\r\n                        message,\r\n                        args,\r\n                        type: instance.name\r\n                    });\r\n                }\r\n            };\r\n        }\r\n    }\r\n}\n\n\n//# sourceMappingURL=index.esm2017.js.map\n\n;// CONCATENATED MODULE: ./node_modules/idb/build/wrap-idb-value.js\nconst instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap_idb_value_wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap_idb_value_wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap_idb_value_wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap_idb_value_wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap_idb_value_wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap_idb_value_wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n\n\n;// CONCATENATED MODULE: ./node_modules/idb/build/index.js\n\n\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap_idb_value_wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap_idb_value_wrap(request.result), event.oldVersion, event.newVersion, wrap_idb_value_wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@firebase/app/dist/esm/index.esm2017.js\n\n\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass PlatformLoggerServiceImpl {\r\n    constructor(container) {\r\n        this.container = container;\r\n    }\r\n    // In initial implementation, this will be called by installations on\r\n    // auth token refresh, and installations will send this string.\r\n    getPlatformInfoString() {\r\n        const providers = this.container.getProviders();\r\n        // Loop through providers and get library/version pairs from any that are\r\n        // version components.\r\n        return providers\r\n            .map(provider => {\r\n            if (isVersionServiceProvider(provider)) {\r\n                const service = provider.getImmediate();\r\n                return `${service.library}/${service.version}`;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        })\r\n            .filter(logString => logString)\r\n            .join(' ');\r\n    }\r\n}\r\n/**\r\n *\r\n * @param provider check if this provider provides a VersionService\r\n *\r\n * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider\r\n * provides VersionService. The provider is not necessarily a 'app-version'\r\n * provider.\r\n */\r\nfunction isVersionServiceProvider(provider) {\r\n    const component = provider.getComponent();\r\n    return (component === null || component === void 0 ? void 0 : component.type) === \"VERSION\" /* ComponentType.VERSION */;\r\n}\n\nconst name$p = \"@firebase/app\";\nconst version$1 = \"0.10.9\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst logger = new Logger('@firebase/app');\n\nconst name$o = \"@firebase/app-compat\";\n\nconst name$n = \"@firebase/analytics-compat\";\n\nconst name$m = \"@firebase/analytics\";\n\nconst name$l = \"@firebase/app-check-compat\";\n\nconst name$k = \"@firebase/app-check\";\n\nconst name$j = \"@firebase/auth\";\n\nconst name$i = \"@firebase/auth-compat\";\n\nconst name$h = \"@firebase/database\";\n\nconst name$g = \"@firebase/database-compat\";\n\nconst name$f = \"@firebase/functions\";\n\nconst name$e = \"@firebase/functions-compat\";\n\nconst name$d = \"@firebase/installations\";\n\nconst name$c = \"@firebase/installations-compat\";\n\nconst name$b = \"@firebase/messaging\";\n\nconst name$a = \"@firebase/messaging-compat\";\n\nconst name$9 = \"@firebase/performance\";\n\nconst name$8 = \"@firebase/performance-compat\";\n\nconst name$7 = \"@firebase/remote-config\";\n\nconst name$6 = \"@firebase/remote-config-compat\";\n\nconst name$5 = \"@firebase/storage\";\n\nconst name$4 = \"@firebase/storage-compat\";\n\nconst name$3 = \"@firebase/firestore\";\n\nconst name$2 = \"@firebase/vertexai-preview\";\n\nconst name$1 = \"@firebase/firestore-compat\";\n\nconst index_esm2017_name = \"firebase\";\nconst version = \"10.13.0\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The default app name\r\n *\r\n * @internal\r\n */\r\nconst index_esm2017_DEFAULT_ENTRY_NAME = '[DEFAULT]';\r\nconst PLATFORM_LOG_STRING = {\r\n    [name$p]: 'fire-core',\r\n    [name$o]: 'fire-core-compat',\r\n    [name$m]: 'fire-analytics',\r\n    [name$n]: 'fire-analytics-compat',\r\n    [name$k]: 'fire-app-check',\r\n    [name$l]: 'fire-app-check-compat',\r\n    [name$j]: 'fire-auth',\r\n    [name$i]: 'fire-auth-compat',\r\n    [name$h]: 'fire-rtdb',\r\n    [name$g]: 'fire-rtdb-compat',\r\n    [name$f]: 'fire-fn',\r\n    [name$e]: 'fire-fn-compat',\r\n    [name$d]: 'fire-iid',\r\n    [name$c]: 'fire-iid-compat',\r\n    [name$b]: 'fire-fcm',\r\n    [name$a]: 'fire-fcm-compat',\r\n    [name$9]: 'fire-perf',\r\n    [name$8]: 'fire-perf-compat',\r\n    [name$7]: 'fire-rc',\r\n    [name$6]: 'fire-rc-compat',\r\n    [name$5]: 'fire-gcs',\r\n    [name$4]: 'fire-gcs-compat',\r\n    [name$3]: 'fire-fst',\r\n    [name$1]: 'fire-fst-compat',\r\n    [name$2]: 'fire-vertex',\r\n    'fire-js': 'fire-js',\r\n    [index_esm2017_name]: 'fire-js-all'\r\n};\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @internal\r\n */\r\nconst _apps = new Map();\r\n/**\r\n * @internal\r\n */\r\nconst _serverApps = new Map();\r\n/**\r\n * Registered components.\r\n *\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconst _components = new Map();\r\n/**\r\n * @param component - the component being added to this app's container\r\n *\r\n * @internal\r\n */\r\nfunction _addComponent(app, component) {\r\n    try {\r\n        app.container.addComponent(component);\r\n    }\r\n    catch (e) {\r\n        logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);\r\n    }\r\n}\r\n/**\r\n *\r\n * @internal\r\n */\r\nfunction _addOrOverwriteComponent(app, component) {\r\n    app.container.addOrOverwriteComponent(component);\r\n}\r\n/**\r\n *\r\n * @param component - the component to register\r\n * @returns whether or not the component is registered successfully\r\n *\r\n * @internal\r\n */\r\nfunction _registerComponent(component) {\r\n    const componentName = component.name;\r\n    if (_components.has(componentName)) {\r\n        logger.debug(`There were multiple attempts to register component ${componentName}.`);\r\n        return false;\r\n    }\r\n    _components.set(componentName, component);\r\n    // add the component to existing app instances\r\n    for (const app of _apps.values()) {\r\n        _addComponent(app, component);\r\n    }\r\n    for (const serverApp of _serverApps.values()) {\r\n        _addComponent(serverApp, component);\r\n    }\r\n    return true;\r\n}\r\n/**\r\n *\r\n * @param app - FirebaseApp instance\r\n * @param name - service name\r\n *\r\n * @returns the provider for the service with the matching name\r\n *\r\n * @internal\r\n */\r\nfunction _getProvider(app, name) {\r\n    const heartbeatController = app.container\r\n        .getProvider('heartbeat')\r\n        .getImmediate({ optional: true });\r\n    if (heartbeatController) {\r\n        void heartbeatController.triggerHeartbeat();\r\n    }\r\n    return app.container.getProvider(name);\r\n}\r\n/**\r\n *\r\n * @param app - FirebaseApp instance\r\n * @param name - service name\r\n * @param instanceIdentifier - service instance identifier in case the service supports multiple instances\r\n *\r\n * @internal\r\n */\r\nfunction _removeServiceInstance(app, name, instanceIdentifier = index_esm2017_DEFAULT_ENTRY_NAME) {\r\n    _getProvider(app, name).clearInstance(instanceIdentifier);\r\n}\r\n/**\r\n *\r\n * @param obj - an object of type FirebaseApp or FirebaseOptions.\r\n *\r\n * @returns true if the provide object is of type FirebaseApp.\r\n *\r\n * @internal\r\n */\r\nfunction _isFirebaseApp(obj) {\r\n    return obj.options !== undefined;\r\n}\r\n/**\r\n *\r\n * @param obj - an object of type FirebaseApp.\r\n *\r\n * @returns true if the provided object is of type FirebaseServerAppImpl.\r\n *\r\n * @internal\r\n */\r\nfunction _isFirebaseServerApp(obj) {\r\n    return obj.settings !== undefined;\r\n}\r\n/**\r\n * Test only\r\n *\r\n * @internal\r\n */\r\nfunction _clearComponents() {\r\n    _components.clear();\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst ERRORS = {\r\n    [\"no-app\" /* AppError.NO_APP */]: \"No Firebase App '{$appName}' has been created - \" +\r\n        'call initializeApp() first',\r\n    [\"bad-app-name\" /* AppError.BAD_APP_NAME */]: \"Illegal App name: '{$appName}'\",\r\n    [\"duplicate-app\" /* AppError.DUPLICATE_APP */]: \"Firebase App named '{$appName}' already exists with different options or config\",\r\n    [\"app-deleted\" /* AppError.APP_DELETED */]: \"Firebase App named '{$appName}' already deleted\",\r\n    [\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */]: 'Firebase Server App has been deleted',\r\n    [\"no-options\" /* AppError.NO_OPTIONS */]: 'Need to provide options, when not being deployed to hosting via source.',\r\n    [\"invalid-app-argument\" /* AppError.INVALID_APP_ARGUMENT */]: 'firebase.{$appName}() takes either no argument or a ' +\r\n        'Firebase App instance.',\r\n    [\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */]: 'First argument to `onLog` must be null or a function.',\r\n    [\"idb-open\" /* AppError.IDB_OPEN */]: 'Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.',\r\n    [\"idb-get\" /* AppError.IDB_GET */]: 'Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.',\r\n    [\"idb-set\" /* AppError.IDB_WRITE */]: 'Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.',\r\n    [\"idb-delete\" /* AppError.IDB_DELETE */]: 'Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.',\r\n    [\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */]: 'FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.',\r\n    [\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */]: 'FirebaseServerApp is not for use in browser environments.'\r\n};\r\nconst ERROR_FACTORY = new ErrorFactory('app', 'Firebase', ERRORS);\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass FirebaseAppImpl {\r\n    constructor(options, config, container) {\r\n        this._isDeleted = false;\r\n        this._options = Object.assign({}, options);\r\n        this._config = Object.assign({}, config);\r\n        this._name = config.name;\r\n        this._automaticDataCollectionEnabled =\r\n            config.automaticDataCollectionEnabled;\r\n        this._container = container;\r\n        this.container.addComponent(new index_esm2017_Component('app', () => this, \"PUBLIC\" /* ComponentType.PUBLIC */));\r\n    }\r\n    get automaticDataCollectionEnabled() {\r\n        this.checkDestroyed();\r\n        return this._automaticDataCollectionEnabled;\r\n    }\r\n    set automaticDataCollectionEnabled(val) {\r\n        this.checkDestroyed();\r\n        this._automaticDataCollectionEnabled = val;\r\n    }\r\n    get name() {\r\n        this.checkDestroyed();\r\n        return this._name;\r\n    }\r\n    get options() {\r\n        this.checkDestroyed();\r\n        return this._options;\r\n    }\r\n    get config() {\r\n        this.checkDestroyed();\r\n        return this._config;\r\n    }\r\n    get container() {\r\n        return this._container;\r\n    }\r\n    get isDeleted() {\r\n        return this._isDeleted;\r\n    }\r\n    set isDeleted(val) {\r\n        this._isDeleted = val;\r\n    }\r\n    /**\r\n     * This function will throw an Error if the App has already been deleted -\r\n     * use before performing API actions on the App.\r\n     */\r\n    checkDestroyed() {\r\n        if (this.isDeleted) {\r\n            throw ERROR_FACTORY.create(\"app-deleted\" /* AppError.APP_DELETED */, { appName: this._name });\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass FirebaseServerAppImpl extends FirebaseAppImpl {\r\n    constructor(options, serverConfig, name, container) {\r\n        // Build configuration parameters for the FirebaseAppImpl base class.\r\n        const automaticDataCollectionEnabled = serverConfig.automaticDataCollectionEnabled !== undefined\r\n            ? serverConfig.automaticDataCollectionEnabled\r\n            : false;\r\n        // Create the FirebaseAppSettings object for the FirebaseAppImp constructor.\r\n        const config = {\r\n            name,\r\n            automaticDataCollectionEnabled\r\n        };\r\n        if (options.apiKey !== undefined) {\r\n            // Construct the parent FirebaseAppImp object.\r\n            super(options, config, container);\r\n        }\r\n        else {\r\n            const appImpl = options;\r\n            super(appImpl.options, config, container);\r\n        }\r\n        // Now construct the data for the FirebaseServerAppImpl.\r\n        this._serverConfig = Object.assign({ automaticDataCollectionEnabled }, serverConfig);\r\n        this._finalizationRegistry = null;\r\n        if (typeof FinalizationRegistry !== 'undefined') {\r\n            this._finalizationRegistry = new FinalizationRegistry(() => {\r\n                this.automaticCleanup();\r\n            });\r\n        }\r\n        this._refCount = 0;\r\n        this.incRefCount(this._serverConfig.releaseOnDeref);\r\n        // Do not retain a hard reference to the dref object, otherwise the FinalizationRegistry\r\n        // will never trigger.\r\n        this._serverConfig.releaseOnDeref = undefined;\r\n        serverConfig.releaseOnDeref = undefined;\r\n        registerVersion(name$p, version$1, 'serverapp');\r\n    }\r\n    toJSON() {\r\n        return undefined;\r\n    }\r\n    get refCount() {\r\n        return this._refCount;\r\n    }\r\n    // Increment the reference count of this server app. If an object is provided, register it\r\n    // with the finalization registry.\r\n    incRefCount(obj) {\r\n        if (this.isDeleted) {\r\n            return;\r\n        }\r\n        this._refCount++;\r\n        if (obj !== undefined && this._finalizationRegistry !== null) {\r\n            this._finalizationRegistry.register(obj, this);\r\n        }\r\n    }\r\n    // Decrement the reference count.\r\n    decRefCount() {\r\n        if (this.isDeleted) {\r\n            return 0;\r\n        }\r\n        return --this._refCount;\r\n    }\r\n    // Invoked by the FinalizationRegistry callback to note that this app should go through its\r\n    // reference counts and delete itself if no reference count remain. The coordinating logic that\r\n    // handles this is in deleteApp(...).\r\n    automaticCleanup() {\r\n        void deleteApp(this);\r\n    }\r\n    get settings() {\r\n        this.checkDestroyed();\r\n        return this._serverConfig;\r\n    }\r\n    /**\r\n     * This function will throw an Error if the App has already been deleted -\r\n     * use before performing API actions on the App.\r\n     */\r\n    checkDestroyed() {\r\n        if (this.isDeleted) {\r\n            throw ERROR_FACTORY.create(\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The current SDK version.\r\n *\r\n * @public\r\n */\r\nconst SDK_VERSION = version;\r\nfunction initializeApp(_options, rawConfig = {}) {\r\n    let options = _options;\r\n    if (typeof rawConfig !== 'object') {\r\n        const name = rawConfig;\r\n        rawConfig = { name };\r\n    }\r\n    const config = Object.assign({ name: index_esm2017_DEFAULT_ENTRY_NAME, automaticDataCollectionEnabled: false }, rawConfig);\r\n    const name = config.name;\r\n    if (typeof name !== 'string' || !name) {\r\n        throw ERROR_FACTORY.create(\"bad-app-name\" /* AppError.BAD_APP_NAME */, {\r\n            appName: String(name)\r\n        });\r\n    }\r\n    options || (options = getDefaultAppConfig());\r\n    if (!options) {\r\n        throw ERROR_FACTORY.create(\"no-options\" /* AppError.NO_OPTIONS */);\r\n    }\r\n    const existingApp = _apps.get(name);\r\n    if (existingApp) {\r\n        // return the existing app if options and config deep equal the ones in the existing app.\r\n        if (deepEqual(options, existingApp.options) &&\r\n            deepEqual(config, existingApp.config)) {\r\n            return existingApp;\r\n        }\r\n        else {\r\n            throw ERROR_FACTORY.create(\"duplicate-app\" /* AppError.DUPLICATE_APP */, { appName: name });\r\n        }\r\n    }\r\n    const container = new index_esm2017_ComponentContainer(name);\r\n    for (const component of _components.values()) {\r\n        container.addComponent(component);\r\n    }\r\n    const newApp = new FirebaseAppImpl(options, config, container);\r\n    _apps.set(name, newApp);\r\n    return newApp;\r\n}\r\nfunction initializeServerApp(_options, _serverAppConfig) {\r\n    if (isBrowser() && !isWebWorker()) {\r\n        // FirebaseServerApp isn't designed to be run in browsers.\r\n        throw ERROR_FACTORY.create(\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */);\r\n    }\r\n    if (_serverAppConfig.automaticDataCollectionEnabled === undefined) {\r\n        _serverAppConfig.automaticDataCollectionEnabled = false;\r\n    }\r\n    let appOptions;\r\n    if (_isFirebaseApp(_options)) {\r\n        appOptions = _options.options;\r\n    }\r\n    else {\r\n        appOptions = _options;\r\n    }\r\n    // Build an app name based on a hash of the configuration options.\r\n    const nameObj = Object.assign(Object.assign({}, _serverAppConfig), appOptions);\r\n    // However, Do not mangle the name based on releaseOnDeref, since it will vary between the\r\n    // construction of FirebaseServerApp instances. For example, if the object is the request headers.\r\n    if (nameObj.releaseOnDeref !== undefined) {\r\n        delete nameObj.releaseOnDeref;\r\n    }\r\n    const hashCode = (s) => {\r\n        return [...s].reduce((hash, c) => (Math.imul(31, hash) + c.charCodeAt(0)) | 0, 0);\r\n    };\r\n    if (_serverAppConfig.releaseOnDeref !== undefined) {\r\n        if (typeof FinalizationRegistry === 'undefined') {\r\n            throw ERROR_FACTORY.create(\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */, {});\r\n        }\r\n    }\r\n    const nameString = '' + hashCode(JSON.stringify(nameObj));\r\n    const existingApp = _serverApps.get(nameString);\r\n    if (existingApp) {\r\n        existingApp.incRefCount(_serverAppConfig.releaseOnDeref);\r\n        return existingApp;\r\n    }\r\n    const container = new ComponentContainer(nameString);\r\n    for (const component of _components.values()) {\r\n        container.addComponent(component);\r\n    }\r\n    const newApp = new FirebaseServerAppImpl(appOptions, _serverAppConfig, nameString, container);\r\n    _serverApps.set(nameString, newApp);\r\n    return newApp;\r\n}\r\n/**\r\n * Retrieves a {@link @firebase/app#FirebaseApp} instance.\r\n *\r\n * When called with no arguments, the default app is returned. When an app name\r\n * is provided, the app corresponding to that name is returned.\r\n *\r\n * An exception is thrown if the app being retrieved has not yet been\r\n * initialized.\r\n *\r\n * @example\r\n * ```javascript\r\n * // Return the default app\r\n * const app = getApp();\r\n * ```\r\n *\r\n * @example\r\n * ```javascript\r\n * // Return a named app\r\n * const otherApp = getApp(\"otherApp\");\r\n * ```\r\n *\r\n * @param name - Optional name of the app to return. If no name is\r\n *   provided, the default is `\"[DEFAULT]\"`.\r\n *\r\n * @returns The app corresponding to the provided app name.\r\n *   If no app name is provided, the default app is returned.\r\n *\r\n * @public\r\n */\r\nfunction getApp(name = index_esm2017_DEFAULT_ENTRY_NAME) {\r\n    const app = _apps.get(name);\r\n    if (!app && name === index_esm2017_DEFAULT_ENTRY_NAME && getDefaultAppConfig()) {\r\n        return initializeApp();\r\n    }\r\n    if (!app) {\r\n        throw ERROR_FACTORY.create(\"no-app\" /* AppError.NO_APP */, { appName: name });\r\n    }\r\n    return app;\r\n}\r\n/**\r\n * A (read-only) array of all initialized apps.\r\n * @public\r\n */\r\nfunction getApps() {\r\n    return Array.from(_apps.values());\r\n}\r\n/**\r\n * Renders this app unusable and frees the resources of all associated\r\n * services.\r\n *\r\n * @example\r\n * ```javascript\r\n * deleteApp(app)\r\n *   .then(function() {\r\n *     console.log(\"App deleted successfully\");\r\n *   })\r\n *   .catch(function(error) {\r\n *     console.log(\"Error deleting app:\", error);\r\n *   });\r\n * ```\r\n *\r\n * @public\r\n */\r\nasync function deleteApp(app) {\r\n    let cleanupProviders = false;\r\n    const name = app.name;\r\n    if (_apps.has(name)) {\r\n        cleanupProviders = true;\r\n        _apps.delete(name);\r\n    }\r\n    else if (_serverApps.has(name)) {\r\n        const firebaseServerApp = app;\r\n        if (firebaseServerApp.decRefCount() <= 0) {\r\n            _serverApps.delete(name);\r\n            cleanupProviders = true;\r\n        }\r\n    }\r\n    if (cleanupProviders) {\r\n        await Promise.all(app.container\r\n            .getProviders()\r\n            .map(provider => provider.delete()));\r\n        app.isDeleted = true;\r\n    }\r\n}\r\n/**\r\n * Registers a library's name and version for platform logging purposes.\r\n * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)\r\n * @param version - Current version of that library.\r\n * @param variant - Bundle variant, e.g., node, rn, etc.\r\n *\r\n * @public\r\n */\r\nfunction registerVersion(libraryKeyOrName, version, variant) {\r\n    var _a;\r\n    // TODO: We can use this check to whitelist strings when/if we set up\r\n    // a good whitelist system.\r\n    let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;\r\n    if (variant) {\r\n        library += `-${variant}`;\r\n    }\r\n    const libraryMismatch = library.match(/\\s|\\//);\r\n    const versionMismatch = version.match(/\\s|\\//);\r\n    if (libraryMismatch || versionMismatch) {\r\n        const warning = [\r\n            `Unable to register library \"${library}\" with version \"${version}\":`\r\n        ];\r\n        if (libraryMismatch) {\r\n            warning.push(`library name \"${library}\" contains illegal characters (whitespace or \"/\")`);\r\n        }\r\n        if (libraryMismatch && versionMismatch) {\r\n            warning.push('and');\r\n        }\r\n        if (versionMismatch) {\r\n            warning.push(`version name \"${version}\" contains illegal characters (whitespace or \"/\")`);\r\n        }\r\n        logger.warn(warning.join(' '));\r\n        return;\r\n    }\r\n    _registerComponent(new index_esm2017_Component(`${library}-version`, () => ({ library, version }), \"VERSION\" /* ComponentType.VERSION */));\r\n}\r\n/**\r\n * Sets log handler for all Firebase SDKs.\r\n * @param logCallback - An optional custom log handler that executes user code whenever\r\n * the Firebase SDK makes a logging call.\r\n *\r\n * @public\r\n */\r\nfunction onLog(logCallback, options) {\r\n    if (logCallback !== null && typeof logCallback !== 'function') {\r\n        throw ERROR_FACTORY.create(\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */);\r\n    }\r\n    setUserLogHandler(logCallback, options);\r\n}\r\n/**\r\n * Sets log level for all Firebase SDKs.\r\n *\r\n * All of the log types above the current log level are captured (i.e. if\r\n * you set the log level to `info`, errors are logged, but `debug` and\r\n * `verbose` logs are not).\r\n *\r\n * @public\r\n */\r\nfunction index_esm2017_setLogLevel(logLevel) {\r\n    setLogLevel$1(logLevel);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DB_NAME = 'firebase-heartbeat-database';\r\nconst DB_VERSION = 1;\r\nconst STORE_NAME = 'firebase-heartbeat-store';\r\nlet dbPromise = null;\r\nfunction getDbPromise() {\r\n    if (!dbPromise) {\r\n        dbPromise = openDB(DB_NAME, DB_VERSION, {\r\n            upgrade: (db, oldVersion) => {\r\n                // We don't use 'break' in this switch statement, the fall-through\r\n                // behavior is what we want, because if there are multiple versions between\r\n                // the old version and the current version, we want ALL the migrations\r\n                // that correspond to those versions to run, not only the last one.\r\n                // eslint-disable-next-line default-case\r\n                switch (oldVersion) {\r\n                    case 0:\r\n                        try {\r\n                            db.createObjectStore(STORE_NAME);\r\n                        }\r\n                        catch (e) {\r\n                            // Safari/iOS browsers throw occasional exceptions on\r\n                            // db.createObjectStore() that may be a bug. Avoid blocking\r\n                            // the rest of the app functionality.\r\n                            console.warn(e);\r\n                        }\r\n                }\r\n            }\r\n        }).catch(e => {\r\n            throw ERROR_FACTORY.create(\"idb-open\" /* AppError.IDB_OPEN */, {\r\n                originalErrorMessage: e.message\r\n            });\r\n        });\r\n    }\r\n    return dbPromise;\r\n}\r\nasync function readHeartbeatsFromIndexedDB(app) {\r\n    try {\r\n        const db = await getDbPromise();\r\n        const tx = db.transaction(STORE_NAME);\r\n        const result = await tx.objectStore(STORE_NAME).get(computeKey(app));\r\n        // We already have the value but tx.done can throw,\r\n        // so we need to await it here to catch errors\r\n        await tx.done;\r\n        return result;\r\n    }\r\n    catch (e) {\r\n        if (e instanceof FirebaseError) {\r\n            logger.warn(e.message);\r\n        }\r\n        else {\r\n            const idbGetError = ERROR_FACTORY.create(\"idb-get\" /* AppError.IDB_GET */, {\r\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\r\n            });\r\n            logger.warn(idbGetError.message);\r\n        }\r\n    }\r\n}\r\nasync function writeHeartbeatsToIndexedDB(app, heartbeatObject) {\r\n    try {\r\n        const db = await getDbPromise();\r\n        const tx = db.transaction(STORE_NAME, 'readwrite');\r\n        const objectStore = tx.objectStore(STORE_NAME);\r\n        await objectStore.put(heartbeatObject, computeKey(app));\r\n        await tx.done;\r\n    }\r\n    catch (e) {\r\n        if (e instanceof FirebaseError) {\r\n            logger.warn(e.message);\r\n        }\r\n        else {\r\n            const idbGetError = ERROR_FACTORY.create(\"idb-set\" /* AppError.IDB_WRITE */, {\r\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\r\n            });\r\n            logger.warn(idbGetError.message);\r\n        }\r\n    }\r\n}\r\nfunction computeKey(app) {\r\n    return `${app.name}!${app.options.appId}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst MAX_HEADER_BYTES = 1024;\r\n// 30 days\r\nconst STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1000;\r\nclass HeartbeatServiceImpl {\r\n    constructor(container) {\r\n        this.container = container;\r\n        /**\r\n         * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate\r\n         * the header string.\r\n         * Stores one record per date. This will be consolidated into the standard\r\n         * format of one record per user agent string before being sent as a header.\r\n         * Populated from indexedDB when the controller is instantiated and should\r\n         * be kept in sync with indexedDB.\r\n         * Leave public for easier testing.\r\n         */\r\n        this._heartbeatsCache = null;\r\n        const app = this.container.getProvider('app').getImmediate();\r\n        this._storage = new HeartbeatStorageImpl(app);\r\n        this._heartbeatsCachePromise = this._storage.read().then(result => {\r\n            this._heartbeatsCache = result;\r\n            return result;\r\n        });\r\n    }\r\n    /**\r\n     * Called to report a heartbeat. The function will generate\r\n     * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it\r\n     * to IndexedDB.\r\n     * Note that we only store one heartbeat per day. So if a heartbeat for today is\r\n     * already logged, subsequent calls to this function in the same day will be ignored.\r\n     */\r\n    async triggerHeartbeat() {\r\n        var _a, _b, _c;\r\n        try {\r\n            const platformLogger = this.container\r\n                .getProvider('platform-logger')\r\n                .getImmediate();\r\n            // This is the \"Firebase user agent\" string from the platform logger\r\n            // service, not the browser user agent.\r\n            const agent = platformLogger.getPlatformInfoString();\r\n            const date = getUTCDateString();\r\n            console.log('heartbeats', (_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats);\r\n            if (((_b = this._heartbeatsCache) === null || _b === void 0 ? void 0 : _b.heartbeats) == null) {\r\n                this._heartbeatsCache = await this._heartbeatsCachePromise;\r\n                // If we failed to construct a heartbeats cache, then return immediately.\r\n                if (((_c = this._heartbeatsCache) === null || _c === void 0 ? void 0 : _c.heartbeats) == null) {\r\n                    return;\r\n                }\r\n            }\r\n            // Do not store a heartbeat if one is already stored for this day\r\n            // or if a header has already been sent today.\r\n            if (this._heartbeatsCache.lastSentHeartbeatDate === date ||\r\n                this._heartbeatsCache.heartbeats.some(singleDateHeartbeat => singleDateHeartbeat.date === date)) {\r\n                return;\r\n            }\r\n            else {\r\n                // There is no entry for this date. Create one.\r\n                this._heartbeatsCache.heartbeats.push({ date, agent });\r\n            }\r\n            // Remove entries older than 30 days.\r\n            this._heartbeatsCache.heartbeats =\r\n                this._heartbeatsCache.heartbeats.filter(singleDateHeartbeat => {\r\n                    const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();\r\n                    const now = Date.now();\r\n                    return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;\r\n                });\r\n            return this._storage.overwrite(this._heartbeatsCache);\r\n        }\r\n        catch (e) {\r\n            logger.warn(e);\r\n        }\r\n    }\r\n    /**\r\n     * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.\r\n     * It also clears all heartbeats from memory as well as in IndexedDB.\r\n     *\r\n     * NOTE: Consuming product SDKs should not send the header if this method\r\n     * returns an empty string.\r\n     */\r\n    async getHeartbeatsHeader() {\r\n        var _a;\r\n        try {\r\n            if (this._heartbeatsCache === null) {\r\n                await this._heartbeatsCachePromise;\r\n            }\r\n            // If it's still null or the array is empty, there is no data to send.\r\n            if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null ||\r\n                this._heartbeatsCache.heartbeats.length === 0) {\r\n                return '';\r\n            }\r\n            const date = getUTCDateString();\r\n            // Extract as many heartbeats from the cache as will fit under the size limit.\r\n            const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);\r\n            const headerString = base64urlEncodeWithoutPadding(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));\r\n            // Store last sent date to prevent another being logged/sent for the same day.\r\n            this._heartbeatsCache.lastSentHeartbeatDate = date;\r\n            if (unsentEntries.length > 0) {\r\n                // Store any unsent entries if they exist.\r\n                this._heartbeatsCache.heartbeats = unsentEntries;\r\n                // This seems more likely than emptying the array (below) to lead to some odd state\r\n                // since the cache isn't empty and this will be called again on the next request,\r\n                // and is probably safest if we await it.\r\n                await this._storage.overwrite(this._heartbeatsCache);\r\n            }\r\n            else {\r\n                this._heartbeatsCache.heartbeats = [];\r\n                // Do not wait for this, to reduce latency.\r\n                void this._storage.overwrite(this._heartbeatsCache);\r\n            }\r\n            return headerString;\r\n        }\r\n        catch (e) {\r\n            logger.warn(e);\r\n            return '';\r\n        }\r\n    }\r\n}\r\nfunction getUTCDateString() {\r\n    const today = new Date();\r\n    // Returns date format 'YYYY-MM-DD'\r\n    return today.toISOString().substring(0, 10);\r\n}\r\nfunction extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {\r\n    // Heartbeats grouped by user agent in the standard format to be sent in\r\n    // the header.\r\n    const heartbeatsToSend = [];\r\n    // Single date format heartbeats that are not sent.\r\n    let unsentEntries = heartbeatsCache.slice();\r\n    for (const singleDateHeartbeat of heartbeatsCache) {\r\n        // Look for an existing entry with the same user agent.\r\n        const heartbeatEntry = heartbeatsToSend.find(hb => hb.agent === singleDateHeartbeat.agent);\r\n        if (!heartbeatEntry) {\r\n            // If no entry for this user agent exists, create one.\r\n            heartbeatsToSend.push({\r\n                agent: singleDateHeartbeat.agent,\r\n                dates: [singleDateHeartbeat.date]\r\n            });\r\n            if (countBytes(heartbeatsToSend) > maxSize) {\r\n                // If the header would exceed max size, remove the added heartbeat\r\n                // entry and stop adding to the header.\r\n                heartbeatsToSend.pop();\r\n                break;\r\n            }\r\n        }\r\n        else {\r\n            heartbeatEntry.dates.push(singleDateHeartbeat.date);\r\n            // If the header would exceed max size, remove the added date\r\n            // and stop adding to the header.\r\n            if (countBytes(heartbeatsToSend) > maxSize) {\r\n                heartbeatEntry.dates.pop();\r\n                break;\r\n            }\r\n        }\r\n        // Pop unsent entry from queue. (Skipped if adding the entry exceeded\r\n        // quota and the loop breaks early.)\r\n        unsentEntries = unsentEntries.slice(1);\r\n    }\r\n    return {\r\n        heartbeatsToSend,\r\n        unsentEntries\r\n    };\r\n}\r\nclass HeartbeatStorageImpl {\r\n    constructor(app) {\r\n        this.app = app;\r\n        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();\r\n    }\r\n    async runIndexedDBEnvironmentCheck() {\r\n        if (!isIndexedDBAvailable()) {\r\n            return false;\r\n        }\r\n        else {\r\n            return validateIndexedDBOpenable()\r\n                .then(() => true)\r\n                .catch(() => false);\r\n        }\r\n    }\r\n    /**\r\n     * Read all heartbeats.\r\n     */\r\n    async read() {\r\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\r\n        if (!canUseIndexedDB) {\r\n            return { heartbeats: [] };\r\n        }\r\n        else {\r\n            const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);\r\n            if (idbHeartbeatObject === null || idbHeartbeatObject === void 0 ? void 0 : idbHeartbeatObject.heartbeats) {\r\n                return idbHeartbeatObject;\r\n            }\r\n            else {\r\n                return { heartbeats: [] };\r\n            }\r\n        }\r\n    }\r\n    // overwrite the storage with the provided heartbeats\r\n    async overwrite(heartbeatsObject) {\r\n        var _a;\r\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\r\n        if (!canUseIndexedDB) {\r\n            return;\r\n        }\r\n        else {\r\n            const existingHeartbeatsObject = await this.read();\r\n            return writeHeartbeatsToIndexedDB(this.app, {\r\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\r\n                heartbeats: heartbeatsObject.heartbeats\r\n            });\r\n        }\r\n    }\r\n    // add heartbeats\r\n    async add(heartbeatsObject) {\r\n        var _a;\r\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\r\n        if (!canUseIndexedDB) {\r\n            return;\r\n        }\r\n        else {\r\n            const existingHeartbeatsObject = await this.read();\r\n            return writeHeartbeatsToIndexedDB(this.app, {\r\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\r\n                heartbeats: [\r\n                    ...existingHeartbeatsObject.heartbeats,\r\n                    ...heartbeatsObject.heartbeats\r\n                ]\r\n            });\r\n        }\r\n    }\r\n}\r\n/**\r\n * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped\r\n * in a platform logging header JSON object, stringified, and converted\r\n * to base 64.\r\n */\r\nfunction countBytes(heartbeatsCache) {\r\n    // base64 has a restricted set of characters, all of which should be 1 byte.\r\n    return base64urlEncodeWithoutPadding(\r\n    // heartbeatsCache wrapper properties\r\n    JSON.stringify({ version: 2, heartbeats: heartbeatsCache })).length;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction registerCoreComponents(variant) {\r\n    _registerComponent(new index_esm2017_Component('platform-logger', container => new PlatformLoggerServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */));\r\n    _registerComponent(new index_esm2017_Component('heartbeat', container => new HeartbeatServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */));\r\n    // Register `app` package.\r\n    registerVersion(name$p, version$1, variant);\r\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\r\n    registerVersion(name$p, version$1, 'esm2017');\r\n    // Register platform SDK identifier (no version).\r\n    registerVersion('fire-js', '');\r\n}\n\n/**\r\n * Firebase App\r\n *\r\n * @remarks This package coordinates the communication between the different Firebase components\r\n * @packageDocumentation\r\n */\r\nregisterCoreComponents('');\n\n\n//# sourceMappingURL=index.esm2017.js.map\n\n;// CONCATENATED MODULE: ./node_modules/firebase/app/dist/esm/index.esm.js\n\n\n\nvar index_esm_name = \"firebase\";\nvar index_esm_version = \"10.13.0\";\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nregisterVersion(index_esm_name, index_esm_version, 'app');\n//# sourceMappingURL=index.esm.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@firebase/functions/dist/index.esm2017.js\n\n\n\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LONG_TYPE = 'type.googleapis.com/google.protobuf.Int64Value';\r\nconst UNSIGNED_LONG_TYPE = 'type.googleapis.com/google.protobuf.UInt64Value';\r\nfunction mapValues(\r\n// { [k: string]: unknown } is no longer a wildcard assignment target after typescript 3.5\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\no, f) {\r\n    const result = {};\r\n    for (const key in o) {\r\n        if (o.hasOwnProperty(key)) {\r\n            result[key] = f(o[key]);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Takes data and encodes it in a JSON-friendly way, such that types such as\r\n * Date are preserved.\r\n * @internal\r\n * @param data - Data to encode.\r\n */\r\nfunction encode(data) {\r\n    if (data == null) {\r\n        return null;\r\n    }\r\n    if (data instanceof Number) {\r\n        data = data.valueOf();\r\n    }\r\n    if (typeof data === 'number' && isFinite(data)) {\r\n        // Any number in JS is safe to put directly in JSON and parse as a double\r\n        // without any loss of precision.\r\n        return data;\r\n    }\r\n    if (data === true || data === false) {\r\n        return data;\r\n    }\r\n    if (Object.prototype.toString.call(data) === '[object String]') {\r\n        return data;\r\n    }\r\n    if (data instanceof Date) {\r\n        return data.toISOString();\r\n    }\r\n    if (Array.isArray(data)) {\r\n        return data.map(x => encode(x));\r\n    }\r\n    if (typeof data === 'function' || typeof data === 'object') {\r\n        return mapValues(data, x => encode(x));\r\n    }\r\n    // If we got this far, the data is not encodable.\r\n    throw new Error('Data cannot be encoded in JSON: ' + data);\r\n}\r\n/**\r\n * Takes data that's been encoded in a JSON-friendly form and returns a form\r\n * with richer datatypes, such as Dates, etc.\r\n * @internal\r\n * @param json - JSON to convert.\r\n */\r\nfunction index_esm2017_decode(json) {\r\n    if (json == null) {\r\n        return json;\r\n    }\r\n    if (json['@type']) {\r\n        switch (json['@type']) {\r\n            case LONG_TYPE:\r\n            // Fall through and handle this the same as unsigned.\r\n            case UNSIGNED_LONG_TYPE: {\r\n                // Technically, this could work return a valid number for malformed\r\n                // data if there was a number followed by garbage. But it's just not\r\n                // worth all the extra code to detect that case.\r\n                const value = Number(json['value']);\r\n                if (isNaN(value)) {\r\n                    throw new Error('Data cannot be decoded from JSON: ' + json);\r\n                }\r\n                return value;\r\n            }\r\n            default: {\r\n                throw new Error('Data cannot be decoded from JSON: ' + json);\r\n            }\r\n        }\r\n    }\r\n    if (Array.isArray(json)) {\r\n        return json.map(x => index_esm2017_decode(x));\r\n    }\r\n    if (typeof json === 'function' || typeof json === 'object') {\r\n        return mapValues(json, x => index_esm2017_decode(x));\r\n    }\r\n    // Anything else is safe to return.\r\n    return json;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Type constant for Firebase Functions.\r\n */\r\nconst FUNCTIONS_TYPE = 'functions';\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Standard error codes for different ways a request can fail, as defined by:\r\n * https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto\r\n *\r\n * This map is used primarily to convert from a backend error code string to\r\n * a client SDK error code string, and make sure it's in the supported set.\r\n */\r\nconst errorCodeMap = {\r\n    OK: 'ok',\r\n    CANCELLED: 'cancelled',\r\n    UNKNOWN: 'unknown',\r\n    INVALID_ARGUMENT: 'invalid-argument',\r\n    DEADLINE_EXCEEDED: 'deadline-exceeded',\r\n    NOT_FOUND: 'not-found',\r\n    ALREADY_EXISTS: 'already-exists',\r\n    PERMISSION_DENIED: 'permission-denied',\r\n    UNAUTHENTICATED: 'unauthenticated',\r\n    RESOURCE_EXHAUSTED: 'resource-exhausted',\r\n    FAILED_PRECONDITION: 'failed-precondition',\r\n    ABORTED: 'aborted',\r\n    OUT_OF_RANGE: 'out-of-range',\r\n    UNIMPLEMENTED: 'unimplemented',\r\n    INTERNAL: 'internal',\r\n    UNAVAILABLE: 'unavailable',\r\n    DATA_LOSS: 'data-loss'\r\n};\r\n/**\r\n * An explicit error that can be thrown from a handler to send an error to the\r\n * client that called the function.\r\n */\r\nclass FunctionsError extends FirebaseError {\r\n    constructor(\r\n    /**\r\n     * A standard error code that will be returned to the client. This also\r\n     * determines the HTTP status code of the response, as defined in code.proto.\r\n     */\r\n    code, message, \r\n    /**\r\n     * Extra data to be converted to JSON and included in the error response.\r\n     */\r\n    details) {\r\n        super(`${FUNCTIONS_TYPE}/${code}`, message || '');\r\n        this.details = details;\r\n    }\r\n}\r\n/**\r\n * Takes an HTTP status code and returns the corresponding ErrorCode.\r\n * This is the standard HTTP status code -> error mapping defined in:\r\n * https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto\r\n *\r\n * @param status An HTTP status code.\r\n * @return The corresponding ErrorCode, or ErrorCode.UNKNOWN if none.\r\n */\r\nfunction codeForHTTPStatus(status) {\r\n    // Make sure any successful status is OK.\r\n    if (status >= 200 && status < 300) {\r\n        return 'ok';\r\n    }\r\n    switch (status) {\r\n        case 0:\r\n            // This can happen if the server returns 500.\r\n            return 'internal';\r\n        case 400:\r\n            return 'invalid-argument';\r\n        case 401:\r\n            return 'unauthenticated';\r\n        case 403:\r\n            return 'permission-denied';\r\n        case 404:\r\n            return 'not-found';\r\n        case 409:\r\n            return 'aborted';\r\n        case 429:\r\n            return 'resource-exhausted';\r\n        case 499:\r\n            return 'cancelled';\r\n        case 500:\r\n            return 'internal';\r\n        case 501:\r\n            return 'unimplemented';\r\n        case 503:\r\n            return 'unavailable';\r\n        case 504:\r\n            return 'deadline-exceeded';\r\n    }\r\n    return 'unknown';\r\n}\r\n/**\r\n * Takes an HTTP response and returns the corresponding Error, if any.\r\n */\r\nfunction _errorForResponse(status, bodyJSON) {\r\n    let code = codeForHTTPStatus(status);\r\n    // Start with reasonable defaults from the status code.\r\n    let description = code;\r\n    let details = undefined;\r\n    // Then look through the body for explicit details.\r\n    try {\r\n        const errorJSON = bodyJSON && bodyJSON.error;\r\n        if (errorJSON) {\r\n            const status = errorJSON.status;\r\n            if (typeof status === 'string') {\r\n                if (!errorCodeMap[status]) {\r\n                    // They must've included an unknown error code in the body.\r\n                    return new FunctionsError('internal', 'internal');\r\n                }\r\n                code = errorCodeMap[status];\r\n                // TODO(klimt): Add better default descriptions for error enums.\r\n                // The default description needs to be updated for the new code.\r\n                description = status;\r\n            }\r\n            const message = errorJSON.message;\r\n            if (typeof message === 'string') {\r\n                description = message;\r\n            }\r\n            details = errorJSON.details;\r\n            if (details !== undefined) {\r\n                details = index_esm2017_decode(details);\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        // If we couldn't parse explicit error data, that's fine.\r\n    }\r\n    if (code === 'ok') {\r\n        // Technically, there's an edge case where a developer could explicitly\r\n        // return an error code of OK, and we will treat it as success, but that\r\n        // seems reasonable.\r\n        return null;\r\n    }\r\n    return new FunctionsError(code, description, details);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Helper class to get metadata that should be included with a function call.\r\n * @internal\r\n */\r\nclass ContextProvider {\r\n    constructor(authProvider, messagingProvider, appCheckProvider) {\r\n        this.auth = null;\r\n        this.messaging = null;\r\n        this.appCheck = null;\r\n        this.auth = authProvider.getImmediate({ optional: true });\r\n        this.messaging = messagingProvider.getImmediate({\r\n            optional: true\r\n        });\r\n        if (!this.auth) {\r\n            authProvider.get().then(auth => (this.auth = auth), () => {\r\n                /* get() never rejects */\r\n            });\r\n        }\r\n        if (!this.messaging) {\r\n            messagingProvider.get().then(messaging => (this.messaging = messaging), () => {\r\n                /* get() never rejects */\r\n            });\r\n        }\r\n        if (!this.appCheck) {\r\n            appCheckProvider.get().then(appCheck => (this.appCheck = appCheck), () => {\r\n                /* get() never rejects */\r\n            });\r\n        }\r\n    }\r\n    async getAuthToken() {\r\n        if (!this.auth) {\r\n            return undefined;\r\n        }\r\n        try {\r\n            const token = await this.auth.getToken();\r\n            return token === null || token === void 0 ? void 0 : token.accessToken;\r\n        }\r\n        catch (e) {\r\n            // If there's any error when trying to get the auth token, leave it off.\r\n            return undefined;\r\n        }\r\n    }\r\n    async getMessagingToken() {\r\n        if (!this.messaging ||\r\n            !('Notification' in self) ||\r\n            Notification.permission !== 'granted') {\r\n            return undefined;\r\n        }\r\n        try {\r\n            return await this.messaging.getToken();\r\n        }\r\n        catch (e) {\r\n            // We don't warn on this, because it usually means messaging isn't set up.\r\n            // console.warn('Failed to retrieve instance id token.', e);\r\n            // If there's any error when trying to get the token, leave it off.\r\n            return undefined;\r\n        }\r\n    }\r\n    async getAppCheckToken(limitedUseAppCheckTokens) {\r\n        if (this.appCheck) {\r\n            const result = limitedUseAppCheckTokens\r\n                ? await this.appCheck.getLimitedUseToken()\r\n                : await this.appCheck.getToken();\r\n            if (result.error) {\r\n                // Do not send the App Check header to the functions endpoint if\r\n                // there was an error from the App Check exchange endpoint. The App\r\n                // Check SDK will already have logged the error to console.\r\n                return null;\r\n            }\r\n            return result.token;\r\n        }\r\n        return null;\r\n    }\r\n    async getContext(limitedUseAppCheckTokens) {\r\n        const authToken = await this.getAuthToken();\r\n        const messagingToken = await this.getMessagingToken();\r\n        const appCheckToken = await this.getAppCheckToken(limitedUseAppCheckTokens);\r\n        return { authToken, messagingToken, appCheckToken };\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DEFAULT_REGION = 'us-central1';\r\n/**\r\n * Returns a Promise that will be rejected after the given duration.\r\n * The error will be of type FunctionsError.\r\n *\r\n * @param millis Number of milliseconds to wait before rejecting.\r\n */\r\nfunction failAfter(millis) {\r\n    // Node timers and browser timers are fundamentally incompatible, but we\r\n    // don't care about the value here\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    let timer = null;\r\n    return {\r\n        promise: new Promise((_, reject) => {\r\n            timer = setTimeout(() => {\r\n                reject(new FunctionsError('deadline-exceeded', 'deadline-exceeded'));\r\n            }, millis);\r\n        }),\r\n        cancel: () => {\r\n            if (timer) {\r\n                clearTimeout(timer);\r\n            }\r\n        }\r\n    };\r\n}\r\n/**\r\n * The main class for the Firebase Functions SDK.\r\n * @internal\r\n */\r\nclass FunctionsService {\r\n    /**\r\n     * Creates a new Functions service for the given app.\r\n     * @param app - The FirebaseApp to use.\r\n     */\r\n    constructor(app, authProvider, messagingProvider, appCheckProvider, regionOrCustomDomain = DEFAULT_REGION, fetchImpl) {\r\n        this.app = app;\r\n        this.fetchImpl = fetchImpl;\r\n        this.emulatorOrigin = null;\r\n        this.contextProvider = new ContextProvider(authProvider, messagingProvider, appCheckProvider);\r\n        // Cancels all ongoing requests when resolved.\r\n        this.cancelAllRequests = new Promise(resolve => {\r\n            this.deleteService = () => {\r\n                return Promise.resolve(resolve());\r\n            };\r\n        });\r\n        // Resolve the region or custom domain overload by attempting to parse it.\r\n        try {\r\n            const url = new URL(regionOrCustomDomain);\r\n            this.customDomain = url.origin;\r\n            this.region = DEFAULT_REGION;\r\n        }\r\n        catch (e) {\r\n            this.customDomain = null;\r\n            this.region = regionOrCustomDomain;\r\n        }\r\n    }\r\n    _delete() {\r\n        return this.deleteService();\r\n    }\r\n    /**\r\n     * Returns the URL for a callable with the given name.\r\n     * @param name - The name of the callable.\r\n     * @internal\r\n     */\r\n    _url(name) {\r\n        const projectId = this.app.options.projectId;\r\n        if (this.emulatorOrigin !== null) {\r\n            const origin = this.emulatorOrigin;\r\n            return `${origin}/${projectId}/${this.region}/${name}`;\r\n        }\r\n        if (this.customDomain !== null) {\r\n            return `${this.customDomain}/${name}`;\r\n        }\r\n        return `https://${this.region}-${projectId}.cloudfunctions.net/${name}`;\r\n    }\r\n}\r\n/**\r\n * Modify this instance to communicate with the Cloud Functions emulator.\r\n *\r\n * Note: this must be called before this instance has been used to do any operations.\r\n *\r\n * @param host The emulator host (ex: localhost)\r\n * @param port The emulator port (ex: 5001)\r\n * @public\r\n */\r\nfunction connectFunctionsEmulator$1(functionsInstance, host, port) {\r\n    functionsInstance.emulatorOrigin = `http://${host}:${port}`;\r\n}\r\n/**\r\n * Returns a reference to the callable https trigger with the given name.\r\n * @param name - The name of the trigger.\r\n * @public\r\n */\r\nfunction httpsCallable$1(functionsInstance, name, options) {\r\n    return (data => {\r\n        return call(functionsInstance, name, data, options || {});\r\n    });\r\n}\r\n/**\r\n * Returns a reference to the callable https trigger with the given url.\r\n * @param url - The url of the trigger.\r\n * @public\r\n */\r\nfunction httpsCallableFromURL$1(functionsInstance, url, options) {\r\n    return (data => {\r\n        return callAtURL(functionsInstance, url, data, options || {});\r\n    });\r\n}\r\n/**\r\n * Does an HTTP POST and returns the completed response.\r\n * @param url The url to post to.\r\n * @param body The JSON body of the post.\r\n * @param headers The HTTP headers to include in the request.\r\n * @return A Promise that will succeed when the request finishes.\r\n */\r\nasync function postJSON(url, body, headers, fetchImpl) {\r\n    headers['Content-Type'] = 'application/json';\r\n    let response;\r\n    try {\r\n        response = await fetchImpl(url, {\r\n            method: 'POST',\r\n            body: JSON.stringify(body),\r\n            headers\r\n        });\r\n    }\r\n    catch (e) {\r\n        // This could be an unhandled error on the backend, or it could be a\r\n        // network error. There's no way to know, since an unhandled error on the\r\n        // backend will fail to set the proper CORS header, and thus will be\r\n        // treated as a network error by fetch.\r\n        return {\r\n            status: 0,\r\n            json: null\r\n        };\r\n    }\r\n    let json = null;\r\n    try {\r\n        json = await response.json();\r\n    }\r\n    catch (e) {\r\n        // If we fail to parse JSON, it will fail the same as an empty body.\r\n    }\r\n    return {\r\n        status: response.status,\r\n        json\r\n    };\r\n}\r\n/**\r\n * Calls a callable function asynchronously and returns the result.\r\n * @param name The name of the callable trigger.\r\n * @param data The data to pass as params to the function.s\r\n */\r\nfunction call(functionsInstance, name, data, options) {\r\n    const url = functionsInstance._url(name);\r\n    return callAtURL(functionsInstance, url, data, options);\r\n}\r\n/**\r\n * Calls a callable function asynchronously and returns the result.\r\n * @param url The url of the callable trigger.\r\n * @param data The data to pass as params to the function.s\r\n */\r\nasync function callAtURL(functionsInstance, url, data, options) {\r\n    // Encode any special types, such as dates, in the input data.\r\n    data = encode(data);\r\n    const body = { data };\r\n    // Add a header for the authToken.\r\n    const headers = {};\r\n    const context = await functionsInstance.contextProvider.getContext(options.limitedUseAppCheckTokens);\r\n    if (context.authToken) {\r\n        headers['Authorization'] = 'Bearer ' + context.authToken;\r\n    }\r\n    if (context.messagingToken) {\r\n        headers['Firebase-Instance-ID-Token'] = context.messagingToken;\r\n    }\r\n    if (context.appCheckToken !== null) {\r\n        headers['X-Firebase-AppCheck'] = context.appCheckToken;\r\n    }\r\n    // Default timeout to 70s, but let the options override it.\r\n    const timeout = options.timeout || 70000;\r\n    const failAfterHandle = failAfter(timeout);\r\n    const response = await Promise.race([\r\n        postJSON(url, body, headers, functionsInstance.fetchImpl),\r\n        failAfterHandle.promise,\r\n        functionsInstance.cancelAllRequests\r\n    ]);\r\n    // Always clear the failAfter timeout\r\n    failAfterHandle.cancel();\r\n    // If service was deleted, interrupted response throws an error.\r\n    if (!response) {\r\n        throw new FunctionsError('cancelled', 'Firebase Functions instance was deleted.');\r\n    }\r\n    // Check for an error status, regardless of http status.\r\n    const error = _errorForResponse(response.status, response.json);\r\n    if (error) {\r\n        throw error;\r\n    }\r\n    if (!response.json) {\r\n        throw new FunctionsError('internal', 'Response is not valid JSON object.');\r\n    }\r\n    let responseData = response.json.data;\r\n    // TODO(klimt): For right now, allow \"result\" instead of \"data\", for\r\n    // backwards compatibility.\r\n    if (typeof responseData === 'undefined') {\r\n        responseData = response.json.result;\r\n    }\r\n    if (typeof responseData === 'undefined') {\r\n        // Consider the response malformed.\r\n        throw new FunctionsError('internal', 'Response is missing data field.');\r\n    }\r\n    // Decode any special types, such as dates, in the returned data.\r\n    const decodedData = index_esm2017_decode(responseData);\r\n    return { data: decodedData };\r\n}\n\nconst dist_index_esm2017_name = \"@firebase/functions\";\nconst index_esm2017_version = \"0.11.6\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst AUTH_INTERNAL_NAME = 'auth-internal';\r\nconst APP_CHECK_INTERNAL_NAME = 'app-check-internal';\r\nconst MESSAGING_INTERNAL_NAME = 'messaging-internal';\r\nfunction registerFunctions(fetchImpl, variant) {\r\n    const factory = (container, { instanceIdentifier: regionOrCustomDomain }) => {\r\n        // Dependencies\r\n        const app = container.getProvider('app').getImmediate();\r\n        const authProvider = container.getProvider(AUTH_INTERNAL_NAME);\r\n        const messagingProvider = container.getProvider(MESSAGING_INTERNAL_NAME);\r\n        const appCheckProvider = container.getProvider(APP_CHECK_INTERNAL_NAME);\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return new FunctionsService(app, authProvider, messagingProvider, appCheckProvider, regionOrCustomDomain, fetchImpl);\r\n    };\r\n    _registerComponent(new index_esm2017_Component(FUNCTIONS_TYPE, factory, \"PUBLIC\" /* ComponentType.PUBLIC */).setMultipleInstances(true));\r\n    registerVersion(dist_index_esm2017_name, index_esm2017_version, variant);\r\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\r\n    registerVersion(dist_index_esm2017_name, index_esm2017_version, 'esm2017');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a {@link Functions} instance for the given app.\r\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\r\n * @param regionOrCustomDomain - one of:\r\n *   a) The region the callable functions are located in (ex: us-central1)\r\n *   b) A custom domain hosting the callable functions (ex: https://mydomain.com)\r\n * @public\r\n */\r\nfunction getFunctions(app = getApp(), regionOrCustomDomain = DEFAULT_REGION) {\r\n    // Dependencies\r\n    const functionsProvider = _getProvider(index_esm2017_getModularInstance(app), FUNCTIONS_TYPE);\r\n    const functionsInstance = functionsProvider.getImmediate({\r\n        identifier: regionOrCustomDomain\r\n    });\r\n    const emulator = getDefaultEmulatorHostnameAndPort('functions');\r\n    if (emulator) {\r\n        connectFunctionsEmulator(functionsInstance, ...emulator);\r\n    }\r\n    return functionsInstance;\r\n}\r\n/**\r\n * Modify this instance to communicate with the Cloud Functions emulator.\r\n *\r\n * Note: this must be called before this instance has been used to do any operations.\r\n *\r\n * @param host - The emulator host (ex: localhost)\r\n * @param port - The emulator port (ex: 5001)\r\n * @public\r\n */\r\nfunction connectFunctionsEmulator(functionsInstance, host, port) {\r\n    connectFunctionsEmulator$1(index_esm2017_getModularInstance(functionsInstance), host, port);\r\n}\r\n/**\r\n * Returns a reference to the callable HTTPS trigger with the given name.\r\n * @param name - The name of the trigger.\r\n * @public\r\n */\r\nfunction httpsCallable(functionsInstance, name, options) {\r\n    return httpsCallable$1(index_esm2017_getModularInstance(functionsInstance), name, options);\r\n}\r\n/**\r\n * Returns a reference to the callable HTTPS trigger with the specified url.\r\n * @param url - The url of the trigger.\r\n * @public\r\n */\r\nfunction httpsCallableFromURL(functionsInstance, url, options) {\r\n    return httpsCallableFromURL$1(getModularInstance(functionsInstance), url, options);\r\n}\n\n/**\r\n * Cloud Functions for Firebase\r\n *\r\n * @packageDocumentation\r\n */\r\nregisterFunctions(fetch.bind(self));\n\n\n//# sourceMappingURL=index.esm2017.js.map\n\n;// CONCATENATED MODULE: ./node_modules/firebase/functions/dist/esm/index.esm.js\n\n//# sourceMappingURL=index.esm.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@firebase/database/dist/index.esm2017.js\n\n\n\n\n\nconst database_dist_index_esm2017_name = \"@firebase/database\";\nconst dist_index_esm2017_version = \"1.0.7\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** The semver (www.semver.org) version of the SDK. */\r\nlet index_esm2017_SDK_VERSION = '';\r\n/**\r\n * SDK_VERSION should be set before any database instance is created\r\n * @internal\r\n */\r\nfunction setSDKVersion(version) {\r\n    index_esm2017_SDK_VERSION = version;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Wraps a DOM Storage object and:\r\n * - automatically encode objects as JSON strings before storing them to allow us to store arbitrary types.\r\n * - prefixes names with \"firebase:\" to avoid collisions with app data.\r\n *\r\n * We automatically (see storage.js) create two such wrappers, one for sessionStorage,\r\n * and one for localStorage.\r\n *\r\n */\r\nclass DOMStorageWrapper {\r\n    /**\r\n     * @param domStorage_ - The underlying storage object (e.g. localStorage or sessionStorage)\r\n     */\r\n    constructor(domStorage_) {\r\n        this.domStorage_ = domStorage_;\r\n        // Use a prefix to avoid collisions with other stuff saved by the app.\r\n        this.prefix_ = 'firebase:';\r\n    }\r\n    /**\r\n     * @param key - The key to save the value under\r\n     * @param value - The value being stored, or null to remove the key.\r\n     */\r\n    set(key, value) {\r\n        if (value == null) {\r\n            this.domStorage_.removeItem(this.prefixedName_(key));\r\n        }\r\n        else {\r\n            this.domStorage_.setItem(this.prefixedName_(key), index_esm2017_stringify(value));\r\n        }\r\n    }\r\n    /**\r\n     * @returns The value that was stored under this key, or null\r\n     */\r\n    get(key) {\r\n        const storedVal = this.domStorage_.getItem(this.prefixedName_(key));\r\n        if (storedVal == null) {\r\n            return null;\r\n        }\r\n        else {\r\n            return jsonEval(storedVal);\r\n        }\r\n    }\r\n    remove(key) {\r\n        this.domStorage_.removeItem(this.prefixedName_(key));\r\n    }\r\n    prefixedName_(name) {\r\n        return this.prefix_ + name;\r\n    }\r\n    toString() {\r\n        return this.domStorage_.toString();\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An in-memory storage implementation that matches the API of DOMStorageWrapper\r\n * (TODO: create interface for both to implement).\r\n */\r\nclass MemoryStorage {\r\n    constructor() {\r\n        this.cache_ = {};\r\n        this.isInMemoryStorage = true;\r\n    }\r\n    set(key, value) {\r\n        if (value == null) {\r\n            delete this.cache_[key];\r\n        }\r\n        else {\r\n            this.cache_[key] = value;\r\n        }\r\n    }\r\n    get(key) {\r\n        if (index_esm2017_contains(this.cache_, key)) {\r\n            return this.cache_[key];\r\n        }\r\n        return null;\r\n    }\r\n    remove(key) {\r\n        delete this.cache_[key];\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Helper to create a DOMStorageWrapper or else fall back to MemoryStorage.\r\n * TODO: Once MemoryStorage and DOMStorageWrapper have a shared interface this method annotation should change\r\n * to reflect this type\r\n *\r\n * @param domStorageName - Name of the underlying storage object\r\n *   (e.g. 'localStorage' or 'sessionStorage').\r\n * @returns Turning off type information until a common interface is defined.\r\n */\r\nconst createStoragefor = function (domStorageName) {\r\n    try {\r\n        // NOTE: just accessing \"localStorage\" or \"window['localStorage']\" may throw a security exception,\r\n        // so it must be inside the try/catch.\r\n        if (typeof window !== 'undefined' &&\r\n            typeof window[domStorageName] !== 'undefined') {\r\n            // Need to test cache. Just because it's here doesn't mean it works\r\n            const domStorage = window[domStorageName];\r\n            domStorage.setItem('firebase:sentinel', 'cache');\r\n            domStorage.removeItem('firebase:sentinel');\r\n            return new DOMStorageWrapper(domStorage);\r\n        }\r\n    }\r\n    catch (e) { }\r\n    // Failed to create wrapper.  Just return in-memory storage.\r\n    // TODO: log?\r\n    return new MemoryStorage();\r\n};\r\n/** A storage object that lasts across sessions */\r\nconst PersistentStorage = createStoragefor('localStorage');\r\n/** A storage object that only lasts one session */\r\nconst SessionStorage = createStoragefor('sessionStorage');\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst logClient = new Logger('@firebase/database');\r\n/**\r\n * Returns a locally-unique ID (generated by just incrementing up from 0 each time its called).\r\n */\r\nconst LUIDGenerator = (function () {\r\n    let id = 1;\r\n    return function () {\r\n        return id++;\r\n    };\r\n})();\r\n/**\r\n * Sha1 hash of the input string\r\n * @param str - The string to hash\r\n * @returns {!string} The resulting hash\r\n */\r\nconst sha1 = function (str) {\r\n    const utf8Bytes = stringToByteArray(str);\r\n    const sha1 = new Sha1();\r\n    sha1.update(utf8Bytes);\r\n    const sha1Bytes = sha1.digest();\r\n    return base64.encodeByteArray(sha1Bytes);\r\n};\r\nconst buildLogMessage_ = function (...varArgs) {\r\n    let message = '';\r\n    for (let i = 0; i < varArgs.length; i++) {\r\n        const arg = varArgs[i];\r\n        if (Array.isArray(arg) ||\r\n            (arg &&\r\n                typeof arg === 'object' &&\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                typeof arg.length === 'number')) {\r\n            message += buildLogMessage_.apply(null, arg);\r\n        }\r\n        else if (typeof arg === 'object') {\r\n            message += index_esm2017_stringify(arg);\r\n        }\r\n        else {\r\n            message += arg;\r\n        }\r\n        message += ' ';\r\n    }\r\n    return message;\r\n};\r\n/**\r\n * Use this for all debug messages in Firebase.\r\n */\r\nlet index_esm2017_logger = null;\r\n/**\r\n * Flag to check for log availability on first log message\r\n */\r\nlet firstLog_ = true;\r\n/**\r\n * The implementation of Firebase.enableLogging (defined here to break dependencies)\r\n * @param logger_ - A flag to turn on logging, or a custom logger\r\n * @param persistent - Whether or not to persist logging settings across refreshes\r\n */\r\nconst enableLogging$1 = function (logger_, persistent) {\r\n    index_esm2017_assert(!persistent || logger_ === true || logger_ === false, \"Can't turn on custom loggers persistently.\");\r\n    if (logger_ === true) {\r\n        logClient.logLevel = LogLevel.VERBOSE;\r\n        index_esm2017_logger = logClient.log.bind(logClient);\r\n        if (persistent) {\r\n            SessionStorage.set('logging_enabled', true);\r\n        }\r\n    }\r\n    else if (typeof logger_ === 'function') {\r\n        index_esm2017_logger = logger_;\r\n    }\r\n    else {\r\n        index_esm2017_logger = null;\r\n        SessionStorage.remove('logging_enabled');\r\n    }\r\n};\r\nconst log = function (...varArgs) {\r\n    if (firstLog_ === true) {\r\n        firstLog_ = false;\r\n        if (index_esm2017_logger === null && SessionStorage.get('logging_enabled') === true) {\r\n            enableLogging$1(true);\r\n        }\r\n    }\r\n    if (index_esm2017_logger) {\r\n        const message = buildLogMessage_.apply(null, varArgs);\r\n        index_esm2017_logger(message);\r\n    }\r\n};\r\nconst logWrapper = function (prefix) {\r\n    return function (...varArgs) {\r\n        log(prefix, ...varArgs);\r\n    };\r\n};\r\nconst error = function (...varArgs) {\r\n    const message = 'FIREBASE INTERNAL ERROR: ' + buildLogMessage_(...varArgs);\r\n    logClient.error(message);\r\n};\r\nconst fatal = function (...varArgs) {\r\n    const message = `FIREBASE FATAL ERROR: ${buildLogMessage_(...varArgs)}`;\r\n    logClient.error(message);\r\n    throw new Error(message);\r\n};\r\nconst warn = function (...varArgs) {\r\n    const message = 'FIREBASE WARNING: ' + buildLogMessage_(...varArgs);\r\n    logClient.warn(message);\r\n};\r\n/**\r\n * Logs a warning if the containing page uses https. Called when a call to new Firebase\r\n * does not use https.\r\n */\r\nconst warnIfPageIsSecure = function () {\r\n    // Be very careful accessing browser globals. Who knows what may or may not exist.\r\n    if (typeof window !== 'undefined' &&\r\n        window.location &&\r\n        window.location.protocol &&\r\n        window.location.protocol.indexOf('https:') !== -1) {\r\n        warn('Insecure Firebase access from a secure page. ' +\r\n            'Please use https in calls to new Firebase().');\r\n    }\r\n};\r\n/**\r\n * Returns true if data is NaN, or +/- Infinity.\r\n */\r\nconst isInvalidJSONNumber = function (data) {\r\n    return (typeof data === 'number' &&\r\n        (data !== data || // NaN\r\n            data === Number.POSITIVE_INFINITY ||\r\n            data === Number.NEGATIVE_INFINITY));\r\n};\r\nconst executeWhenDOMReady = function (fn) {\r\n    if (isNodeSdk() || document.readyState === 'complete') {\r\n        fn();\r\n    }\r\n    else {\r\n        // Modeled after jQuery. Try DOMContentLoaded and onreadystatechange (which\r\n        // fire before onload), but fall back to onload.\r\n        let called = false;\r\n        const wrappedFn = function () {\r\n            if (!document.body) {\r\n                setTimeout(wrappedFn, Math.floor(10));\r\n                return;\r\n            }\r\n            if (!called) {\r\n                called = true;\r\n                fn();\r\n            }\r\n        };\r\n        if (document.addEventListener) {\r\n            document.addEventListener('DOMContentLoaded', wrappedFn, false);\r\n            // fallback to onload.\r\n            window.addEventListener('load', wrappedFn, false);\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        }\r\n        else if (document.attachEvent) {\r\n            // IE.\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            document.attachEvent('onreadystatechange', () => {\r\n                if (document.readyState === 'complete') {\r\n                    wrappedFn();\r\n                }\r\n            });\r\n            // fallback to onload.\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            window.attachEvent('onload', wrappedFn);\r\n            // jQuery has an extra hack for IE that we could employ (based on\r\n            // http://javascript.nwbox.com/IEContentLoaded/) But it looks really old.\r\n            // I'm hoping we don't need it.\r\n        }\r\n    }\r\n};\r\n/**\r\n * Minimum key name. Invalid for actual data, used as a marker to sort before any valid names\r\n */\r\nconst MIN_NAME = '[MIN_NAME]';\r\n/**\r\n * Maximum key name. Invalid for actual data, used as a marker to sort above any valid names\r\n */\r\nconst MAX_NAME = '[MAX_NAME]';\r\n/**\r\n * Compares valid Firebase key names, plus min and max name\r\n */\r\nconst nameCompare = function (a, b) {\r\n    if (a === b) {\r\n        return 0;\r\n    }\r\n    else if (a === MIN_NAME || b === MAX_NAME) {\r\n        return -1;\r\n    }\r\n    else if (b === MIN_NAME || a === MAX_NAME) {\r\n        return 1;\r\n    }\r\n    else {\r\n        const aAsInt = tryParseInt(a), bAsInt = tryParseInt(b);\r\n        if (aAsInt !== null) {\r\n            if (bAsInt !== null) {\r\n                return aAsInt - bAsInt === 0 ? a.length - b.length : aAsInt - bAsInt;\r\n            }\r\n            else {\r\n                return -1;\r\n            }\r\n        }\r\n        else if (bAsInt !== null) {\r\n            return 1;\r\n        }\r\n        else {\r\n            return a < b ? -1 : 1;\r\n        }\r\n    }\r\n};\r\n/**\r\n * @returns {!number} comparison result.\r\n */\r\nconst stringCompare = function (a, b) {\r\n    if (a === b) {\r\n        return 0;\r\n    }\r\n    else if (a < b) {\r\n        return -1;\r\n    }\r\n    else {\r\n        return 1;\r\n    }\r\n};\r\nconst requireKey = function (key, obj) {\r\n    if (obj && key in obj) {\r\n        return obj[key];\r\n    }\r\n    else {\r\n        throw new Error('Missing required key (' + key + ') in object: ' + index_esm2017_stringify(obj));\r\n    }\r\n};\r\nconst ObjectToUniqueKey = function (obj) {\r\n    if (typeof obj !== 'object' || obj === null) {\r\n        return index_esm2017_stringify(obj);\r\n    }\r\n    const keys = [];\r\n    // eslint-disable-next-line guard-for-in\r\n    for (const k in obj) {\r\n        keys.push(k);\r\n    }\r\n    // Export as json, but with the keys sorted.\r\n    keys.sort();\r\n    let key = '{';\r\n    for (let i = 0; i < keys.length; i++) {\r\n        if (i !== 0) {\r\n            key += ',';\r\n        }\r\n        key += index_esm2017_stringify(keys[i]);\r\n        key += ':';\r\n        key += ObjectToUniqueKey(obj[keys[i]]);\r\n    }\r\n    key += '}';\r\n    return key;\r\n};\r\n/**\r\n * Splits a string into a number of smaller segments of maximum size\r\n * @param str - The string\r\n * @param segsize - The maximum number of chars in the string.\r\n * @returns The string, split into appropriately-sized chunks\r\n */\r\nconst splitStringBySize = function (str, segsize) {\r\n    const len = str.length;\r\n    if (len <= segsize) {\r\n        return [str];\r\n    }\r\n    const dataSegs = [];\r\n    for (let c = 0; c < len; c += segsize) {\r\n        if (c + segsize > len) {\r\n            dataSegs.push(str.substring(c, len));\r\n        }\r\n        else {\r\n            dataSegs.push(str.substring(c, c + segsize));\r\n        }\r\n    }\r\n    return dataSegs;\r\n};\r\n/**\r\n * Apply a function to each (key, value) pair in an object or\r\n * apply a function to each (index, value) pair in an array\r\n * @param obj - The object or array to iterate over\r\n * @param fn - The function to apply\r\n */\r\nfunction each(obj, fn) {\r\n    for (const key in obj) {\r\n        if (obj.hasOwnProperty(key)) {\r\n            fn(key, obj[key]);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Borrowed from http://hg.secondlife.com/llsd/src/tip/js/typedarray.js (MIT License)\r\n * I made one modification at the end and removed the NaN / Infinity\r\n * handling (since it seemed broken [caused an overflow] and we don't need it).  See MJL comments.\r\n * @param v - A double\r\n *\r\n */\r\nconst doubleToIEEE754String = function (v) {\r\n    index_esm2017_assert(!isInvalidJSONNumber(v), 'Invalid JSON number'); // MJL\r\n    const ebits = 11, fbits = 52;\r\n    const bias = (1 << (ebits - 1)) - 1;\r\n    let s, e, f, ln, i;\r\n    // Compute sign, exponent, fraction\r\n    // Skip NaN / Infinity handling --MJL.\r\n    if (v === 0) {\r\n        e = 0;\r\n        f = 0;\r\n        s = 1 / v === -Infinity ? 1 : 0;\r\n    }\r\n    else {\r\n        s = v < 0;\r\n        v = Math.abs(v);\r\n        if (v >= Math.pow(2, 1 - bias)) {\r\n            // Normalized\r\n            ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);\r\n            e = ln + bias;\r\n            f = Math.round(v * Math.pow(2, fbits - ln) - Math.pow(2, fbits));\r\n        }\r\n        else {\r\n            // Denormalized\r\n            e = 0;\r\n            f = Math.round(v / Math.pow(2, 1 - bias - fbits));\r\n        }\r\n    }\r\n    // Pack sign, exponent, fraction\r\n    const bits = [];\r\n    for (i = fbits; i; i -= 1) {\r\n        bits.push(f % 2 ? 1 : 0);\r\n        f = Math.floor(f / 2);\r\n    }\r\n    for (i = ebits; i; i -= 1) {\r\n        bits.push(e % 2 ? 1 : 0);\r\n        e = Math.floor(e / 2);\r\n    }\r\n    bits.push(s ? 1 : 0);\r\n    bits.reverse();\r\n    const str = bits.join('');\r\n    // Return the data as a hex string. --MJL\r\n    let hexByteString = '';\r\n    for (i = 0; i < 64; i += 8) {\r\n        let hexByte = parseInt(str.substr(i, 8), 2).toString(16);\r\n        if (hexByte.length === 1) {\r\n            hexByte = '0' + hexByte;\r\n        }\r\n        hexByteString = hexByteString + hexByte;\r\n    }\r\n    return hexByteString.toLowerCase();\r\n};\r\n/**\r\n * Used to detect if we're in a Chrome content script (which executes in an\r\n * isolated environment where long-polling doesn't work).\r\n */\r\nconst isChromeExtensionContentScript = function () {\r\n    return !!(typeof window === 'object' &&\r\n        window['chrome'] &&\r\n        window['chrome']['extension'] &&\r\n        !/^chrome/.test(window.location.href));\r\n};\r\n/**\r\n * Used to detect if we're in a Windows 8 Store app.\r\n */\r\nconst isWindowsStoreApp = function () {\r\n    // Check for the presence of a couple WinRT globals\r\n    return typeof Windows === 'object' && typeof Windows.UI === 'object';\r\n};\r\n/**\r\n * Converts a server error code to a JavaScript Error\r\n */\r\nfunction errorForServerCode(code, query) {\r\n    let reason = 'Unknown Error';\r\n    if (code === 'too_big') {\r\n        reason =\r\n            'The data requested exceeds the maximum size ' +\r\n                'that can be accessed with a single request.';\r\n    }\r\n    else if (code === 'permission_denied') {\r\n        reason = \"Client doesn't have permission to access the desired data.\";\r\n    }\r\n    else if (code === 'unavailable') {\r\n        reason = 'The service is unavailable';\r\n    }\r\n    const error = new Error(code + ' at ' + query._path.toString() + ': ' + reason);\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    error.code = code.toUpperCase();\r\n    return error;\r\n}\r\n/**\r\n * Used to test for integer-looking strings\r\n */\r\nconst INTEGER_REGEXP_ = new RegExp('^-?(0*)\\\\d{1,10}$');\r\n/**\r\n * For use in keys, the minimum possible 32-bit integer.\r\n */\r\nconst INTEGER_32_MIN = -2147483648;\r\n/**\r\n * For use in keys, the maximum possible 32-bit integer.\r\n */\r\nconst INTEGER_32_MAX = 2147483647;\r\n/**\r\n * If the string contains a 32-bit integer, return it.  Else return null.\r\n */\r\nconst tryParseInt = function (str) {\r\n    if (INTEGER_REGEXP_.test(str)) {\r\n        const intVal = Number(str);\r\n        if (intVal >= INTEGER_32_MIN && intVal <= INTEGER_32_MAX) {\r\n            return intVal;\r\n        }\r\n    }\r\n    return null;\r\n};\r\n/**\r\n * Helper to run some code but catch any exceptions and re-throw them later.\r\n * Useful for preventing user callbacks from breaking internal code.\r\n *\r\n * Re-throwing the exception from a setTimeout is a little evil, but it's very\r\n * convenient (we don't have to try to figure out when is a safe point to\r\n * re-throw it), and the behavior seems reasonable:\r\n *\r\n * * If you aren't pausing on exceptions, you get an error in the console with\r\n *   the correct stack trace.\r\n * * If you're pausing on all exceptions, the debugger will pause on your\r\n *   exception and then again when we rethrow it.\r\n * * If you're only pausing on uncaught exceptions, the debugger will only pause\r\n *   on us re-throwing it.\r\n *\r\n * @param fn - The code to guard.\r\n */\r\nconst exceptionGuard = function (fn) {\r\n    try {\r\n        fn();\r\n    }\r\n    catch (e) {\r\n        // Re-throw exception when it's safe.\r\n        setTimeout(() => {\r\n            // It used to be that \"throw e\" would result in a good console error with\r\n            // relevant context, but as of Chrome 39, you just get the firebase.js\r\n            // file/line number where we re-throw it, which is useless. So we log\r\n            // e.stack explicitly.\r\n            const stack = e.stack || '';\r\n            warn('Exception was thrown by user callback.', stack);\r\n            throw e;\r\n        }, Math.floor(0));\r\n    }\r\n};\r\n/**\r\n * @returns {boolean} true if we think we're currently being crawled.\r\n */\r\nconst beingCrawled = function () {\r\n    const userAgent = (typeof window === 'object' &&\r\n        window['navigator'] &&\r\n        window['navigator']['userAgent']) ||\r\n        '';\r\n    // For now we whitelist the most popular crawlers.  We should refine this to be the set of crawlers we\r\n    // believe to support JavaScript/AJAX rendering.\r\n    // NOTE: Google Webmaster Tools doesn't really belong, but their \"This is how a visitor to your website\r\n    // would have seen the page\" is flaky if we don't treat it as a crawler.\r\n    return (userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0);\r\n};\r\n/**\r\n * Same as setTimeout() except on Node.JS it will /not/ prevent the process from exiting.\r\n *\r\n * It is removed with clearTimeout() as normal.\r\n *\r\n * @param fn - Function to run.\r\n * @param time - Milliseconds to wait before running.\r\n * @returns The setTimeout() return value.\r\n */\r\nconst setTimeoutNonBlocking = function (fn, time) {\r\n    const timeout = setTimeout(fn, time);\r\n    // Note: at the time of this comment, unrefTimer is under the unstable set of APIs. Run with --unstable to enable the API.\r\n    if (typeof timeout === 'number' &&\r\n        // @ts-ignore Is only defined in Deno environments.\r\n        typeof Deno !== 'undefined' &&\r\n        // @ts-ignore Deno and unrefTimer are only defined in Deno environments.\r\n        Deno['unrefTimer']) {\r\n        // @ts-ignore Deno and unrefTimer are only defined in Deno environments.\r\n        Deno.unrefTimer(timeout);\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    }\r\n    else if (typeof timeout === 'object' && timeout['unref']) {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        timeout['unref']();\r\n    }\r\n    return timeout;\r\n};\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Abstraction around AppCheck's token fetching capabilities.\r\n */\r\nclass AppCheckTokenProvider {\r\n    constructor(appName_, appCheckProvider) {\r\n        this.appName_ = appName_;\r\n        this.appCheckProvider = appCheckProvider;\r\n        this.appCheck = appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.getImmediate({ optional: true });\r\n        if (!this.appCheck) {\r\n            appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.get().then(appCheck => (this.appCheck = appCheck));\r\n        }\r\n    }\r\n    getToken(forceRefresh) {\r\n        if (!this.appCheck) {\r\n            return new Promise((resolve, reject) => {\r\n                // Support delayed initialization of FirebaseAppCheck. This allows our\r\n                // customers to initialize the RTDB SDK before initializing Firebase\r\n                // AppCheck and ensures that all requests are authenticated if a token\r\n                // becomes available before the timeout below expires.\r\n                setTimeout(() => {\r\n                    if (this.appCheck) {\r\n                        this.getToken(forceRefresh).then(resolve, reject);\r\n                    }\r\n                    else {\r\n                        resolve(null);\r\n                    }\r\n                }, 0);\r\n            });\r\n        }\r\n        return this.appCheck.getToken(forceRefresh);\r\n    }\r\n    addTokenChangeListener(listener) {\r\n        var _a;\r\n        (_a = this.appCheckProvider) === null || _a === void 0 ? void 0 : _a.get().then(appCheck => appCheck.addTokenListener(listener));\r\n    }\r\n    notifyForInvalidToken() {\r\n        warn(`Provided AppCheck credentials for the app named \"${this.appName_}\" ` +\r\n            'are invalid. This usually indicates your app was not initialized correctly.');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Abstraction around FirebaseApp's token fetching capabilities.\r\n */\r\nclass FirebaseAuthTokenProvider {\r\n    constructor(appName_, firebaseOptions_, authProvider_) {\r\n        this.appName_ = appName_;\r\n        this.firebaseOptions_ = firebaseOptions_;\r\n        this.authProvider_ = authProvider_;\r\n        this.auth_ = null;\r\n        this.auth_ = authProvider_.getImmediate({ optional: true });\r\n        if (!this.auth_) {\r\n            authProvider_.onInit(auth => (this.auth_ = auth));\r\n        }\r\n    }\r\n    getToken(forceRefresh) {\r\n        if (!this.auth_) {\r\n            return new Promise((resolve, reject) => {\r\n                // Support delayed initialization of FirebaseAuth. This allows our\r\n                // customers to initialize the RTDB SDK before initializing Firebase\r\n                // Auth and ensures that all requests are authenticated if a token\r\n                // becomes available before the timeout below expires.\r\n                setTimeout(() => {\r\n                    if (this.auth_) {\r\n                        this.getToken(forceRefresh).then(resolve, reject);\r\n                    }\r\n                    else {\r\n                        resolve(null);\r\n                    }\r\n                }, 0);\r\n            });\r\n        }\r\n        return this.auth_.getToken(forceRefresh).catch(error => {\r\n            // TODO: Need to figure out all the cases this is raised and whether\r\n            // this makes sense.\r\n            if (error && error.code === 'auth/token-not-initialized') {\r\n                log('Got auth/token-not-initialized error.  Treating as null token.');\r\n                return null;\r\n            }\r\n            else {\r\n                return Promise.reject(error);\r\n            }\r\n        });\r\n    }\r\n    addTokenChangeListener(listener) {\r\n        // TODO: We might want to wrap the listener and call it with no args to\r\n        // avoid a leaky abstraction, but that makes removing the listener harder.\r\n        if (this.auth_) {\r\n            this.auth_.addAuthTokenListener(listener);\r\n        }\r\n        else {\r\n            this.authProvider_\r\n                .get()\r\n                .then(auth => auth.addAuthTokenListener(listener));\r\n        }\r\n    }\r\n    removeTokenChangeListener(listener) {\r\n        this.authProvider_\r\n            .get()\r\n            .then(auth => auth.removeAuthTokenListener(listener));\r\n    }\r\n    notifyForInvalidToken() {\r\n        let errorMessage = 'Provided authentication credentials for the app named \"' +\r\n            this.appName_ +\r\n            '\" are invalid. This usually indicates your app was not ' +\r\n            'initialized correctly. ';\r\n        if ('credential' in this.firebaseOptions_) {\r\n            errorMessage +=\r\n                'Make sure the \"credential\" property provided to initializeApp() ' +\r\n                    'is authorized to access the specified \"databaseURL\" and is from the correct ' +\r\n                    'project.';\r\n        }\r\n        else if ('serviceAccount' in this.firebaseOptions_) {\r\n            errorMessage +=\r\n                'Make sure the \"serviceAccount\" property provided to initializeApp() ' +\r\n                    'is authorized to access the specified \"databaseURL\" and is from the correct ' +\r\n                    'project.';\r\n        }\r\n        else {\r\n            errorMessage +=\r\n                'Make sure the \"apiKey\" and \"databaseURL\" properties provided to ' +\r\n                    'initializeApp() match the values provided for your app at ' +\r\n                    'https://console.firebase.google.com/.';\r\n        }\r\n        warn(errorMessage);\r\n    }\r\n}\r\n/* AuthTokenProvider that supplies a constant token. Used by Admin SDK or mockUserToken with emulators. */\r\nclass EmulatorTokenProvider {\r\n    constructor(accessToken) {\r\n        this.accessToken = accessToken;\r\n    }\r\n    getToken(forceRefresh) {\r\n        return Promise.resolve({\r\n            accessToken: this.accessToken\r\n        });\r\n    }\r\n    addTokenChangeListener(listener) {\r\n        // Invoke the listener immediately to match the behavior in Firebase Auth\r\n        // (see packages/auth/src/auth.js#L1807)\r\n        listener(this.accessToken);\r\n    }\r\n    removeTokenChangeListener(listener) { }\r\n    notifyForInvalidToken() { }\r\n}\r\n/** A string that is treated as an admin access token by the RTDB emulator. Used by Admin SDK. */\r\nEmulatorTokenProvider.OWNER = 'owner';\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst PROTOCOL_VERSION = '5';\r\nconst VERSION_PARAM = 'v';\r\nconst TRANSPORT_SESSION_PARAM = 's';\r\nconst REFERER_PARAM = 'r';\r\nconst FORGE_REF = 'f';\r\n// Matches console.firebase.google.com, firebase-console-*.corp.google.com and\r\n// firebase.corp.google.com\r\nconst FORGE_DOMAIN_RE = /(console\\.firebase|firebase-console-\\w+\\.corp|firebase\\.corp)\\.google\\.com/;\r\nconst LAST_SESSION_PARAM = 'ls';\r\nconst APPLICATION_ID_PARAM = 'p';\r\nconst APP_CHECK_TOKEN_PARAM = 'ac';\r\nconst WEBSOCKET = 'websocket';\r\nconst LONG_POLLING = 'long_polling';\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A class that holds metadata about a Repo object\r\n */\r\nclass RepoInfo {\r\n    /**\r\n     * @param host - Hostname portion of the url for the repo\r\n     * @param secure - Whether or not this repo is accessed over ssl\r\n     * @param namespace - The namespace represented by the repo\r\n     * @param webSocketOnly - Whether to prefer websockets over all other transports (used by Nest).\r\n     * @param nodeAdmin - Whether this instance uses Admin SDK credentials\r\n     * @param persistenceKey - Override the default session persistence storage key\r\n     */\r\n    constructor(host, secure, namespace, webSocketOnly, nodeAdmin = false, persistenceKey = '', includeNamespaceInQueryParams = false, isUsingEmulator = false) {\r\n        this.secure = secure;\r\n        this.namespace = namespace;\r\n        this.webSocketOnly = webSocketOnly;\r\n        this.nodeAdmin = nodeAdmin;\r\n        this.persistenceKey = persistenceKey;\r\n        this.includeNamespaceInQueryParams = includeNamespaceInQueryParams;\r\n        this.isUsingEmulator = isUsingEmulator;\r\n        this._host = host.toLowerCase();\r\n        this._domain = this._host.substr(this._host.indexOf('.') + 1);\r\n        this.internalHost =\r\n            PersistentStorage.get('host:' + host) || this._host;\r\n    }\r\n    isCacheableHost() {\r\n        return this.internalHost.substr(0, 2) === 's-';\r\n    }\r\n    isCustomHost() {\r\n        return (this._domain !== 'firebaseio.com' &&\r\n            this._domain !== 'firebaseio-demo.com');\r\n    }\r\n    get host() {\r\n        return this._host;\r\n    }\r\n    set host(newHost) {\r\n        if (newHost !== this.internalHost) {\r\n            this.internalHost = newHost;\r\n            if (this.isCacheableHost()) {\r\n                PersistentStorage.set('host:' + this._host, this.internalHost);\r\n            }\r\n        }\r\n    }\r\n    toString() {\r\n        let str = this.toURLString();\r\n        if (this.persistenceKey) {\r\n            str += '<' + this.persistenceKey + '>';\r\n        }\r\n        return str;\r\n    }\r\n    toURLString() {\r\n        const protocol = this.secure ? 'https://' : 'http://';\r\n        const query = this.includeNamespaceInQueryParams\r\n            ? `?ns=${this.namespace}`\r\n            : '';\r\n        return `${protocol}${this.host}/${query}`;\r\n    }\r\n}\r\nfunction repoInfoNeedsQueryParam(repoInfo) {\r\n    return (repoInfo.host !== repoInfo.internalHost ||\r\n        repoInfo.isCustomHost() ||\r\n        repoInfo.includeNamespaceInQueryParams);\r\n}\r\n/**\r\n * Returns the websocket URL for this repo\r\n * @param repoInfo - RepoInfo object\r\n * @param type - of connection\r\n * @param params - list\r\n * @returns The URL for this repo\r\n */\r\nfunction repoInfoConnectionURL(repoInfo, type, params) {\r\n    index_esm2017_assert(typeof type === 'string', 'typeof type must == string');\r\n    index_esm2017_assert(typeof params === 'object', 'typeof params must == object');\r\n    let connURL;\r\n    if (type === WEBSOCKET) {\r\n        connURL =\r\n            (repoInfo.secure ? 'wss://' : 'ws://') + repoInfo.internalHost + '/.ws?';\r\n    }\r\n    else if (type === LONG_POLLING) {\r\n        connURL =\r\n            (repoInfo.secure ? 'https://' : 'http://') +\r\n                repoInfo.internalHost +\r\n                '/.lp?';\r\n    }\r\n    else {\r\n        throw new Error('Unknown connection type: ' + type);\r\n    }\r\n    if (repoInfoNeedsQueryParam(repoInfo)) {\r\n        params['ns'] = repoInfo.namespace;\r\n    }\r\n    const pairs = [];\r\n    each(params, (key, value) => {\r\n        pairs.push(key + '=' + value);\r\n    });\r\n    return connURL + pairs.join('&');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Tracks a collection of stats.\r\n */\r\nclass StatsCollection {\r\n    constructor() {\r\n        this.counters_ = {};\r\n    }\r\n    incrementCounter(name, amount = 1) {\r\n        if (!index_esm2017_contains(this.counters_, name)) {\r\n            this.counters_[name] = 0;\r\n        }\r\n        this.counters_[name] += amount;\r\n    }\r\n    get() {\r\n        return deepCopy(this.counters_);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst collections = {};\r\nconst reporters = {};\r\nfunction statsManagerGetCollection(repoInfo) {\r\n    const hashString = repoInfo.toString();\r\n    if (!collections[hashString]) {\r\n        collections[hashString] = new StatsCollection();\r\n    }\r\n    return collections[hashString];\r\n}\r\nfunction statsManagerGetOrCreateReporter(repoInfo, creatorFunction) {\r\n    const hashString = repoInfo.toString();\r\n    if (!reporters[hashString]) {\r\n        reporters[hashString] = creatorFunction();\r\n    }\r\n    return reporters[hashString];\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * This class ensures the packets from the server arrive in order\r\n * This class takes data from the server and ensures it gets passed into the callbacks in order.\r\n */\r\nclass PacketReceiver {\r\n    /**\r\n     * @param onMessage_\r\n     */\r\n    constructor(onMessage_) {\r\n        this.onMessage_ = onMessage_;\r\n        this.pendingResponses = [];\r\n        this.currentResponseNum = 0;\r\n        this.closeAfterResponse = -1;\r\n        this.onClose = null;\r\n    }\r\n    closeAfter(responseNum, callback) {\r\n        this.closeAfterResponse = responseNum;\r\n        this.onClose = callback;\r\n        if (this.closeAfterResponse < this.currentResponseNum) {\r\n            this.onClose();\r\n            this.onClose = null;\r\n        }\r\n    }\r\n    /**\r\n     * Each message from the server comes with a response number, and an array of data. The responseNumber\r\n     * allows us to ensure that we process them in the right order, since we can't be guaranteed that all\r\n     * browsers will respond in the same order as the requests we sent\r\n     */\r\n    handleResponse(requestNum, data) {\r\n        this.pendingResponses[requestNum] = data;\r\n        while (this.pendingResponses[this.currentResponseNum]) {\r\n            const toProcess = this.pendingResponses[this.currentResponseNum];\r\n            delete this.pendingResponses[this.currentResponseNum];\r\n            for (let i = 0; i < toProcess.length; ++i) {\r\n                if (toProcess[i]) {\r\n                    exceptionGuard(() => {\r\n                        this.onMessage_(toProcess[i]);\r\n                    });\r\n                }\r\n            }\r\n            if (this.currentResponseNum === this.closeAfterResponse) {\r\n                if (this.onClose) {\r\n                    this.onClose();\r\n                    this.onClose = null;\r\n                }\r\n                break;\r\n            }\r\n            this.currentResponseNum++;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// URL query parameters associated with longpolling\r\nconst FIREBASE_LONGPOLL_START_PARAM = 'start';\r\nconst FIREBASE_LONGPOLL_CLOSE_COMMAND = 'close';\r\nconst FIREBASE_LONGPOLL_COMMAND_CB_NAME = 'pLPCommand';\r\nconst FIREBASE_LONGPOLL_DATA_CB_NAME = 'pRTLPCB';\r\nconst FIREBASE_LONGPOLL_ID_PARAM = 'id';\r\nconst FIREBASE_LONGPOLL_PW_PARAM = 'pw';\r\nconst FIREBASE_LONGPOLL_SERIAL_PARAM = 'ser';\r\nconst FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = 'cb';\r\nconst FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = 'seg';\r\nconst FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = 'ts';\r\nconst FIREBASE_LONGPOLL_DATA_PARAM = 'd';\r\nconst FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = 'dframe';\r\n//Data size constants.\r\n//TODO: Perf: the maximum length actually differs from browser to browser.\r\n// We should check what browser we're on and set accordingly.\r\nconst MAX_URL_DATA_SIZE = 1870;\r\nconst SEG_HEADER_SIZE = 30; //ie: &seg=8299234&ts=982389123&d=\r\nconst MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;\r\n/**\r\n * Keepalive period\r\n * send a fresh request at minimum every 25 seconds. Opera has a maximum request\r\n * length of 30 seconds that we can't exceed.\r\n */\r\nconst KEEPALIVE_REQUEST_INTERVAL = 25000;\r\n/**\r\n * How long to wait before aborting a long-polling connection attempt.\r\n */\r\nconst LP_CONNECT_TIMEOUT = 30000;\r\n/**\r\n * This class manages a single long-polling connection.\r\n */\r\nclass BrowserPollConnection {\r\n    /**\r\n     * @param connId An identifier for this connection, used for logging\r\n     * @param repoInfo The info for the endpoint to send data to.\r\n     * @param applicationId The Firebase App ID for this project.\r\n     * @param appCheckToken The AppCheck token for this client.\r\n     * @param authToken The AuthToken to use for this connection.\r\n     * @param transportSessionId Optional transportSessionid if we are\r\n     * reconnecting for an existing transport session\r\n     * @param lastSessionId Optional lastSessionId if the PersistentConnection has\r\n     * already created a connection previously\r\n     */\r\n    constructor(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId) {\r\n        this.connId = connId;\r\n        this.repoInfo = repoInfo;\r\n        this.applicationId = applicationId;\r\n        this.appCheckToken = appCheckToken;\r\n        this.authToken = authToken;\r\n        this.transportSessionId = transportSessionId;\r\n        this.lastSessionId = lastSessionId;\r\n        this.bytesSent = 0;\r\n        this.bytesReceived = 0;\r\n        this.everConnected_ = false;\r\n        this.log_ = logWrapper(connId);\r\n        this.stats_ = statsManagerGetCollection(repoInfo);\r\n        this.urlFn = (params) => {\r\n            // Always add the token if we have one.\r\n            if (this.appCheckToken) {\r\n                params[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;\r\n            }\r\n            return repoInfoConnectionURL(repoInfo, LONG_POLLING, params);\r\n        };\r\n    }\r\n    /**\r\n     * @param onMessage - Callback when messages arrive\r\n     * @param onDisconnect - Callback with connection lost.\r\n     */\r\n    open(onMessage, onDisconnect) {\r\n        this.curSegmentNum = 0;\r\n        this.onDisconnect_ = onDisconnect;\r\n        this.myPacketOrderer = new PacketReceiver(onMessage);\r\n        this.isClosed_ = false;\r\n        this.connectTimeoutTimer_ = setTimeout(() => {\r\n            this.log_('Timed out trying to connect.');\r\n            // Make sure we clear the host cache\r\n            this.onClosed_();\r\n            this.connectTimeoutTimer_ = null;\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        }, Math.floor(LP_CONNECT_TIMEOUT));\r\n        // Ensure we delay the creation of the iframe until the DOM is loaded.\r\n        executeWhenDOMReady(() => {\r\n            if (this.isClosed_) {\r\n                return;\r\n            }\r\n            //Set up a callback that gets triggered once a connection is set up.\r\n            this.scriptTagHolder = new FirebaseIFrameScriptHolder((...args) => {\r\n                const [command, arg1, arg2, arg3, arg4] = args;\r\n                this.incrementIncomingBytes_(args);\r\n                if (!this.scriptTagHolder) {\r\n                    return; // we closed the connection.\r\n                }\r\n                if (this.connectTimeoutTimer_) {\r\n                    clearTimeout(this.connectTimeoutTimer_);\r\n                    this.connectTimeoutTimer_ = null;\r\n                }\r\n                this.everConnected_ = true;\r\n                if (command === FIREBASE_LONGPOLL_START_PARAM) {\r\n                    this.id = arg1;\r\n                    this.password = arg2;\r\n                }\r\n                else if (command === FIREBASE_LONGPOLL_CLOSE_COMMAND) {\r\n                    // Don't clear the host cache. We got a response from the server, so we know it's reachable\r\n                    if (arg1) {\r\n                        // We aren't expecting any more data (other than what the server's already in the process of sending us\r\n                        // through our already open polls), so don't send any more.\r\n                        this.scriptTagHolder.sendNewPolls = false;\r\n                        // arg1 in this case is the last response number sent by the server. We should try to receive\r\n                        // all of the responses up to this one before closing\r\n                        this.myPacketOrderer.closeAfter(arg1, () => {\r\n                            this.onClosed_();\r\n                        });\r\n                    }\r\n                    else {\r\n                        this.onClosed_();\r\n                    }\r\n                }\r\n                else {\r\n                    throw new Error('Unrecognized command received: ' + command);\r\n                }\r\n            }, (...args) => {\r\n                const [pN, data] = args;\r\n                this.incrementIncomingBytes_(args);\r\n                this.myPacketOrderer.handleResponse(pN, data);\r\n            }, () => {\r\n                this.onClosed_();\r\n            }, this.urlFn);\r\n            //Send the initial request to connect. The serial number is simply to keep the browser from pulling previous results\r\n            //from cache.\r\n            const urlParams = {};\r\n            urlParams[FIREBASE_LONGPOLL_START_PARAM] = 't';\r\n            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(Math.random() * 100000000);\r\n            if (this.scriptTagHolder.uniqueCallbackIdentifier) {\r\n                urlParams[FIREBASE_LONGPOLL_CALLBACK_ID_PARAM] =\r\n                    this.scriptTagHolder.uniqueCallbackIdentifier;\r\n            }\r\n            urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\r\n            if (this.transportSessionId) {\r\n                urlParams[TRANSPORT_SESSION_PARAM] = this.transportSessionId;\r\n            }\r\n            if (this.lastSessionId) {\r\n                urlParams[LAST_SESSION_PARAM] = this.lastSessionId;\r\n            }\r\n            if (this.applicationId) {\r\n                urlParams[APPLICATION_ID_PARAM] = this.applicationId;\r\n            }\r\n            if (this.appCheckToken) {\r\n                urlParams[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;\r\n            }\r\n            if (typeof location !== 'undefined' &&\r\n                location.hostname &&\r\n                FORGE_DOMAIN_RE.test(location.hostname)) {\r\n                urlParams[REFERER_PARAM] = FORGE_REF;\r\n            }\r\n            const connectURL = this.urlFn(urlParams);\r\n            this.log_('Connecting via long-poll to ' + connectURL);\r\n            this.scriptTagHolder.addTag(connectURL, () => {\r\n                /* do nothing */\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Call this when a handshake has completed successfully and we want to consider the connection established\r\n     */\r\n    start() {\r\n        this.scriptTagHolder.startLongPoll(this.id, this.password);\r\n        this.addDisconnectPingFrame(this.id, this.password);\r\n    }\r\n    /**\r\n     * Forces long polling to be considered as a potential transport\r\n     */\r\n    static forceAllow() {\r\n        BrowserPollConnection.forceAllow_ = true;\r\n    }\r\n    /**\r\n     * Forces longpolling to not be considered as a potential transport\r\n     */\r\n    static forceDisallow() {\r\n        BrowserPollConnection.forceDisallow_ = true;\r\n    }\r\n    // Static method, use string literal so it can be accessed in a generic way\r\n    static isAvailable() {\r\n        if (isNodeSdk()) {\r\n            return false;\r\n        }\r\n        else if (BrowserPollConnection.forceAllow_) {\r\n            return true;\r\n        }\r\n        else {\r\n            // NOTE: In React-Native there's normally no 'document', but if you debug a React-Native app in\r\n            // the Chrome debugger, 'document' is defined, but document.createElement is null (2015/06/08).\r\n            return (!BrowserPollConnection.forceDisallow_ &&\r\n                typeof document !== 'undefined' &&\r\n                document.createElement != null &&\r\n                !isChromeExtensionContentScript() &&\r\n                !isWindowsStoreApp());\r\n        }\r\n    }\r\n    /**\r\n     * No-op for polling\r\n     */\r\n    markConnectionHealthy() { }\r\n    /**\r\n     * Stops polling and cleans up the iframe\r\n     */\r\n    shutdown_() {\r\n        this.isClosed_ = true;\r\n        if (this.scriptTagHolder) {\r\n            this.scriptTagHolder.close();\r\n            this.scriptTagHolder = null;\r\n        }\r\n        //remove the disconnect frame, which will trigger an XHR call to the server to tell it we're leaving.\r\n        if (this.myDisconnFrame) {\r\n            document.body.removeChild(this.myDisconnFrame);\r\n            this.myDisconnFrame = null;\r\n        }\r\n        if (this.connectTimeoutTimer_) {\r\n            clearTimeout(this.connectTimeoutTimer_);\r\n            this.connectTimeoutTimer_ = null;\r\n        }\r\n    }\r\n    /**\r\n     * Triggered when this transport is closed\r\n     */\r\n    onClosed_() {\r\n        if (!this.isClosed_) {\r\n            this.log_('Longpoll is closing itself');\r\n            this.shutdown_();\r\n            if (this.onDisconnect_) {\r\n                this.onDisconnect_(this.everConnected_);\r\n                this.onDisconnect_ = null;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server\r\n     * that we've left.\r\n     */\r\n    close() {\r\n        if (!this.isClosed_) {\r\n            this.log_('Longpoll is being closed.');\r\n            this.shutdown_();\r\n        }\r\n    }\r\n    /**\r\n     * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then\r\n     * broken into chunks (since URLs have a small maximum length).\r\n     * @param data - The JSON data to transmit.\r\n     */\r\n    send(data) {\r\n        const dataStr = index_esm2017_stringify(data);\r\n        this.bytesSent += dataStr.length;\r\n        this.stats_.incrementCounter('bytes_sent', dataStr.length);\r\n        //first, lets get the base64-encoded data\r\n        const base64data = base64Encode(dataStr);\r\n        //We can only fit a certain amount in each URL, so we need to split this request\r\n        //up into multiple pieces if it doesn't fit in one request.\r\n        const dataSegs = splitStringBySize(base64data, MAX_PAYLOAD_SIZE);\r\n        //Enqueue each segment for transmission. We assign each chunk a sequential ID and a total number\r\n        //of segments so that we can reassemble the packet on the server.\r\n        for (let i = 0; i < dataSegs.length; i++) {\r\n            this.scriptTagHolder.enqueueSegment(this.curSegmentNum, dataSegs.length, dataSegs[i]);\r\n            this.curSegmentNum++;\r\n        }\r\n    }\r\n    /**\r\n     * This is how we notify the server that we're leaving.\r\n     * We aren't able to send requests with DHTML on a window close event, but we can\r\n     * trigger XHR requests in some browsers (everything but Opera basically).\r\n     */\r\n    addDisconnectPingFrame(id, pw) {\r\n        if (isNodeSdk()) {\r\n            return;\r\n        }\r\n        this.myDisconnFrame = document.createElement('iframe');\r\n        const urlParams = {};\r\n        urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = 't';\r\n        urlParams[FIREBASE_LONGPOLL_ID_PARAM] = id;\r\n        urlParams[FIREBASE_LONGPOLL_PW_PARAM] = pw;\r\n        this.myDisconnFrame.src = this.urlFn(urlParams);\r\n        this.myDisconnFrame.style.display = 'none';\r\n        document.body.appendChild(this.myDisconnFrame);\r\n    }\r\n    /**\r\n     * Used to track the bytes received by this client\r\n     */\r\n    incrementIncomingBytes_(args) {\r\n        // TODO: This is an annoying perf hit just to track the number of incoming bytes.  Maybe it should be opt-in.\r\n        const bytesReceived = index_esm2017_stringify(args).length;\r\n        this.bytesReceived += bytesReceived;\r\n        this.stats_.incrementCounter('bytes_received', bytesReceived);\r\n    }\r\n}\r\n/*********************************************************************************************\r\n * A wrapper around an iframe that is used as a long-polling script holder.\r\n *********************************************************************************************/\r\nclass FirebaseIFrameScriptHolder {\r\n    /**\r\n     * @param commandCB - The callback to be called when control commands are received from the server.\r\n     * @param onMessageCB - The callback to be triggered when responses arrive from the server.\r\n     * @param onDisconnect - The callback to be triggered when this tag holder is closed\r\n     * @param urlFn - A function that provides the URL of the endpoint to send data to.\r\n     */\r\n    constructor(commandCB, onMessageCB, onDisconnect, urlFn) {\r\n        this.onDisconnect = onDisconnect;\r\n        this.urlFn = urlFn;\r\n        //We maintain a count of all of the outstanding requests, because if we have too many active at once it can cause\r\n        //problems in some browsers.\r\n        this.outstandingRequests = new Set();\r\n        //A queue of the pending segments waiting for transmission to the server.\r\n        this.pendingSegs = [];\r\n        //A serial number. We use this for two things:\r\n        // 1) A way to ensure the browser doesn't cache responses to polls\r\n        // 2) A way to make the server aware when long-polls arrive in a different order than we started them. The\r\n        //    server needs to release both polls in this case or it will cause problems in Opera since Opera can only execute\r\n        //    JSONP code in the order it was added to the iframe.\r\n        this.currentSerial = Math.floor(Math.random() * 100000000);\r\n        // This gets set to false when we're \"closing down\" the connection (e.g. we're switching transports but there's still\r\n        // incoming data from the server that we're waiting for).\r\n        this.sendNewPolls = true;\r\n        if (!isNodeSdk()) {\r\n            //Each script holder registers a couple of uniquely named callbacks with the window. These are called from the\r\n            //iframes where we put the long-polling script tags. We have two callbacks:\r\n            //   1) Command Callback - Triggered for control issues, like starting a connection.\r\n            //   2) Message Callback - Triggered when new data arrives.\r\n            this.uniqueCallbackIdentifier = LUIDGenerator();\r\n            window[FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier] = commandCB;\r\n            window[FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier] =\r\n                onMessageCB;\r\n            //Create an iframe for us to add script tags to.\r\n            this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_();\r\n            // Set the iframe's contents.\r\n            let script = '';\r\n            // if we set a javascript url, it's IE and we need to set the document domain. The javascript url is sufficient\r\n            // for ie9, but ie8 needs to do it again in the document itself.\r\n            if (this.myIFrame.src &&\r\n                this.myIFrame.src.substr(0, 'javascript:'.length) === 'javascript:') {\r\n                const currentDomain = document.domain;\r\n                script = '<script>document.domain=\"' + currentDomain + '\";<\/script>';\r\n            }\r\n            const iframeContents = '<html><body>' + script + '</body></html>';\r\n            try {\r\n                this.myIFrame.doc.open();\r\n                this.myIFrame.doc.write(iframeContents);\r\n                this.myIFrame.doc.close();\r\n            }\r\n            catch (e) {\r\n                log('frame writing exception');\r\n                if (e.stack) {\r\n                    log(e.stack);\r\n                }\r\n                log(e);\r\n            }\r\n        }\r\n        else {\r\n            this.commandCB = commandCB;\r\n            this.onMessageCB = onMessageCB;\r\n        }\r\n    }\r\n    /**\r\n     * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can\r\n     * actually use.\r\n     */\r\n    static createIFrame_() {\r\n        const iframe = document.createElement('iframe');\r\n        iframe.style.display = 'none';\r\n        // This is necessary in order to initialize the document inside the iframe\r\n        if (document.body) {\r\n            document.body.appendChild(iframe);\r\n            try {\r\n                // If document.domain has been modified in IE, this will throw an error, and we need to set the\r\n                // domain of the iframe's document manually. We can do this via a javascript: url as the src attribute\r\n                // Also note that we must do this *after* the iframe has been appended to the page. Otherwise it doesn't work.\r\n                const a = iframe.contentWindow.document;\r\n                if (!a) {\r\n                    // Apologies for the log-spam, I need to do something to keep closure from optimizing out the assignment above.\r\n                    log('No IE domain setting required');\r\n                }\r\n            }\r\n            catch (e) {\r\n                const domain = document.domain;\r\n                iframe.src =\r\n                    \"javascript:void((function(){document.open();document.domain='\" +\r\n                        domain +\r\n                        \"';document.close();})())\";\r\n            }\r\n        }\r\n        else {\r\n            // LongPollConnection attempts to delay initialization until the document is ready, so hopefully this\r\n            // never gets hit.\r\n            throw 'Document body has not initialized. Wait to initialize Firebase until after the document is ready.';\r\n        }\r\n        // Get the document of the iframe in a browser-specific way.\r\n        if (iframe.contentDocument) {\r\n            iframe.doc = iframe.contentDocument; // Firefox, Opera, Safari\r\n        }\r\n        else if (iframe.contentWindow) {\r\n            iframe.doc = iframe.contentWindow.document; // Internet Explorer\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        }\r\n        else if (iframe.document) {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            iframe.doc = iframe.document; //others?\r\n        }\r\n        return iframe;\r\n    }\r\n    /**\r\n     * Cancel all outstanding queries and remove the frame.\r\n     */\r\n    close() {\r\n        //Mark this iframe as dead, so no new requests are sent.\r\n        this.alive = false;\r\n        if (this.myIFrame) {\r\n            //We have to actually remove all of the html inside this iframe before removing it from the\r\n            //window, or IE will continue loading and executing the script tags we've already added, which\r\n            //can lead to some errors being thrown. Setting textContent seems to be the safest way to do this.\r\n            this.myIFrame.doc.body.textContent = '';\r\n            setTimeout(() => {\r\n                if (this.myIFrame !== null) {\r\n                    document.body.removeChild(this.myIFrame);\r\n                    this.myIFrame = null;\r\n                }\r\n            }, Math.floor(0));\r\n        }\r\n        // Protect from being called recursively.\r\n        const onDisconnect = this.onDisconnect;\r\n        if (onDisconnect) {\r\n            this.onDisconnect = null;\r\n            onDisconnect();\r\n        }\r\n    }\r\n    /**\r\n     * Actually start the long-polling session by adding the first script tag(s) to the iframe.\r\n     * @param id - The ID of this connection\r\n     * @param pw - The password for this connection\r\n     */\r\n    startLongPoll(id, pw) {\r\n        this.myID = id;\r\n        this.myPW = pw;\r\n        this.alive = true;\r\n        //send the initial request. If there are requests queued, make sure that we transmit as many as we are currently able to.\r\n        while (this.newRequest_()) { }\r\n    }\r\n    /**\r\n     * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't\r\n     * too many outstanding requests and we are still alive.\r\n     *\r\n     * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if\r\n     * needed.\r\n     */\r\n    newRequest_() {\r\n        // We keep one outstanding request open all the time to receive data, but if we need to send data\r\n        // (pendingSegs.length > 0) then we create a new request to send the data.  The server will automatically\r\n        // close the old request.\r\n        if (this.alive &&\r\n            this.sendNewPolls &&\r\n            this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)) {\r\n            //construct our url\r\n            this.currentSerial++;\r\n            const urlParams = {};\r\n            urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;\r\n            urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;\r\n            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;\r\n            let theURL = this.urlFn(urlParams);\r\n            //Now add as much data as we can.\r\n            let curDataString = '';\r\n            let i = 0;\r\n            while (this.pendingSegs.length > 0) {\r\n                //first, lets see if the next segment will fit.\r\n                const nextSeg = this.pendingSegs[0];\r\n                if (nextSeg.d.length +\r\n                    SEG_HEADER_SIZE +\r\n                    curDataString.length <=\r\n                    MAX_URL_DATA_SIZE) {\r\n                    //great, the segment will fit. Lets append it.\r\n                    const theSeg = this.pendingSegs.shift();\r\n                    curDataString =\r\n                        curDataString +\r\n                            '&' +\r\n                            FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM +\r\n                            i +\r\n                            '=' +\r\n                            theSeg.seg +\r\n                            '&' +\r\n                            FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET +\r\n                            i +\r\n                            '=' +\r\n                            theSeg.ts +\r\n                            '&' +\r\n                            FIREBASE_LONGPOLL_DATA_PARAM +\r\n                            i +\r\n                            '=' +\r\n                            theSeg.d;\r\n                    i++;\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            theURL = theURL + curDataString;\r\n            this.addLongPollTag_(theURL, this.currentSerial);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Queue a packet for transmission to the server.\r\n     * @param segnum - A sequential id for this packet segment used for reassembly\r\n     * @param totalsegs - The total number of segments in this packet\r\n     * @param data - The data for this segment.\r\n     */\r\n    enqueueSegment(segnum, totalsegs, data) {\r\n        //add this to the queue of segments to send.\r\n        this.pendingSegs.push({ seg: segnum, ts: totalsegs, d: data });\r\n        //send the data immediately if there isn't already data being transmitted, unless\r\n        //startLongPoll hasn't been called yet.\r\n        if (this.alive) {\r\n            this.newRequest_();\r\n        }\r\n    }\r\n    /**\r\n     * Add a script tag for a regular long-poll request.\r\n     * @param url - The URL of the script tag.\r\n     * @param serial - The serial number of the request.\r\n     */\r\n    addLongPollTag_(url, serial) {\r\n        //remember that we sent this request.\r\n        this.outstandingRequests.add(serial);\r\n        const doNewRequest = () => {\r\n            this.outstandingRequests.delete(serial);\r\n            this.newRequest_();\r\n        };\r\n        // If this request doesn't return on its own accord (by the server sending us some data), we'll\r\n        // create a new one after the KEEPALIVE interval to make sure we always keep a fresh request open.\r\n        const keepaliveTimeout = setTimeout(doNewRequest, Math.floor(KEEPALIVE_REQUEST_INTERVAL));\r\n        const readyStateCB = () => {\r\n            // Request completed.  Cancel the keepalive.\r\n            clearTimeout(keepaliveTimeout);\r\n            // Trigger a new request so we can continue receiving data.\r\n            doNewRequest();\r\n        };\r\n        this.addTag(url, readyStateCB);\r\n    }\r\n    /**\r\n     * Add an arbitrary script tag to the iframe.\r\n     * @param url - The URL for the script tag source.\r\n     * @param loadCB - A callback to be triggered once the script has loaded.\r\n     */\r\n    addTag(url, loadCB) {\r\n        if (isNodeSdk()) {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            this.doNodeLongPoll(url, loadCB);\r\n        }\r\n        else {\r\n            setTimeout(() => {\r\n                try {\r\n                    // if we're already closed, don't add this poll\r\n                    if (!this.sendNewPolls) {\r\n                        return;\r\n                    }\r\n                    const newScript = this.myIFrame.doc.createElement('script');\r\n                    newScript.type = 'text/javascript';\r\n                    newScript.async = true;\r\n                    newScript.src = url;\r\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                    newScript.onload = newScript.onreadystatechange =\r\n                        function () {\r\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                            const rstate = newScript.readyState;\r\n                            if (!rstate || rstate === 'loaded' || rstate === 'complete') {\r\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                                newScript.onload = newScript.onreadystatechange = null;\r\n                                if (newScript.parentNode) {\r\n                                    newScript.parentNode.removeChild(newScript);\r\n                                }\r\n                                loadCB();\r\n                            }\r\n                        };\r\n                    newScript.onerror = () => {\r\n                        log('Long-poll script failed to load: ' + url);\r\n                        this.sendNewPolls = false;\r\n                        this.close();\r\n                    };\r\n                    this.myIFrame.doc.body.appendChild(newScript);\r\n                }\r\n                catch (e) {\r\n                    // TODO: we should make this error visible somehow\r\n                }\r\n            }, Math.floor(1));\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst WEBSOCKET_MAX_FRAME_SIZE = 16384;\r\nconst WEBSOCKET_KEEPALIVE_INTERVAL = 45000;\r\nlet WebSocketImpl = null;\r\nif (typeof MozWebSocket !== 'undefined') {\r\n    WebSocketImpl = MozWebSocket;\r\n}\r\nelse if (typeof WebSocket !== 'undefined') {\r\n    WebSocketImpl = WebSocket;\r\n}\r\n/**\r\n * Create a new websocket connection with the given callbacks.\r\n */\r\nclass WebSocketConnection {\r\n    /**\r\n     * @param connId identifier for this transport\r\n     * @param repoInfo The info for the websocket endpoint.\r\n     * @param applicationId The Firebase App ID for this project.\r\n     * @param appCheckToken The App Check Token for this client.\r\n     * @param authToken The Auth Token for this client.\r\n     * @param transportSessionId Optional transportSessionId if this is connecting\r\n     * to an existing transport session\r\n     * @param lastSessionId Optional lastSessionId if there was a previous\r\n     * connection\r\n     */\r\n    constructor(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId) {\r\n        this.connId = connId;\r\n        this.applicationId = applicationId;\r\n        this.appCheckToken = appCheckToken;\r\n        this.authToken = authToken;\r\n        this.keepaliveTimer = null;\r\n        this.frames = null;\r\n        this.totalFrames = 0;\r\n        this.bytesSent = 0;\r\n        this.bytesReceived = 0;\r\n        this.log_ = logWrapper(this.connId);\r\n        this.stats_ = statsManagerGetCollection(repoInfo);\r\n        this.connURL = WebSocketConnection.connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken, applicationId);\r\n        this.nodeAdmin = repoInfo.nodeAdmin;\r\n    }\r\n    /**\r\n     * @param repoInfo - The info for the websocket endpoint.\r\n     * @param transportSessionId - Optional transportSessionId if this is connecting to an existing transport\r\n     *                                         session\r\n     * @param lastSessionId - Optional lastSessionId if there was a previous connection\r\n     * @returns connection url\r\n     */\r\n    static connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken, applicationId) {\r\n        const urlParams = {};\r\n        urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\r\n        if (!isNodeSdk() &&\r\n            typeof location !== 'undefined' &&\r\n            location.hostname &&\r\n            FORGE_DOMAIN_RE.test(location.hostname)) {\r\n            urlParams[REFERER_PARAM] = FORGE_REF;\r\n        }\r\n        if (transportSessionId) {\r\n            urlParams[TRANSPORT_SESSION_PARAM] = transportSessionId;\r\n        }\r\n        if (lastSessionId) {\r\n            urlParams[LAST_SESSION_PARAM] = lastSessionId;\r\n        }\r\n        if (appCheckToken) {\r\n            urlParams[APP_CHECK_TOKEN_PARAM] = appCheckToken;\r\n        }\r\n        if (applicationId) {\r\n            urlParams[APPLICATION_ID_PARAM] = applicationId;\r\n        }\r\n        return repoInfoConnectionURL(repoInfo, WEBSOCKET, urlParams);\r\n    }\r\n    /**\r\n     * @param onMessage - Callback when messages arrive\r\n     * @param onDisconnect - Callback with connection lost.\r\n     */\r\n    open(onMessage, onDisconnect) {\r\n        this.onDisconnect = onDisconnect;\r\n        this.onMessage = onMessage;\r\n        this.log_('Websocket connecting to ' + this.connURL);\r\n        this.everConnected_ = false;\r\n        // Assume failure until proven otherwise.\r\n        PersistentStorage.set('previous_websocket_failure', true);\r\n        try {\r\n            let options;\r\n            if (isNodeSdk()) {\r\n                const device = this.nodeAdmin ? 'AdminNode' : 'Node';\r\n                // UA Format: Firebase/<wire_protocol>/<sdk_version>/<platform>/<device>\r\n                options = {\r\n                    headers: {\r\n                        'User-Agent': `Firebase/${PROTOCOL_VERSION}/${index_esm2017_SDK_VERSION}/${process.platform}/${device}`,\r\n                        'X-Firebase-GMPID': this.applicationId || ''\r\n                    }\r\n                };\r\n                // If using Node with admin creds, AppCheck-related checks are unnecessary.\r\n                // Note that we send the credentials here even if they aren't admin credentials, which is\r\n                // not a problem.\r\n                // Note that this header is just used to bypass appcheck, and the token should still be sent\r\n                // through the websocket connection once it is established.\r\n                if (this.authToken) {\r\n                    options.headers['Authorization'] = `Bearer ${this.authToken}`;\r\n                }\r\n                if (this.appCheckToken) {\r\n                    options.headers['X-Firebase-AppCheck'] = this.appCheckToken;\r\n                }\r\n                // Plumb appropriate http_proxy environment variable into faye-websocket if it exists.\r\n                const env = process['env'];\r\n                const proxy = this.connURL.indexOf('wss://') === 0\r\n                    ? env['HTTPS_PROXY'] || env['https_proxy']\r\n                    : env['HTTP_PROXY'] || env['http_proxy'];\r\n                if (proxy) {\r\n                    options['proxy'] = { origin: proxy };\r\n                }\r\n            }\r\n            this.mySock = new WebSocketImpl(this.connURL, [], options);\r\n        }\r\n        catch (e) {\r\n            this.log_('Error instantiating WebSocket.');\r\n            const error = e.message || e.data;\r\n            if (error) {\r\n                this.log_(error);\r\n            }\r\n            this.onClosed_();\r\n            return;\r\n        }\r\n        this.mySock.onopen = () => {\r\n            this.log_('Websocket connected.');\r\n            this.everConnected_ = true;\r\n        };\r\n        this.mySock.onclose = () => {\r\n            this.log_('Websocket connection was disconnected.');\r\n            this.mySock = null;\r\n            this.onClosed_();\r\n        };\r\n        this.mySock.onmessage = m => {\r\n            this.handleIncomingFrame(m);\r\n        };\r\n        this.mySock.onerror = e => {\r\n            this.log_('WebSocket error.  Closing connection.');\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            const error = e.message || e.data;\r\n            if (error) {\r\n                this.log_(error);\r\n            }\r\n            this.onClosed_();\r\n        };\r\n    }\r\n    /**\r\n     * No-op for websockets, we don't need to do anything once the connection is confirmed as open\r\n     */\r\n    start() { }\r\n    static forceDisallow() {\r\n        WebSocketConnection.forceDisallow_ = true;\r\n    }\r\n    static isAvailable() {\r\n        let isOldAndroid = false;\r\n        if (typeof navigator !== 'undefined' && navigator.userAgent) {\r\n            const oldAndroidRegex = /Android ([0-9]{0,}\\.[0-9]{0,})/;\r\n            const oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);\r\n            if (oldAndroidMatch && oldAndroidMatch.length > 1) {\r\n                if (parseFloat(oldAndroidMatch[1]) < 4.4) {\r\n                    isOldAndroid = true;\r\n                }\r\n            }\r\n        }\r\n        return (!isOldAndroid &&\r\n            WebSocketImpl !== null &&\r\n            !WebSocketConnection.forceDisallow_);\r\n    }\r\n    /**\r\n     * Returns true if we previously failed to connect with this transport.\r\n     */\r\n    static previouslyFailed() {\r\n        // If our persistent storage is actually only in-memory storage,\r\n        // we default to assuming that it previously failed to be safe.\r\n        return (PersistentStorage.isInMemoryStorage ||\r\n            PersistentStorage.get('previous_websocket_failure') === true);\r\n    }\r\n    markConnectionHealthy() {\r\n        PersistentStorage.remove('previous_websocket_failure');\r\n    }\r\n    appendFrame_(data) {\r\n        this.frames.push(data);\r\n        if (this.frames.length === this.totalFrames) {\r\n            const fullMess = this.frames.join('');\r\n            this.frames = null;\r\n            const jsonMess = jsonEval(fullMess);\r\n            //handle the message\r\n            this.onMessage(jsonMess);\r\n        }\r\n    }\r\n    /**\r\n     * @param frameCount - The number of frames we are expecting from the server\r\n     */\r\n    handleNewFrameCount_(frameCount) {\r\n        this.totalFrames = frameCount;\r\n        this.frames = [];\r\n    }\r\n    /**\r\n     * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1\r\n     * @returns Any remaining data to be process, or null if there is none\r\n     */\r\n    extractFrameCount_(data) {\r\n        index_esm2017_assert(this.frames === null, 'We already have a frame buffer');\r\n        // TODO: The server is only supposed to send up to 9999 frames (i.e. length <= 4), but that isn't being enforced\r\n        // currently.  So allowing larger frame counts (length <= 6).  See https://app.asana.com/0/search/8688598998380/8237608042508\r\n        if (data.length <= 6) {\r\n            const frameCount = Number(data);\r\n            if (!isNaN(frameCount)) {\r\n                this.handleNewFrameCount_(frameCount);\r\n                return null;\r\n            }\r\n        }\r\n        this.handleNewFrameCount_(1);\r\n        return data;\r\n    }\r\n    /**\r\n     * Process a websocket frame that has arrived from the server.\r\n     * @param mess - The frame data\r\n     */\r\n    handleIncomingFrame(mess) {\r\n        if (this.mySock === null) {\r\n            return; // Chrome apparently delivers incoming packets even after we .close() the connection sometimes.\r\n        }\r\n        const data = mess['data'];\r\n        this.bytesReceived += data.length;\r\n        this.stats_.incrementCounter('bytes_received', data.length);\r\n        this.resetKeepAlive();\r\n        if (this.frames !== null) {\r\n            // we're buffering\r\n            this.appendFrame_(data);\r\n        }\r\n        else {\r\n            // try to parse out a frame count, otherwise, assume 1 and process it\r\n            const remainingData = this.extractFrameCount_(data);\r\n            if (remainingData !== null) {\r\n                this.appendFrame_(remainingData);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Send a message to the server\r\n     * @param data - The JSON object to transmit\r\n     */\r\n    send(data) {\r\n        this.resetKeepAlive();\r\n        const dataStr = index_esm2017_stringify(data);\r\n        this.bytesSent += dataStr.length;\r\n        this.stats_.incrementCounter('bytes_sent', dataStr.length);\r\n        //We can only fit a certain amount in each websocket frame, so we need to split this request\r\n        //up into multiple pieces if it doesn't fit in one request.\r\n        const dataSegs = splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);\r\n        //Send the length header\r\n        if (dataSegs.length > 1) {\r\n            this.sendString_(String(dataSegs.length));\r\n        }\r\n        //Send the actual data in segments.\r\n        for (let i = 0; i < dataSegs.length; i++) {\r\n            this.sendString_(dataSegs[i]);\r\n        }\r\n    }\r\n    shutdown_() {\r\n        this.isClosed_ = true;\r\n        if (this.keepaliveTimer) {\r\n            clearInterval(this.keepaliveTimer);\r\n            this.keepaliveTimer = null;\r\n        }\r\n        if (this.mySock) {\r\n            this.mySock.close();\r\n            this.mySock = null;\r\n        }\r\n    }\r\n    onClosed_() {\r\n        if (!this.isClosed_) {\r\n            this.log_('WebSocket is closing itself');\r\n            this.shutdown_();\r\n            // since this is an internal close, trigger the close listener\r\n            if (this.onDisconnect) {\r\n                this.onDisconnect(this.everConnected_);\r\n                this.onDisconnect = null;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * External-facing close handler.\r\n     * Close the websocket and kill the connection.\r\n     */\r\n    close() {\r\n        if (!this.isClosed_) {\r\n            this.log_('WebSocket is being closed');\r\n            this.shutdown_();\r\n        }\r\n    }\r\n    /**\r\n     * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after\r\n     * the last activity.\r\n     */\r\n    resetKeepAlive() {\r\n        clearInterval(this.keepaliveTimer);\r\n        this.keepaliveTimer = setInterval(() => {\r\n            //If there has been no websocket activity for a while, send a no-op\r\n            if (this.mySock) {\r\n                this.sendString_('0');\r\n            }\r\n            this.resetKeepAlive();\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));\r\n    }\r\n    /**\r\n     * Send a string over the websocket.\r\n     *\r\n     * @param str - String to send.\r\n     */\r\n    sendString_(str) {\r\n        // Firefox seems to sometimes throw exceptions (NS_ERROR_UNEXPECTED) from websocket .send()\r\n        // calls for some unknown reason.  We treat these as an error and disconnect.\r\n        // See https://app.asana.com/0/58926111402292/68021340250410\r\n        try {\r\n            this.mySock.send(str);\r\n        }\r\n        catch (e) {\r\n            this.log_('Exception thrown from WebSocket.send():', e.message || e.data, 'Closing connection.');\r\n            setTimeout(this.onClosed_.bind(this), 0);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Number of response before we consider the connection \"healthy.\"\r\n */\r\nWebSocketConnection.responsesRequiredToBeHealthy = 2;\r\n/**\r\n * Time to wait for the connection te become healthy before giving up.\r\n */\r\nWebSocketConnection.healthyTimeout = 30000;\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Currently simplistic, this class manages what transport a Connection should use at various stages of its\r\n * lifecycle.\r\n *\r\n * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if\r\n * they are available.\r\n */\r\nclass TransportManager {\r\n    /**\r\n     * @param repoInfo - Metadata around the namespace we're connecting to\r\n     */\r\n    constructor(repoInfo) {\r\n        this.initTransports_(repoInfo);\r\n    }\r\n    static get ALL_TRANSPORTS() {\r\n        return [BrowserPollConnection, WebSocketConnection];\r\n    }\r\n    /**\r\n     * Returns whether transport has been selected to ensure WebSocketConnection or BrowserPollConnection are not called after\r\n     * TransportManager has already set up transports_\r\n     */\r\n    static get IS_TRANSPORT_INITIALIZED() {\r\n        return this.globalTransportInitialized_;\r\n    }\r\n    initTransports_(repoInfo) {\r\n        const isWebSocketsAvailable = WebSocketConnection && WebSocketConnection['isAvailable']();\r\n        let isSkipPollConnection = isWebSocketsAvailable && !WebSocketConnection.previouslyFailed();\r\n        if (repoInfo.webSocketOnly) {\r\n            if (!isWebSocketsAvailable) {\r\n                warn(\"wss:// URL used, but browser isn't known to support websockets.  Trying anyway.\");\r\n            }\r\n            isSkipPollConnection = true;\r\n        }\r\n        if (isSkipPollConnection) {\r\n            this.transports_ = [WebSocketConnection];\r\n        }\r\n        else {\r\n            const transports = (this.transports_ = []);\r\n            for (const transport of TransportManager.ALL_TRANSPORTS) {\r\n                if (transport && transport['isAvailable']()) {\r\n                    transports.push(transport);\r\n                }\r\n            }\r\n            TransportManager.globalTransportInitialized_ = true;\r\n        }\r\n    }\r\n    /**\r\n     * @returns The constructor for the initial transport to use\r\n     */\r\n    initialTransport() {\r\n        if (this.transports_.length > 0) {\r\n            return this.transports_[0];\r\n        }\r\n        else {\r\n            throw new Error('No transports available');\r\n        }\r\n    }\r\n    /**\r\n     * @returns The constructor for the next transport, or null\r\n     */\r\n    upgradeTransport() {\r\n        if (this.transports_.length > 1) {\r\n            return this.transports_[1];\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n// Keeps track of whether the TransportManager has already chosen a transport to use\r\nTransportManager.globalTransportInitialized_ = false;\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Abort upgrade attempt if it takes longer than 60s.\r\nconst UPGRADE_TIMEOUT = 60000;\r\n// For some transports (WebSockets), we need to \"validate\" the transport by exchanging a few requests and responses.\r\n// If we haven't sent enough requests within 5s, we'll start sending noop ping requests.\r\nconst DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5000;\r\n// If the initial data sent triggers a lot of bandwidth (i.e. it's a large put or a listen for a large amount of data)\r\n// then we may not be able to exchange our ping/pong requests within the healthy timeout.  So if we reach the timeout\r\n// but we've sent/received enough bytes, we don't cancel the connection.\r\nconst BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;\r\nconst BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;\r\nconst MESSAGE_TYPE = 't';\r\nconst MESSAGE_DATA = 'd';\r\nconst CONTROL_SHUTDOWN = 's';\r\nconst CONTROL_RESET = 'r';\r\nconst CONTROL_ERROR = 'e';\r\nconst CONTROL_PONG = 'o';\r\nconst SWITCH_ACK = 'a';\r\nconst END_TRANSMISSION = 'n';\r\nconst PING = 'p';\r\nconst SERVER_HELLO = 'h';\r\n/**\r\n * Creates a new real-time connection to the server using whichever method works\r\n * best in the current browser.\r\n */\r\nclass Connection {\r\n    /**\r\n     * @param id - an id for this connection\r\n     * @param repoInfo_ - the info for the endpoint to connect to\r\n     * @param applicationId_ - the Firebase App ID for this project\r\n     * @param appCheckToken_ - The App Check Token for this device.\r\n     * @param authToken_ - The auth token for this session.\r\n     * @param onMessage_ - the callback to be triggered when a server-push message arrives\r\n     * @param onReady_ - the callback to be triggered when this connection is ready to send messages.\r\n     * @param onDisconnect_ - the callback to be triggered when a connection was lost\r\n     * @param onKill_ - the callback to be triggered when this connection has permanently shut down.\r\n     * @param lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server\r\n     */\r\n    constructor(id, repoInfo_, applicationId_, appCheckToken_, authToken_, onMessage_, onReady_, onDisconnect_, onKill_, lastSessionId) {\r\n        this.id = id;\r\n        this.repoInfo_ = repoInfo_;\r\n        this.applicationId_ = applicationId_;\r\n        this.appCheckToken_ = appCheckToken_;\r\n        this.authToken_ = authToken_;\r\n        this.onMessage_ = onMessage_;\r\n        this.onReady_ = onReady_;\r\n        this.onDisconnect_ = onDisconnect_;\r\n        this.onKill_ = onKill_;\r\n        this.lastSessionId = lastSessionId;\r\n        this.connectionCount = 0;\r\n        this.pendingDataMessages = [];\r\n        this.state_ = 0 /* RealtimeState.CONNECTING */;\r\n        this.log_ = logWrapper('c:' + this.id + ':');\r\n        this.transportManager_ = new TransportManager(repoInfo_);\r\n        this.log_('Connection created');\r\n        this.start_();\r\n    }\r\n    /**\r\n     * Starts a connection attempt\r\n     */\r\n    start_() {\r\n        const conn = this.transportManager_.initialTransport();\r\n        this.conn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, null, this.lastSessionId);\r\n        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\r\n        // can consider the transport healthy.\r\n        this.primaryResponsesRequired_ = conn['responsesRequiredToBeHealthy'] || 0;\r\n        const onMessageReceived = this.connReceiver_(this.conn_);\r\n        const onConnectionLost = this.disconnReceiver_(this.conn_);\r\n        this.tx_ = this.conn_;\r\n        this.rx_ = this.conn_;\r\n        this.secondaryConn_ = null;\r\n        this.isHealthy_ = false;\r\n        /*\r\n         * Firefox doesn't like when code from one iframe tries to create another iframe by way of the parent frame.\r\n         * This can occur in the case of a redirect, i.e. we guessed wrong on what server to connect to and received a reset.\r\n         * Somehow, setTimeout seems to make this ok. That doesn't make sense from a security perspective, since you should\r\n         * still have the context of your originating frame.\r\n         */\r\n        setTimeout(() => {\r\n            // this.conn_ gets set to null in some of the tests. Check to make sure it still exists before using it\r\n            this.conn_ && this.conn_.open(onMessageReceived, onConnectionLost);\r\n        }, Math.floor(0));\r\n        const healthyTimeoutMS = conn['healthyTimeout'] || 0;\r\n        if (healthyTimeoutMS > 0) {\r\n            this.healthyTimeout_ = setTimeoutNonBlocking(() => {\r\n                this.healthyTimeout_ = null;\r\n                if (!this.isHealthy_) {\r\n                    if (this.conn_ &&\r\n                        this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE) {\r\n                        this.log_('Connection exceeded healthy timeout but has received ' +\r\n                            this.conn_.bytesReceived +\r\n                            ' bytes.  Marking connection healthy.');\r\n                        this.isHealthy_ = true;\r\n                        this.conn_.markConnectionHealthy();\r\n                    }\r\n                    else if (this.conn_ &&\r\n                        this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE) {\r\n                        this.log_('Connection exceeded healthy timeout but has sent ' +\r\n                            this.conn_.bytesSent +\r\n                            ' bytes.  Leaving connection alive.');\r\n                        // NOTE: We don't want to mark it healthy, since we have no guarantee that the bytes have made it to\r\n                        // the server.\r\n                    }\r\n                    else {\r\n                        this.log_('Closing unhealthy connection after timeout.');\r\n                        this.close();\r\n                    }\r\n                }\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            }, Math.floor(healthyTimeoutMS));\r\n        }\r\n    }\r\n    nextTransportId_() {\r\n        return 'c:' + this.id + ':' + this.connectionCount++;\r\n    }\r\n    disconnReceiver_(conn) {\r\n        return everConnected => {\r\n            if (conn === this.conn_) {\r\n                this.onConnectionLost_(everConnected);\r\n            }\r\n            else if (conn === this.secondaryConn_) {\r\n                this.log_('Secondary connection lost.');\r\n                this.onSecondaryConnectionLost_();\r\n            }\r\n            else {\r\n                this.log_('closing an old connection');\r\n            }\r\n        };\r\n    }\r\n    connReceiver_(conn) {\r\n        return (message) => {\r\n            if (this.state_ !== 2 /* RealtimeState.DISCONNECTED */) {\r\n                if (conn === this.rx_) {\r\n                    this.onPrimaryMessageReceived_(message);\r\n                }\r\n                else if (conn === this.secondaryConn_) {\r\n                    this.onSecondaryMessageReceived_(message);\r\n                }\r\n                else {\r\n                    this.log_('message on old connection');\r\n                }\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * @param dataMsg - An arbitrary data message to be sent to the server\r\n     */\r\n    sendRequest(dataMsg) {\r\n        // wrap in a data message envelope and send it on\r\n        const msg = { t: 'd', d: dataMsg };\r\n        this.sendData_(msg);\r\n    }\r\n    tryCleanupConnection() {\r\n        if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {\r\n            this.log_('cleaning up and promoting a connection: ' + this.secondaryConn_.connId);\r\n            this.conn_ = this.secondaryConn_;\r\n            this.secondaryConn_ = null;\r\n            // the server will shutdown the old connection\r\n        }\r\n    }\r\n    onSecondaryControl_(controlData) {\r\n        if (MESSAGE_TYPE in controlData) {\r\n            const cmd = controlData[MESSAGE_TYPE];\r\n            if (cmd === SWITCH_ACK) {\r\n                this.upgradeIfSecondaryHealthy_();\r\n            }\r\n            else if (cmd === CONTROL_RESET) {\r\n                // Most likely the session wasn't valid. Abandon the switch attempt\r\n                this.log_('Got a reset on secondary, closing it');\r\n                this.secondaryConn_.close();\r\n                // If we were already using this connection for something, than we need to fully close\r\n                if (this.tx_ === this.secondaryConn_ ||\r\n                    this.rx_ === this.secondaryConn_) {\r\n                    this.close();\r\n                }\r\n            }\r\n            else if (cmd === CONTROL_PONG) {\r\n                this.log_('got pong on secondary.');\r\n                this.secondaryResponsesRequired_--;\r\n                this.upgradeIfSecondaryHealthy_();\r\n            }\r\n        }\r\n    }\r\n    onSecondaryMessageReceived_(parsedData) {\r\n        const layer = requireKey('t', parsedData);\r\n        const data = requireKey('d', parsedData);\r\n        if (layer === 'c') {\r\n            this.onSecondaryControl_(data);\r\n        }\r\n        else if (layer === 'd') {\r\n            // got a data message, but we're still second connection. Need to buffer it up\r\n            this.pendingDataMessages.push(data);\r\n        }\r\n        else {\r\n            throw new Error('Unknown protocol layer: ' + layer);\r\n        }\r\n    }\r\n    upgradeIfSecondaryHealthy_() {\r\n        if (this.secondaryResponsesRequired_ <= 0) {\r\n            this.log_('Secondary connection is healthy.');\r\n            this.isHealthy_ = true;\r\n            this.secondaryConn_.markConnectionHealthy();\r\n            this.proceedWithUpgrade_();\r\n        }\r\n        else {\r\n            // Send a ping to make sure the connection is healthy.\r\n            this.log_('sending ping on secondary.');\r\n            this.secondaryConn_.send({ t: 'c', d: { t: PING, d: {} } });\r\n        }\r\n    }\r\n    proceedWithUpgrade_() {\r\n        // tell this connection to consider itself open\r\n        this.secondaryConn_.start();\r\n        // send ack\r\n        this.log_('sending client ack on secondary');\r\n        this.secondaryConn_.send({ t: 'c', d: { t: SWITCH_ACK, d: {} } });\r\n        // send end packet on primary transport, switch to sending on this one\r\n        // can receive on this one, buffer responses until end received on primary transport\r\n        this.log_('Ending transmission on primary');\r\n        this.conn_.send({ t: 'c', d: { t: END_TRANSMISSION, d: {} } });\r\n        this.tx_ = this.secondaryConn_;\r\n        this.tryCleanupConnection();\r\n    }\r\n    onPrimaryMessageReceived_(parsedData) {\r\n        // Must refer to parsedData properties in quotes, so closure doesn't touch them.\r\n        const layer = requireKey('t', parsedData);\r\n        const data = requireKey('d', parsedData);\r\n        if (layer === 'c') {\r\n            this.onControl_(data);\r\n        }\r\n        else if (layer === 'd') {\r\n            this.onDataMessage_(data);\r\n        }\r\n    }\r\n    onDataMessage_(message) {\r\n        this.onPrimaryResponse_();\r\n        // We don't do anything with data messages, just kick them up a level\r\n        this.onMessage_(message);\r\n    }\r\n    onPrimaryResponse_() {\r\n        if (!this.isHealthy_) {\r\n            this.primaryResponsesRequired_--;\r\n            if (this.primaryResponsesRequired_ <= 0) {\r\n                this.log_('Primary connection is healthy.');\r\n                this.isHealthy_ = true;\r\n                this.conn_.markConnectionHealthy();\r\n            }\r\n        }\r\n    }\r\n    onControl_(controlData) {\r\n        const cmd = requireKey(MESSAGE_TYPE, controlData);\r\n        if (MESSAGE_DATA in controlData) {\r\n            const payload = controlData[MESSAGE_DATA];\r\n            if (cmd === SERVER_HELLO) {\r\n                const handshakePayload = Object.assign({}, payload);\r\n                if (this.repoInfo_.isUsingEmulator) {\r\n                    // Upon connecting, the emulator will pass the hostname that it's aware of, but we prefer the user's set hostname via `connectDatabaseEmulator` over what the emulator passes.\r\n                    handshakePayload.h = this.repoInfo_.host;\r\n                }\r\n                this.onHandshake_(handshakePayload);\r\n            }\r\n            else if (cmd === END_TRANSMISSION) {\r\n                this.log_('recvd end transmission on primary');\r\n                this.rx_ = this.secondaryConn_;\r\n                for (let i = 0; i < this.pendingDataMessages.length; ++i) {\r\n                    this.onDataMessage_(this.pendingDataMessages[i]);\r\n                }\r\n                this.pendingDataMessages = [];\r\n                this.tryCleanupConnection();\r\n            }\r\n            else if (cmd === CONTROL_SHUTDOWN) {\r\n                // This was previously the 'onKill' callback passed to the lower-level connection\r\n                // payload in this case is the reason for the shutdown. Generally a human-readable error\r\n                this.onConnectionShutdown_(payload);\r\n            }\r\n            else if (cmd === CONTROL_RESET) {\r\n                // payload in this case is the host we should contact\r\n                this.onReset_(payload);\r\n            }\r\n            else if (cmd === CONTROL_ERROR) {\r\n                error('Server Error: ' + payload);\r\n            }\r\n            else if (cmd === CONTROL_PONG) {\r\n                this.log_('got pong on primary.');\r\n                this.onPrimaryResponse_();\r\n                this.sendPingOnPrimaryIfNecessary_();\r\n            }\r\n            else {\r\n                error('Unknown control packet command: ' + cmd);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @param handshake - The handshake data returned from the server\r\n     */\r\n    onHandshake_(handshake) {\r\n        const timestamp = handshake.ts;\r\n        const version = handshake.v;\r\n        const host = handshake.h;\r\n        this.sessionId = handshake.s;\r\n        this.repoInfo_.host = host;\r\n        // if we've already closed the connection, then don't bother trying to progress further\r\n        if (this.state_ === 0 /* RealtimeState.CONNECTING */) {\r\n            this.conn_.start();\r\n            this.onConnectionEstablished_(this.conn_, timestamp);\r\n            if (PROTOCOL_VERSION !== version) {\r\n                warn('Protocol version mismatch detected');\r\n            }\r\n            // TODO: do we want to upgrade? when? maybe a delay?\r\n            this.tryStartUpgrade_();\r\n        }\r\n    }\r\n    tryStartUpgrade_() {\r\n        const conn = this.transportManager_.upgradeTransport();\r\n        if (conn) {\r\n            this.startUpgrade_(conn);\r\n        }\r\n    }\r\n    startUpgrade_(conn) {\r\n        this.secondaryConn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, this.sessionId);\r\n        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\r\n        // can consider the transport healthy.\r\n        this.secondaryResponsesRequired_ =\r\n            conn['responsesRequiredToBeHealthy'] || 0;\r\n        const onMessage = this.connReceiver_(this.secondaryConn_);\r\n        const onDisconnect = this.disconnReceiver_(this.secondaryConn_);\r\n        this.secondaryConn_.open(onMessage, onDisconnect);\r\n        // If we haven't successfully upgraded after UPGRADE_TIMEOUT, give up and kill the secondary.\r\n        setTimeoutNonBlocking(() => {\r\n            if (this.secondaryConn_) {\r\n                this.log_('Timed out trying to upgrade.');\r\n                this.secondaryConn_.close();\r\n            }\r\n        }, Math.floor(UPGRADE_TIMEOUT));\r\n    }\r\n    onReset_(host) {\r\n        this.log_('Reset packet received.  New host: ' + host);\r\n        this.repoInfo_.host = host;\r\n        // TODO: if we're already \"connected\", we need to trigger a disconnect at the next layer up.\r\n        // We don't currently support resets after the connection has already been established\r\n        if (this.state_ === 1 /* RealtimeState.CONNECTED */) {\r\n            this.close();\r\n        }\r\n        else {\r\n            // Close whatever connections we have open and start again.\r\n            this.closeConnections_();\r\n            this.start_();\r\n        }\r\n    }\r\n    onConnectionEstablished_(conn, timestamp) {\r\n        this.log_('Realtime connection established.');\r\n        this.conn_ = conn;\r\n        this.state_ = 1 /* RealtimeState.CONNECTED */;\r\n        if (this.onReady_) {\r\n            this.onReady_(timestamp, this.sessionId);\r\n            this.onReady_ = null;\r\n        }\r\n        // If after 5 seconds we haven't sent enough requests to the server to get the connection healthy,\r\n        // send some pings.\r\n        if (this.primaryResponsesRequired_ === 0) {\r\n            this.log_('Primary connection is healthy.');\r\n            this.isHealthy_ = true;\r\n        }\r\n        else {\r\n            setTimeoutNonBlocking(() => {\r\n                this.sendPingOnPrimaryIfNecessary_();\r\n            }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));\r\n        }\r\n    }\r\n    sendPingOnPrimaryIfNecessary_() {\r\n        // If the connection isn't considered healthy yet, we'll send a noop ping packet request.\r\n        if (!this.isHealthy_ && this.state_ === 1 /* RealtimeState.CONNECTED */) {\r\n            this.log_('sending ping on primary.');\r\n            this.sendData_({ t: 'c', d: { t: PING, d: {} } });\r\n        }\r\n    }\r\n    onSecondaryConnectionLost_() {\r\n        const conn = this.secondaryConn_;\r\n        this.secondaryConn_ = null;\r\n        if (this.tx_ === conn || this.rx_ === conn) {\r\n            // we are relying on this connection already in some capacity. Therefore, a failure is real\r\n            this.close();\r\n        }\r\n    }\r\n    /**\r\n     * @param everConnected - Whether or not the connection ever reached a server. Used to determine if\r\n     * we should flush the host cache\r\n     */\r\n    onConnectionLost_(everConnected) {\r\n        this.conn_ = null;\r\n        // NOTE: IF you're seeing a Firefox error for this line, I think it might be because it's getting\r\n        // called on window close and RealtimeState.CONNECTING is no longer defined.  Just a guess.\r\n        if (!everConnected && this.state_ === 0 /* RealtimeState.CONNECTING */) {\r\n            this.log_('Realtime connection failed.');\r\n            // Since we failed to connect at all, clear any cached entry for this namespace in case the machine went away\r\n            if (this.repoInfo_.isCacheableHost()) {\r\n                PersistentStorage.remove('host:' + this.repoInfo_.host);\r\n                // reset the internal host to what we would show the user, i.e. <ns>.firebaseio.com\r\n                this.repoInfo_.internalHost = this.repoInfo_.host;\r\n            }\r\n        }\r\n        else if (this.state_ === 1 /* RealtimeState.CONNECTED */) {\r\n            this.log_('Realtime connection lost.');\r\n        }\r\n        this.close();\r\n    }\r\n    onConnectionShutdown_(reason) {\r\n        this.log_('Connection shutdown command received. Shutting down...');\r\n        if (this.onKill_) {\r\n            this.onKill_(reason);\r\n            this.onKill_ = null;\r\n        }\r\n        // We intentionally don't want to fire onDisconnect (kill is a different case),\r\n        // so clear the callback.\r\n        this.onDisconnect_ = null;\r\n        this.close();\r\n    }\r\n    sendData_(data) {\r\n        if (this.state_ !== 1 /* RealtimeState.CONNECTED */) {\r\n            throw 'Connection is not connected';\r\n        }\r\n        else {\r\n            this.tx_.send(data);\r\n        }\r\n    }\r\n    /**\r\n     * Cleans up this connection, calling the appropriate callbacks\r\n     */\r\n    close() {\r\n        if (this.state_ !== 2 /* RealtimeState.DISCONNECTED */) {\r\n            this.log_('Closing realtime connection.');\r\n            this.state_ = 2 /* RealtimeState.DISCONNECTED */;\r\n            this.closeConnections_();\r\n            if (this.onDisconnect_) {\r\n                this.onDisconnect_();\r\n                this.onDisconnect_ = null;\r\n            }\r\n        }\r\n    }\r\n    closeConnections_() {\r\n        this.log_('Shutting down all connections');\r\n        if (this.conn_) {\r\n            this.conn_.close();\r\n            this.conn_ = null;\r\n        }\r\n        if (this.secondaryConn_) {\r\n            this.secondaryConn_.close();\r\n            this.secondaryConn_ = null;\r\n        }\r\n        if (this.healthyTimeout_) {\r\n            clearTimeout(this.healthyTimeout_);\r\n            this.healthyTimeout_ = null;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Interface defining the set of actions that can be performed against the Firebase server\r\n * (basically corresponds to our wire protocol).\r\n *\r\n * @interface\r\n */\r\nclass ServerActions {\r\n    put(pathString, data, onComplete, hash) { }\r\n    merge(pathString, data, onComplete, hash) { }\r\n    /**\r\n     * Refreshes the auth token for the current connection.\r\n     * @param token - The authentication token\r\n     */\r\n    refreshAuthToken(token) { }\r\n    /**\r\n     * Refreshes the app check token for the current connection.\r\n     * @param token The app check token\r\n     */\r\n    refreshAppCheckToken(token) { }\r\n    onDisconnectPut(pathString, data, onComplete) { }\r\n    onDisconnectMerge(pathString, data, onComplete) { }\r\n    onDisconnectCancel(pathString, onComplete) { }\r\n    reportStats(stats) { }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Base class to be used if you want to emit events. Call the constructor with\r\n * the set of allowed event names.\r\n */\r\nclass EventEmitter {\r\n    constructor(allowedEvents_) {\r\n        this.allowedEvents_ = allowedEvents_;\r\n        this.listeners_ = {};\r\n        index_esm2017_assert(Array.isArray(allowedEvents_) && allowedEvents_.length > 0, 'Requires a non-empty array');\r\n    }\r\n    /**\r\n     * To be called by derived classes to trigger events.\r\n     */\r\n    trigger(eventType, ...varArgs) {\r\n        if (Array.isArray(this.listeners_[eventType])) {\r\n            // Clone the list, since callbacks could add/remove listeners.\r\n            const listeners = [...this.listeners_[eventType]];\r\n            for (let i = 0; i < listeners.length; i++) {\r\n                listeners[i].callback.apply(listeners[i].context, varArgs);\r\n            }\r\n        }\r\n    }\r\n    on(eventType, callback, context) {\r\n        this.validateEventType_(eventType);\r\n        this.listeners_[eventType] = this.listeners_[eventType] || [];\r\n        this.listeners_[eventType].push({ callback, context });\r\n        const eventData = this.getInitialEvent(eventType);\r\n        if (eventData) {\r\n            callback.apply(context, eventData);\r\n        }\r\n    }\r\n    off(eventType, callback, context) {\r\n        this.validateEventType_(eventType);\r\n        const listeners = this.listeners_[eventType] || [];\r\n        for (let i = 0; i < listeners.length; i++) {\r\n            if (listeners[i].callback === callback &&\r\n                (!context || context === listeners[i].context)) {\r\n                listeners.splice(i, 1);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    validateEventType_(eventType) {\r\n        index_esm2017_assert(this.allowedEvents_.find(et => {\r\n            return et === eventType;\r\n        }), 'Unknown event: ' + eventType);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Monitors online state (as reported by window.online/offline events).\r\n *\r\n * The expectation is that this could have many false positives (thinks we are online\r\n * when we're not), but no false negatives.  So we can safely use it to determine when\r\n * we definitely cannot reach the internet.\r\n */\r\nclass OnlineMonitor extends EventEmitter {\r\n    constructor() {\r\n        super(['online']);\r\n        this.online_ = true;\r\n        // We've had repeated complaints that Cordova apps can get stuck \"offline\", e.g.\r\n        // https://forum.ionicframework.com/t/firebase-connection-is-lost-and-never-come-back/43810\r\n        // It would seem that the 'online' event does not always fire consistently. So we disable it\r\n        // for Cordova.\r\n        if (typeof window !== 'undefined' &&\r\n            typeof window.addEventListener !== 'undefined' &&\r\n            !isMobileCordova()) {\r\n            window.addEventListener('online', () => {\r\n                if (!this.online_) {\r\n                    this.online_ = true;\r\n                    this.trigger('online', true);\r\n                }\r\n            }, false);\r\n            window.addEventListener('offline', () => {\r\n                if (this.online_) {\r\n                    this.online_ = false;\r\n                    this.trigger('online', false);\r\n                }\r\n            }, false);\r\n        }\r\n    }\r\n    static getInstance() {\r\n        return new OnlineMonitor();\r\n    }\r\n    getInitialEvent(eventType) {\r\n        index_esm2017_assert(eventType === 'online', 'Unknown event type: ' + eventType);\r\n        return [this.online_];\r\n    }\r\n    currentlyOnline() {\r\n        return this.online_;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Maximum key depth. */\r\nconst MAX_PATH_DEPTH = 32;\r\n/** Maximum number of (UTF8) bytes in a Firebase path. */\r\nconst MAX_PATH_LENGTH_BYTES = 768;\r\n/**\r\n * An immutable object representing a parsed path.  It's immutable so that you\r\n * can pass them around to other functions without worrying about them changing\r\n * it.\r\n */\r\nclass Path {\r\n    /**\r\n     * @param pathOrString - Path string to parse, or another path, or the raw\r\n     * tokens array\r\n     */\r\n    constructor(pathOrString, pieceNum) {\r\n        if (pieceNum === void 0) {\r\n            this.pieces_ = pathOrString.split('/');\r\n            // Remove empty pieces.\r\n            let copyTo = 0;\r\n            for (let i = 0; i < this.pieces_.length; i++) {\r\n                if (this.pieces_[i].length > 0) {\r\n                    this.pieces_[copyTo] = this.pieces_[i];\r\n                    copyTo++;\r\n                }\r\n            }\r\n            this.pieces_.length = copyTo;\r\n            this.pieceNum_ = 0;\r\n        }\r\n        else {\r\n            this.pieces_ = pathOrString;\r\n            this.pieceNum_ = pieceNum;\r\n        }\r\n    }\r\n    toString() {\r\n        let pathString = '';\r\n        for (let i = this.pieceNum_; i < this.pieces_.length; i++) {\r\n            if (this.pieces_[i] !== '') {\r\n                pathString += '/' + this.pieces_[i];\r\n            }\r\n        }\r\n        return pathString || '/';\r\n    }\r\n}\r\nfunction newEmptyPath() {\r\n    return new Path('');\r\n}\r\nfunction pathGetFront(path) {\r\n    if (path.pieceNum_ >= path.pieces_.length) {\r\n        return null;\r\n    }\r\n    return path.pieces_[path.pieceNum_];\r\n}\r\n/**\r\n * @returns The number of segments in this path\r\n */\r\nfunction pathGetLength(path) {\r\n    return path.pieces_.length - path.pieceNum_;\r\n}\r\nfunction pathPopFront(path) {\r\n    let pieceNum = path.pieceNum_;\r\n    if (pieceNum < path.pieces_.length) {\r\n        pieceNum++;\r\n    }\r\n    return new Path(path.pieces_, pieceNum);\r\n}\r\nfunction pathGetBack(path) {\r\n    if (path.pieceNum_ < path.pieces_.length) {\r\n        return path.pieces_[path.pieces_.length - 1];\r\n    }\r\n    return null;\r\n}\r\nfunction pathToUrlEncodedString(path) {\r\n    let pathString = '';\r\n    for (let i = path.pieceNum_; i < path.pieces_.length; i++) {\r\n        if (path.pieces_[i] !== '') {\r\n            pathString += '/' + encodeURIComponent(String(path.pieces_[i]));\r\n        }\r\n    }\r\n    return pathString || '/';\r\n}\r\n/**\r\n * Shallow copy of the parts of the path.\r\n *\r\n */\r\nfunction pathSlice(path, begin = 0) {\r\n    return path.pieces_.slice(path.pieceNum_ + begin);\r\n}\r\nfunction pathParent(path) {\r\n    if (path.pieceNum_ >= path.pieces_.length) {\r\n        return null;\r\n    }\r\n    const pieces = [];\r\n    for (let i = path.pieceNum_; i < path.pieces_.length - 1; i++) {\r\n        pieces.push(path.pieces_[i]);\r\n    }\r\n    return new Path(pieces, 0);\r\n}\r\nfunction pathChild(path, childPathObj) {\r\n    const pieces = [];\r\n    for (let i = path.pieceNum_; i < path.pieces_.length; i++) {\r\n        pieces.push(path.pieces_[i]);\r\n    }\r\n    if (childPathObj instanceof Path) {\r\n        for (let i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++) {\r\n            pieces.push(childPathObj.pieces_[i]);\r\n        }\r\n    }\r\n    else {\r\n        const childPieces = childPathObj.split('/');\r\n        for (let i = 0; i < childPieces.length; i++) {\r\n            if (childPieces[i].length > 0) {\r\n                pieces.push(childPieces[i]);\r\n            }\r\n        }\r\n    }\r\n    return new Path(pieces, 0);\r\n}\r\n/**\r\n * @returns True if there are no segments in this path\r\n */\r\nfunction pathIsEmpty(path) {\r\n    return path.pieceNum_ >= path.pieces_.length;\r\n}\r\n/**\r\n * @returns The path from outerPath to innerPath\r\n */\r\nfunction newRelativePath(outerPath, innerPath) {\r\n    const outer = pathGetFront(outerPath), inner = pathGetFront(innerPath);\r\n    if (outer === null) {\r\n        return innerPath;\r\n    }\r\n    else if (outer === inner) {\r\n        return newRelativePath(pathPopFront(outerPath), pathPopFront(innerPath));\r\n    }\r\n    else {\r\n        throw new Error('INTERNAL ERROR: innerPath (' +\r\n            innerPath +\r\n            ') is not within ' +\r\n            'outerPath (' +\r\n            outerPath +\r\n            ')');\r\n    }\r\n}\r\n/**\r\n * @returns -1, 0, 1 if left is less, equal, or greater than the right.\r\n */\r\nfunction pathCompare(left, right) {\r\n    const leftKeys = pathSlice(left, 0);\r\n    const rightKeys = pathSlice(right, 0);\r\n    for (let i = 0; i < leftKeys.length && i < rightKeys.length; i++) {\r\n        const cmp = nameCompare(leftKeys[i], rightKeys[i]);\r\n        if (cmp !== 0) {\r\n            return cmp;\r\n        }\r\n    }\r\n    if (leftKeys.length === rightKeys.length) {\r\n        return 0;\r\n    }\r\n    return leftKeys.length < rightKeys.length ? -1 : 1;\r\n}\r\n/**\r\n * @returns true if paths are the same.\r\n */\r\nfunction pathEquals(path, other) {\r\n    if (pathGetLength(path) !== pathGetLength(other)) {\r\n        return false;\r\n    }\r\n    for (let i = path.pieceNum_, j = other.pieceNum_; i <= path.pieces_.length; i++, j++) {\r\n        if (path.pieces_[i] !== other.pieces_[j]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * @returns True if this path is a parent of (or the same as) other\r\n */\r\nfunction pathContains(path, other) {\r\n    let i = path.pieceNum_;\r\n    let j = other.pieceNum_;\r\n    if (pathGetLength(path) > pathGetLength(other)) {\r\n        return false;\r\n    }\r\n    while (i < path.pieces_.length) {\r\n        if (path.pieces_[i] !== other.pieces_[j]) {\r\n            return false;\r\n        }\r\n        ++i;\r\n        ++j;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Dynamic (mutable) path used to count path lengths.\r\n *\r\n * This class is used to efficiently check paths for valid\r\n * length (in UTF8 bytes) and depth (used in path validation).\r\n *\r\n * Throws Error exception if path is ever invalid.\r\n *\r\n * The definition of a path always begins with '/'.\r\n */\r\nclass ValidationPath {\r\n    /**\r\n     * @param path - Initial Path.\r\n     * @param errorPrefix_ - Prefix for any error messages.\r\n     */\r\n    constructor(path, errorPrefix_) {\r\n        this.errorPrefix_ = errorPrefix_;\r\n        this.parts_ = pathSlice(path, 0);\r\n        /** Initialize to number of '/' chars needed in path. */\r\n        this.byteLength_ = Math.max(1, this.parts_.length);\r\n        for (let i = 0; i < this.parts_.length; i++) {\r\n            this.byteLength_ += stringLength(this.parts_[i]);\r\n        }\r\n        validationPathCheckValid(this);\r\n    }\r\n}\r\nfunction validationPathPush(validationPath, child) {\r\n    // Count the needed '/'\r\n    if (validationPath.parts_.length > 0) {\r\n        validationPath.byteLength_ += 1;\r\n    }\r\n    validationPath.parts_.push(child);\r\n    validationPath.byteLength_ += stringLength(child);\r\n    validationPathCheckValid(validationPath);\r\n}\r\nfunction validationPathPop(validationPath) {\r\n    const last = validationPath.parts_.pop();\r\n    validationPath.byteLength_ -= stringLength(last);\r\n    // Un-count the previous '/'\r\n    if (validationPath.parts_.length > 0) {\r\n        validationPath.byteLength_ -= 1;\r\n    }\r\n}\r\nfunction validationPathCheckValid(validationPath) {\r\n    if (validationPath.byteLength_ > MAX_PATH_LENGTH_BYTES) {\r\n        throw new Error(validationPath.errorPrefix_ +\r\n            'has a key path longer than ' +\r\n            MAX_PATH_LENGTH_BYTES +\r\n            ' bytes (' +\r\n            validationPath.byteLength_ +\r\n            ').');\r\n    }\r\n    if (validationPath.parts_.length > MAX_PATH_DEPTH) {\r\n        throw new Error(validationPath.errorPrefix_ +\r\n            'path specified exceeds the maximum depth that can be written (' +\r\n            MAX_PATH_DEPTH +\r\n            ') or object contains a cycle ' +\r\n            validationPathToErrorString(validationPath));\r\n    }\r\n}\r\n/**\r\n * String for use in error messages - uses '.' notation for path.\r\n */\r\nfunction validationPathToErrorString(validationPath) {\r\n    if (validationPath.parts_.length === 0) {\r\n        return '';\r\n    }\r\n    return \"in property '\" + validationPath.parts_.join('.') + \"'\";\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass VisibilityMonitor extends EventEmitter {\r\n    constructor() {\r\n        super(['visible']);\r\n        let hidden;\r\n        let visibilityChange;\r\n        if (typeof document !== 'undefined' &&\r\n            typeof document.addEventListener !== 'undefined') {\r\n            if (typeof document['hidden'] !== 'undefined') {\r\n                // Opera 12.10 and Firefox 18 and later support\r\n                visibilityChange = 'visibilitychange';\r\n                hidden = 'hidden';\r\n            }\r\n            else if (typeof document['mozHidden'] !== 'undefined') {\r\n                visibilityChange = 'mozvisibilitychange';\r\n                hidden = 'mozHidden';\r\n            }\r\n            else if (typeof document['msHidden'] !== 'undefined') {\r\n                visibilityChange = 'msvisibilitychange';\r\n                hidden = 'msHidden';\r\n            }\r\n            else if (typeof document['webkitHidden'] !== 'undefined') {\r\n                visibilityChange = 'webkitvisibilitychange';\r\n                hidden = 'webkitHidden';\r\n            }\r\n        }\r\n        // Initially, we always assume we are visible. This ensures that in browsers\r\n        // without page visibility support or in cases where we are never visible\r\n        // (e.g. chrome extension), we act as if we are visible, i.e. don't delay\r\n        // reconnects\r\n        this.visible_ = true;\r\n        if (visibilityChange) {\r\n            document.addEventListener(visibilityChange, () => {\r\n                const visible = !document[hidden];\r\n                if (visible !== this.visible_) {\r\n                    this.visible_ = visible;\r\n                    this.trigger('visible', visible);\r\n                }\r\n            }, false);\r\n        }\r\n    }\r\n    static getInstance() {\r\n        return new VisibilityMonitor();\r\n    }\r\n    getInitialEvent(eventType) {\r\n        index_esm2017_assert(eventType === 'visible', 'Unknown event type: ' + eventType);\r\n        return [this.visible_];\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst RECONNECT_MIN_DELAY = 1000;\r\nconst RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1000; // 5 minutes in milliseconds (Case: 1858)\r\nconst RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1000; // 30 seconds for admin clients (likely to be a backend server)\r\nconst RECONNECT_DELAY_MULTIPLIER = 1.3;\r\nconst RECONNECT_DELAY_RESET_TIMEOUT = 30000; // Reset delay back to MIN_DELAY after being connected for 30sec.\r\nconst SERVER_KILL_INTERRUPT_REASON = 'server_kill';\r\n// If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.\r\nconst INVALID_TOKEN_THRESHOLD = 3;\r\n/**\r\n * Firebase connection.  Abstracts wire protocol and handles reconnecting.\r\n *\r\n * NOTE: All JSON objects sent to the realtime connection must have property names enclosed\r\n * in quotes to make sure the closure compiler does not minify them.\r\n */\r\nclass PersistentConnection extends ServerActions {\r\n    /**\r\n     * @param repoInfo_ - Data about the namespace we are connecting to\r\n     * @param applicationId_ - The Firebase App ID for this project\r\n     * @param onDataUpdate_ - A callback for new data from the server\r\n     */\r\n    constructor(repoInfo_, applicationId_, onDataUpdate_, onConnectStatus_, onServerInfoUpdate_, authTokenProvider_, appCheckTokenProvider_, authOverride_) {\r\n        super();\r\n        this.repoInfo_ = repoInfo_;\r\n        this.applicationId_ = applicationId_;\r\n        this.onDataUpdate_ = onDataUpdate_;\r\n        this.onConnectStatus_ = onConnectStatus_;\r\n        this.onServerInfoUpdate_ = onServerInfoUpdate_;\r\n        this.authTokenProvider_ = authTokenProvider_;\r\n        this.appCheckTokenProvider_ = appCheckTokenProvider_;\r\n        this.authOverride_ = authOverride_;\r\n        // Used for diagnostic logging.\r\n        this.id = PersistentConnection.nextPersistentConnectionId_++;\r\n        this.log_ = logWrapper('p:' + this.id + ':');\r\n        this.interruptReasons_ = {};\r\n        this.listens = new Map();\r\n        this.outstandingPuts_ = [];\r\n        this.outstandingGets_ = [];\r\n        this.outstandingPutCount_ = 0;\r\n        this.outstandingGetCount_ = 0;\r\n        this.onDisconnectRequestQueue_ = [];\r\n        this.connected_ = false;\r\n        this.reconnectDelay_ = RECONNECT_MIN_DELAY;\r\n        this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;\r\n        this.securityDebugCallback_ = null;\r\n        this.lastSessionId = null;\r\n        this.establishConnectionTimer_ = null;\r\n        this.visible_ = false;\r\n        // Before we get connected, we keep a queue of pending messages to send.\r\n        this.requestCBHash_ = {};\r\n        this.requestNumber_ = 0;\r\n        this.realtime_ = null;\r\n        this.authToken_ = null;\r\n        this.appCheckToken_ = null;\r\n        this.forceTokenRefresh_ = false;\r\n        this.invalidAuthTokenCount_ = 0;\r\n        this.invalidAppCheckTokenCount_ = 0;\r\n        this.firstConnection_ = true;\r\n        this.lastConnectionAttemptTime_ = null;\r\n        this.lastConnectionEstablishedTime_ = null;\r\n        if (authOverride_ && !isNodeSdk()) {\r\n            throw new Error('Auth override specified in options, but not supported on non Node.js platforms');\r\n        }\r\n        VisibilityMonitor.getInstance().on('visible', this.onVisible_, this);\r\n        if (repoInfo_.host.indexOf('fblocal') === -1) {\r\n            OnlineMonitor.getInstance().on('online', this.onOnline_, this);\r\n        }\r\n    }\r\n    sendRequest(action, body, onResponse) {\r\n        const curReqNum = ++this.requestNumber_;\r\n        const msg = { r: curReqNum, a: action, b: body };\r\n        this.log_(index_esm2017_stringify(msg));\r\n        index_esm2017_assert(this.connected_, \"sendRequest call when we're not connected not allowed.\");\r\n        this.realtime_.sendRequest(msg);\r\n        if (onResponse) {\r\n            this.requestCBHash_[curReqNum] = onResponse;\r\n        }\r\n    }\r\n    get(query) {\r\n        this.initConnection_();\r\n        const deferred = new index_esm2017_Deferred();\r\n        const request = {\r\n            p: query._path.toString(),\r\n            q: query._queryObject\r\n        };\r\n        const outstandingGet = {\r\n            action: 'g',\r\n            request,\r\n            onComplete: (message) => {\r\n                const payload = message['d'];\r\n                if (message['s'] === 'ok') {\r\n                    deferred.resolve(payload);\r\n                }\r\n                else {\r\n                    deferred.reject(payload);\r\n                }\r\n            }\r\n        };\r\n        this.outstandingGets_.push(outstandingGet);\r\n        this.outstandingGetCount_++;\r\n        const index = this.outstandingGets_.length - 1;\r\n        if (this.connected_) {\r\n            this.sendGet_(index);\r\n        }\r\n        return deferred.promise;\r\n    }\r\n    listen(query, currentHashFn, tag, onComplete) {\r\n        this.initConnection_();\r\n        const queryId = query._queryIdentifier;\r\n        const pathString = query._path.toString();\r\n        this.log_('Listen called for ' + pathString + ' ' + queryId);\r\n        if (!this.listens.has(pathString)) {\r\n            this.listens.set(pathString, new Map());\r\n        }\r\n        index_esm2017_assert(query._queryParams.isDefault() || !query._queryParams.loadsAllData(), 'listen() called for non-default but complete query');\r\n        index_esm2017_assert(!this.listens.get(pathString).has(queryId), `listen() called twice for same path/queryId.`);\r\n        const listenSpec = {\r\n            onComplete,\r\n            hashFn: currentHashFn,\r\n            query,\r\n            tag\r\n        };\r\n        this.listens.get(pathString).set(queryId, listenSpec);\r\n        if (this.connected_) {\r\n            this.sendListen_(listenSpec);\r\n        }\r\n    }\r\n    sendGet_(index) {\r\n        const get = this.outstandingGets_[index];\r\n        this.sendRequest('g', get.request, (message) => {\r\n            delete this.outstandingGets_[index];\r\n            this.outstandingGetCount_--;\r\n            if (this.outstandingGetCount_ === 0) {\r\n                this.outstandingGets_ = [];\r\n            }\r\n            if (get.onComplete) {\r\n                get.onComplete(message);\r\n            }\r\n        });\r\n    }\r\n    sendListen_(listenSpec) {\r\n        const query = listenSpec.query;\r\n        const pathString = query._path.toString();\r\n        const queryId = query._queryIdentifier;\r\n        this.log_('Listen on ' + pathString + ' for ' + queryId);\r\n        const req = { /*path*/ p: pathString };\r\n        const action = 'q';\r\n        // Only bother to send query if it's non-default.\r\n        if (listenSpec.tag) {\r\n            req['q'] = query._queryObject;\r\n            req['t'] = listenSpec.tag;\r\n        }\r\n        req[ /*hash*/'h'] = listenSpec.hashFn();\r\n        this.sendRequest(action, req, (message) => {\r\n            const payload = message[ /*data*/'d'];\r\n            const status = message[ /*status*/'s'];\r\n            // print warnings in any case...\r\n            PersistentConnection.warnOnListenWarnings_(payload, query);\r\n            const currentListenSpec = this.listens.get(pathString) &&\r\n                this.listens.get(pathString).get(queryId);\r\n            // only trigger actions if the listen hasn't been removed and readded\r\n            if (currentListenSpec === listenSpec) {\r\n                this.log_('listen response', message);\r\n                if (status !== 'ok') {\r\n                    this.removeListen_(pathString, queryId);\r\n                }\r\n                if (listenSpec.onComplete) {\r\n                    listenSpec.onComplete(status, payload);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    static warnOnListenWarnings_(payload, query) {\r\n        if (payload && typeof payload === 'object' && index_esm2017_contains(payload, 'w')) {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            const warnings = index_esm2017_safeGet(payload, 'w');\r\n            if (Array.isArray(warnings) && ~warnings.indexOf('no_index')) {\r\n                const indexSpec = '\".indexOn\": \"' + query._queryParams.getIndex().toString() + '\"';\r\n                const indexPath = query._path.toString();\r\n                warn(`Using an unspecified index. Your data will be downloaded and ` +\r\n                    `filtered on the client. Consider adding ${indexSpec} at ` +\r\n                    `${indexPath} to your security rules for better performance.`);\r\n            }\r\n        }\r\n    }\r\n    refreshAuthToken(token) {\r\n        this.authToken_ = token;\r\n        this.log_('Auth token refreshed');\r\n        if (this.authToken_) {\r\n            this.tryAuth();\r\n        }\r\n        else {\r\n            //If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete\r\n            //the credential so we dont become authenticated next time we connect.\r\n            if (this.connected_) {\r\n                this.sendRequest('unauth', {}, () => { });\r\n            }\r\n        }\r\n        this.reduceReconnectDelayIfAdminCredential_(token);\r\n    }\r\n    reduceReconnectDelayIfAdminCredential_(credential) {\r\n        // NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).\r\n        // Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.\r\n        const isFirebaseSecret = credential && credential.length === 40;\r\n        if (isFirebaseSecret || isAdmin(credential)) {\r\n            this.log_('Admin auth credential detected.  Reducing max reconnect time.');\r\n            this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\r\n        }\r\n    }\r\n    refreshAppCheckToken(token) {\r\n        this.appCheckToken_ = token;\r\n        this.log_('App check token refreshed');\r\n        if (this.appCheckToken_) {\r\n            this.tryAppCheck();\r\n        }\r\n        else {\r\n            //If we're connected we want to let the server know to unauthenticate us.\r\n            //If we're not connected, simply delete the credential so we dont become\r\n            // authenticated next time we connect.\r\n            if (this.connected_) {\r\n                this.sendRequest('unappeck', {}, () => { });\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like\r\n     * a auth revoked (the connection is closed).\r\n     */\r\n    tryAuth() {\r\n        if (this.connected_ && this.authToken_) {\r\n            const token = this.authToken_;\r\n            const authMethod = isValidFormat(token) ? 'auth' : 'gauth';\r\n            const requestData = { cred: token };\r\n            if (this.authOverride_ === null) {\r\n                requestData['noauth'] = true;\r\n            }\r\n            else if (typeof this.authOverride_ === 'object') {\r\n                requestData['authvar'] = this.authOverride_;\r\n            }\r\n            this.sendRequest(authMethod, requestData, (res) => {\r\n                const status = res[ /*status*/'s'];\r\n                const data = res[ /*data*/'d'] || 'error';\r\n                if (this.authToken_ === token) {\r\n                    if (status === 'ok') {\r\n                        this.invalidAuthTokenCount_ = 0;\r\n                    }\r\n                    else {\r\n                        // Triggers reconnect and force refresh for auth token\r\n                        this.onAuthRevoked_(status, data);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Attempts to authenticate with the given token. If the authentication\r\n     * attempt fails, it's triggered like the token was revoked (the connection is\r\n     * closed).\r\n     */\r\n    tryAppCheck() {\r\n        if (this.connected_ && this.appCheckToken_) {\r\n            this.sendRequest('appcheck', { 'token': this.appCheckToken_ }, (res) => {\r\n                const status = res[ /*status*/'s'];\r\n                const data = res[ /*data*/'d'] || 'error';\r\n                if (status === 'ok') {\r\n                    this.invalidAppCheckTokenCount_ = 0;\r\n                }\r\n                else {\r\n                    this.onAppCheckRevoked_(status, data);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * @inheritDoc\r\n     */\r\n    unlisten(query, tag) {\r\n        const pathString = query._path.toString();\r\n        const queryId = query._queryIdentifier;\r\n        this.log_('Unlisten called for ' + pathString + ' ' + queryId);\r\n        index_esm2017_assert(query._queryParams.isDefault() || !query._queryParams.loadsAllData(), 'unlisten() called for non-default but complete query');\r\n        const listen = this.removeListen_(pathString, queryId);\r\n        if (listen && this.connected_) {\r\n            this.sendUnlisten_(pathString, queryId, query._queryObject, tag);\r\n        }\r\n    }\r\n    sendUnlisten_(pathString, queryId, queryObj, tag) {\r\n        this.log_('Unlisten on ' + pathString + ' for ' + queryId);\r\n        const req = { /*path*/ p: pathString };\r\n        const action = 'n';\r\n        // Only bother sending queryId if it's non-default.\r\n        if (tag) {\r\n            req['q'] = queryObj;\r\n            req['t'] = tag;\r\n        }\r\n        this.sendRequest(action, req);\r\n    }\r\n    onDisconnectPut(pathString, data, onComplete) {\r\n        this.initConnection_();\r\n        if (this.connected_) {\r\n            this.sendOnDisconnect_('o', pathString, data, onComplete);\r\n        }\r\n        else {\r\n            this.onDisconnectRequestQueue_.push({\r\n                pathString,\r\n                action: 'o',\r\n                data,\r\n                onComplete\r\n            });\r\n        }\r\n    }\r\n    onDisconnectMerge(pathString, data, onComplete) {\r\n        this.initConnection_();\r\n        if (this.connected_) {\r\n            this.sendOnDisconnect_('om', pathString, data, onComplete);\r\n        }\r\n        else {\r\n            this.onDisconnectRequestQueue_.push({\r\n                pathString,\r\n                action: 'om',\r\n                data,\r\n                onComplete\r\n            });\r\n        }\r\n    }\r\n    onDisconnectCancel(pathString, onComplete) {\r\n        this.initConnection_();\r\n        if (this.connected_) {\r\n            this.sendOnDisconnect_('oc', pathString, null, onComplete);\r\n        }\r\n        else {\r\n            this.onDisconnectRequestQueue_.push({\r\n                pathString,\r\n                action: 'oc',\r\n                data: null,\r\n                onComplete\r\n            });\r\n        }\r\n    }\r\n    sendOnDisconnect_(action, pathString, data, onComplete) {\r\n        const request = { /*path*/ p: pathString, /*data*/ d: data };\r\n        this.log_('onDisconnect ' + action, request);\r\n        this.sendRequest(action, request, (response) => {\r\n            if (onComplete) {\r\n                setTimeout(() => {\r\n                    onComplete(response[ /*status*/'s'], response[ /* data */'d']);\r\n                }, Math.floor(0));\r\n            }\r\n        });\r\n    }\r\n    put(pathString, data, onComplete, hash) {\r\n        this.putInternal('p', pathString, data, onComplete, hash);\r\n    }\r\n    merge(pathString, data, onComplete, hash) {\r\n        this.putInternal('m', pathString, data, onComplete, hash);\r\n    }\r\n    putInternal(action, pathString, data, onComplete, hash) {\r\n        this.initConnection_();\r\n        const request = {\r\n            /*path*/ p: pathString,\r\n            /*data*/ d: data\r\n        };\r\n        if (hash !== undefined) {\r\n            request[ /*hash*/'h'] = hash;\r\n        }\r\n        // TODO: Only keep track of the most recent put for a given path?\r\n        this.outstandingPuts_.push({\r\n            action,\r\n            request,\r\n            onComplete\r\n        });\r\n        this.outstandingPutCount_++;\r\n        const index = this.outstandingPuts_.length - 1;\r\n        if (this.connected_) {\r\n            this.sendPut_(index);\r\n        }\r\n        else {\r\n            this.log_('Buffering put: ' + pathString);\r\n        }\r\n    }\r\n    sendPut_(index) {\r\n        const action = this.outstandingPuts_[index].action;\r\n        const request = this.outstandingPuts_[index].request;\r\n        const onComplete = this.outstandingPuts_[index].onComplete;\r\n        this.outstandingPuts_[index].queued = this.connected_;\r\n        this.sendRequest(action, request, (message) => {\r\n            this.log_(action + ' response', message);\r\n            delete this.outstandingPuts_[index];\r\n            this.outstandingPutCount_--;\r\n            // Clean up array occasionally.\r\n            if (this.outstandingPutCount_ === 0) {\r\n                this.outstandingPuts_ = [];\r\n            }\r\n            if (onComplete) {\r\n                onComplete(message[ /*status*/'s'], message[ /* data */'d']);\r\n            }\r\n        });\r\n    }\r\n    reportStats(stats) {\r\n        // If we're not connected, we just drop the stats.\r\n        if (this.connected_) {\r\n            const request = { /*counters*/ c: stats };\r\n            this.log_('reportStats', request);\r\n            this.sendRequest(/*stats*/ 's', request, result => {\r\n                const status = result[ /*status*/'s'];\r\n                if (status !== 'ok') {\r\n                    const errorReason = result[ /* data */'d'];\r\n                    this.log_('reportStats', 'Error sending stats: ' + errorReason);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    onDataMessage_(message) {\r\n        if ('r' in message) {\r\n            // this is a response\r\n            this.log_('from server: ' + index_esm2017_stringify(message));\r\n            const reqNum = message['r'];\r\n            const onResponse = this.requestCBHash_[reqNum];\r\n            if (onResponse) {\r\n                delete this.requestCBHash_[reqNum];\r\n                onResponse(message[ /*body*/'b']);\r\n            }\r\n        }\r\n        else if ('error' in message) {\r\n            throw 'A server-side error has occurred: ' + message['error'];\r\n        }\r\n        else if ('a' in message) {\r\n            // a and b are action and body, respectively\r\n            this.onDataPush_(message['a'], message['b']);\r\n        }\r\n    }\r\n    onDataPush_(action, body) {\r\n        this.log_('handleServerMessage', action, body);\r\n        if (action === 'd') {\r\n            this.onDataUpdate_(body[ /*path*/'p'], body[ /*data*/'d'], \r\n            /*isMerge*/ false, body['t']);\r\n        }\r\n        else if (action === 'm') {\r\n            this.onDataUpdate_(body[ /*path*/'p'], body[ /*data*/'d'], \r\n            /*isMerge=*/ true, body['t']);\r\n        }\r\n        else if (action === 'c') {\r\n            this.onListenRevoked_(body[ /*path*/'p'], body[ /*query*/'q']);\r\n        }\r\n        else if (action === 'ac') {\r\n            this.onAuthRevoked_(body[ /*status code*/'s'], body[ /* explanation */'d']);\r\n        }\r\n        else if (action === 'apc') {\r\n            this.onAppCheckRevoked_(body[ /*status code*/'s'], body[ /* explanation */'d']);\r\n        }\r\n        else if (action === 'sd') {\r\n            this.onSecurityDebugPacket_(body);\r\n        }\r\n        else {\r\n            error('Unrecognized action received from server: ' +\r\n                index_esm2017_stringify(action) +\r\n                '\\nAre you using the latest client?');\r\n        }\r\n    }\r\n    onReady_(timestamp, sessionId) {\r\n        this.log_('connection ready');\r\n        this.connected_ = true;\r\n        this.lastConnectionEstablishedTime_ = new Date().getTime();\r\n        this.handleTimestamp_(timestamp);\r\n        this.lastSessionId = sessionId;\r\n        if (this.firstConnection_) {\r\n            this.sendConnectStats_();\r\n        }\r\n        this.restoreState_();\r\n        this.firstConnection_ = false;\r\n        this.onConnectStatus_(true);\r\n    }\r\n    scheduleConnect_(timeout) {\r\n        index_esm2017_assert(!this.realtime_, \"Scheduling a connect when we're already connected/ing?\");\r\n        if (this.establishConnectionTimer_) {\r\n            clearTimeout(this.establishConnectionTimer_);\r\n        }\r\n        // NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating \"Security Error\" in\r\n        // Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).\r\n        this.establishConnectionTimer_ = setTimeout(() => {\r\n            this.establishConnectionTimer_ = null;\r\n            this.establishConnection_();\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        }, Math.floor(timeout));\r\n    }\r\n    initConnection_() {\r\n        if (!this.realtime_ && this.firstConnection_) {\r\n            this.scheduleConnect_(0);\r\n        }\r\n    }\r\n    onVisible_(visible) {\r\n        // NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.\r\n        if (visible &&\r\n            !this.visible_ &&\r\n            this.reconnectDelay_ === this.maxReconnectDelay_) {\r\n            this.log_('Window became visible.  Reducing delay.');\r\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\r\n            if (!this.realtime_) {\r\n                this.scheduleConnect_(0);\r\n            }\r\n        }\r\n        this.visible_ = visible;\r\n    }\r\n    onOnline_(online) {\r\n        if (online) {\r\n            this.log_('Browser went online.');\r\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\r\n            if (!this.realtime_) {\r\n                this.scheduleConnect_(0);\r\n            }\r\n        }\r\n        else {\r\n            this.log_('Browser went offline.  Killing connection.');\r\n            if (this.realtime_) {\r\n                this.realtime_.close();\r\n            }\r\n        }\r\n    }\r\n    onRealtimeDisconnect_() {\r\n        this.log_('data client disconnected');\r\n        this.connected_ = false;\r\n        this.realtime_ = null;\r\n        // Since we don't know if our sent transactions succeeded or not, we need to cancel them.\r\n        this.cancelSentTransactions_();\r\n        // Clear out the pending requests.\r\n        this.requestCBHash_ = {};\r\n        if (this.shouldReconnect_()) {\r\n            if (!this.visible_) {\r\n                this.log_(\"Window isn't visible.  Delaying reconnect.\");\r\n                this.reconnectDelay_ = this.maxReconnectDelay_;\r\n                this.lastConnectionAttemptTime_ = new Date().getTime();\r\n            }\r\n            else if (this.lastConnectionEstablishedTime_) {\r\n                // If we've been connected long enough, reset reconnect delay to minimum.\r\n                const timeSinceLastConnectSucceeded = new Date().getTime() - this.lastConnectionEstablishedTime_;\r\n                if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT) {\r\n                    this.reconnectDelay_ = RECONNECT_MIN_DELAY;\r\n                }\r\n                this.lastConnectionEstablishedTime_ = null;\r\n            }\r\n            const timeSinceLastConnectAttempt = new Date().getTime() - this.lastConnectionAttemptTime_;\r\n            let reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);\r\n            reconnectDelay = Math.random() * reconnectDelay;\r\n            this.log_('Trying to reconnect in ' + reconnectDelay + 'ms');\r\n            this.scheduleConnect_(reconnectDelay);\r\n            // Adjust reconnect delay for next time.\r\n            this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);\r\n        }\r\n        this.onConnectStatus_(false);\r\n    }\r\n    async establishConnection_() {\r\n        if (this.shouldReconnect_()) {\r\n            this.log_('Making a connection attempt');\r\n            this.lastConnectionAttemptTime_ = new Date().getTime();\r\n            this.lastConnectionEstablishedTime_ = null;\r\n            const onDataMessage = this.onDataMessage_.bind(this);\r\n            const onReady = this.onReady_.bind(this);\r\n            const onDisconnect = this.onRealtimeDisconnect_.bind(this);\r\n            const connId = this.id + ':' + PersistentConnection.nextConnectionId_++;\r\n            const lastSessionId = this.lastSessionId;\r\n            let canceled = false;\r\n            let connection = null;\r\n            const closeFn = function () {\r\n                if (connection) {\r\n                    connection.close();\r\n                }\r\n                else {\r\n                    canceled = true;\r\n                    onDisconnect();\r\n                }\r\n            };\r\n            const sendRequestFn = function (msg) {\r\n                index_esm2017_assert(connection, \"sendRequest call when we're not connected not allowed.\");\r\n                connection.sendRequest(msg);\r\n            };\r\n            this.realtime_ = {\r\n                close: closeFn,\r\n                sendRequest: sendRequestFn\r\n            };\r\n            const forceRefresh = this.forceTokenRefresh_;\r\n            this.forceTokenRefresh_ = false;\r\n            try {\r\n                // First fetch auth and app check token, and establish connection after\r\n                // fetching the token was successful\r\n                const [authToken, appCheckToken] = await Promise.all([\r\n                    this.authTokenProvider_.getToken(forceRefresh),\r\n                    this.appCheckTokenProvider_.getToken(forceRefresh)\r\n                ]);\r\n                if (!canceled) {\r\n                    log('getToken() completed. Creating connection.');\r\n                    this.authToken_ = authToken && authToken.accessToken;\r\n                    this.appCheckToken_ = appCheckToken && appCheckToken.token;\r\n                    connection = new Connection(connId, this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, onDataMessage, onReady, onDisconnect, \r\n                    /* onKill= */ reason => {\r\n                        warn(reason + ' (' + this.repoInfo_.toString() + ')');\r\n                        this.interrupt(SERVER_KILL_INTERRUPT_REASON);\r\n                    }, lastSessionId);\r\n                }\r\n                else {\r\n                    log('getToken() completed but was canceled');\r\n                }\r\n            }\r\n            catch (error) {\r\n                this.log_('Failed to get token: ' + error);\r\n                if (!canceled) {\r\n                    if (this.repoInfo_.nodeAdmin) {\r\n                        // This may be a critical error for the Admin Node.js SDK, so log a warning.\r\n                        // But getToken() may also just have temporarily failed, so we still want to\r\n                        // continue retrying.\r\n                        warn(error);\r\n                    }\r\n                    closeFn();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    interrupt(reason) {\r\n        log('Interrupting connection for reason: ' + reason);\r\n        this.interruptReasons_[reason] = true;\r\n        if (this.realtime_) {\r\n            this.realtime_.close();\r\n        }\r\n        else {\r\n            if (this.establishConnectionTimer_) {\r\n                clearTimeout(this.establishConnectionTimer_);\r\n                this.establishConnectionTimer_ = null;\r\n            }\r\n            if (this.connected_) {\r\n                this.onRealtimeDisconnect_();\r\n            }\r\n        }\r\n    }\r\n    resume(reason) {\r\n        log('Resuming connection for reason: ' + reason);\r\n        delete this.interruptReasons_[reason];\r\n        if (index_esm2017_isEmpty(this.interruptReasons_)) {\r\n            this.reconnectDelay_ = RECONNECT_MIN_DELAY;\r\n            if (!this.realtime_) {\r\n                this.scheduleConnect_(0);\r\n            }\r\n        }\r\n    }\r\n    handleTimestamp_(timestamp) {\r\n        const delta = timestamp - new Date().getTime();\r\n        this.onServerInfoUpdate_({ serverTimeOffset: delta });\r\n    }\r\n    cancelSentTransactions_() {\r\n        for (let i = 0; i < this.outstandingPuts_.length; i++) {\r\n            const put = this.outstandingPuts_[i];\r\n            if (put && /*hash*/ 'h' in put.request && put.queued) {\r\n                if (put.onComplete) {\r\n                    put.onComplete('disconnect');\r\n                }\r\n                delete this.outstandingPuts_[i];\r\n                this.outstandingPutCount_--;\r\n            }\r\n        }\r\n        // Clean up array occasionally.\r\n        if (this.outstandingPutCount_ === 0) {\r\n            this.outstandingPuts_ = [];\r\n        }\r\n    }\r\n    onListenRevoked_(pathString, query) {\r\n        // Remove the listen and manufacture a \"permission_denied\" error for the failed listen.\r\n        let queryId;\r\n        if (!query) {\r\n            queryId = 'default';\r\n        }\r\n        else {\r\n            queryId = query.map(q => ObjectToUniqueKey(q)).join('$');\r\n        }\r\n        const listen = this.removeListen_(pathString, queryId);\r\n        if (listen && listen.onComplete) {\r\n            listen.onComplete('permission_denied');\r\n        }\r\n    }\r\n    removeListen_(pathString, queryId) {\r\n        const normalizedPathString = new Path(pathString).toString(); // normalize path.\r\n        let listen;\r\n        if (this.listens.has(normalizedPathString)) {\r\n            const map = this.listens.get(normalizedPathString);\r\n            listen = map.get(queryId);\r\n            map.delete(queryId);\r\n            if (map.size === 0) {\r\n                this.listens.delete(normalizedPathString);\r\n            }\r\n        }\r\n        else {\r\n            // all listens for this path has already been removed\r\n            listen = undefined;\r\n        }\r\n        return listen;\r\n    }\r\n    onAuthRevoked_(statusCode, explanation) {\r\n        log('Auth token revoked: ' + statusCode + '/' + explanation);\r\n        this.authToken_ = null;\r\n        this.forceTokenRefresh_ = true;\r\n        this.realtime_.close();\r\n        if (statusCode === 'invalid_token' || statusCode === 'permission_denied') {\r\n            // We'll wait a couple times before logging the warning / increasing the\r\n            // retry period since oauth tokens will report as \"invalid\" if they're\r\n            // just expired. Plus there may be transient issues that resolve themselves.\r\n            this.invalidAuthTokenCount_++;\r\n            if (this.invalidAuthTokenCount_ >= INVALID_TOKEN_THRESHOLD) {\r\n                // Set a long reconnect delay because recovery is unlikely\r\n                this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;\r\n                // Notify the auth token provider that the token is invalid, which will log\r\n                // a warning\r\n                this.authTokenProvider_.notifyForInvalidToken();\r\n            }\r\n        }\r\n    }\r\n    onAppCheckRevoked_(statusCode, explanation) {\r\n        log('App check token revoked: ' + statusCode + '/' + explanation);\r\n        this.appCheckToken_ = null;\r\n        this.forceTokenRefresh_ = true;\r\n        // Note: We don't close the connection as the developer may not have\r\n        // enforcement enabled. The backend closes connections with enforcements.\r\n        if (statusCode === 'invalid_token' || statusCode === 'permission_denied') {\r\n            // We'll wait a couple times before logging the warning / increasing the\r\n            // retry period since oauth tokens will report as \"invalid\" if they're\r\n            // just expired. Plus there may be transient issues that resolve themselves.\r\n            this.invalidAppCheckTokenCount_++;\r\n            if (this.invalidAppCheckTokenCount_ >= INVALID_TOKEN_THRESHOLD) {\r\n                this.appCheckTokenProvider_.notifyForInvalidToken();\r\n            }\r\n        }\r\n    }\r\n    onSecurityDebugPacket_(body) {\r\n        if (this.securityDebugCallback_) {\r\n            this.securityDebugCallback_(body);\r\n        }\r\n        else {\r\n            if ('msg' in body) {\r\n                console.log('FIREBASE: ' + body['msg'].replace('\\n', '\\nFIREBASE: '));\r\n            }\r\n        }\r\n    }\r\n    restoreState_() {\r\n        //Re-authenticate ourselves if we have a credential stored.\r\n        this.tryAuth();\r\n        this.tryAppCheck();\r\n        // Puts depend on having received the corresponding data update from the server before they complete, so we must\r\n        // make sure to send listens before puts.\r\n        for (const queries of this.listens.values()) {\r\n            for (const listenSpec of queries.values()) {\r\n                this.sendListen_(listenSpec);\r\n            }\r\n        }\r\n        for (let i = 0; i < this.outstandingPuts_.length; i++) {\r\n            if (this.outstandingPuts_[i]) {\r\n                this.sendPut_(i);\r\n            }\r\n        }\r\n        while (this.onDisconnectRequestQueue_.length) {\r\n            const request = this.onDisconnectRequestQueue_.shift();\r\n            this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);\r\n        }\r\n        for (let i = 0; i < this.outstandingGets_.length; i++) {\r\n            if (this.outstandingGets_[i]) {\r\n                this.sendGet_(i);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Sends client stats for first connection\r\n     */\r\n    sendConnectStats_() {\r\n        const stats = {};\r\n        let clientName = 'js';\r\n        if (isNodeSdk()) {\r\n            if (this.repoInfo_.nodeAdmin) {\r\n                clientName = 'admin_node';\r\n            }\r\n            else {\r\n                clientName = 'node';\r\n            }\r\n        }\r\n        stats['sdk.' + clientName + '.' + index_esm2017_SDK_VERSION.replace(/\\./g, '-')] = 1;\r\n        if (isMobileCordova()) {\r\n            stats['framework.cordova'] = 1;\r\n        }\r\n        else if (isReactNative()) {\r\n            stats['framework.reactnative'] = 1;\r\n        }\r\n        this.reportStats(stats);\r\n    }\r\n    shouldReconnect_() {\r\n        const online = OnlineMonitor.getInstance().currentlyOnline();\r\n        return index_esm2017_isEmpty(this.interruptReasons_) && online;\r\n    }\r\n}\r\nPersistentConnection.nextPersistentConnectionId_ = 0;\r\n/**\r\n * Counter for number of connections created. Mainly used for tagging in the logs\r\n */\r\nPersistentConnection.nextConnectionId_ = 0;\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass NamedNode {\r\n    constructor(name, node) {\r\n        this.name = name;\r\n        this.node = node;\r\n    }\r\n    static Wrap(name, node) {\r\n        return new NamedNode(name, node);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass Index {\r\n    /**\r\n     * @returns A standalone comparison function for\r\n     * this index\r\n     */\r\n    getCompare() {\r\n        return this.compare.bind(this);\r\n    }\r\n    /**\r\n     * Given a before and after value for a node, determine if the indexed value has changed. Even if they are different,\r\n     * it's possible that the changes are isolated to parts of the snapshot that are not indexed.\r\n     *\r\n     *\r\n     * @returns True if the portion of the snapshot being indexed changed between oldNode and newNode\r\n     */\r\n    indexedValueChanged(oldNode, newNode) {\r\n        const oldWrapped = new NamedNode(MIN_NAME, oldNode);\r\n        const newWrapped = new NamedNode(MIN_NAME, newNode);\r\n        return this.compare(oldWrapped, newWrapped) !== 0;\r\n    }\r\n    /**\r\n     * @returns a node wrapper that will sort equal to or less than\r\n     * any other node wrapper, using this index\r\n     */\r\n    minPost() {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return NamedNode.MIN;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nlet __EMPTY_NODE;\r\nclass KeyIndex extends Index {\r\n    static get __EMPTY_NODE() {\r\n        return __EMPTY_NODE;\r\n    }\r\n    static set __EMPTY_NODE(val) {\r\n        __EMPTY_NODE = val;\r\n    }\r\n    compare(a, b) {\r\n        return nameCompare(a.name, b.name);\r\n    }\r\n    isDefinedOn(node) {\r\n        // We could probably return true here (since every node has a key), but it's never called\r\n        // so just leaving unimplemented for now.\r\n        throw assertionError('KeyIndex.isDefinedOn not expected to be called.');\r\n    }\r\n    indexedValueChanged(oldNode, newNode) {\r\n        return false; // The key for a node never changes.\r\n    }\r\n    minPost() {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return NamedNode.MIN;\r\n    }\r\n    maxPost() {\r\n        // TODO: This should really be created once and cached in a static property, but\r\n        // NamedNode isn't defined yet, so I can't use it in a static.  Bleh.\r\n        return new NamedNode(MAX_NAME, __EMPTY_NODE);\r\n    }\r\n    makePost(indexValue, name) {\r\n        index_esm2017_assert(typeof indexValue === 'string', 'KeyIndex indexValue must always be a string.');\r\n        // We just use empty node, but it'll never be compared, since our comparator only looks at name.\r\n        return new NamedNode(indexValue, __EMPTY_NODE);\r\n    }\r\n    /**\r\n     * @returns String representation for inclusion in a query spec\r\n     */\r\n    toString() {\r\n        return '.key';\r\n    }\r\n}\r\nconst KEY_INDEX = new KeyIndex();\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An iterator over an LLRBNode.\r\n */\r\nclass SortedMapIterator {\r\n    /**\r\n     * @param node - Node to iterate.\r\n     * @param isReverse_ - Whether or not to iterate in reverse\r\n     */\r\n    constructor(node, startKey, comparator, isReverse_, resultGenerator_ = null) {\r\n        this.isReverse_ = isReverse_;\r\n        this.resultGenerator_ = resultGenerator_;\r\n        this.nodeStack_ = [];\r\n        let cmp = 1;\r\n        while (!node.isEmpty()) {\r\n            node = node;\r\n            cmp = startKey ? comparator(node.key, startKey) : 1;\r\n            // flip the comparison if we're going in reverse\r\n            if (isReverse_) {\r\n                cmp *= -1;\r\n            }\r\n            if (cmp < 0) {\r\n                // This node is less than our start key. ignore it\r\n                if (this.isReverse_) {\r\n                    node = node.left;\r\n                }\r\n                else {\r\n                    node = node.right;\r\n                }\r\n            }\r\n            else if (cmp === 0) {\r\n                // This node is exactly equal to our start key. Push it on the stack, but stop iterating;\r\n                this.nodeStack_.push(node);\r\n                break;\r\n            }\r\n            else {\r\n                // This node is greater than our start key, add it to the stack and move to the next one\r\n                this.nodeStack_.push(node);\r\n                if (this.isReverse_) {\r\n                    node = node.right;\r\n                }\r\n                else {\r\n                    node = node.left;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    getNext() {\r\n        if (this.nodeStack_.length === 0) {\r\n            return null;\r\n        }\r\n        let node = this.nodeStack_.pop();\r\n        let result;\r\n        if (this.resultGenerator_) {\r\n            result = this.resultGenerator_(node.key, node.value);\r\n        }\r\n        else {\r\n            result = { key: node.key, value: node.value };\r\n        }\r\n        if (this.isReverse_) {\r\n            node = node.left;\r\n            while (!node.isEmpty()) {\r\n                this.nodeStack_.push(node);\r\n                node = node.right;\r\n            }\r\n        }\r\n        else {\r\n            node = node.right;\r\n            while (!node.isEmpty()) {\r\n                this.nodeStack_.push(node);\r\n                node = node.left;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    hasNext() {\r\n        return this.nodeStack_.length > 0;\r\n    }\r\n    peek() {\r\n        if (this.nodeStack_.length === 0) {\r\n            return null;\r\n        }\r\n        const node = this.nodeStack_[this.nodeStack_.length - 1];\r\n        if (this.resultGenerator_) {\r\n            return this.resultGenerator_(node.key, node.value);\r\n        }\r\n        else {\r\n            return { key: node.key, value: node.value };\r\n        }\r\n    }\r\n}\r\n/**\r\n * Represents a node in a Left-leaning Red-Black tree.\r\n */\r\nclass LLRBNode {\r\n    /**\r\n     * @param key - Key associated with this node.\r\n     * @param value - Value associated with this node.\r\n     * @param color - Whether this node is red.\r\n     * @param left - Left child.\r\n     * @param right - Right child.\r\n     */\r\n    constructor(key, value, color, left, right) {\r\n        this.key = key;\r\n        this.value = value;\r\n        this.color = color != null ? color : LLRBNode.RED;\r\n        this.left =\r\n            left != null ? left : SortedMap.EMPTY_NODE;\r\n        this.right =\r\n            right != null ? right : SortedMap.EMPTY_NODE;\r\n    }\r\n    /**\r\n     * Returns a copy of the current node, optionally replacing pieces of it.\r\n     *\r\n     * @param key - New key for the node, or null.\r\n     * @param value - New value for the node, or null.\r\n     * @param color - New color for the node, or null.\r\n     * @param left - New left child for the node, or null.\r\n     * @param right - New right child for the node, or null.\r\n     * @returns The node copy.\r\n     */\r\n    copy(key, value, color, left, right) {\r\n        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);\r\n    }\r\n    /**\r\n     * @returns The total number of nodes in the tree.\r\n     */\r\n    count() {\r\n        return this.left.count() + 1 + this.right.count();\r\n    }\r\n    /**\r\n     * @returns True if the tree is empty.\r\n     */\r\n    isEmpty() {\r\n        return false;\r\n    }\r\n    /**\r\n     * Traverses the tree in key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     *   node.  If it returns true, traversal is aborted.\r\n     * @returns The first truthy value returned by action, or the last falsey\r\n     *   value returned by action\r\n     */\r\n    inorderTraversal(action) {\r\n        return (this.left.inorderTraversal(action) ||\r\n            !!action(this.key, this.value) ||\r\n            this.right.inorderTraversal(action));\r\n    }\r\n    /**\r\n     * Traverses the tree in reverse key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     * node.  If it returns true, traversal is aborted.\r\n     * @returns True if traversal was aborted.\r\n     */\r\n    reverseTraversal(action) {\r\n        return (this.right.reverseTraversal(action) ||\r\n            action(this.key, this.value) ||\r\n            this.left.reverseTraversal(action));\r\n    }\r\n    /**\r\n     * @returns The minimum node in the tree.\r\n     */\r\n    min_() {\r\n        if (this.left.isEmpty()) {\r\n            return this;\r\n        }\r\n        else {\r\n            return this.left.min_();\r\n        }\r\n    }\r\n    /**\r\n     * @returns The maximum key in the tree.\r\n     */\r\n    minKey() {\r\n        return this.min_().key;\r\n    }\r\n    /**\r\n     * @returns The maximum key in the tree.\r\n     */\r\n    maxKey() {\r\n        if (this.right.isEmpty()) {\r\n            return this.key;\r\n        }\r\n        else {\r\n            return this.right.maxKey();\r\n        }\r\n    }\r\n    /**\r\n     * @param key - Key to insert.\r\n     * @param value - Value to insert.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with the key/value added.\r\n     */\r\n    insert(key, value, comparator) {\r\n        let n = this;\r\n        const cmp = comparator(key, n.key);\r\n        if (cmp < 0) {\r\n            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\r\n        }\r\n        else if (cmp === 0) {\r\n            n = n.copy(null, value, null, null, null);\r\n        }\r\n        else {\r\n            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));\r\n        }\r\n        return n.fixUp_();\r\n    }\r\n    /**\r\n     * @returns New tree, with the minimum key removed.\r\n     */\r\n    removeMin_() {\r\n        if (this.left.isEmpty()) {\r\n            return SortedMap.EMPTY_NODE;\r\n        }\r\n        let n = this;\r\n        if (!n.left.isRed_() && !n.left.left.isRed_()) {\r\n            n = n.moveRedLeft_();\r\n        }\r\n        n = n.copy(null, null, null, n.left.removeMin_(), null);\r\n        return n.fixUp_();\r\n    }\r\n    /**\r\n     * @param key - The key of the item to remove.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with the specified item removed.\r\n     */\r\n    remove(key, comparator) {\r\n        let n, smallest;\r\n        n = this;\r\n        if (comparator(key, n.key) < 0) {\r\n            if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) {\r\n                n = n.moveRedLeft_();\r\n            }\r\n            n = n.copy(null, null, null, n.left.remove(key, comparator), null);\r\n        }\r\n        else {\r\n            if (n.left.isRed_()) {\r\n                n = n.rotateRight_();\r\n            }\r\n            if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) {\r\n                n = n.moveRedRight_();\r\n            }\r\n            if (comparator(key, n.key) === 0) {\r\n                if (n.right.isEmpty()) {\r\n                    return SortedMap.EMPTY_NODE;\r\n                }\r\n                else {\r\n                    smallest = n.right.min_();\r\n                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin_());\r\n                }\r\n            }\r\n            n = n.copy(null, null, null, null, n.right.remove(key, comparator));\r\n        }\r\n        return n.fixUp_();\r\n    }\r\n    /**\r\n     * @returns Whether this is a RED node.\r\n     */\r\n    isRed_() {\r\n        return this.color;\r\n    }\r\n    /**\r\n     * @returns New tree after performing any needed rotations.\r\n     */\r\n    fixUp_() {\r\n        let n = this;\r\n        if (n.right.isRed_() && !n.left.isRed_()) {\r\n            n = n.rotateLeft_();\r\n        }\r\n        if (n.left.isRed_() && n.left.left.isRed_()) {\r\n            n = n.rotateRight_();\r\n        }\r\n        if (n.left.isRed_() && n.right.isRed_()) {\r\n            n = n.colorFlip_();\r\n        }\r\n        return n;\r\n    }\r\n    /**\r\n     * @returns New tree, after moveRedLeft.\r\n     */\r\n    moveRedLeft_() {\r\n        let n = this.colorFlip_();\r\n        if (n.right.left.isRed_()) {\r\n            n = n.copy(null, null, null, null, n.right.rotateRight_());\r\n            n = n.rotateLeft_();\r\n            n = n.colorFlip_();\r\n        }\r\n        return n;\r\n    }\r\n    /**\r\n     * @returns New tree, after moveRedRight.\r\n     */\r\n    moveRedRight_() {\r\n        let n = this.colorFlip_();\r\n        if (n.left.left.isRed_()) {\r\n            n = n.rotateRight_();\r\n            n = n.colorFlip_();\r\n        }\r\n        return n;\r\n    }\r\n    /**\r\n     * @returns New tree, after rotateLeft.\r\n     */\r\n    rotateLeft_() {\r\n        const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\r\n        return this.right.copy(null, null, this.color, nl, null);\r\n    }\r\n    /**\r\n     * @returns New tree, after rotateRight.\r\n     */\r\n    rotateRight_() {\r\n        const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\r\n        return this.left.copy(null, null, this.color, null, nr);\r\n    }\r\n    /**\r\n     * @returns Newt ree, after colorFlip.\r\n     */\r\n    colorFlip_() {\r\n        const left = this.left.copy(null, null, !this.left.color, null, null);\r\n        const right = this.right.copy(null, null, !this.right.color, null, null);\r\n        return this.copy(null, null, !this.color, left, right);\r\n    }\r\n    /**\r\n     * For testing.\r\n     *\r\n     * @returns True if all is well.\r\n     */\r\n    checkMaxDepth_() {\r\n        const blackDepth = this.check_();\r\n        return Math.pow(2.0, blackDepth) <= this.count() + 1;\r\n    }\r\n    check_() {\r\n        if (this.isRed_() && this.left.isRed_()) {\r\n            throw new Error('Red node has red child(' + this.key + ',' + this.value + ')');\r\n        }\r\n        if (this.right.isRed_()) {\r\n            throw new Error('Right child of (' + this.key + ',' + this.value + ') is red');\r\n        }\r\n        const blackDepth = this.left.check_();\r\n        if (blackDepth !== this.right.check_()) {\r\n            throw new Error('Black depths differ');\r\n        }\r\n        else {\r\n            return blackDepth + (this.isRed_() ? 0 : 1);\r\n        }\r\n    }\r\n}\r\nLLRBNode.RED = true;\r\nLLRBNode.BLACK = false;\r\n/**\r\n * Represents an empty node (a leaf node in the Red-Black Tree).\r\n */\r\nclass LLRBEmptyNode {\r\n    /**\r\n     * Returns a copy of the current node.\r\n     *\r\n     * @returns The node copy.\r\n     */\r\n    copy(key, value, color, left, right) {\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns a copy of the tree, with the specified key/value added.\r\n     *\r\n     * @param key - Key to be added.\r\n     * @param value - Value to be added.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with item added.\r\n     */\r\n    insert(key, value, comparator) {\r\n        return new LLRBNode(key, value, null);\r\n    }\r\n    /**\r\n     * Returns a copy of the tree, with the specified key removed.\r\n     *\r\n     * @param key - The key to remove.\r\n     * @param comparator - Comparator.\r\n     * @returns New tree, with item removed.\r\n     */\r\n    remove(key, comparator) {\r\n        return this;\r\n    }\r\n    /**\r\n     * @returns The total number of nodes in the tree.\r\n     */\r\n    count() {\r\n        return 0;\r\n    }\r\n    /**\r\n     * @returns True if the tree is empty.\r\n     */\r\n    isEmpty() {\r\n        return true;\r\n    }\r\n    /**\r\n     * Traverses the tree in key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     * node.  If it returns true, traversal is aborted.\r\n     * @returns True if traversal was aborted.\r\n     */\r\n    inorderTraversal(action) {\r\n        return false;\r\n    }\r\n    /**\r\n     * Traverses the tree in reverse key order and calls the specified action function\r\n     * for each node.\r\n     *\r\n     * @param action - Callback function to be called for each\r\n     * node.  If it returns true, traversal is aborted.\r\n     * @returns True if traversal was aborted.\r\n     */\r\n    reverseTraversal(action) {\r\n        return false;\r\n    }\r\n    minKey() {\r\n        return null;\r\n    }\r\n    maxKey() {\r\n        return null;\r\n    }\r\n    check_() {\r\n        return 0;\r\n    }\r\n    /**\r\n     * @returns Whether this node is red.\r\n     */\r\n    isRed_() {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * An immutable sorted map implementation, based on a Left-leaning Red-Black\r\n * tree.\r\n */\r\nclass SortedMap {\r\n    /**\r\n     * @param comparator_ - Key comparator.\r\n     * @param root_ - Optional root node for the map.\r\n     */\r\n    constructor(comparator_, root_ = SortedMap.EMPTY_NODE) {\r\n        this.comparator_ = comparator_;\r\n        this.root_ = root_;\r\n    }\r\n    /**\r\n     * Returns a copy of the map, with the specified key/value added or replaced.\r\n     * (TODO: We should perhaps rename this method to 'put')\r\n     *\r\n     * @param key - Key to be added.\r\n     * @param value - Value to be added.\r\n     * @returns New map, with item added.\r\n     */\r\n    insert(key, value) {\r\n        return new SortedMap(this.comparator_, this.root_\r\n            .insert(key, value, this.comparator_)\r\n            .copy(null, null, LLRBNode.BLACK, null, null));\r\n    }\r\n    /**\r\n     * Returns a copy of the map, with the specified key removed.\r\n     *\r\n     * @param key - The key to remove.\r\n     * @returns New map, with item removed.\r\n     */\r\n    remove(key) {\r\n        return new SortedMap(this.comparator_, this.root_\r\n            .remove(key, this.comparator_)\r\n            .copy(null, null, LLRBNode.BLACK, null, null));\r\n    }\r\n    /**\r\n     * Returns the value of the node with the given key, or null.\r\n     *\r\n     * @param key - The key to look up.\r\n     * @returns The value of the node with the given key, or null if the\r\n     * key doesn't exist.\r\n     */\r\n    get(key) {\r\n        let cmp;\r\n        let node = this.root_;\r\n        while (!node.isEmpty()) {\r\n            cmp = this.comparator_(key, node.key);\r\n            if (cmp === 0) {\r\n                return node.value;\r\n            }\r\n            else if (cmp < 0) {\r\n                node = node.left;\r\n            }\r\n            else if (cmp > 0) {\r\n                node = node.right;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Returns the key of the item *before* the specified key, or null if key is the first item.\r\n     * @param key - The key to find the predecessor of\r\n     * @returns The predecessor key.\r\n     */\r\n    getPredecessorKey(key) {\r\n        let cmp, node = this.root_, rightParent = null;\r\n        while (!node.isEmpty()) {\r\n            cmp = this.comparator_(key, node.key);\r\n            if (cmp === 0) {\r\n                if (!node.left.isEmpty()) {\r\n                    node = node.left;\r\n                    while (!node.right.isEmpty()) {\r\n                        node = node.right;\r\n                    }\r\n                    return node.key;\r\n                }\r\n                else if (rightParent) {\r\n                    return rightParent.key;\r\n                }\r\n                else {\r\n                    return null; // first item.\r\n                }\r\n            }\r\n            else if (cmp < 0) {\r\n                node = node.left;\r\n            }\r\n            else if (cmp > 0) {\r\n                rightParent = node;\r\n                node = node.right;\r\n            }\r\n        }\r\n        throw new Error('Attempted to find predecessor key for a nonexistent key.  What gives?');\r\n    }\r\n    /**\r\n     * @returns True if the map is empty.\r\n     */\r\n    isEmpty() {\r\n        return this.root_.isEmpty();\r\n    }\r\n    /**\r\n     * @returns The total number of nodes in the map.\r\n     */\r\n    count() {\r\n        return this.root_.count();\r\n    }\r\n    /**\r\n     * @returns The minimum key in the map.\r\n     */\r\n    minKey() {\r\n        return this.root_.minKey();\r\n    }\r\n    /**\r\n     * @returns The maximum key in the map.\r\n     */\r\n    maxKey() {\r\n        return this.root_.maxKey();\r\n    }\r\n    /**\r\n     * Traverses the map in key order and calls the specified action function\r\n     * for each key/value pair.\r\n     *\r\n     * @param action - Callback function to be called\r\n     * for each key/value pair.  If action returns true, traversal is aborted.\r\n     * @returns The first truthy value returned by action, or the last falsey\r\n     *   value returned by action\r\n     */\r\n    inorderTraversal(action) {\r\n        return this.root_.inorderTraversal(action);\r\n    }\r\n    /**\r\n     * Traverses the map in reverse key order and calls the specified action function\r\n     * for each key/value pair.\r\n     *\r\n     * @param action - Callback function to be called\r\n     * for each key/value pair.  If action returns true, traversal is aborted.\r\n     * @returns True if the traversal was aborted.\r\n     */\r\n    reverseTraversal(action) {\r\n        return this.root_.reverseTraversal(action);\r\n    }\r\n    /**\r\n     * Returns an iterator over the SortedMap.\r\n     * @returns The iterator.\r\n     */\r\n    getIterator(resultGenerator) {\r\n        return new SortedMapIterator(this.root_, null, this.comparator_, false, resultGenerator);\r\n    }\r\n    getIteratorFrom(key, resultGenerator) {\r\n        return new SortedMapIterator(this.root_, key, this.comparator_, false, resultGenerator);\r\n    }\r\n    getReverseIteratorFrom(key, resultGenerator) {\r\n        return new SortedMapIterator(this.root_, key, this.comparator_, true, resultGenerator);\r\n    }\r\n    getReverseIterator(resultGenerator) {\r\n        return new SortedMapIterator(this.root_, null, this.comparator_, true, resultGenerator);\r\n    }\r\n}\r\n/**\r\n * Always use the same empty node, to reduce memory.\r\n */\r\nSortedMap.EMPTY_NODE = new LLRBEmptyNode();\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction NAME_ONLY_COMPARATOR(left, right) {\r\n    return nameCompare(left.name, right.name);\r\n}\r\nfunction NAME_COMPARATOR(left, right) {\r\n    return nameCompare(left, right);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nlet MAX_NODE$2;\r\nfunction setMaxNode$1(val) {\r\n    MAX_NODE$2 = val;\r\n}\r\nconst priorityHashText = function (priority) {\r\n    if (typeof priority === 'number') {\r\n        return 'number:' + doubleToIEEE754String(priority);\r\n    }\r\n    else {\r\n        return 'string:' + priority;\r\n    }\r\n};\r\n/**\r\n * Validates that a priority snapshot Node is valid.\r\n */\r\nconst validatePriorityNode = function (priorityNode) {\r\n    if (priorityNode.isLeafNode()) {\r\n        const val = priorityNode.val();\r\n        index_esm2017_assert(typeof val === 'string' ||\r\n            typeof val === 'number' ||\r\n            (typeof val === 'object' && index_esm2017_contains(val, '.sv')), 'Priority must be a string or number.');\r\n    }\r\n    else {\r\n        index_esm2017_assert(priorityNode === MAX_NODE$2 || priorityNode.isEmpty(), 'priority of unexpected type.');\r\n    }\r\n    // Don't call getPriority() on MAX_NODE to avoid hitting assertion.\r\n    index_esm2017_assert(priorityNode === MAX_NODE$2 || priorityNode.getPriority().isEmpty(), \"Priority nodes can't have a priority of their own.\");\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nlet __childrenNodeConstructor;\r\n/**\r\n * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It\r\n * implements Node and stores the value of the node (a string,\r\n * number, or boolean) accessible via getValue().\r\n */\r\nclass LeafNode {\r\n    /**\r\n     * @param value_ - The value to store in this leaf node. The object type is\r\n     * possible in the event of a deferred value\r\n     * @param priorityNode_ - The priority of this node.\r\n     */\r\n    constructor(value_, priorityNode_ = LeafNode.__childrenNodeConstructor.EMPTY_NODE) {\r\n        this.value_ = value_;\r\n        this.priorityNode_ = priorityNode_;\r\n        this.lazyHash_ = null;\r\n        index_esm2017_assert(this.value_ !== undefined && this.value_ !== null, \"LeafNode shouldn't be created with null/undefined value.\");\r\n        validatePriorityNode(this.priorityNode_);\r\n    }\r\n    static set __childrenNodeConstructor(val) {\r\n        __childrenNodeConstructor = val;\r\n    }\r\n    static get __childrenNodeConstructor() {\r\n        return __childrenNodeConstructor;\r\n    }\r\n    /** @inheritDoc */\r\n    isLeafNode() {\r\n        return true;\r\n    }\r\n    /** @inheritDoc */\r\n    getPriority() {\r\n        return this.priorityNode_;\r\n    }\r\n    /** @inheritDoc */\r\n    updatePriority(newPriorityNode) {\r\n        return new LeafNode(this.value_, newPriorityNode);\r\n    }\r\n    /** @inheritDoc */\r\n    getImmediateChild(childName) {\r\n        // Hack to treat priority as a regular child\r\n        if (childName === '.priority') {\r\n            return this.priorityNode_;\r\n        }\r\n        else {\r\n            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    getChild(path) {\r\n        if (pathIsEmpty(path)) {\r\n            return this;\r\n        }\r\n        else if (pathGetFront(path) === '.priority') {\r\n            return this.priorityNode_;\r\n        }\r\n        else {\r\n            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;\r\n        }\r\n    }\r\n    hasChild() {\r\n        return false;\r\n    }\r\n    /** @inheritDoc */\r\n    getPredecessorChildName(childName, childNode) {\r\n        return null;\r\n    }\r\n    /** @inheritDoc */\r\n    updateImmediateChild(childName, newChildNode) {\r\n        if (childName === '.priority') {\r\n            return this.updatePriority(newChildNode);\r\n        }\r\n        else if (newChildNode.isEmpty() && childName !== '.priority') {\r\n            return this;\r\n        }\r\n        else {\r\n            return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName, newChildNode).updatePriority(this.priorityNode_);\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    updateChild(path, newChildNode) {\r\n        const front = pathGetFront(path);\r\n        if (front === null) {\r\n            return newChildNode;\r\n        }\r\n        else if (newChildNode.isEmpty() && front !== '.priority') {\r\n            return this;\r\n        }\r\n        else {\r\n            index_esm2017_assert(front !== '.priority' || pathGetLength(path) === 1, '.priority must be the last token in a path');\r\n            return this.updateImmediateChild(front, LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(pathPopFront(path), newChildNode));\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    isEmpty() {\r\n        return false;\r\n    }\r\n    /** @inheritDoc */\r\n    numChildren() {\r\n        return 0;\r\n    }\r\n    /** @inheritDoc */\r\n    forEachChild(index, action) {\r\n        return false;\r\n    }\r\n    val(exportFormat) {\r\n        if (exportFormat && !this.getPriority().isEmpty()) {\r\n            return {\r\n                '.value': this.getValue(),\r\n                '.priority': this.getPriority().val()\r\n            };\r\n        }\r\n        else {\r\n            return this.getValue();\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    hash() {\r\n        if (this.lazyHash_ === null) {\r\n            let toHash = '';\r\n            if (!this.priorityNode_.isEmpty()) {\r\n                toHash +=\r\n                    'priority:' +\r\n                        priorityHashText(this.priorityNode_.val()) +\r\n                        ':';\r\n            }\r\n            const type = typeof this.value_;\r\n            toHash += type + ':';\r\n            if (type === 'number') {\r\n                toHash += doubleToIEEE754String(this.value_);\r\n            }\r\n            else {\r\n                toHash += this.value_;\r\n            }\r\n            this.lazyHash_ = sha1(toHash);\r\n        }\r\n        return this.lazyHash_;\r\n    }\r\n    /**\r\n     * Returns the value of the leaf node.\r\n     * @returns The value of the node.\r\n     */\r\n    getValue() {\r\n        return this.value_;\r\n    }\r\n    compareTo(other) {\r\n        if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) {\r\n            return 1;\r\n        }\r\n        else if (other instanceof LeafNode.__childrenNodeConstructor) {\r\n            return -1;\r\n        }\r\n        else {\r\n            index_esm2017_assert(other.isLeafNode(), 'Unknown node type');\r\n            return this.compareToLeafNode_(other);\r\n        }\r\n    }\r\n    /**\r\n     * Comparison specifically for two leaf nodes\r\n     */\r\n    compareToLeafNode_(otherLeaf) {\r\n        const otherLeafType = typeof otherLeaf.value_;\r\n        const thisLeafType = typeof this.value_;\r\n        const otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);\r\n        const thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);\r\n        index_esm2017_assert(otherIndex >= 0, 'Unknown leaf type: ' + otherLeafType);\r\n        index_esm2017_assert(thisIndex >= 0, 'Unknown leaf type: ' + thisLeafType);\r\n        if (otherIndex === thisIndex) {\r\n            // Same type, compare values\r\n            if (thisLeafType === 'object') {\r\n                // Deferred value nodes are all equal, but we should also never get to this point...\r\n                return 0;\r\n            }\r\n            else {\r\n                // Note that this works because true > false, all others are number or string comparisons\r\n                if (this.value_ < otherLeaf.value_) {\r\n                    return -1;\r\n                }\r\n                else if (this.value_ === otherLeaf.value_) {\r\n                    return 0;\r\n                }\r\n                else {\r\n                    return 1;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return thisIndex - otherIndex;\r\n        }\r\n    }\r\n    withIndex() {\r\n        return this;\r\n    }\r\n    isIndexed() {\r\n        return true;\r\n    }\r\n    equals(other) {\r\n        if (other === this) {\r\n            return true;\r\n        }\r\n        else if (other.isLeafNode()) {\r\n            const otherLeaf = other;\r\n            return (this.value_ === otherLeaf.value_ &&\r\n                this.priorityNode_.equals(otherLeaf.priorityNode_));\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n/**\r\n * The sort order for comparing leaf nodes of different types. If two leaf nodes have\r\n * the same type, the comparison falls back to their value\r\n */\r\nLeafNode.VALUE_TYPE_ORDER = ['object', 'boolean', 'number', 'string'];\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nlet nodeFromJSON$1;\r\nlet MAX_NODE$1;\r\nfunction setNodeFromJSON(val) {\r\n    nodeFromJSON$1 = val;\r\n}\r\nfunction setMaxNode(val) {\r\n    MAX_NODE$1 = val;\r\n}\r\nclass PriorityIndex extends Index {\r\n    compare(a, b) {\r\n        const aPriority = a.node.getPriority();\r\n        const bPriority = b.node.getPriority();\r\n        const indexCmp = aPriority.compareTo(bPriority);\r\n        if (indexCmp === 0) {\r\n            return nameCompare(a.name, b.name);\r\n        }\r\n        else {\r\n            return indexCmp;\r\n        }\r\n    }\r\n    isDefinedOn(node) {\r\n        return !node.getPriority().isEmpty();\r\n    }\r\n    indexedValueChanged(oldNode, newNode) {\r\n        return !oldNode.getPriority().equals(newNode.getPriority());\r\n    }\r\n    minPost() {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return NamedNode.MIN;\r\n    }\r\n    maxPost() {\r\n        return new NamedNode(MAX_NAME, new LeafNode('[PRIORITY-POST]', MAX_NODE$1));\r\n    }\r\n    makePost(indexValue, name) {\r\n        const priorityNode = nodeFromJSON$1(indexValue);\r\n        return new NamedNode(name, new LeafNode('[PRIORITY-POST]', priorityNode));\r\n    }\r\n    /**\r\n     * @returns String representation for inclusion in a query spec\r\n     */\r\n    toString() {\r\n        return '.priority';\r\n    }\r\n}\r\nconst PRIORITY_INDEX = new PriorityIndex();\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst LOG_2 = Math.log(2);\r\nclass Base12Num {\r\n    constructor(length) {\r\n        const logBase2 = (num) => \r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        parseInt((Math.log(num) / LOG_2), 10);\r\n        const bitMask = (bits) => parseInt(Array(bits + 1).join('1'), 2);\r\n        this.count = logBase2(length + 1);\r\n        this.current_ = this.count - 1;\r\n        const mask = bitMask(this.count);\r\n        this.bits_ = (length + 1) & mask;\r\n    }\r\n    nextBitIsOne() {\r\n        //noinspection JSBitwiseOperatorUsage\r\n        const result = !(this.bits_ & (0x1 << this.current_));\r\n        this.current_--;\r\n        return result;\r\n    }\r\n}\r\n/**\r\n * Takes a list of child nodes and constructs a SortedSet using the given comparison\r\n * function\r\n *\r\n * Uses the algorithm described in the paper linked here:\r\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458\r\n *\r\n * @param childList - Unsorted list of children\r\n * @param cmp - The comparison method to be used\r\n * @param keyFn - An optional function to extract K from a node wrapper, if K's\r\n * type is not NamedNode\r\n * @param mapSortFn - An optional override for comparator used by the generated sorted map\r\n */\r\nconst buildChildSet = function (childList, cmp, keyFn, mapSortFn) {\r\n    childList.sort(cmp);\r\n    const buildBalancedTree = function (low, high) {\r\n        const length = high - low;\r\n        let namedNode;\r\n        let key;\r\n        if (length === 0) {\r\n            return null;\r\n        }\r\n        else if (length === 1) {\r\n            namedNode = childList[low];\r\n            key = keyFn ? keyFn(namedNode) : namedNode;\r\n            return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, null, null);\r\n        }\r\n        else {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            const middle = parseInt((length / 2), 10) + low;\r\n            const left = buildBalancedTree(low, middle);\r\n            const right = buildBalancedTree(middle + 1, high);\r\n            namedNode = childList[middle];\r\n            key = keyFn ? keyFn(namedNode) : namedNode;\r\n            return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, left, right);\r\n        }\r\n    };\r\n    const buildFrom12Array = function (base12) {\r\n        let node = null;\r\n        let root = null;\r\n        let index = childList.length;\r\n        const buildPennant = function (chunkSize, color) {\r\n            const low = index - chunkSize;\r\n            const high = index;\r\n            index -= chunkSize;\r\n            const childTree = buildBalancedTree(low + 1, high);\r\n            const namedNode = childList[low];\r\n            const key = keyFn ? keyFn(namedNode) : namedNode;\r\n            attachPennant(new LLRBNode(key, namedNode.node, color, null, childTree));\r\n        };\r\n        const attachPennant = function (pennant) {\r\n            if (node) {\r\n                node.left = pennant;\r\n                node = pennant;\r\n            }\r\n            else {\r\n                root = pennant;\r\n                node = pennant;\r\n            }\r\n        };\r\n        for (let i = 0; i < base12.count; ++i) {\r\n            const isOne = base12.nextBitIsOne();\r\n            // The number of nodes taken in each slice is 2^(arr.length - (i + 1))\r\n            const chunkSize = Math.pow(2, base12.count - (i + 1));\r\n            if (isOne) {\r\n                buildPennant(chunkSize, LLRBNode.BLACK);\r\n            }\r\n            else {\r\n                // current == 2\r\n                buildPennant(chunkSize, LLRBNode.BLACK);\r\n                buildPennant(chunkSize, LLRBNode.RED);\r\n            }\r\n        }\r\n        return root;\r\n    };\r\n    const base12 = new Base12Num(childList.length);\r\n    const root = buildFrom12Array(base12);\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    return new SortedMap(mapSortFn || cmp, root);\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nlet _defaultIndexMap;\r\nconst fallbackObject = {};\r\nclass IndexMap {\r\n    constructor(indexes_, indexSet_) {\r\n        this.indexes_ = indexes_;\r\n        this.indexSet_ = indexSet_;\r\n    }\r\n    /**\r\n     * The default IndexMap for nodes without a priority\r\n     */\r\n    static get Default() {\r\n        index_esm2017_assert(fallbackObject && PRIORITY_INDEX, 'ChildrenNode.ts has not been loaded');\r\n        _defaultIndexMap =\r\n            _defaultIndexMap ||\r\n                new IndexMap({ '.priority': fallbackObject }, { '.priority': PRIORITY_INDEX });\r\n        return _defaultIndexMap;\r\n    }\r\n    get(indexKey) {\r\n        const sortedMap = index_esm2017_safeGet(this.indexes_, indexKey);\r\n        if (!sortedMap) {\r\n            throw new Error('No index defined for ' + indexKey);\r\n        }\r\n        if (sortedMap instanceof SortedMap) {\r\n            return sortedMap;\r\n        }\r\n        else {\r\n            // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the\r\n            // regular child map\r\n            return null;\r\n        }\r\n    }\r\n    hasIndex(indexDefinition) {\r\n        return index_esm2017_contains(this.indexSet_, indexDefinition.toString());\r\n    }\r\n    addIndex(indexDefinition, existingChildren) {\r\n        index_esm2017_assert(indexDefinition !== KEY_INDEX, \"KeyIndex always exists and isn't meant to be added to the IndexMap.\");\r\n        const childList = [];\r\n        let sawIndexedValue = false;\r\n        const iter = existingChildren.getIterator(NamedNode.Wrap);\r\n        let next = iter.getNext();\r\n        while (next) {\r\n            sawIndexedValue =\r\n                sawIndexedValue || indexDefinition.isDefinedOn(next.node);\r\n            childList.push(next);\r\n            next = iter.getNext();\r\n        }\r\n        let newIndex;\r\n        if (sawIndexedValue) {\r\n            newIndex = buildChildSet(childList, indexDefinition.getCompare());\r\n        }\r\n        else {\r\n            newIndex = fallbackObject;\r\n        }\r\n        const indexName = indexDefinition.toString();\r\n        const newIndexSet = Object.assign({}, this.indexSet_);\r\n        newIndexSet[indexName] = indexDefinition;\r\n        const newIndexes = Object.assign({}, this.indexes_);\r\n        newIndexes[indexName] = newIndex;\r\n        return new IndexMap(newIndexes, newIndexSet);\r\n    }\r\n    /**\r\n     * Ensure that this node is properly tracked in any indexes that we're maintaining\r\n     */\r\n    addToIndexes(namedNode, existingChildren) {\r\n        const newIndexes = map(this.indexes_, (indexedChildren, indexName) => {\r\n            const index = index_esm2017_safeGet(this.indexSet_, indexName);\r\n            index_esm2017_assert(index, 'Missing index implementation for ' + indexName);\r\n            if (indexedChildren === fallbackObject) {\r\n                // Check to see if we need to index everything\r\n                if (index.isDefinedOn(namedNode.node)) {\r\n                    // We need to build this index\r\n                    const childList = [];\r\n                    const iter = existingChildren.getIterator(NamedNode.Wrap);\r\n                    let next = iter.getNext();\r\n                    while (next) {\r\n                        if (next.name !== namedNode.name) {\r\n                            childList.push(next);\r\n                        }\r\n                        next = iter.getNext();\r\n                    }\r\n                    childList.push(namedNode);\r\n                    return buildChildSet(childList, index.getCompare());\r\n                }\r\n                else {\r\n                    // No change, this remains a fallback\r\n                    return fallbackObject;\r\n                }\r\n            }\r\n            else {\r\n                const existingSnap = existingChildren.get(namedNode.name);\r\n                let newChildren = indexedChildren;\r\n                if (existingSnap) {\r\n                    newChildren = newChildren.remove(new NamedNode(namedNode.name, existingSnap));\r\n                }\r\n                return newChildren.insert(namedNode, namedNode.node);\r\n            }\r\n        });\r\n        return new IndexMap(newIndexes, this.indexSet_);\r\n    }\r\n    /**\r\n     * Create a new IndexMap instance with the given value removed\r\n     */\r\n    removeFromIndexes(namedNode, existingChildren) {\r\n        const newIndexes = map(this.indexes_, (indexedChildren) => {\r\n            if (indexedChildren === fallbackObject) {\r\n                // This is the fallback. Just return it, nothing to do in this case\r\n                return indexedChildren;\r\n            }\r\n            else {\r\n                const existingSnap = existingChildren.get(namedNode.name);\r\n                if (existingSnap) {\r\n                    return indexedChildren.remove(new NamedNode(namedNode.name, existingSnap));\r\n                }\r\n                else {\r\n                    // No record of this child\r\n                    return indexedChildren;\r\n                }\r\n            }\r\n        });\r\n        return new IndexMap(newIndexes, this.indexSet_);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// TODO: For memory savings, don't store priorityNode_ if it's empty.\r\nlet EMPTY_NODE;\r\n/**\r\n * ChildrenNode is a class for storing internal nodes in a DataSnapshot\r\n * (i.e. nodes with children).  It implements Node and stores the\r\n * list of children in the children property, sorted by child name.\r\n */\r\nclass ChildrenNode {\r\n    /**\r\n     * @param children_ - List of children of this node..\r\n     * @param priorityNode_ - The priority of this node (as a snapshot node).\r\n     */\r\n    constructor(children_, priorityNode_, indexMap_) {\r\n        this.children_ = children_;\r\n        this.priorityNode_ = priorityNode_;\r\n        this.indexMap_ = indexMap_;\r\n        this.lazyHash_ = null;\r\n        /**\r\n         * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use\r\n         * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own\r\n         * class instead of an empty ChildrenNode.\r\n         */\r\n        if (this.priorityNode_) {\r\n            validatePriorityNode(this.priorityNode_);\r\n        }\r\n        if (this.children_.isEmpty()) {\r\n            index_esm2017_assert(!this.priorityNode_ || this.priorityNode_.isEmpty(), 'An empty node cannot have a priority');\r\n        }\r\n    }\r\n    static get EMPTY_NODE() {\r\n        return (EMPTY_NODE ||\r\n            (EMPTY_NODE = new ChildrenNode(new SortedMap(NAME_COMPARATOR), null, IndexMap.Default)));\r\n    }\r\n    /** @inheritDoc */\r\n    isLeafNode() {\r\n        return false;\r\n    }\r\n    /** @inheritDoc */\r\n    getPriority() {\r\n        return this.priorityNode_ || EMPTY_NODE;\r\n    }\r\n    /** @inheritDoc */\r\n    updatePriority(newPriorityNode) {\r\n        if (this.children_.isEmpty()) {\r\n            // Don't allow priorities on empty nodes\r\n            return this;\r\n        }\r\n        else {\r\n            return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    getImmediateChild(childName) {\r\n        // Hack to treat priority as a regular child\r\n        if (childName === '.priority') {\r\n            return this.getPriority();\r\n        }\r\n        else {\r\n            const child = this.children_.get(childName);\r\n            return child === null ? EMPTY_NODE : child;\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    getChild(path) {\r\n        const front = pathGetFront(path);\r\n        if (front === null) {\r\n            return this;\r\n        }\r\n        return this.getImmediateChild(front).getChild(pathPopFront(path));\r\n    }\r\n    /** @inheritDoc */\r\n    hasChild(childName) {\r\n        return this.children_.get(childName) !== null;\r\n    }\r\n    /** @inheritDoc */\r\n    updateImmediateChild(childName, newChildNode) {\r\n        index_esm2017_assert(newChildNode, 'We should always be passing snapshot nodes');\r\n        if (childName === '.priority') {\r\n            return this.updatePriority(newChildNode);\r\n        }\r\n        else {\r\n            const namedNode = new NamedNode(childName, newChildNode);\r\n            let newChildren, newIndexMap;\r\n            if (newChildNode.isEmpty()) {\r\n                newChildren = this.children_.remove(childName);\r\n                newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);\r\n            }\r\n            else {\r\n                newChildren = this.children_.insert(childName, newChildNode);\r\n                newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);\r\n            }\r\n            const newPriority = newChildren.isEmpty()\r\n                ? EMPTY_NODE\r\n                : this.priorityNode_;\r\n            return new ChildrenNode(newChildren, newPriority, newIndexMap);\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    updateChild(path, newChildNode) {\r\n        const front = pathGetFront(path);\r\n        if (front === null) {\r\n            return newChildNode;\r\n        }\r\n        else {\r\n            index_esm2017_assert(pathGetFront(path) !== '.priority' || pathGetLength(path) === 1, '.priority must be the last token in a path');\r\n            const newImmediateChild = this.getImmediateChild(front).updateChild(pathPopFront(path), newChildNode);\r\n            return this.updateImmediateChild(front, newImmediateChild);\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    isEmpty() {\r\n        return this.children_.isEmpty();\r\n    }\r\n    /** @inheritDoc */\r\n    numChildren() {\r\n        return this.children_.count();\r\n    }\r\n    /** @inheritDoc */\r\n    val(exportFormat) {\r\n        if (this.isEmpty()) {\r\n            return null;\r\n        }\r\n        const obj = {};\r\n        let numKeys = 0, maxKey = 0, allIntegerKeys = true;\r\n        this.forEachChild(PRIORITY_INDEX, (key, childNode) => {\r\n            obj[key] = childNode.val(exportFormat);\r\n            numKeys++;\r\n            if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) {\r\n                maxKey = Math.max(maxKey, Number(key));\r\n            }\r\n            else {\r\n                allIntegerKeys = false;\r\n            }\r\n        });\r\n        if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {\r\n            // convert to array.\r\n            const array = [];\r\n            // eslint-disable-next-line guard-for-in\r\n            for (const key in obj) {\r\n                array[key] = obj[key];\r\n            }\r\n            return array;\r\n        }\r\n        else {\r\n            if (exportFormat && !this.getPriority().isEmpty()) {\r\n                obj['.priority'] = this.getPriority().val();\r\n            }\r\n            return obj;\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    hash() {\r\n        if (this.lazyHash_ === null) {\r\n            let toHash = '';\r\n            if (!this.getPriority().isEmpty()) {\r\n                toHash +=\r\n                    'priority:' +\r\n                        priorityHashText(this.getPriority().val()) +\r\n                        ':';\r\n            }\r\n            this.forEachChild(PRIORITY_INDEX, (key, childNode) => {\r\n                const childHash = childNode.hash();\r\n                if (childHash !== '') {\r\n                    toHash += ':' + key + ':' + childHash;\r\n                }\r\n            });\r\n            this.lazyHash_ = toHash === '' ? '' : sha1(toHash);\r\n        }\r\n        return this.lazyHash_;\r\n    }\r\n    /** @inheritDoc */\r\n    getPredecessorChildName(childName, childNode, index) {\r\n        const idx = this.resolveIndex_(index);\r\n        if (idx) {\r\n            const predecessor = idx.getPredecessorKey(new NamedNode(childName, childNode));\r\n            return predecessor ? predecessor.name : null;\r\n        }\r\n        else {\r\n            return this.children_.getPredecessorKey(childName);\r\n        }\r\n    }\r\n    getFirstChildName(indexDefinition) {\r\n        const idx = this.resolveIndex_(indexDefinition);\r\n        if (idx) {\r\n            const minKey = idx.minKey();\r\n            return minKey && minKey.name;\r\n        }\r\n        else {\r\n            return this.children_.minKey();\r\n        }\r\n    }\r\n    getFirstChild(indexDefinition) {\r\n        const minKey = this.getFirstChildName(indexDefinition);\r\n        if (minKey) {\r\n            return new NamedNode(minKey, this.children_.get(minKey));\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Given an index, return the key name of the largest value we have, according to that index\r\n     */\r\n    getLastChildName(indexDefinition) {\r\n        const idx = this.resolveIndex_(indexDefinition);\r\n        if (idx) {\r\n            const maxKey = idx.maxKey();\r\n            return maxKey && maxKey.name;\r\n        }\r\n        else {\r\n            return this.children_.maxKey();\r\n        }\r\n    }\r\n    getLastChild(indexDefinition) {\r\n        const maxKey = this.getLastChildName(indexDefinition);\r\n        if (maxKey) {\r\n            return new NamedNode(maxKey, this.children_.get(maxKey));\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    forEachChild(index, action) {\r\n        const idx = this.resolveIndex_(index);\r\n        if (idx) {\r\n            return idx.inorderTraversal(wrappedNode => {\r\n                return action(wrappedNode.name, wrappedNode.node);\r\n            });\r\n        }\r\n        else {\r\n            return this.children_.inorderTraversal(action);\r\n        }\r\n    }\r\n    getIterator(indexDefinition) {\r\n        return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);\r\n    }\r\n    getIteratorFrom(startPost, indexDefinition) {\r\n        const idx = this.resolveIndex_(indexDefinition);\r\n        if (idx) {\r\n            return idx.getIteratorFrom(startPost, key => key);\r\n        }\r\n        else {\r\n            const iterator = this.children_.getIteratorFrom(startPost.name, NamedNode.Wrap);\r\n            let next = iterator.peek();\r\n            while (next != null && indexDefinition.compare(next, startPost) < 0) {\r\n                iterator.getNext();\r\n                next = iterator.peek();\r\n            }\r\n            return iterator;\r\n        }\r\n    }\r\n    getReverseIterator(indexDefinition) {\r\n        return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);\r\n    }\r\n    getReverseIteratorFrom(endPost, indexDefinition) {\r\n        const idx = this.resolveIndex_(indexDefinition);\r\n        if (idx) {\r\n            return idx.getReverseIteratorFrom(endPost, key => {\r\n                return key;\r\n            });\r\n        }\r\n        else {\r\n            const iterator = this.children_.getReverseIteratorFrom(endPost.name, NamedNode.Wrap);\r\n            let next = iterator.peek();\r\n            while (next != null && indexDefinition.compare(next, endPost) > 0) {\r\n                iterator.getNext();\r\n                next = iterator.peek();\r\n            }\r\n            return iterator;\r\n        }\r\n    }\r\n    compareTo(other) {\r\n        if (this.isEmpty()) {\r\n            if (other.isEmpty()) {\r\n                return 0;\r\n            }\r\n            else {\r\n                return -1;\r\n            }\r\n        }\r\n        else if (other.isLeafNode() || other.isEmpty()) {\r\n            return 1;\r\n        }\r\n        else if (other === MAX_NODE) {\r\n            return -1;\r\n        }\r\n        else {\r\n            // Must be another node with children.\r\n            return 0;\r\n        }\r\n    }\r\n    withIndex(indexDefinition) {\r\n        if (indexDefinition === KEY_INDEX ||\r\n            this.indexMap_.hasIndex(indexDefinition)) {\r\n            return this;\r\n        }\r\n        else {\r\n            const newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);\r\n            return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);\r\n        }\r\n    }\r\n    isIndexed(index) {\r\n        return index === KEY_INDEX || this.indexMap_.hasIndex(index);\r\n    }\r\n    equals(other) {\r\n        if (other === this) {\r\n            return true;\r\n        }\r\n        else if (other.isLeafNode()) {\r\n            return false;\r\n        }\r\n        else {\r\n            const otherChildrenNode = other;\r\n            if (!this.getPriority().equals(otherChildrenNode.getPriority())) {\r\n                return false;\r\n            }\r\n            else if (this.children_.count() === otherChildrenNode.children_.count()) {\r\n                const thisIter = this.getIterator(PRIORITY_INDEX);\r\n                const otherIter = otherChildrenNode.getIterator(PRIORITY_INDEX);\r\n                let thisCurrent = thisIter.getNext();\r\n                let otherCurrent = otherIter.getNext();\r\n                while (thisCurrent && otherCurrent) {\r\n                    if (thisCurrent.name !== otherCurrent.name ||\r\n                        !thisCurrent.node.equals(otherCurrent.node)) {\r\n                        return false;\r\n                    }\r\n                    thisCurrent = thisIter.getNext();\r\n                    otherCurrent = otherIter.getNext();\r\n                }\r\n                return thisCurrent === null && otherCurrent === null;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used\r\n     * instead.\r\n     *\r\n     */\r\n    resolveIndex_(indexDefinition) {\r\n        if (indexDefinition === KEY_INDEX) {\r\n            return null;\r\n        }\r\n        else {\r\n            return this.indexMap_.get(indexDefinition.toString());\r\n        }\r\n    }\r\n}\r\nChildrenNode.INTEGER_REGEXP_ = /^(0|[1-9]\\d*)$/;\r\nclass MaxNode extends ChildrenNode {\r\n    constructor() {\r\n        super(new SortedMap(NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap.Default);\r\n    }\r\n    compareTo(other) {\r\n        if (other === this) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return 1;\r\n        }\r\n    }\r\n    equals(other) {\r\n        // Not that we every compare it, but MAX_NODE is only ever equal to itself\r\n        return other === this;\r\n    }\r\n    getPriority() {\r\n        return this;\r\n    }\r\n    getImmediateChild(childName) {\r\n        return ChildrenNode.EMPTY_NODE;\r\n    }\r\n    isEmpty() {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Marker that will sort higher than any other snapshot.\r\n */\r\nconst MAX_NODE = new MaxNode();\r\nObject.defineProperties(NamedNode, {\r\n    MIN: {\r\n        value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE)\r\n    },\r\n    MAX: {\r\n        value: new NamedNode(MAX_NAME, MAX_NODE)\r\n    }\r\n});\r\n/**\r\n * Reference Extensions\r\n */\r\nKeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;\r\nLeafNode.__childrenNodeConstructor = ChildrenNode;\r\nsetMaxNode$1(MAX_NODE);\r\nsetMaxNode(MAX_NODE);\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst USE_HINZE = true;\r\n/**\r\n * Constructs a snapshot node representing the passed JSON and returns it.\r\n * @param json - JSON to create a node for.\r\n * @param priority - Optional priority to use.  This will be ignored if the\r\n * passed JSON contains a .priority property.\r\n */\r\nfunction nodeFromJSON(json, priority = null) {\r\n    if (json === null) {\r\n        return ChildrenNode.EMPTY_NODE;\r\n    }\r\n    if (typeof json === 'object' && '.priority' in json) {\r\n        priority = json['.priority'];\r\n    }\r\n    index_esm2017_assert(priority === null ||\r\n        typeof priority === 'string' ||\r\n        typeof priority === 'number' ||\r\n        (typeof priority === 'object' && '.sv' in priority), 'Invalid priority type found: ' + typeof priority);\r\n    if (typeof json === 'object' && '.value' in json && json['.value'] !== null) {\r\n        json = json['.value'];\r\n    }\r\n    // Valid leaf nodes include non-objects or server-value wrapper objects\r\n    if (typeof json !== 'object' || '.sv' in json) {\r\n        const jsonLeaf = json;\r\n        return new LeafNode(jsonLeaf, nodeFromJSON(priority));\r\n    }\r\n    if (!(json instanceof Array) && USE_HINZE) {\r\n        const children = [];\r\n        let childrenHavePriority = false;\r\n        const hinzeJsonObj = json;\r\n        each(hinzeJsonObj, (key, child) => {\r\n            if (key.substring(0, 1) !== '.') {\r\n                // Ignore metadata nodes\r\n                const childNode = nodeFromJSON(child);\r\n                if (!childNode.isEmpty()) {\r\n                    childrenHavePriority =\r\n                        childrenHavePriority || !childNode.getPriority().isEmpty();\r\n                    children.push(new NamedNode(key, childNode));\r\n                }\r\n            }\r\n        });\r\n        if (children.length === 0) {\r\n            return ChildrenNode.EMPTY_NODE;\r\n        }\r\n        const childSet = buildChildSet(children, NAME_ONLY_COMPARATOR, namedNode => namedNode.name, NAME_COMPARATOR);\r\n        if (childrenHavePriority) {\r\n            const sortedChildSet = buildChildSet(children, PRIORITY_INDEX.getCompare());\r\n            return new ChildrenNode(childSet, nodeFromJSON(priority), new IndexMap({ '.priority': sortedChildSet }, { '.priority': PRIORITY_INDEX }));\r\n        }\r\n        else {\r\n            return new ChildrenNode(childSet, nodeFromJSON(priority), IndexMap.Default);\r\n        }\r\n    }\r\n    else {\r\n        let node = ChildrenNode.EMPTY_NODE;\r\n        each(json, (key, childData) => {\r\n            if (index_esm2017_contains(json, key)) {\r\n                if (key.substring(0, 1) !== '.') {\r\n                    // ignore metadata nodes.\r\n                    const childNode = nodeFromJSON(childData);\r\n                    if (childNode.isLeafNode() || !childNode.isEmpty()) {\r\n                        node = node.updateImmediateChild(key, childNode);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        return node.updatePriority(nodeFromJSON(priority));\r\n    }\r\n}\r\nsetNodeFromJSON(nodeFromJSON);\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass PathIndex extends Index {\r\n    constructor(indexPath_) {\r\n        super();\r\n        this.indexPath_ = indexPath_;\r\n        index_esm2017_assert(!pathIsEmpty(indexPath_) && pathGetFront(indexPath_) !== '.priority', \"Can't create PathIndex with empty path or .priority key\");\r\n    }\r\n    extractChild(snap) {\r\n        return snap.getChild(this.indexPath_);\r\n    }\r\n    isDefinedOn(node) {\r\n        return !node.getChild(this.indexPath_).isEmpty();\r\n    }\r\n    compare(a, b) {\r\n        const aChild = this.extractChild(a.node);\r\n        const bChild = this.extractChild(b.node);\r\n        const indexCmp = aChild.compareTo(bChild);\r\n        if (indexCmp === 0) {\r\n            return nameCompare(a.name, b.name);\r\n        }\r\n        else {\r\n            return indexCmp;\r\n        }\r\n    }\r\n    makePost(indexValue, name) {\r\n        const valueNode = nodeFromJSON(indexValue);\r\n        const node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, valueNode);\r\n        return new NamedNode(name, node);\r\n    }\r\n    maxPost() {\r\n        const node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, MAX_NODE);\r\n        return new NamedNode(MAX_NAME, node);\r\n    }\r\n    toString() {\r\n        return pathSlice(this.indexPath_, 0).join('/');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass ValueIndex extends Index {\r\n    compare(a, b) {\r\n        const indexCmp = a.node.compareTo(b.node);\r\n        if (indexCmp === 0) {\r\n            return nameCompare(a.name, b.name);\r\n        }\r\n        else {\r\n            return indexCmp;\r\n        }\r\n    }\r\n    isDefinedOn(node) {\r\n        return true;\r\n    }\r\n    indexedValueChanged(oldNode, newNode) {\r\n        return !oldNode.equals(newNode);\r\n    }\r\n    minPost() {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return NamedNode.MIN;\r\n    }\r\n    maxPost() {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return NamedNode.MAX;\r\n    }\r\n    makePost(indexValue, name) {\r\n        const valueNode = nodeFromJSON(indexValue);\r\n        return new NamedNode(name, valueNode);\r\n    }\r\n    /**\r\n     * @returns String representation for inclusion in a query spec\r\n     */\r\n    toString() {\r\n        return '.value';\r\n    }\r\n}\r\nconst VALUE_INDEX = new ValueIndex();\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction changeValue(snapshotNode) {\r\n    return { type: \"value\" /* ChangeType.VALUE */, snapshotNode };\r\n}\r\nfunction changeChildAdded(childName, snapshotNode) {\r\n    return { type: \"child_added\" /* ChangeType.CHILD_ADDED */, snapshotNode, childName };\r\n}\r\nfunction changeChildRemoved(childName, snapshotNode) {\r\n    return { type: \"child_removed\" /* ChangeType.CHILD_REMOVED */, snapshotNode, childName };\r\n}\r\nfunction changeChildChanged(childName, snapshotNode, oldSnap) {\r\n    return {\r\n        type: \"child_changed\" /* ChangeType.CHILD_CHANGED */,\r\n        snapshotNode,\r\n        childName,\r\n        oldSnap\r\n    };\r\n}\r\nfunction changeChildMoved(childName, snapshotNode) {\r\n    return { type: \"child_moved\" /* ChangeType.CHILD_MOVED */, snapshotNode, childName };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Doesn't really filter nodes but applies an index to the node and keeps track of any changes\r\n */\r\nclass IndexedFilter {\r\n    constructor(index_) {\r\n        this.index_ = index_;\r\n    }\r\n    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) {\r\n        index_esm2017_assert(snap.isIndexed(this.index_), 'A node must be indexed if only a child is updated');\r\n        const oldChild = snap.getImmediateChild(key);\r\n        // Check if anything actually changed.\r\n        if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) {\r\n            // There's an edge case where a child can enter or leave the view because affectedPath was set to null.\r\n            // In this case, affectedPath will appear null in both the old and new snapshots.  So we need\r\n            // to avoid treating these cases as \"nothing changed.\"\r\n            if (oldChild.isEmpty() === newChild.isEmpty()) {\r\n                // Nothing changed.\r\n                // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.\r\n                //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');\r\n                return snap;\r\n            }\r\n        }\r\n        if (optChangeAccumulator != null) {\r\n            if (newChild.isEmpty()) {\r\n                if (snap.hasChild(key)) {\r\n                    optChangeAccumulator.trackChildChange(changeChildRemoved(key, oldChild));\r\n                }\r\n                else {\r\n                    index_esm2017_assert(snap.isLeafNode(), 'A child remove without an old child only makes sense on a leaf node');\r\n                }\r\n            }\r\n            else if (oldChild.isEmpty()) {\r\n                optChangeAccumulator.trackChildChange(changeChildAdded(key, newChild));\r\n            }\r\n            else {\r\n                optChangeAccumulator.trackChildChange(changeChildChanged(key, newChild, oldChild));\r\n            }\r\n        }\r\n        if (snap.isLeafNode() && newChild.isEmpty()) {\r\n            return snap;\r\n        }\r\n        else {\r\n            // Make sure the node is indexed\r\n            return snap.updateImmediateChild(key, newChild).withIndex(this.index_);\r\n        }\r\n    }\r\n    updateFullNode(oldSnap, newSnap, optChangeAccumulator) {\r\n        if (optChangeAccumulator != null) {\r\n            if (!oldSnap.isLeafNode()) {\r\n                oldSnap.forEachChild(PRIORITY_INDEX, (key, childNode) => {\r\n                    if (!newSnap.hasChild(key)) {\r\n                        optChangeAccumulator.trackChildChange(changeChildRemoved(key, childNode));\r\n                    }\r\n                });\r\n            }\r\n            if (!newSnap.isLeafNode()) {\r\n                newSnap.forEachChild(PRIORITY_INDEX, (key, childNode) => {\r\n                    if (oldSnap.hasChild(key)) {\r\n                        const oldChild = oldSnap.getImmediateChild(key);\r\n                        if (!oldChild.equals(childNode)) {\r\n                            optChangeAccumulator.trackChildChange(changeChildChanged(key, childNode, oldChild));\r\n                        }\r\n                    }\r\n                    else {\r\n                        optChangeAccumulator.trackChildChange(changeChildAdded(key, childNode));\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        return newSnap.withIndex(this.index_);\r\n    }\r\n    updatePriority(oldSnap, newPriority) {\r\n        if (oldSnap.isEmpty()) {\r\n            return ChildrenNode.EMPTY_NODE;\r\n        }\r\n        else {\r\n            return oldSnap.updatePriority(newPriority);\r\n        }\r\n    }\r\n    filtersNodes() {\r\n        return false;\r\n    }\r\n    getIndexedFilter() {\r\n        return this;\r\n    }\r\n    getIndex() {\r\n        return this.index_;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node\r\n */\r\nclass RangedFilter {\r\n    constructor(params) {\r\n        this.indexedFilter_ = new IndexedFilter(params.getIndex());\r\n        this.index_ = params.getIndex();\r\n        this.startPost_ = RangedFilter.getStartPost_(params);\r\n        this.endPost_ = RangedFilter.getEndPost_(params);\r\n        this.startIsInclusive_ = !params.startAfterSet_;\r\n        this.endIsInclusive_ = !params.endBeforeSet_;\r\n    }\r\n    getStartPost() {\r\n        return this.startPost_;\r\n    }\r\n    getEndPost() {\r\n        return this.endPost_;\r\n    }\r\n    matches(node) {\r\n        const isWithinStart = this.startIsInclusive_\r\n            ? this.index_.compare(this.getStartPost(), node) <= 0\r\n            : this.index_.compare(this.getStartPost(), node) < 0;\r\n        const isWithinEnd = this.endIsInclusive_\r\n            ? this.index_.compare(node, this.getEndPost()) <= 0\r\n            : this.index_.compare(node, this.getEndPost()) < 0;\r\n        return isWithinStart && isWithinEnd;\r\n    }\r\n    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) {\r\n        if (!this.matches(new NamedNode(key, newChild))) {\r\n            newChild = ChildrenNode.EMPTY_NODE;\r\n        }\r\n        return this.indexedFilter_.updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);\r\n    }\r\n    updateFullNode(oldSnap, newSnap, optChangeAccumulator) {\r\n        if (newSnap.isLeafNode()) {\r\n            // Make sure we have a children node with the correct index, not a leaf node;\r\n            newSnap = ChildrenNode.EMPTY_NODE;\r\n        }\r\n        let filtered = newSnap.withIndex(this.index_);\r\n        // Don't support priorities on queries\r\n        filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);\r\n        const self = this;\r\n        newSnap.forEachChild(PRIORITY_INDEX, (key, childNode) => {\r\n            if (!self.matches(new NamedNode(key, childNode))) {\r\n                filtered = filtered.updateImmediateChild(key, ChildrenNode.EMPTY_NODE);\r\n            }\r\n        });\r\n        return this.indexedFilter_.updateFullNode(oldSnap, filtered, optChangeAccumulator);\r\n    }\r\n    updatePriority(oldSnap, newPriority) {\r\n        // Don't support priorities on queries\r\n        return oldSnap;\r\n    }\r\n    filtersNodes() {\r\n        return true;\r\n    }\r\n    getIndexedFilter() {\r\n        return this.indexedFilter_;\r\n    }\r\n    getIndex() {\r\n        return this.index_;\r\n    }\r\n    static getStartPost_(params) {\r\n        if (params.hasStart()) {\r\n            const startName = params.getIndexStartName();\r\n            return params.getIndex().makePost(params.getIndexStartValue(), startName);\r\n        }\r\n        else {\r\n            return params.getIndex().minPost();\r\n        }\r\n    }\r\n    static getEndPost_(params) {\r\n        if (params.hasEnd()) {\r\n            const endName = params.getIndexEndName();\r\n            return params.getIndex().makePost(params.getIndexEndValue(), endName);\r\n        }\r\n        else {\r\n            return params.getIndex().maxPost();\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible\r\n */\r\nclass LimitedFilter {\r\n    constructor(params) {\r\n        this.withinDirectionalStart = (node) => this.reverse_ ? this.withinEndPost(node) : this.withinStartPost(node);\r\n        this.withinDirectionalEnd = (node) => this.reverse_ ? this.withinStartPost(node) : this.withinEndPost(node);\r\n        this.withinStartPost = (node) => {\r\n            const compareRes = this.index_.compare(this.rangedFilter_.getStartPost(), node);\r\n            return this.startIsInclusive_ ? compareRes <= 0 : compareRes < 0;\r\n        };\r\n        this.withinEndPost = (node) => {\r\n            const compareRes = this.index_.compare(node, this.rangedFilter_.getEndPost());\r\n            return this.endIsInclusive_ ? compareRes <= 0 : compareRes < 0;\r\n        };\r\n        this.rangedFilter_ = new RangedFilter(params);\r\n        this.index_ = params.getIndex();\r\n        this.limit_ = params.getLimit();\r\n        this.reverse_ = !params.isViewFromLeft();\r\n        this.startIsInclusive_ = !params.startAfterSet_;\r\n        this.endIsInclusive_ = !params.endBeforeSet_;\r\n    }\r\n    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) {\r\n        if (!this.rangedFilter_.matches(new NamedNode(key, newChild))) {\r\n            newChild = ChildrenNode.EMPTY_NODE;\r\n        }\r\n        if (snap.getImmediateChild(key).equals(newChild)) {\r\n            // No change\r\n            return snap;\r\n        }\r\n        else if (snap.numChildren() < this.limit_) {\r\n            return this.rangedFilter_\r\n                .getIndexedFilter()\r\n                .updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);\r\n        }\r\n        else {\r\n            return this.fullLimitUpdateChild_(snap, key, newChild, source, optChangeAccumulator);\r\n        }\r\n    }\r\n    updateFullNode(oldSnap, newSnap, optChangeAccumulator) {\r\n        let filtered;\r\n        if (newSnap.isLeafNode() || newSnap.isEmpty()) {\r\n            // Make sure we have a children node with the correct index, not a leaf node;\r\n            filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\r\n        }\r\n        else {\r\n            if (this.limit_ * 2 < newSnap.numChildren() &&\r\n                newSnap.isIndexed(this.index_)) {\r\n                // Easier to build up a snapshot, since what we're given has more than twice the elements we want\r\n                filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);\r\n                // anchor to the startPost, endPost, or last element as appropriate\r\n                let iterator;\r\n                if (this.reverse_) {\r\n                    iterator = newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_);\r\n                }\r\n                else {\r\n                    iterator = newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);\r\n                }\r\n                let count = 0;\r\n                while (iterator.hasNext() && count < this.limit_) {\r\n                    const next = iterator.getNext();\r\n                    if (!this.withinDirectionalStart(next)) {\r\n                        // if we have not reached the start, skip to the next element\r\n                        continue;\r\n                    }\r\n                    else if (!this.withinDirectionalEnd(next)) {\r\n                        // if we have reached the end, stop adding elements\r\n                        break;\r\n                    }\r\n                    else {\r\n                        filtered = filtered.updateImmediateChild(next.name, next.node);\r\n                        count++;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // The snap contains less than twice the limit. Faster to delete from the snap than build up a new one\r\n                filtered = newSnap.withIndex(this.index_);\r\n                // Don't support priorities on queries\r\n                filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);\r\n                let iterator;\r\n                if (this.reverse_) {\r\n                    iterator = filtered.getReverseIterator(this.index_);\r\n                }\r\n                else {\r\n                    iterator = filtered.getIterator(this.index_);\r\n                }\r\n                let count = 0;\r\n                while (iterator.hasNext()) {\r\n                    const next = iterator.getNext();\r\n                    const inRange = count < this.limit_ &&\r\n                        this.withinDirectionalStart(next) &&\r\n                        this.withinDirectionalEnd(next);\r\n                    if (inRange) {\r\n                        count++;\r\n                    }\r\n                    else {\r\n                        filtered = filtered.updateImmediateChild(next.name, ChildrenNode.EMPTY_NODE);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return this.rangedFilter_\r\n            .getIndexedFilter()\r\n            .updateFullNode(oldSnap, filtered, optChangeAccumulator);\r\n    }\r\n    updatePriority(oldSnap, newPriority) {\r\n        // Don't support priorities on queries\r\n        return oldSnap;\r\n    }\r\n    filtersNodes() {\r\n        return true;\r\n    }\r\n    getIndexedFilter() {\r\n        return this.rangedFilter_.getIndexedFilter();\r\n    }\r\n    getIndex() {\r\n        return this.index_;\r\n    }\r\n    fullLimitUpdateChild_(snap, childKey, childSnap, source, changeAccumulator) {\r\n        // TODO: rename all cache stuff etc to general snap terminology\r\n        let cmp;\r\n        if (this.reverse_) {\r\n            const indexCmp = this.index_.getCompare();\r\n            cmp = (a, b) => indexCmp(b, a);\r\n        }\r\n        else {\r\n            cmp = this.index_.getCompare();\r\n        }\r\n        const oldEventCache = snap;\r\n        index_esm2017_assert(oldEventCache.numChildren() === this.limit_, '');\r\n        const newChildNamedNode = new NamedNode(childKey, childSnap);\r\n        const windowBoundary = this.reverse_\r\n            ? oldEventCache.getFirstChild(this.index_)\r\n            : oldEventCache.getLastChild(this.index_);\r\n        const inRange = this.rangedFilter_.matches(newChildNamedNode);\r\n        if (oldEventCache.hasChild(childKey)) {\r\n            const oldChildSnap = oldEventCache.getImmediateChild(childKey);\r\n            let nextChild = source.getChildAfterChild(this.index_, windowBoundary, this.reverse_);\r\n            while (nextChild != null &&\r\n                (nextChild.name === childKey || oldEventCache.hasChild(nextChild.name))) {\r\n                // There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't\r\n                // been applied to the limited filter yet. Ignore this next child which will be updated later in\r\n                // the limited filter...\r\n                nextChild = source.getChildAfterChild(this.index_, nextChild, this.reverse_);\r\n            }\r\n            const compareNext = nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);\r\n            const remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;\r\n            if (remainsInWindow) {\r\n                if (changeAccumulator != null) {\r\n                    changeAccumulator.trackChildChange(changeChildChanged(childKey, childSnap, oldChildSnap));\r\n                }\r\n                return oldEventCache.updateImmediateChild(childKey, childSnap);\r\n            }\r\n            else {\r\n                if (changeAccumulator != null) {\r\n                    changeAccumulator.trackChildChange(changeChildRemoved(childKey, oldChildSnap));\r\n                }\r\n                const newEventCache = oldEventCache.updateImmediateChild(childKey, ChildrenNode.EMPTY_NODE);\r\n                const nextChildInRange = nextChild != null && this.rangedFilter_.matches(nextChild);\r\n                if (nextChildInRange) {\r\n                    if (changeAccumulator != null) {\r\n                        changeAccumulator.trackChildChange(changeChildAdded(nextChild.name, nextChild.node));\r\n                    }\r\n                    return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);\r\n                }\r\n                else {\r\n                    return newEventCache;\r\n                }\r\n            }\r\n        }\r\n        else if (childSnap.isEmpty()) {\r\n            // we're deleting a node, but it was not in the window, so ignore it\r\n            return snap;\r\n        }\r\n        else if (inRange) {\r\n            if (cmp(windowBoundary, newChildNamedNode) >= 0) {\r\n                if (changeAccumulator != null) {\r\n                    changeAccumulator.trackChildChange(changeChildRemoved(windowBoundary.name, windowBoundary.node));\r\n                    changeAccumulator.trackChildChange(changeChildAdded(childKey, childSnap));\r\n                }\r\n                return oldEventCache\r\n                    .updateImmediateChild(childKey, childSnap)\r\n                    .updateImmediateChild(windowBoundary.name, ChildrenNode.EMPTY_NODE);\r\n            }\r\n            else {\r\n                return snap;\r\n            }\r\n        }\r\n        else {\r\n            return snap;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * This class is an immutable-from-the-public-api struct containing a set of query parameters defining a\r\n * range to be returned for a particular location. It is assumed that validation of parameters is done at the\r\n * user-facing API level, so it is not done here.\r\n *\r\n * @internal\r\n */\r\nclass QueryParams {\r\n    constructor() {\r\n        this.limitSet_ = false;\r\n        this.startSet_ = false;\r\n        this.startNameSet_ = false;\r\n        this.startAfterSet_ = false; // can only be true if startSet_ is true\r\n        this.endSet_ = false;\r\n        this.endNameSet_ = false;\r\n        this.endBeforeSet_ = false; // can only be true if endSet_ is true\r\n        this.limit_ = 0;\r\n        this.viewFrom_ = '';\r\n        this.indexStartValue_ = null;\r\n        this.indexStartName_ = '';\r\n        this.indexEndValue_ = null;\r\n        this.indexEndName_ = '';\r\n        this.index_ = PRIORITY_INDEX;\r\n    }\r\n    hasStart() {\r\n        return this.startSet_;\r\n    }\r\n    /**\r\n     * @returns True if it would return from left.\r\n     */\r\n    isViewFromLeft() {\r\n        if (this.viewFrom_ === '') {\r\n            // limit(), rather than limitToFirst or limitToLast was called.\r\n            // This means that only one of startSet_ and endSet_ is true. Use them\r\n            // to calculate which side of the view to anchor to. If neither is set,\r\n            // anchor to the end.\r\n            return this.startSet_;\r\n        }\r\n        else {\r\n            return this.viewFrom_ === \"l\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT */;\r\n        }\r\n    }\r\n    /**\r\n     * Only valid to call if hasStart() returns true\r\n     */\r\n    getIndexStartValue() {\r\n        index_esm2017_assert(this.startSet_, 'Only valid if start has been set');\r\n        return this.indexStartValue_;\r\n    }\r\n    /**\r\n     * Only valid to call if hasStart() returns true.\r\n     * Returns the starting key name for the range defined by these query parameters\r\n     */\r\n    getIndexStartName() {\r\n        index_esm2017_assert(this.startSet_, 'Only valid if start has been set');\r\n        if (this.startNameSet_) {\r\n            return this.indexStartName_;\r\n        }\r\n        else {\r\n            return MIN_NAME;\r\n        }\r\n    }\r\n    hasEnd() {\r\n        return this.endSet_;\r\n    }\r\n    /**\r\n     * Only valid to call if hasEnd() returns true.\r\n     */\r\n    getIndexEndValue() {\r\n        index_esm2017_assert(this.endSet_, 'Only valid if end has been set');\r\n        return this.indexEndValue_;\r\n    }\r\n    /**\r\n     * Only valid to call if hasEnd() returns true.\r\n     * Returns the end key name for the range defined by these query parameters\r\n     */\r\n    getIndexEndName() {\r\n        index_esm2017_assert(this.endSet_, 'Only valid if end has been set');\r\n        if (this.endNameSet_) {\r\n            return this.indexEndName_;\r\n        }\r\n        else {\r\n            return MAX_NAME;\r\n        }\r\n    }\r\n    hasLimit() {\r\n        return this.limitSet_;\r\n    }\r\n    /**\r\n     * @returns True if a limit has been set and it has been explicitly anchored\r\n     */\r\n    hasAnchoredLimit() {\r\n        return this.limitSet_ && this.viewFrom_ !== '';\r\n    }\r\n    /**\r\n     * Only valid to call if hasLimit() returns true\r\n     */\r\n    getLimit() {\r\n        index_esm2017_assert(this.limitSet_, 'Only valid if limit has been set');\r\n        return this.limit_;\r\n    }\r\n    getIndex() {\r\n        return this.index_;\r\n    }\r\n    loadsAllData() {\r\n        return !(this.startSet_ || this.endSet_ || this.limitSet_);\r\n    }\r\n    isDefault() {\r\n        return this.loadsAllData() && this.index_ === PRIORITY_INDEX;\r\n    }\r\n    copy() {\r\n        const copy = new QueryParams();\r\n        copy.limitSet_ = this.limitSet_;\r\n        copy.limit_ = this.limit_;\r\n        copy.startSet_ = this.startSet_;\r\n        copy.startAfterSet_ = this.startAfterSet_;\r\n        copy.indexStartValue_ = this.indexStartValue_;\r\n        copy.startNameSet_ = this.startNameSet_;\r\n        copy.indexStartName_ = this.indexStartName_;\r\n        copy.endSet_ = this.endSet_;\r\n        copy.endBeforeSet_ = this.endBeforeSet_;\r\n        copy.indexEndValue_ = this.indexEndValue_;\r\n        copy.endNameSet_ = this.endNameSet_;\r\n        copy.indexEndName_ = this.indexEndName_;\r\n        copy.index_ = this.index_;\r\n        copy.viewFrom_ = this.viewFrom_;\r\n        return copy;\r\n    }\r\n}\r\nfunction queryParamsGetNodeFilter(queryParams) {\r\n    if (queryParams.loadsAllData()) {\r\n        return new IndexedFilter(queryParams.getIndex());\r\n    }\r\n    else if (queryParams.hasLimit()) {\r\n        return new LimitedFilter(queryParams);\r\n    }\r\n    else {\r\n        return new RangedFilter(queryParams);\r\n    }\r\n}\r\nfunction queryParamsLimitToFirst(queryParams, newLimit) {\r\n    const newParams = queryParams.copy();\r\n    newParams.limitSet_ = true;\r\n    newParams.limit_ = newLimit;\r\n    newParams.viewFrom_ = \"l\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT */;\r\n    return newParams;\r\n}\r\nfunction queryParamsLimitToLast(queryParams, newLimit) {\r\n    const newParams = queryParams.copy();\r\n    newParams.limitSet_ = true;\r\n    newParams.limit_ = newLimit;\r\n    newParams.viewFrom_ = \"r\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_RIGHT */;\r\n    return newParams;\r\n}\r\nfunction queryParamsStartAt(queryParams, indexValue, key) {\r\n    const newParams = queryParams.copy();\r\n    newParams.startSet_ = true;\r\n    if (indexValue === undefined) {\r\n        indexValue = null;\r\n    }\r\n    newParams.indexStartValue_ = indexValue;\r\n    if (key != null) {\r\n        newParams.startNameSet_ = true;\r\n        newParams.indexStartName_ = key;\r\n    }\r\n    else {\r\n        newParams.startNameSet_ = false;\r\n        newParams.indexStartName_ = '';\r\n    }\r\n    return newParams;\r\n}\r\nfunction queryParamsStartAfter(queryParams, indexValue, key) {\r\n    let params;\r\n    if (queryParams.index_ === KEY_INDEX || !!key) {\r\n        params = queryParamsStartAt(queryParams, indexValue, key);\r\n    }\r\n    else {\r\n        params = queryParamsStartAt(queryParams, indexValue, MAX_NAME);\r\n    }\r\n    params.startAfterSet_ = true;\r\n    return params;\r\n}\r\nfunction queryParamsEndAt(queryParams, indexValue, key) {\r\n    const newParams = queryParams.copy();\r\n    newParams.endSet_ = true;\r\n    if (indexValue === undefined) {\r\n        indexValue = null;\r\n    }\r\n    newParams.indexEndValue_ = indexValue;\r\n    if (key !== undefined) {\r\n        newParams.endNameSet_ = true;\r\n        newParams.indexEndName_ = key;\r\n    }\r\n    else {\r\n        newParams.endNameSet_ = false;\r\n        newParams.indexEndName_ = '';\r\n    }\r\n    return newParams;\r\n}\r\nfunction queryParamsEndBefore(queryParams, indexValue, key) {\r\n    let params;\r\n    if (queryParams.index_ === KEY_INDEX || !!key) {\r\n        params = queryParamsEndAt(queryParams, indexValue, key);\r\n    }\r\n    else {\r\n        params = queryParamsEndAt(queryParams, indexValue, MIN_NAME);\r\n    }\r\n    params.endBeforeSet_ = true;\r\n    return params;\r\n}\r\nfunction queryParamsOrderBy(queryParams, index) {\r\n    const newParams = queryParams.copy();\r\n    newParams.index_ = index;\r\n    return newParams;\r\n}\r\n/**\r\n * Returns a set of REST query string parameters representing this query.\r\n *\r\n * @returns query string parameters\r\n */\r\nfunction queryParamsToRestQueryStringParameters(queryParams) {\r\n    const qs = {};\r\n    if (queryParams.isDefault()) {\r\n        return qs;\r\n    }\r\n    let orderBy;\r\n    if (queryParams.index_ === PRIORITY_INDEX) {\r\n        orderBy = \"$priority\" /* REST_QUERY_CONSTANTS.PRIORITY_INDEX */;\r\n    }\r\n    else if (queryParams.index_ === VALUE_INDEX) {\r\n        orderBy = \"$value\" /* REST_QUERY_CONSTANTS.VALUE_INDEX */;\r\n    }\r\n    else if (queryParams.index_ === KEY_INDEX) {\r\n        orderBy = \"$key\" /* REST_QUERY_CONSTANTS.KEY_INDEX */;\r\n    }\r\n    else {\r\n        index_esm2017_assert(queryParams.index_ instanceof PathIndex, 'Unrecognized index type!');\r\n        orderBy = queryParams.index_.toString();\r\n    }\r\n    qs[\"orderBy\" /* REST_QUERY_CONSTANTS.ORDER_BY */] = index_esm2017_stringify(orderBy);\r\n    if (queryParams.startSet_) {\r\n        const startParam = queryParams.startAfterSet_\r\n            ? \"startAfter\" /* REST_QUERY_CONSTANTS.START_AFTER */\r\n            : \"startAt\" /* REST_QUERY_CONSTANTS.START_AT */;\r\n        qs[startParam] = index_esm2017_stringify(queryParams.indexStartValue_);\r\n        if (queryParams.startNameSet_) {\r\n            qs[startParam] += ',' + index_esm2017_stringify(queryParams.indexStartName_);\r\n        }\r\n    }\r\n    if (queryParams.endSet_) {\r\n        const endParam = queryParams.endBeforeSet_\r\n            ? \"endBefore\" /* REST_QUERY_CONSTANTS.END_BEFORE */\r\n            : \"endAt\" /* REST_QUERY_CONSTANTS.END_AT */;\r\n        qs[endParam] = index_esm2017_stringify(queryParams.indexEndValue_);\r\n        if (queryParams.endNameSet_) {\r\n            qs[endParam] += ',' + index_esm2017_stringify(queryParams.indexEndName_);\r\n        }\r\n    }\r\n    if (queryParams.limitSet_) {\r\n        if (queryParams.isViewFromLeft()) {\r\n            qs[\"limitToFirst\" /* REST_QUERY_CONSTANTS.LIMIT_TO_FIRST */] = queryParams.limit_;\r\n        }\r\n        else {\r\n            qs[\"limitToLast\" /* REST_QUERY_CONSTANTS.LIMIT_TO_LAST */] = queryParams.limit_;\r\n        }\r\n    }\r\n    return qs;\r\n}\r\nfunction queryParamsGetQueryObject(queryParams) {\r\n    const obj = {};\r\n    if (queryParams.startSet_) {\r\n        obj[\"sp\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_VALUE */] =\r\n            queryParams.indexStartValue_;\r\n        if (queryParams.startNameSet_) {\r\n            obj[\"sn\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_NAME */] =\r\n                queryParams.indexStartName_;\r\n        }\r\n        obj[\"sin\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_IS_INCLUSIVE */] =\r\n            !queryParams.startAfterSet_;\r\n    }\r\n    if (queryParams.endSet_) {\r\n        obj[\"ep\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_VALUE */] = queryParams.indexEndValue_;\r\n        if (queryParams.endNameSet_) {\r\n            obj[\"en\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_NAME */] = queryParams.indexEndName_;\r\n        }\r\n        obj[\"ein\" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_IS_INCLUSIVE */] =\r\n            !queryParams.endBeforeSet_;\r\n    }\r\n    if (queryParams.limitSet_) {\r\n        obj[\"l\" /* WIRE_PROTOCOL_CONSTANTS.LIMIT */] = queryParams.limit_;\r\n        let viewFrom = queryParams.viewFrom_;\r\n        if (viewFrom === '') {\r\n            if (queryParams.isViewFromLeft()) {\r\n                viewFrom = \"l\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT */;\r\n            }\r\n            else {\r\n                viewFrom = \"r\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_RIGHT */;\r\n            }\r\n        }\r\n        obj[\"vf\" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM */] = viewFrom;\r\n    }\r\n    // For now, priority index is the default, so we only specify if it's some other index\r\n    if (queryParams.index_ !== PRIORITY_INDEX) {\r\n        obj[\"i\" /* WIRE_PROTOCOL_CONSTANTS.INDEX */] = queryParams.index_.toString();\r\n    }\r\n    return obj;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An implementation of ServerActions that communicates with the server via REST requests.\r\n * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full\r\n * persistent connection (using WebSockets or long-polling)\r\n */\r\nclass ReadonlyRestClient extends ServerActions {\r\n    /**\r\n     * @param repoInfo_ - Data about the namespace we are connecting to\r\n     * @param onDataUpdate_ - A callback for new data from the server\r\n     */\r\n    constructor(repoInfo_, onDataUpdate_, authTokenProvider_, appCheckTokenProvider_) {\r\n        super();\r\n        this.repoInfo_ = repoInfo_;\r\n        this.onDataUpdate_ = onDataUpdate_;\r\n        this.authTokenProvider_ = authTokenProvider_;\r\n        this.appCheckTokenProvider_ = appCheckTokenProvider_;\r\n        /** @private {function(...[*])} */\r\n        this.log_ = logWrapper('p:rest:');\r\n        /**\r\n         * We don't actually need to track listens, except to prevent us calling an onComplete for a listen\r\n         * that's been removed. :-/\r\n         */\r\n        this.listens_ = {};\r\n    }\r\n    reportStats(stats) {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n    static getListenId_(query, tag) {\r\n        if (tag !== undefined) {\r\n            return 'tag$' + tag;\r\n        }\r\n        else {\r\n            index_esm2017_assert(query._queryParams.isDefault(), \"should have a tag if it's not a default query.\");\r\n            return query._path.toString();\r\n        }\r\n    }\r\n    /** @inheritDoc */\r\n    listen(query, currentHashFn, tag, onComplete) {\r\n        const pathString = query._path.toString();\r\n        this.log_('Listen called for ' + pathString + ' ' + query._queryIdentifier);\r\n        // Mark this listener so we can tell if it's removed.\r\n        const listenId = ReadonlyRestClient.getListenId_(query, tag);\r\n        const thisListen = {};\r\n        this.listens_[listenId] = thisListen;\r\n        const queryStringParameters = queryParamsToRestQueryStringParameters(query._queryParams);\r\n        this.restRequest_(pathString + '.json', queryStringParameters, (error, result) => {\r\n            let data = result;\r\n            if (error === 404) {\r\n                data = null;\r\n                error = null;\r\n            }\r\n            if (error === null) {\r\n                this.onDataUpdate_(pathString, data, /*isMerge=*/ false, tag);\r\n            }\r\n            if (index_esm2017_safeGet(this.listens_, listenId) === thisListen) {\r\n                let status;\r\n                if (!error) {\r\n                    status = 'ok';\r\n                }\r\n                else if (error === 401) {\r\n                    status = 'permission_denied';\r\n                }\r\n                else {\r\n                    status = 'rest_error:' + error;\r\n                }\r\n                onComplete(status, null);\r\n            }\r\n        });\r\n    }\r\n    /** @inheritDoc */\r\n    unlisten(query, tag) {\r\n        const listenId = ReadonlyRestClient.getListenId_(query, tag);\r\n        delete this.listens_[listenId];\r\n    }\r\n    get(query) {\r\n        const queryStringParameters = queryParamsToRestQueryStringParameters(query._queryParams);\r\n        const pathString = query._path.toString();\r\n        const deferred = new index_esm2017_Deferred();\r\n        this.restRequest_(pathString + '.json', queryStringParameters, (error, result) => {\r\n            let data = result;\r\n            if (error === 404) {\r\n                data = null;\r\n                error = null;\r\n            }\r\n            if (error === null) {\r\n                this.onDataUpdate_(pathString, data, \r\n                /*isMerge=*/ false, \r\n                /*tag=*/ null);\r\n                deferred.resolve(data);\r\n            }\r\n            else {\r\n                deferred.reject(new Error(data));\r\n            }\r\n        });\r\n        return deferred.promise;\r\n    }\r\n    /** @inheritDoc */\r\n    refreshAuthToken(token) {\r\n        // no-op since we just always call getToken.\r\n    }\r\n    /**\r\n     * Performs a REST request to the given path, with the provided query string parameters,\r\n     * and any auth credentials we have.\r\n     */\r\n    restRequest_(pathString, queryStringParameters = {}, callback) {\r\n        queryStringParameters['format'] = 'export';\r\n        return Promise.all([\r\n            this.authTokenProvider_.getToken(/*forceRefresh=*/ false),\r\n            this.appCheckTokenProvider_.getToken(/*forceRefresh=*/ false)\r\n        ]).then(([authToken, appCheckToken]) => {\r\n            if (authToken && authToken.accessToken) {\r\n                queryStringParameters['auth'] = authToken.accessToken;\r\n            }\r\n            if (appCheckToken && appCheckToken.token) {\r\n                queryStringParameters['ac'] = appCheckToken.token;\r\n            }\r\n            const url = (this.repoInfo_.secure ? 'https://' : 'http://') +\r\n                this.repoInfo_.host +\r\n                pathString +\r\n                '?' +\r\n                'ns=' +\r\n                this.repoInfo_.namespace +\r\n                querystring(queryStringParameters);\r\n            this.log_('Sending REST request for ' + url);\r\n            const xhr = new XMLHttpRequest();\r\n            xhr.onreadystatechange = () => {\r\n                if (callback && xhr.readyState === 4) {\r\n                    this.log_('REST Response for ' + url + ' received. status:', xhr.status, 'response:', xhr.responseText);\r\n                    let res = null;\r\n                    if (xhr.status >= 200 && xhr.status < 300) {\r\n                        try {\r\n                            res = jsonEval(xhr.responseText);\r\n                        }\r\n                        catch (e) {\r\n                            warn('Failed to parse JSON response for ' +\r\n                                url +\r\n                                ': ' +\r\n                                xhr.responseText);\r\n                        }\r\n                        callback(null, res);\r\n                    }\r\n                    else {\r\n                        // 401 and 404 are expected.\r\n                        if (xhr.status !== 401 && xhr.status !== 404) {\r\n                            warn('Got unsuccessful REST response for ' +\r\n                                url +\r\n                                ' Status: ' +\r\n                                xhr.status);\r\n                        }\r\n                        callback(xhr.status);\r\n                    }\r\n                    callback = null;\r\n                }\r\n            };\r\n            xhr.open('GET', url, /*asynchronous=*/ true);\r\n            xhr.send();\r\n        });\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Mutable object which basically just stores a reference to the \"latest\" immutable snapshot.\r\n */\r\nclass SnapshotHolder {\r\n    constructor() {\r\n        this.rootNode_ = ChildrenNode.EMPTY_NODE;\r\n    }\r\n    getNode(path) {\r\n        return this.rootNode_.getChild(path);\r\n    }\r\n    updateSnapshot(path, newSnapshotNode) {\r\n        this.rootNode_ = this.rootNode_.updateChild(path, newSnapshotNode);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction newSparseSnapshotTree() {\r\n    return {\r\n        value: null,\r\n        children: new Map()\r\n    };\r\n}\r\n/**\r\n * Stores the given node at the specified path. If there is already a node\r\n * at a shallower path, it merges the new data into that snapshot node.\r\n *\r\n * @param path - Path to look up snapshot for.\r\n * @param data - The new data, or null.\r\n */\r\nfunction sparseSnapshotTreeRemember(sparseSnapshotTree, path, data) {\r\n    if (pathIsEmpty(path)) {\r\n        sparseSnapshotTree.value = data;\r\n        sparseSnapshotTree.children.clear();\r\n    }\r\n    else if (sparseSnapshotTree.value !== null) {\r\n        sparseSnapshotTree.value = sparseSnapshotTree.value.updateChild(path, data);\r\n    }\r\n    else {\r\n        const childKey = pathGetFront(path);\r\n        if (!sparseSnapshotTree.children.has(childKey)) {\r\n            sparseSnapshotTree.children.set(childKey, newSparseSnapshotTree());\r\n        }\r\n        const child = sparseSnapshotTree.children.get(childKey);\r\n        path = pathPopFront(path);\r\n        sparseSnapshotTreeRemember(child, path, data);\r\n    }\r\n}\r\n/**\r\n * Purge the data at path from the cache.\r\n *\r\n * @param path - Path to look up snapshot for.\r\n * @returns True if this node should now be removed.\r\n */\r\nfunction sparseSnapshotTreeForget(sparseSnapshotTree, path) {\r\n    if (pathIsEmpty(path)) {\r\n        sparseSnapshotTree.value = null;\r\n        sparseSnapshotTree.children.clear();\r\n        return true;\r\n    }\r\n    else {\r\n        if (sparseSnapshotTree.value !== null) {\r\n            if (sparseSnapshotTree.value.isLeafNode()) {\r\n                // We're trying to forget a node that doesn't exist\r\n                return false;\r\n            }\r\n            else {\r\n                const value = sparseSnapshotTree.value;\r\n                sparseSnapshotTree.value = null;\r\n                value.forEachChild(PRIORITY_INDEX, (key, tree) => {\r\n                    sparseSnapshotTreeRemember(sparseSnapshotTree, new Path(key), tree);\r\n                });\r\n                return sparseSnapshotTreeForget(sparseSnapshotTree, path);\r\n            }\r\n        }\r\n        else if (sparseSnapshotTree.children.size > 0) {\r\n            const childKey = pathGetFront(path);\r\n            path = pathPopFront(path);\r\n            if (sparseSnapshotTree.children.has(childKey)) {\r\n                const safeToRemove = sparseSnapshotTreeForget(sparseSnapshotTree.children.get(childKey), path);\r\n                if (safeToRemove) {\r\n                    sparseSnapshotTree.children.delete(childKey);\r\n                }\r\n            }\r\n            return sparseSnapshotTree.children.size === 0;\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Recursively iterates through all of the stored tree and calls the\r\n * callback on each one.\r\n *\r\n * @param prefixPath - Path to look up node for.\r\n * @param func - The function to invoke for each tree.\r\n */\r\nfunction sparseSnapshotTreeForEachTree(sparseSnapshotTree, prefixPath, func) {\r\n    if (sparseSnapshotTree.value !== null) {\r\n        func(prefixPath, sparseSnapshotTree.value);\r\n    }\r\n    else {\r\n        sparseSnapshotTreeForEachChild(sparseSnapshotTree, (key, tree) => {\r\n            const path = new Path(prefixPath.toString() + '/' + key);\r\n            sparseSnapshotTreeForEachTree(tree, path, func);\r\n        });\r\n    }\r\n}\r\n/**\r\n * Iterates through each immediate child and triggers the callback.\r\n * Only seems to be used in tests.\r\n *\r\n * @param func - The function to invoke for each child.\r\n */\r\nfunction sparseSnapshotTreeForEachChild(sparseSnapshotTree, func) {\r\n    sparseSnapshotTree.children.forEach((tree, key) => {\r\n        func(key, tree);\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns the delta from the previous call to get stats.\r\n *\r\n * @param collection_ - The collection to \"listen\" to.\r\n */\r\nclass StatsListener {\r\n    constructor(collection_) {\r\n        this.collection_ = collection_;\r\n        this.last_ = null;\r\n    }\r\n    get() {\r\n        const newStats = this.collection_.get();\r\n        const delta = Object.assign({}, newStats);\r\n        if (this.last_) {\r\n            each(this.last_, (stat, value) => {\r\n                delta[stat] = delta[stat] - value;\r\n            });\r\n        }\r\n        this.last_ = newStats;\r\n        return delta;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Assuming some apps may have a short amount of time on page, and a bulk of firebase operations probably\r\n// happen on page load, we try to report our first set of stats pretty quickly, but we wait at least 10\r\n// seconds to try to ensure the Firebase connection is established / settled.\r\nconst FIRST_STATS_MIN_TIME = 10 * 1000;\r\nconst FIRST_STATS_MAX_TIME = 30 * 1000;\r\n// We'll continue to report stats on average every 5 minutes.\r\nconst REPORT_STATS_INTERVAL = 5 * 60 * 1000;\r\nclass StatsReporter {\r\n    constructor(collection, server_) {\r\n        this.server_ = server_;\r\n        this.statsToReport_ = {};\r\n        this.statsListener_ = new StatsListener(collection);\r\n        const timeout = FIRST_STATS_MIN_TIME +\r\n            (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();\r\n        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));\r\n    }\r\n    reportStats_() {\r\n        const stats = this.statsListener_.get();\r\n        const reportedStats = {};\r\n        let haveStatsToReport = false;\r\n        each(stats, (stat, value) => {\r\n            if (value > 0 && index_esm2017_contains(this.statsToReport_, stat)) {\r\n                reportedStats[stat] = value;\r\n                haveStatsToReport = true;\r\n            }\r\n        });\r\n        if (haveStatsToReport) {\r\n            this.server_.reportStats(reportedStats);\r\n        }\r\n        // queue our next run.\r\n        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n *\r\n * @enum\r\n */\r\nvar OperationType;\r\n(function (OperationType) {\r\n    OperationType[OperationType[\"OVERWRITE\"] = 0] = \"OVERWRITE\";\r\n    OperationType[OperationType[\"MERGE\"] = 1] = \"MERGE\";\r\n    OperationType[OperationType[\"ACK_USER_WRITE\"] = 2] = \"ACK_USER_WRITE\";\r\n    OperationType[OperationType[\"LISTEN_COMPLETE\"] = 3] = \"LISTEN_COMPLETE\";\r\n})(OperationType || (OperationType = {}));\r\nfunction newOperationSourceUser() {\r\n    return {\r\n        fromUser: true,\r\n        fromServer: false,\r\n        queryId: null,\r\n        tagged: false\r\n    };\r\n}\r\nfunction newOperationSourceServer() {\r\n    return {\r\n        fromUser: false,\r\n        fromServer: true,\r\n        queryId: null,\r\n        tagged: false\r\n    };\r\n}\r\nfunction newOperationSourceServerTaggedQuery(queryId) {\r\n    return {\r\n        fromUser: false,\r\n        fromServer: true,\r\n        queryId,\r\n        tagged: true\r\n    };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass AckUserWrite {\r\n    /**\r\n     * @param affectedTree - A tree containing true for each affected path. Affected paths can't overlap.\r\n     */\r\n    constructor(\r\n    /** @inheritDoc */ path, \r\n    /** @inheritDoc */ affectedTree, \r\n    /** @inheritDoc */ revert) {\r\n        this.path = path;\r\n        this.affectedTree = affectedTree;\r\n        this.revert = revert;\r\n        /** @inheritDoc */\r\n        this.type = OperationType.ACK_USER_WRITE;\r\n        /** @inheritDoc */\r\n        this.source = newOperationSourceUser();\r\n    }\r\n    operationForChild(childName) {\r\n        if (!pathIsEmpty(this.path)) {\r\n            index_esm2017_assert(pathGetFront(this.path) === childName, 'operationForChild called for unrelated child.');\r\n            return new AckUserWrite(pathPopFront(this.path), this.affectedTree, this.revert);\r\n        }\r\n        else if (this.affectedTree.value != null) {\r\n            index_esm2017_assert(this.affectedTree.children.isEmpty(), 'affectedTree should not have overlapping affected paths.');\r\n            // All child locations are affected as well; just return same operation.\r\n            return this;\r\n        }\r\n        else {\r\n            const childTree = this.affectedTree.subtree(new Path(childName));\r\n            return new AckUserWrite(newEmptyPath(), childTree, this.revert);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass ListenComplete {\r\n    constructor(source, path) {\r\n        this.source = source;\r\n        this.path = path;\r\n        /** @inheritDoc */\r\n        this.type = OperationType.LISTEN_COMPLETE;\r\n    }\r\n    operationForChild(childName) {\r\n        if (pathIsEmpty(this.path)) {\r\n            return new ListenComplete(this.source, newEmptyPath());\r\n        }\r\n        else {\r\n            return new ListenComplete(this.source, pathPopFront(this.path));\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass Overwrite {\r\n    constructor(source, path, snap) {\r\n        this.source = source;\r\n        this.path = path;\r\n        this.snap = snap;\r\n        /** @inheritDoc */\r\n        this.type = OperationType.OVERWRITE;\r\n    }\r\n    operationForChild(childName) {\r\n        if (pathIsEmpty(this.path)) {\r\n            return new Overwrite(this.source, newEmptyPath(), this.snap.getImmediateChild(childName));\r\n        }\r\n        else {\r\n            return new Overwrite(this.source, pathPopFront(this.path), this.snap);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass Merge {\r\n    constructor(\r\n    /** @inheritDoc */ source, \r\n    /** @inheritDoc */ path, \r\n    /** @inheritDoc */ children) {\r\n        this.source = source;\r\n        this.path = path;\r\n        this.children = children;\r\n        /** @inheritDoc */\r\n        this.type = OperationType.MERGE;\r\n    }\r\n    operationForChild(childName) {\r\n        if (pathIsEmpty(this.path)) {\r\n            const childTree = this.children.subtree(new Path(childName));\r\n            if (childTree.isEmpty()) {\r\n                // This child is unaffected\r\n                return null;\r\n            }\r\n            else if (childTree.value) {\r\n                // We have a snapshot for the child in question.  This becomes an overwrite of the child.\r\n                return new Overwrite(this.source, newEmptyPath(), childTree.value);\r\n            }\r\n            else {\r\n                // This is a merge at a deeper level\r\n                return new Merge(this.source, newEmptyPath(), childTree);\r\n            }\r\n        }\r\n        else {\r\n            index_esm2017_assert(pathGetFront(this.path) === childName, \"Can't get a merge for a child not on the path of the operation\");\r\n            return new Merge(this.source, pathPopFront(this.path), this.children);\r\n        }\r\n    }\r\n    toString() {\r\n        return ('Operation(' +\r\n            this.path +\r\n            ': ' +\r\n            this.source.toString() +\r\n            ' merge: ' +\r\n            this.children.toString() +\r\n            ')');\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A cache node only stores complete children. Additionally it holds a flag whether the node can be considered fully\r\n * initialized in the sense that we know at one point in time this represented a valid state of the world, e.g.\r\n * initialized with data from the server, or a complete overwrite by the client. The filtered flag also tracks\r\n * whether a node potentially had children removed due to a filter.\r\n */\r\nclass CacheNode {\r\n    constructor(node_, fullyInitialized_, filtered_) {\r\n        this.node_ = node_;\r\n        this.fullyInitialized_ = fullyInitialized_;\r\n        this.filtered_ = filtered_;\r\n    }\r\n    /**\r\n     * Returns whether this node was fully initialized with either server data or a complete overwrite by the client\r\n     */\r\n    isFullyInitialized() {\r\n        return this.fullyInitialized_;\r\n    }\r\n    /**\r\n     * Returns whether this node is potentially missing children due to a filter applied to the node\r\n     */\r\n    isFiltered() {\r\n        return this.filtered_;\r\n    }\r\n    isCompleteForPath(path) {\r\n        if (pathIsEmpty(path)) {\r\n            return this.isFullyInitialized() && !this.filtered_;\r\n        }\r\n        const childKey = pathGetFront(path);\r\n        return this.isCompleteForChild(childKey);\r\n    }\r\n    isCompleteForChild(key) {\r\n        return ((this.isFullyInitialized() && !this.filtered_) || this.node_.hasChild(key));\r\n    }\r\n    getNode() {\r\n        return this.node_;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An EventGenerator is used to convert \"raw\" changes (Change) as computed by the\r\n * CacheDiffer into actual events (Event) that can be raised.  See generateEventsForChanges()\r\n * for details.\r\n *\r\n */\r\nclass EventGenerator {\r\n    constructor(query_) {\r\n        this.query_ = query_;\r\n        this.index_ = this.query_._queryParams.getIndex();\r\n    }\r\n}\r\n/**\r\n * Given a set of raw changes (no moved events and prevName not specified yet), and a set of\r\n * EventRegistrations that should be notified of these changes, generate the actual events to be raised.\r\n *\r\n * Notes:\r\n *  - child_moved events will be synthesized at this time for any child_changed events that affect\r\n *    our index.\r\n *  - prevName will be calculated based on the index ordering.\r\n */\r\nfunction eventGeneratorGenerateEventsForChanges(eventGenerator, changes, eventCache, eventRegistrations) {\r\n    const events = [];\r\n    const moves = [];\r\n    changes.forEach(change => {\r\n        if (change.type === \"child_changed\" /* ChangeType.CHILD_CHANGED */ &&\r\n            eventGenerator.index_.indexedValueChanged(change.oldSnap, change.snapshotNode)) {\r\n            moves.push(changeChildMoved(change.childName, change.snapshotNode));\r\n        }\r\n    });\r\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"child_removed\" /* ChangeType.CHILD_REMOVED */, changes, eventRegistrations, eventCache);\r\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"child_added\" /* ChangeType.CHILD_ADDED */, changes, eventRegistrations, eventCache);\r\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"child_moved\" /* ChangeType.CHILD_MOVED */, moves, eventRegistrations, eventCache);\r\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"child_changed\" /* ChangeType.CHILD_CHANGED */, changes, eventRegistrations, eventCache);\r\n    eventGeneratorGenerateEventsForType(eventGenerator, events, \"value\" /* ChangeType.VALUE */, changes, eventRegistrations, eventCache);\r\n    return events;\r\n}\r\n/**\r\n * Given changes of a single change type, generate the corresponding events.\r\n */\r\nfunction eventGeneratorGenerateEventsForType(eventGenerator, events, eventType, changes, registrations, eventCache) {\r\n    const filteredChanges = changes.filter(change => change.type === eventType);\r\n    filteredChanges.sort((a, b) => eventGeneratorCompareChanges(eventGenerator, a, b));\r\n    filteredChanges.forEach(change => {\r\n        const materializedChange = eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache);\r\n        registrations.forEach(registration => {\r\n            if (registration.respondsTo(change.type)) {\r\n                events.push(registration.createEvent(materializedChange, eventGenerator.query_));\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache) {\r\n    if (change.type === 'value' || change.type === 'child_removed') {\r\n        return change;\r\n    }\r\n    else {\r\n        change.prevName = eventCache.getPredecessorChildName(change.childName, change.snapshotNode, eventGenerator.index_);\r\n        return change;\r\n    }\r\n}\r\nfunction eventGeneratorCompareChanges(eventGenerator, a, b) {\r\n    if (a.childName == null || b.childName == null) {\r\n        throw assertionError('Should only compare child_ events.');\r\n    }\r\n    const aWrapped = new NamedNode(a.childName, a.snapshotNode);\r\n    const bWrapped = new NamedNode(b.childName, b.snapshotNode);\r\n    return eventGenerator.index_.compare(aWrapped, bWrapped);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction newViewCache(eventCache, serverCache) {\r\n    return { eventCache, serverCache };\r\n}\r\nfunction viewCacheUpdateEventSnap(viewCache, eventSnap, complete, filtered) {\r\n    return newViewCache(new CacheNode(eventSnap, complete, filtered), viewCache.serverCache);\r\n}\r\nfunction viewCacheUpdateServerSnap(viewCache, serverSnap, complete, filtered) {\r\n    return newViewCache(viewCache.eventCache, new CacheNode(serverSnap, complete, filtered));\r\n}\r\nfunction viewCacheGetCompleteEventSnap(viewCache) {\r\n    return viewCache.eventCache.isFullyInitialized()\r\n        ? viewCache.eventCache.getNode()\r\n        : null;\r\n}\r\nfunction viewCacheGetCompleteServerSnap(viewCache) {\r\n    return viewCache.serverCache.isFullyInitialized()\r\n        ? viewCache.serverCache.getNode()\r\n        : null;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nlet emptyChildrenSingleton;\r\n/**\r\n * Singleton empty children collection.\r\n *\r\n */\r\nconst EmptyChildren = () => {\r\n    if (!emptyChildrenSingleton) {\r\n        emptyChildrenSingleton = new SortedMap(stringCompare);\r\n    }\r\n    return emptyChildrenSingleton;\r\n};\r\n/**\r\n * A tree with immutable elements.\r\n */\r\nclass ImmutableTree {\r\n    constructor(value, children = EmptyChildren()) {\r\n        this.value = value;\r\n        this.children = children;\r\n    }\r\n    static fromObject(obj) {\r\n        let tree = new ImmutableTree(null);\r\n        each(obj, (childPath, childSnap) => {\r\n            tree = tree.set(new Path(childPath), childSnap);\r\n        });\r\n        return tree;\r\n    }\r\n    /**\r\n     * True if the value is empty and there are no children\r\n     */\r\n    isEmpty() {\r\n        return this.value === null && this.children.isEmpty();\r\n    }\r\n    /**\r\n     * Given a path and predicate, return the first node and the path to that node\r\n     * where the predicate returns true.\r\n     *\r\n     * TODO Do a perf test -- If we're creating a bunch of `{path: value:}`\r\n     * objects on the way back out, it may be better to pass down a pathSoFar obj.\r\n     *\r\n     * @param relativePath - The remainder of the path\r\n     * @param predicate - The predicate to satisfy to return a node\r\n     */\r\n    findRootMostMatchingPathAndValue(relativePath, predicate) {\r\n        if (this.value != null && predicate(this.value)) {\r\n            return { path: newEmptyPath(), value: this.value };\r\n        }\r\n        else {\r\n            if (pathIsEmpty(relativePath)) {\r\n                return null;\r\n            }\r\n            else {\r\n                const front = pathGetFront(relativePath);\r\n                const child = this.children.get(front);\r\n                if (child !== null) {\r\n                    const childExistingPathAndValue = child.findRootMostMatchingPathAndValue(pathPopFront(relativePath), predicate);\r\n                    if (childExistingPathAndValue != null) {\r\n                        const fullPath = pathChild(new Path(front), childExistingPathAndValue.path);\r\n                        return { path: fullPath, value: childExistingPathAndValue.value };\r\n                    }\r\n                    else {\r\n                        return null;\r\n                    }\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Find, if it exists, the shortest subpath of the given path that points a defined\r\n     * value in the tree\r\n     */\r\n    findRootMostValueAndPath(relativePath) {\r\n        return this.findRootMostMatchingPathAndValue(relativePath, () => true);\r\n    }\r\n    /**\r\n     * @returns The subtree at the given path\r\n     */\r\n    subtree(relativePath) {\r\n        if (pathIsEmpty(relativePath)) {\r\n            return this;\r\n        }\r\n        else {\r\n            const front = pathGetFront(relativePath);\r\n            const childTree = this.children.get(front);\r\n            if (childTree !== null) {\r\n                return childTree.subtree(pathPopFront(relativePath));\r\n            }\r\n            else {\r\n                return new ImmutableTree(null);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Sets a value at the specified path.\r\n     *\r\n     * @param relativePath - Path to set value at.\r\n     * @param toSet - Value to set.\r\n     * @returns Resulting tree.\r\n     */\r\n    set(relativePath, toSet) {\r\n        if (pathIsEmpty(relativePath)) {\r\n            return new ImmutableTree(toSet, this.children);\r\n        }\r\n        else {\r\n            const front = pathGetFront(relativePath);\r\n            const child = this.children.get(front) || new ImmutableTree(null);\r\n            const newChild = child.set(pathPopFront(relativePath), toSet);\r\n            const newChildren = this.children.insert(front, newChild);\r\n            return new ImmutableTree(this.value, newChildren);\r\n        }\r\n    }\r\n    /**\r\n     * Removes the value at the specified path.\r\n     *\r\n     * @param relativePath - Path to value to remove.\r\n     * @returns Resulting tree.\r\n     */\r\n    remove(relativePath) {\r\n        if (pathIsEmpty(relativePath)) {\r\n            if (this.children.isEmpty()) {\r\n                return new ImmutableTree(null);\r\n            }\r\n            else {\r\n                return new ImmutableTree(null, this.children);\r\n            }\r\n        }\r\n        else {\r\n            const front = pathGetFront(relativePath);\r\n            const child = this.children.get(front);\r\n            if (child) {\r\n                const newChild = child.remove(pathPopFront(relativePath));\r\n                let newChildren;\r\n                if (newChild.isEmpty()) {\r\n                    newChildren = this.children.remove(front);\r\n                }\r\n                else {\r\n                    newChildren = this.children.insert(front, newChild);\r\n                }\r\n                if (this.value === null && newChildren.isEmpty()) {\r\n                    return new ImmutableTree(null);\r\n                }\r\n                else {\r\n                    return new ImmutableTree(this.value, newChildren);\r\n                }\r\n            }\r\n            else {\r\n                return this;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Gets a value from the tree.\r\n     *\r\n     * @param relativePath - Path to get value for.\r\n     * @returns Value at path, or null.\r\n     */\r\n    get(relativePath) {\r\n        if (pathIsEmpty(relativePath)) {\r\n            return this.value;\r\n        }\r\n        else {\r\n            const front = pathGetFront(relativePath);\r\n            const child = this.children.get(front);\r\n            if (child) {\r\n                return child.get(pathPopFront(relativePath));\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Replace the subtree at the specified path with the given new tree.\r\n     *\r\n     * @param relativePath - Path to replace subtree for.\r\n     * @param newTree - New tree.\r\n     * @returns Resulting tree.\r\n     */\r\n    setTree(relativePath, newTree) {\r\n        if (pathIsEmpty(relativePath)) {\r\n            return newTree;\r\n        }\r\n        else {\r\n            const front = pathGetFront(relativePath);\r\n            const child = this.children.get(front) || new ImmutableTree(null);\r\n            const newChild = child.setTree(pathPopFront(relativePath), newTree);\r\n            let newChildren;\r\n            if (newChild.isEmpty()) {\r\n                newChildren = this.children.remove(front);\r\n            }\r\n            else {\r\n                newChildren = this.children.insert(front, newChild);\r\n            }\r\n            return new ImmutableTree(this.value, newChildren);\r\n        }\r\n    }\r\n    /**\r\n     * Performs a depth first fold on this tree. Transforms a tree into a single\r\n     * value, given a function that operates on the path to a node, an optional\r\n     * current value, and a map of child names to folded subtrees\r\n     */\r\n    fold(fn) {\r\n        return this.fold_(newEmptyPath(), fn);\r\n    }\r\n    /**\r\n     * Recursive helper for public-facing fold() method\r\n     */\r\n    fold_(pathSoFar, fn) {\r\n        const accum = {};\r\n        this.children.inorderTraversal((childKey, childTree) => {\r\n            accum[childKey] = childTree.fold_(pathChild(pathSoFar, childKey), fn);\r\n        });\r\n        return fn(pathSoFar, this.value, accum);\r\n    }\r\n    /**\r\n     * Find the first matching value on the given path. Return the result of applying f to it.\r\n     */\r\n    findOnPath(path, f) {\r\n        return this.findOnPath_(path, newEmptyPath(), f);\r\n    }\r\n    findOnPath_(pathToFollow, pathSoFar, f) {\r\n        const result = this.value ? f(pathSoFar, this.value) : false;\r\n        if (result) {\r\n            return result;\r\n        }\r\n        else {\r\n            if (pathIsEmpty(pathToFollow)) {\r\n                return null;\r\n            }\r\n            else {\r\n                const front = pathGetFront(pathToFollow);\r\n                const nextChild = this.children.get(front);\r\n                if (nextChild) {\r\n                    return nextChild.findOnPath_(pathPopFront(pathToFollow), pathChild(pathSoFar, front), f);\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    foreachOnPath(path, f) {\r\n        return this.foreachOnPath_(path, newEmptyPath(), f);\r\n    }\r\n    foreachOnPath_(pathToFollow, currentRelativePath, f) {\r\n        if (pathIsEmpty(pathToFollow)) {\r\n            return this;\r\n        }\r\n        else {\r\n            if (this.value) {\r\n                f(currentRelativePath, this.value);\r\n            }\r\n            const front = pathGetFront(pathToFollow);\r\n            const nextChild = this.children.get(front);\r\n            if (nextChild) {\r\n                return nextChild.foreachOnPath_(pathPopFront(pathToFollow), pathChild(currentRelativePath, front), f);\r\n            }\r\n            else {\r\n                return new ImmutableTree(null);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Calls the given function for each node in the tree that has a value.\r\n     *\r\n     * @param f - A function to be called with the path from the root of the tree to\r\n     * a node, and the value at that node. Called in depth-first order.\r\n     */\r\n    foreach(f) {\r\n        this.foreach_(newEmptyPath(), f);\r\n    }\r\n    foreach_(currentRelativePath, f) {\r\n        this.children.inorderTraversal((childName, childTree) => {\r\n            childTree.foreach_(pathChild(currentRelativePath, childName), f);\r\n        });\r\n        if (this.value) {\r\n            f(currentRelativePath, this.value);\r\n        }\r\n    }\r\n    foreachChild(f) {\r\n        this.children.inorderTraversal((childName, childTree) => {\r\n            if (childTree.value) {\r\n                f(childName, childTree.value);\r\n            }\r\n        });\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with\r\n * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write\r\n * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write\r\n * to reflect the write added.\r\n */\r\nclass CompoundWrite {\r\n    constructor(writeTree_) {\r\n        this.writeTree_ = writeTree_;\r\n    }\r\n    static empty() {\r\n        return new CompoundWrite(new ImmutableTree(null));\r\n    }\r\n}\r\nfunction compoundWriteAddWrite(compoundWrite, path, node) {\r\n    if (pathIsEmpty(path)) {\r\n        return new CompoundWrite(new ImmutableTree(node));\r\n    }\r\n    else {\r\n        const rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);\r\n        if (rootmost != null) {\r\n            const rootMostPath = rootmost.path;\r\n            let value = rootmost.value;\r\n            const relativePath = newRelativePath(rootMostPath, path);\r\n            value = value.updateChild(relativePath, node);\r\n            return new CompoundWrite(compoundWrite.writeTree_.set(rootMostPath, value));\r\n        }\r\n        else {\r\n            const subtree = new ImmutableTree(node);\r\n            const newWriteTree = compoundWrite.writeTree_.setTree(path, subtree);\r\n            return new CompoundWrite(newWriteTree);\r\n        }\r\n    }\r\n}\r\nfunction compoundWriteAddWrites(compoundWrite, path, updates) {\r\n    let newWrite = compoundWrite;\r\n    each(updates, (childKey, node) => {\r\n        newWrite = compoundWriteAddWrite(newWrite, pathChild(path, childKey), node);\r\n    });\r\n    return newWrite;\r\n}\r\n/**\r\n * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher\r\n * location, which must be removed by calling this method with that path.\r\n *\r\n * @param compoundWrite - The CompoundWrite to remove.\r\n * @param path - The path at which a write and all deeper writes should be removed\r\n * @returns The new CompoundWrite with the removed path\r\n */\r\nfunction compoundWriteRemoveWrite(compoundWrite, path) {\r\n    if (pathIsEmpty(path)) {\r\n        return CompoundWrite.empty();\r\n    }\r\n    else {\r\n        const newWriteTree = compoundWrite.writeTree_.setTree(path, new ImmutableTree(null));\r\n        return new CompoundWrite(newWriteTree);\r\n    }\r\n}\r\n/**\r\n * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be\r\n * considered \"complete\".\r\n *\r\n * @param compoundWrite - The CompoundWrite to check.\r\n * @param path - The path to check for\r\n * @returns Whether there is a complete write at that path\r\n */\r\nfunction compoundWriteHasCompleteWrite(compoundWrite, path) {\r\n    return compoundWriteGetCompleteNode(compoundWrite, path) != null;\r\n}\r\n/**\r\n * Returns a node for a path if and only if the node is a \"complete\" overwrite at that path. This will not aggregate\r\n * writes from deeper paths, but will return child nodes from a more shallow path.\r\n *\r\n * @param compoundWrite - The CompoundWrite to get the node from.\r\n * @param path - The path to get a complete write\r\n * @returns The node if complete at that path, or null otherwise.\r\n */\r\nfunction compoundWriteGetCompleteNode(compoundWrite, path) {\r\n    const rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);\r\n    if (rootmost != null) {\r\n        return compoundWrite.writeTree_\r\n            .get(rootmost.path)\r\n            .getChild(newRelativePath(rootmost.path, path));\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\n/**\r\n * Returns all children that are guaranteed to be a complete overwrite.\r\n *\r\n * @param compoundWrite - The CompoundWrite to get children from.\r\n * @returns A list of all complete children.\r\n */\r\nfunction compoundWriteGetCompleteChildren(compoundWrite) {\r\n    const children = [];\r\n    const node = compoundWrite.writeTree_.value;\r\n    if (node != null) {\r\n        // If it's a leaf node, it has no children; so nothing to do.\r\n        if (!node.isLeafNode()) {\r\n            node.forEachChild(PRIORITY_INDEX, (childName, childNode) => {\r\n                children.push(new NamedNode(childName, childNode));\r\n            });\r\n        }\r\n    }\r\n    else {\r\n        compoundWrite.writeTree_.children.inorderTraversal((childName, childTree) => {\r\n            if (childTree.value != null) {\r\n                children.push(new NamedNode(childName, childTree.value));\r\n            }\r\n        });\r\n    }\r\n    return children;\r\n}\r\nfunction compoundWriteChildCompoundWrite(compoundWrite, path) {\r\n    if (pathIsEmpty(path)) {\r\n        return compoundWrite;\r\n    }\r\n    else {\r\n        const shadowingNode = compoundWriteGetCompleteNode(compoundWrite, path);\r\n        if (shadowingNode != null) {\r\n            return new CompoundWrite(new ImmutableTree(shadowingNode));\r\n        }\r\n        else {\r\n            return new CompoundWrite(compoundWrite.writeTree_.subtree(path));\r\n        }\r\n    }\r\n}\r\n/**\r\n * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.\r\n * @returns Whether this CompoundWrite is empty\r\n */\r\nfunction compoundWriteIsEmpty(compoundWrite) {\r\n    return compoundWrite.writeTree_.isEmpty();\r\n}\r\n/**\r\n * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the\r\n * node\r\n * @param node - The node to apply this CompoundWrite to\r\n * @returns The node with all writes applied\r\n */\r\nfunction compoundWriteApply(compoundWrite, node) {\r\n    return applySubtreeWrite(newEmptyPath(), compoundWrite.writeTree_, node);\r\n}\r\nfunction applySubtreeWrite(relativePath, writeTree, node) {\r\n    if (writeTree.value != null) {\r\n        // Since there a write is always a leaf, we're done here\r\n        return node.updateChild(relativePath, writeTree.value);\r\n    }\r\n    else {\r\n        let priorityWrite = null;\r\n        writeTree.children.inorderTraversal((childKey, childTree) => {\r\n            if (childKey === '.priority') {\r\n                // Apply priorities at the end so we don't update priorities for either empty nodes or forget\r\n                // to apply priorities to empty nodes that are later filled\r\n                index_esm2017_assert(childTree.value !== null, 'Priority writes must always be leaf nodes');\r\n                priorityWrite = childTree.value;\r\n            }\r\n            else {\r\n                node = applySubtreeWrite(pathChild(relativePath, childKey), childTree, node);\r\n            }\r\n        });\r\n        // If there was a priority write, we only apply it if the node is not empty\r\n        if (!node.getChild(relativePath).isEmpty() && priorityWrite !== null) {\r\n            node = node.updateChild(pathChild(relativePath, '.priority'), priorityWrite);\r\n        }\r\n        return node;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.\r\n *\r\n */\r\nfunction writeTreeChildWrites(writeTree, path) {\r\n    return newWriteTreeRef(path, writeTree);\r\n}\r\n/**\r\n * Record a new overwrite from user code.\r\n *\r\n * @param visible - This is set to false by some transactions. It should be excluded from event caches\r\n */\r\nfunction writeTreeAddOverwrite(writeTree, path, snap, writeId, visible) {\r\n    index_esm2017_assert(writeId > writeTree.lastWriteId, 'Stacking an older write on top of newer ones');\r\n    if (visible === undefined) {\r\n        visible = true;\r\n    }\r\n    writeTree.allWrites.push({\r\n        path,\r\n        snap,\r\n        writeId,\r\n        visible\r\n    });\r\n    if (visible) {\r\n        writeTree.visibleWrites = compoundWriteAddWrite(writeTree.visibleWrites, path, snap);\r\n    }\r\n    writeTree.lastWriteId = writeId;\r\n}\r\n/**\r\n * Record a new merge from user code.\r\n */\r\nfunction writeTreeAddMerge(writeTree, path, changedChildren, writeId) {\r\n    assert(writeId > writeTree.lastWriteId, 'Stacking an older merge on top of newer ones');\r\n    writeTree.allWrites.push({\r\n        path,\r\n        children: changedChildren,\r\n        writeId,\r\n        visible: true\r\n    });\r\n    writeTree.visibleWrites = compoundWriteAddWrites(writeTree.visibleWrites, path, changedChildren);\r\n    writeTree.lastWriteId = writeId;\r\n}\r\nfunction writeTreeGetWrite(writeTree, writeId) {\r\n    for (let i = 0; i < writeTree.allWrites.length; i++) {\r\n        const record = writeTree.allWrites[i];\r\n        if (record.writeId === writeId) {\r\n            return record;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates\r\n * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.\r\n *\r\n * @returns true if the write may have been visible (meaning we'll need to reevaluate / raise\r\n * events as a result).\r\n */\r\nfunction writeTreeRemoveWrite(writeTree, writeId) {\r\n    // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied\r\n    // out of order.\r\n    //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;\r\n    //assert(validClear, \"Either we don't have this write, or it's the first one in the queue\");\r\n    const idx = writeTree.allWrites.findIndex(s => {\r\n        return s.writeId === writeId;\r\n    });\r\n    index_esm2017_assert(idx >= 0, 'removeWrite called with nonexistent writeId.');\r\n    const writeToRemove = writeTree.allWrites[idx];\r\n    writeTree.allWrites.splice(idx, 1);\r\n    let removedWriteWasVisible = writeToRemove.visible;\r\n    let removedWriteOverlapsWithOtherWrites = false;\r\n    let i = writeTree.allWrites.length - 1;\r\n    while (removedWriteWasVisible && i >= 0) {\r\n        const currentWrite = writeTree.allWrites[i];\r\n        if (currentWrite.visible) {\r\n            if (i >= idx &&\r\n                writeTreeRecordContainsPath_(currentWrite, writeToRemove.path)) {\r\n                // The removed write was completely shadowed by a subsequent write.\r\n                removedWriteWasVisible = false;\r\n            }\r\n            else if (pathContains(writeToRemove.path, currentWrite.path)) {\r\n                // Either we're covering some writes or they're covering part of us (depending on which came first).\r\n                removedWriteOverlapsWithOtherWrites = true;\r\n            }\r\n        }\r\n        i--;\r\n    }\r\n    if (!removedWriteWasVisible) {\r\n        return false;\r\n    }\r\n    else if (removedWriteOverlapsWithOtherWrites) {\r\n        // There's some shadowing going on. Just rebuild the visible writes from scratch.\r\n        writeTreeResetTree_(writeTree);\r\n        return true;\r\n    }\r\n    else {\r\n        // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.\r\n        if (writeToRemove.snap) {\r\n            writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, writeToRemove.path);\r\n        }\r\n        else {\r\n            const children = writeToRemove.children;\r\n            each(children, (childName) => {\r\n                writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, pathChild(writeToRemove.path, childName));\r\n            });\r\n        }\r\n        return true;\r\n    }\r\n}\r\nfunction writeTreeRecordContainsPath_(writeRecord, path) {\r\n    if (writeRecord.snap) {\r\n        return pathContains(writeRecord.path, path);\r\n    }\r\n    else {\r\n        for (const childName in writeRecord.children) {\r\n            if (writeRecord.children.hasOwnProperty(childName) &&\r\n                pathContains(pathChild(writeRecord.path, childName), path)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots\r\n */\r\nfunction writeTreeResetTree_(writeTree) {\r\n    writeTree.visibleWrites = writeTreeLayerTree_(writeTree.allWrites, writeTreeDefaultFilter_, newEmptyPath());\r\n    if (writeTree.allWrites.length > 0) {\r\n        writeTree.lastWriteId =\r\n            writeTree.allWrites[writeTree.allWrites.length - 1].writeId;\r\n    }\r\n    else {\r\n        writeTree.lastWriteId = -1;\r\n    }\r\n}\r\n/**\r\n * The default filter used when constructing the tree. Keep everything that's visible.\r\n */\r\nfunction writeTreeDefaultFilter_(write) {\r\n    return write.visible;\r\n}\r\n/**\r\n * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of\r\n * event data at that path.\r\n */\r\nfunction writeTreeLayerTree_(writes, filter, treeRoot) {\r\n    let compoundWrite = CompoundWrite.empty();\r\n    for (let i = 0; i < writes.length; ++i) {\r\n        const write = writes[i];\r\n        // Theory, a later set will either:\r\n        // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction\r\n        // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction\r\n        if (filter(write)) {\r\n            const writePath = write.path;\r\n            let relativePath;\r\n            if (write.snap) {\r\n                if (pathContains(treeRoot, writePath)) {\r\n                    relativePath = newRelativePath(treeRoot, writePath);\r\n                    compoundWrite = compoundWriteAddWrite(compoundWrite, relativePath, write.snap);\r\n                }\r\n                else if (pathContains(writePath, treeRoot)) {\r\n                    relativePath = newRelativePath(writePath, treeRoot);\r\n                    compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), write.snap.getChild(relativePath));\r\n                }\r\n                else ;\r\n            }\r\n            else if (write.children) {\r\n                if (pathContains(treeRoot, writePath)) {\r\n                    relativePath = newRelativePath(treeRoot, writePath);\r\n                    compoundWrite = compoundWriteAddWrites(compoundWrite, relativePath, write.children);\r\n                }\r\n                else if (pathContains(writePath, treeRoot)) {\r\n                    relativePath = newRelativePath(writePath, treeRoot);\r\n                    if (pathIsEmpty(relativePath)) {\r\n                        compoundWrite = compoundWriteAddWrites(compoundWrite, newEmptyPath(), write.children);\r\n                    }\r\n                    else {\r\n                        const child = index_esm2017_safeGet(write.children, pathGetFront(relativePath));\r\n                        if (child) {\r\n                            // There exists a child in this node that matches the root path\r\n                            const deepNode = child.getChild(pathPopFront(relativePath));\r\n                            compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), deepNode);\r\n                        }\r\n                    }\r\n                }\r\n                else ;\r\n            }\r\n            else {\r\n                throw assertionError('WriteRecord should have .snap or .children');\r\n            }\r\n        }\r\n    }\r\n    return compoundWrite;\r\n}\r\n/**\r\n * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden\r\n * writes), attempt to calculate a complete snapshot for the given path\r\n *\r\n * @param writeIdsToExclude - An optional set to be excluded\r\n * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false\r\n */\r\nfunction writeTreeCalcCompleteEventCache(writeTree, treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {\r\n    if (!writeIdsToExclude && !includeHiddenWrites) {\r\n        const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);\r\n        if (shadowingNode != null) {\r\n            return shadowingNode;\r\n        }\r\n        else {\r\n            const subMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\r\n            if (compoundWriteIsEmpty(subMerge)) {\r\n                return completeServerCache;\r\n            }\r\n            else if (completeServerCache == null &&\r\n                !compoundWriteHasCompleteWrite(subMerge, newEmptyPath())) {\r\n                // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow\r\n                return null;\r\n            }\r\n            else {\r\n                const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\r\n                return compoundWriteApply(subMerge, layeredCache);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\r\n        if (!includeHiddenWrites && compoundWriteIsEmpty(merge)) {\r\n            return completeServerCache;\r\n        }\r\n        else {\r\n            // If the server cache is null, and we don't have a complete cache, we need to return null\r\n            if (!includeHiddenWrites &&\r\n                completeServerCache == null &&\r\n                !compoundWriteHasCompleteWrite(merge, newEmptyPath())) {\r\n                return null;\r\n            }\r\n            else {\r\n                const filter = function (write) {\r\n                    return ((write.visible || includeHiddenWrites) &&\r\n                        (!writeIdsToExclude ||\r\n                            !~writeIdsToExclude.indexOf(write.writeId)) &&\r\n                        (pathContains(write.path, treePath) ||\r\n                            pathContains(treePath, write.path)));\r\n                };\r\n                const mergeAtPath = writeTreeLayerTree_(writeTree.allWrites, filter, treePath);\r\n                const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\r\n                return compoundWriteApply(mergeAtPath, layeredCache);\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * With optional, underlying server data, attempt to return a children node of children that we have complete data for.\r\n * Used when creating new views, to pre-fill their complete event children snapshot.\r\n */\r\nfunction writeTreeCalcCompleteEventChildren(writeTree, treePath, completeServerChildren) {\r\n    let completeChildren = ChildrenNode.EMPTY_NODE;\r\n    const topLevelSet = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);\r\n    if (topLevelSet) {\r\n        if (!topLevelSet.isLeafNode()) {\r\n            // we're shadowing everything. Return the children.\r\n            topLevelSet.forEachChild(PRIORITY_INDEX, (childName, childSnap) => {\r\n                completeChildren = completeChildren.updateImmediateChild(childName, childSnap);\r\n            });\r\n        }\r\n        return completeChildren;\r\n    }\r\n    else if (completeServerChildren) {\r\n        // Layer any children we have on top of this\r\n        // We know we don't have a top-level set, so just enumerate existing children\r\n        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\r\n        completeServerChildren.forEachChild(PRIORITY_INDEX, (childName, childNode) => {\r\n            const node = compoundWriteApply(compoundWriteChildCompoundWrite(merge, new Path(childName)), childNode);\r\n            completeChildren = completeChildren.updateImmediateChild(childName, node);\r\n        });\r\n        // Add any complete children we have from the set\r\n        compoundWriteGetCompleteChildren(merge).forEach(namedNode => {\r\n            completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);\r\n        });\r\n        return completeChildren;\r\n    }\r\n    else {\r\n        // We don't have anything to layer on top of. Layer on any children we have\r\n        // Note that we can return an empty snap if we have a defined delete\r\n        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\r\n        compoundWriteGetCompleteChildren(merge).forEach(namedNode => {\r\n            completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);\r\n        });\r\n        return completeChildren;\r\n    }\r\n}\r\n/**\r\n * Given that the underlying server data has updated, determine what, if anything, needs to be\r\n * applied to the event cache.\r\n *\r\n * Possibilities:\r\n *\r\n * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\r\n *\r\n * 2. Some write is completely shadowing. No events to be raised\r\n *\r\n * 3. Is partially shadowed. Events\r\n *\r\n * Either existingEventSnap or existingServerSnap must exist\r\n */\r\nfunction writeTreeCalcEventCacheAfterServerOverwrite(writeTree, treePath, childPath, existingEventSnap, existingServerSnap) {\r\n    index_esm2017_assert(existingEventSnap || existingServerSnap, 'Either existingEventSnap or existingServerSnap must exist');\r\n    const path = pathChild(treePath, childPath);\r\n    if (compoundWriteHasCompleteWrite(writeTree.visibleWrites, path)) {\r\n        // At this point we can probably guarantee that we're in case 2, meaning no events\r\n        // May need to check visibility while doing the findRootMostValueAndPath call\r\n        return null;\r\n    }\r\n    else {\r\n        // No complete shadowing. We're either partially shadowing or not shadowing at all.\r\n        const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);\r\n        if (compoundWriteIsEmpty(childMerge)) {\r\n            // We're not shadowing at all. Case 1\r\n            return existingServerSnap.getChild(childPath);\r\n        }\r\n        else {\r\n            // This could be more efficient if the serverNode + updates doesn't change the eventSnap\r\n            // However this is tricky to find out, since user updates don't necessary change the server\r\n            // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server\r\n            // adds nodes, but doesn't change any existing writes. It is therefore not enough to\r\n            // only check if the updates change the serverNode.\r\n            // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?\r\n            return compoundWriteApply(childMerge, existingServerSnap.getChild(childPath));\r\n        }\r\n    }\r\n}\r\n/**\r\n * Returns a complete child for a given server snap after applying all user writes or null if there is no\r\n * complete child for this ChildKey.\r\n */\r\nfunction writeTreeCalcCompleteChild(writeTree, treePath, childKey, existingServerSnap) {\r\n    const path = pathChild(treePath, childKey);\r\n    const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, path);\r\n    if (shadowingNode != null) {\r\n        return shadowingNode;\r\n    }\r\n    else {\r\n        if (existingServerSnap.isCompleteForChild(childKey)) {\r\n            const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);\r\n            return compoundWriteApply(childMerge, existingServerSnap.getNode().getImmediateChild(childKey));\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\r\n * a higher path, this will return the child of that write relative to the write and this path.\r\n * Returns null if there is no write at this path.\r\n */\r\nfunction writeTreeShadowingWrite(writeTree, path) {\r\n    return compoundWriteGetCompleteNode(writeTree.visibleWrites, path);\r\n}\r\n/**\r\n * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\r\n * the window, but may now be in the window.\r\n */\r\nfunction writeTreeCalcIndexedSlice(writeTree, treePath, completeServerData, startPost, count, reverse, index) {\r\n    let toIterate;\r\n    const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\r\n    const shadowingNode = compoundWriteGetCompleteNode(merge, newEmptyPath());\r\n    if (shadowingNode != null) {\r\n        toIterate = shadowingNode;\r\n    }\r\n    else if (completeServerData != null) {\r\n        toIterate = compoundWriteApply(merge, completeServerData);\r\n    }\r\n    else {\r\n        // no children to iterate on\r\n        return [];\r\n    }\r\n    toIterate = toIterate.withIndex(index);\r\n    if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {\r\n        const nodes = [];\r\n        const cmp = index.getCompare();\r\n        const iter = reverse\r\n            ? toIterate.getReverseIteratorFrom(startPost, index)\r\n            : toIterate.getIteratorFrom(startPost, index);\r\n        let next = iter.getNext();\r\n        while (next && nodes.length < count) {\r\n            if (cmp(next, startPost) !== 0) {\r\n                nodes.push(next);\r\n            }\r\n            next = iter.getNext();\r\n        }\r\n        return nodes;\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n}\r\nfunction newWriteTree() {\r\n    return {\r\n        visibleWrites: CompoundWrite.empty(),\r\n        allWrites: [],\r\n        lastWriteId: -1\r\n    };\r\n}\r\n/**\r\n * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used\r\n * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node\r\n * can lead to a more expensive calculation.\r\n *\r\n * @param writeIdsToExclude - Optional writes to exclude.\r\n * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false\r\n */\r\nfunction writeTreeRefCalcCompleteEventCache(writeTreeRef, completeServerCache, writeIdsToExclude, includeHiddenWrites) {\r\n    return writeTreeCalcCompleteEventCache(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites);\r\n}\r\n/**\r\n * If possible, returns a children node containing all of the complete children we have data for. The returned data is a\r\n * mix of the given server data and write data.\r\n *\r\n */\r\nfunction writeTreeRefCalcCompleteEventChildren(writeTreeRef, completeServerChildren) {\r\n    return writeTreeCalcCompleteEventChildren(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerChildren);\r\n}\r\n/**\r\n * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,\r\n * if anything, needs to be applied to the event cache.\r\n *\r\n * Possibilities:\r\n *\r\n * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\r\n *\r\n * 2. Some write is completely shadowing. No events to be raised\r\n *\r\n * 3. Is partially shadowed. Events should be raised\r\n *\r\n * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert\r\n *\r\n *\r\n */\r\nfunction writeTreeRefCalcEventCacheAfterServerOverwrite(writeTreeRef, path, existingEventSnap, existingServerSnap) {\r\n    return writeTreeCalcEventCacheAfterServerOverwrite(writeTreeRef.writeTree, writeTreeRef.treePath, path, existingEventSnap, existingServerSnap);\r\n}\r\n/**\r\n * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\r\n * a higher path, this will return the child of that write relative to the write and this path.\r\n * Returns null if there is no write at this path.\r\n *\r\n */\r\nfunction writeTreeRefShadowingWrite(writeTreeRef, path) {\r\n    return writeTreeShadowingWrite(writeTreeRef.writeTree, pathChild(writeTreeRef.treePath, path));\r\n}\r\n/**\r\n * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\r\n * the window, but may now be in the window\r\n */\r\nfunction writeTreeRefCalcIndexedSlice(writeTreeRef, completeServerData, startPost, count, reverse, index) {\r\n    return writeTreeCalcIndexedSlice(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerData, startPost, count, reverse, index);\r\n}\r\n/**\r\n * Returns a complete child for a given server snap after applying all user writes or null if there is no\r\n * complete child for this ChildKey.\r\n */\r\nfunction writeTreeRefCalcCompleteChild(writeTreeRef, childKey, existingServerCache) {\r\n    return writeTreeCalcCompleteChild(writeTreeRef.writeTree, writeTreeRef.treePath, childKey, existingServerCache);\r\n}\r\n/**\r\n * Return a WriteTreeRef for a child.\r\n */\r\nfunction writeTreeRefChild(writeTreeRef, childName) {\r\n    return newWriteTreeRef(pathChild(writeTreeRef.treePath, childName), writeTreeRef.writeTree);\r\n}\r\nfunction newWriteTreeRef(path, writeTree) {\r\n    return {\r\n        treePath: path,\r\n        writeTree\r\n    };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass ChildChangeAccumulator {\r\n    constructor() {\r\n        this.changeMap = new Map();\r\n    }\r\n    trackChildChange(change) {\r\n        const type = change.type;\r\n        const childKey = change.childName;\r\n        index_esm2017_assert(type === \"child_added\" /* ChangeType.CHILD_ADDED */ ||\r\n            type === \"child_changed\" /* ChangeType.CHILD_CHANGED */ ||\r\n            type === \"child_removed\" /* ChangeType.CHILD_REMOVED */, 'Only child changes supported for tracking');\r\n        index_esm2017_assert(childKey !== '.priority', 'Only non-priority child changes can be tracked.');\r\n        const oldChange = this.changeMap.get(childKey);\r\n        if (oldChange) {\r\n            const oldType = oldChange.type;\r\n            if (type === \"child_added\" /* ChangeType.CHILD_ADDED */ &&\r\n                oldType === \"child_removed\" /* ChangeType.CHILD_REMOVED */) {\r\n                this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.snapshotNode));\r\n            }\r\n            else if (type === \"child_removed\" /* ChangeType.CHILD_REMOVED */ &&\r\n                oldType === \"child_added\" /* ChangeType.CHILD_ADDED */) {\r\n                this.changeMap.delete(childKey);\r\n            }\r\n            else if (type === \"child_removed\" /* ChangeType.CHILD_REMOVED */ &&\r\n                oldType === \"child_changed\" /* ChangeType.CHILD_CHANGED */) {\r\n                this.changeMap.set(childKey, changeChildRemoved(childKey, oldChange.oldSnap));\r\n            }\r\n            else if (type === \"child_changed\" /* ChangeType.CHILD_CHANGED */ &&\r\n                oldType === \"child_added\" /* ChangeType.CHILD_ADDED */) {\r\n                this.changeMap.set(childKey, changeChildAdded(childKey, change.snapshotNode));\r\n            }\r\n            else if (type === \"child_changed\" /* ChangeType.CHILD_CHANGED */ &&\r\n                oldType === \"child_changed\" /* ChangeType.CHILD_CHANGED */) {\r\n                this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.oldSnap));\r\n            }\r\n            else {\r\n                throw assertionError('Illegal combination of changes: ' +\r\n                    change +\r\n                    ' occurred after ' +\r\n                    oldChange);\r\n            }\r\n        }\r\n        else {\r\n            this.changeMap.set(childKey, change);\r\n        }\r\n    }\r\n    getChanges() {\r\n        return Array.from(this.changeMap.values());\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An implementation of CompleteChildSource that never returns any additional children\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nclass NoCompleteChildSource_ {\r\n    getCompleteChild(childKey) {\r\n        return null;\r\n    }\r\n    getChildAfterChild(index, child, reverse) {\r\n        return null;\r\n    }\r\n}\r\n/**\r\n * Singleton instance.\r\n */\r\nconst NO_COMPLETE_CHILD_SOURCE = new NoCompleteChildSource_();\r\n/**\r\n * An implementation of CompleteChildSource that uses a WriteTree in addition to any other server data or\r\n * old event caches available to calculate complete children.\r\n */\r\nclass WriteTreeCompleteChildSource {\r\n    constructor(writes_, viewCache_, optCompleteServerCache_ = null) {\r\n        this.writes_ = writes_;\r\n        this.viewCache_ = viewCache_;\r\n        this.optCompleteServerCache_ = optCompleteServerCache_;\r\n    }\r\n    getCompleteChild(childKey) {\r\n        const node = this.viewCache_.eventCache;\r\n        if (node.isCompleteForChild(childKey)) {\r\n            return node.getNode().getImmediateChild(childKey);\r\n        }\r\n        else {\r\n            const serverNode = this.optCompleteServerCache_ != null\r\n                ? new CacheNode(this.optCompleteServerCache_, true, false)\r\n                : this.viewCache_.serverCache;\r\n            return writeTreeRefCalcCompleteChild(this.writes_, childKey, serverNode);\r\n        }\r\n    }\r\n    getChildAfterChild(index, child, reverse) {\r\n        const completeServerData = this.optCompleteServerCache_ != null\r\n            ? this.optCompleteServerCache_\r\n            : viewCacheGetCompleteServerSnap(this.viewCache_);\r\n        const nodes = writeTreeRefCalcIndexedSlice(this.writes_, completeServerData, child, 1, reverse, index);\r\n        if (nodes.length === 0) {\r\n            return null;\r\n        }\r\n        else {\r\n            return nodes[0];\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction newViewProcessor(filter) {\r\n    return { filter };\r\n}\r\nfunction viewProcessorAssertIndexed(viewProcessor, viewCache) {\r\n    index_esm2017_assert(viewCache.eventCache.getNode().isIndexed(viewProcessor.filter.getIndex()), 'Event snap not indexed');\r\n    index_esm2017_assert(viewCache.serverCache.getNode().isIndexed(viewProcessor.filter.getIndex()), 'Server snap not indexed');\r\n}\r\nfunction viewProcessorApplyOperation(viewProcessor, oldViewCache, operation, writesCache, completeCache) {\r\n    const accumulator = new ChildChangeAccumulator();\r\n    let newViewCache, filterServerNode;\r\n    if (operation.type === OperationType.OVERWRITE) {\r\n        const overwrite = operation;\r\n        if (overwrite.source.fromUser) {\r\n            newViewCache = viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);\r\n        }\r\n        else {\r\n            index_esm2017_assert(overwrite.source.fromServer, 'Unknown source.');\r\n            // We filter the node if it's a tagged update or the node has been previously filtered  and the\r\n            // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered\r\n            // again\r\n            filterServerNode =\r\n                overwrite.source.tagged ||\r\n                    (oldViewCache.serverCache.isFiltered() && !pathIsEmpty(overwrite.path));\r\n            newViewCache = viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);\r\n        }\r\n    }\r\n    else if (operation.type === OperationType.MERGE) {\r\n        const merge = operation;\r\n        if (merge.source.fromUser) {\r\n            newViewCache = viewProcessorApplyUserMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);\r\n        }\r\n        else {\r\n            index_esm2017_assert(merge.source.fromServer, 'Unknown source.');\r\n            // We filter the node if it's a tagged update or the node has been previously filtered\r\n            filterServerNode =\r\n                merge.source.tagged || oldViewCache.serverCache.isFiltered();\r\n            newViewCache = viewProcessorApplyServerMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);\r\n        }\r\n    }\r\n    else if (operation.type === OperationType.ACK_USER_WRITE) {\r\n        const ackUserWrite = operation;\r\n        if (!ackUserWrite.revert) {\r\n            newViewCache = viewProcessorAckUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);\r\n        }\r\n        else {\r\n            newViewCache = viewProcessorRevertUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);\r\n        }\r\n    }\r\n    else if (operation.type === OperationType.LISTEN_COMPLETE) {\r\n        newViewCache = viewProcessorListenComplete(viewProcessor, oldViewCache, operation.path, writesCache, accumulator);\r\n    }\r\n    else {\r\n        throw assertionError('Unknown operation type: ' + operation.type);\r\n    }\r\n    const changes = accumulator.getChanges();\r\n    viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache, changes);\r\n    return { viewCache: newViewCache, changes };\r\n}\r\nfunction viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache, accumulator) {\r\n    const eventSnap = newViewCache.eventCache;\r\n    if (eventSnap.isFullyInitialized()) {\r\n        const isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();\r\n        const oldCompleteSnap = viewCacheGetCompleteEventSnap(oldViewCache);\r\n        if (accumulator.length > 0 ||\r\n            !oldViewCache.eventCache.isFullyInitialized() ||\r\n            (isLeafOrEmpty && !eventSnap.getNode().equals(oldCompleteSnap)) ||\r\n            !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())) {\r\n            accumulator.push(changeValue(viewCacheGetCompleteEventSnap(newViewCache)));\r\n        }\r\n    }\r\n}\r\nfunction viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, viewCache, changePath, writesCache, source, accumulator) {\r\n    const oldEventSnap = viewCache.eventCache;\r\n    if (writeTreeRefShadowingWrite(writesCache, changePath) != null) {\r\n        // we have a shadowing write, ignore changes\r\n        return viewCache;\r\n    }\r\n    else {\r\n        let newEventCache, serverNode;\r\n        if (pathIsEmpty(changePath)) {\r\n            // TODO: figure out how this plays with \"sliding ack windows\"\r\n            index_esm2017_assert(viewCache.serverCache.isFullyInitialized(), 'If change path is empty, we must have complete server data');\r\n            if (viewCache.serverCache.isFiltered()) {\r\n                // We need to special case this, because we need to only apply writes to complete children, or\r\n                // we might end up raising events for incomplete children. If the server data is filtered deep\r\n                // writes cannot be guaranteed to be complete\r\n                const serverCache = viewCacheGetCompleteServerSnap(viewCache);\r\n                const completeChildren = serverCache instanceof ChildrenNode\r\n                    ? serverCache\r\n                    : ChildrenNode.EMPTY_NODE;\r\n                const completeEventChildren = writeTreeRefCalcCompleteEventChildren(writesCache, completeChildren);\r\n                newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeEventChildren, accumulator);\r\n            }\r\n            else {\r\n                const completeNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));\r\n                newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeNode, accumulator);\r\n            }\r\n        }\r\n        else {\r\n            const childKey = pathGetFront(changePath);\r\n            if (childKey === '.priority') {\r\n                index_esm2017_assert(pathGetLength(changePath) === 1, \"Can't have a priority with additional path components\");\r\n                const oldEventNode = oldEventSnap.getNode();\r\n                serverNode = viewCache.serverCache.getNode();\r\n                // we might have overwrites for this priority\r\n                const updatedPriority = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventNode, serverNode);\r\n                if (updatedPriority != null) {\r\n                    newEventCache = viewProcessor.filter.updatePriority(oldEventNode, updatedPriority);\r\n                }\r\n                else {\r\n                    // priority didn't change, keep old node\r\n                    newEventCache = oldEventSnap.getNode();\r\n                }\r\n            }\r\n            else {\r\n                const childChangePath = pathPopFront(changePath);\r\n                // update child\r\n                let newEventChild;\r\n                if (oldEventSnap.isCompleteForChild(childKey)) {\r\n                    serverNode = viewCache.serverCache.getNode();\r\n                    const eventChildUpdate = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventSnap.getNode(), serverNode);\r\n                    if (eventChildUpdate != null) {\r\n                        newEventChild = oldEventSnap\r\n                            .getNode()\r\n                            .getImmediateChild(childKey)\r\n                            .updateChild(childChangePath, eventChildUpdate);\r\n                    }\r\n                    else {\r\n                        // Nothing changed, just keep the old child\r\n                        newEventChild = oldEventSnap.getNode().getImmediateChild(childKey);\r\n                    }\r\n                }\r\n                else {\r\n                    newEventChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);\r\n                }\r\n                if (newEventChild != null) {\r\n                    newEventCache = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);\r\n                }\r\n                else {\r\n                    // no complete child available or no change\r\n                    newEventCache = oldEventSnap.getNode();\r\n                }\r\n            }\r\n        }\r\n        return viewCacheUpdateEventSnap(viewCache, newEventCache, oldEventSnap.isFullyInitialized() || pathIsEmpty(changePath), viewProcessor.filter.filtersNodes());\r\n    }\r\n}\r\nfunction viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {\r\n    const oldServerSnap = oldViewCache.serverCache;\r\n    let newServerCache;\r\n    const serverFilter = filterServerNode\r\n        ? viewProcessor.filter\r\n        : viewProcessor.filter.getIndexedFilter();\r\n    if (pathIsEmpty(changePath)) {\r\n        newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);\r\n    }\r\n    else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {\r\n        // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update\r\n        const newServerNode = oldServerSnap\r\n            .getNode()\r\n            .updateChild(changePath, changedSnap);\r\n        newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);\r\n    }\r\n    else {\r\n        const childKey = pathGetFront(changePath);\r\n        if (!oldServerSnap.isCompleteForPath(changePath) &&\r\n            pathGetLength(changePath) > 1) {\r\n            // We don't update incomplete nodes with updates intended for other listeners\r\n            return oldViewCache;\r\n        }\r\n        const childChangePath = pathPopFront(changePath);\r\n        const childNode = oldServerSnap.getNode().getImmediateChild(childKey);\r\n        const newChildNode = childNode.updateChild(childChangePath, changedSnap);\r\n        if (childKey === '.priority') {\r\n            newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);\r\n        }\r\n        else {\r\n            newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, NO_COMPLETE_CHILD_SOURCE, null);\r\n        }\r\n    }\r\n    const newViewCache = viewCacheUpdateServerSnap(oldViewCache, newServerCache, oldServerSnap.isFullyInitialized() || pathIsEmpty(changePath), serverFilter.filtersNodes());\r\n    const source = new WriteTreeCompleteChildSource(writesCache, newViewCache, completeCache);\r\n    return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache, changePath, writesCache, source, accumulator);\r\n}\r\nfunction viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {\r\n    const oldEventSnap = oldViewCache.eventCache;\r\n    let newViewCache, newEventCache;\r\n    const source = new WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);\r\n    if (pathIsEmpty(changePath)) {\r\n        newEventCache = viewProcessor.filter.updateFullNode(oldViewCache.eventCache.getNode(), changedSnap, accumulator);\r\n        newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventCache, true, viewProcessor.filter.filtersNodes());\r\n    }\r\n    else {\r\n        const childKey = pathGetFront(changePath);\r\n        if (childKey === '.priority') {\r\n            newEventCache = viewProcessor.filter.updatePriority(oldViewCache.eventCache.getNode(), changedSnap);\r\n            newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());\r\n        }\r\n        else {\r\n            const childChangePath = pathPopFront(changePath);\r\n            const oldChild = oldEventSnap.getNode().getImmediateChild(childKey);\r\n            let newChild;\r\n            if (pathIsEmpty(childChangePath)) {\r\n                // Child overwrite, we can replace the child\r\n                newChild = changedSnap;\r\n            }\r\n            else {\r\n                const childNode = source.getCompleteChild(childKey);\r\n                if (childNode != null) {\r\n                    if (pathGetBack(childChangePath) === '.priority' &&\r\n                        childNode.getChild(pathParent(childChangePath)).isEmpty()) {\r\n                        // This is a priority update on an empty node. If this node exists on the server, the\r\n                        // server will send down the priority in the update, so ignore for now\r\n                        newChild = childNode;\r\n                    }\r\n                    else {\r\n                        newChild = childNode.updateChild(childChangePath, changedSnap);\r\n                    }\r\n                }\r\n                else {\r\n                    // There is no complete child node available\r\n                    newChild = ChildrenNode.EMPTY_NODE;\r\n                }\r\n            }\r\n            if (!oldChild.equals(newChild)) {\r\n                const newEventSnap = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);\r\n                newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventSnap, oldEventSnap.isFullyInitialized(), viewProcessor.filter.filtersNodes());\r\n            }\r\n            else {\r\n                newViewCache = oldViewCache;\r\n            }\r\n        }\r\n    }\r\n    return newViewCache;\r\n}\r\nfunction viewProcessorCacheHasChild(viewCache, childKey) {\r\n    return viewCache.eventCache.isCompleteForChild(childKey);\r\n}\r\nfunction viewProcessorApplyUserMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, accumulator) {\r\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\r\n    // window leaving room for new items.  It's important we process these changes first, so we\r\n    // iterate the changes twice, first processing any that affect items currently in view.\r\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\r\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\r\n    // not the other.\r\n    let curViewCache = viewCache;\r\n    changedChildren.foreach((relativePath, childNode) => {\r\n        const writePath = pathChild(path, relativePath);\r\n        if (viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {\r\n            curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\r\n        }\r\n    });\r\n    changedChildren.foreach((relativePath, childNode) => {\r\n        const writePath = pathChild(path, relativePath);\r\n        if (!viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {\r\n            curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\r\n        }\r\n    });\r\n    return curViewCache;\r\n}\r\nfunction viewProcessorApplyMerge(viewProcessor, node, merge) {\r\n    merge.foreach((relativePath, childNode) => {\r\n        node = node.updateChild(relativePath, childNode);\r\n    });\r\n    return node;\r\n}\r\nfunction viewProcessorApplyServerMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {\r\n    // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and\r\n    // wait for the complete data update coming soon.\r\n    if (viewCache.serverCache.getNode().isEmpty() &&\r\n        !viewCache.serverCache.isFullyInitialized()) {\r\n        return viewCache;\r\n    }\r\n    // HACK: In the case of a limit query, there may be some changes that bump things out of the\r\n    // window leaving room for new items.  It's important we process these changes first, so we\r\n    // iterate the changes twice, first processing any that affect items currently in view.\r\n    // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\r\n    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\r\n    // not the other.\r\n    let curViewCache = viewCache;\r\n    let viewMergeTree;\r\n    if (pathIsEmpty(path)) {\r\n        viewMergeTree = changedChildren;\r\n    }\r\n    else {\r\n        viewMergeTree = new ImmutableTree(null).setTree(path, changedChildren);\r\n    }\r\n    const serverNode = viewCache.serverCache.getNode();\r\n    viewMergeTree.children.inorderTraversal((childKey, childTree) => {\r\n        if (serverNode.hasChild(childKey)) {\r\n            const serverChild = viewCache.serverCache\r\n                .getNode()\r\n                .getImmediateChild(childKey);\r\n            const newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childTree);\r\n            curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\r\n        }\r\n    });\r\n    viewMergeTree.children.inorderTraversal((childKey, childMergeTree) => {\r\n        const isUnknownDeepMerge = !viewCache.serverCache.isCompleteForChild(childKey) &&\r\n            childMergeTree.value === null;\r\n        if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {\r\n            const serverChild = viewCache.serverCache\r\n                .getNode()\r\n                .getImmediateChild(childKey);\r\n            const newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childMergeTree);\r\n            curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\r\n        }\r\n    });\r\n    return curViewCache;\r\n}\r\nfunction viewProcessorAckUserWrite(viewProcessor, viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {\r\n    if (writeTreeRefShadowingWrite(writesCache, ackPath) != null) {\r\n        return viewCache;\r\n    }\r\n    // Only filter server node if it is currently filtered\r\n    const filterServerNode = viewCache.serverCache.isFiltered();\r\n    // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update\r\n    // now that it won't be shadowed.\r\n    const serverCache = viewCache.serverCache;\r\n    if (affectedTree.value != null) {\r\n        // This is an overwrite.\r\n        if ((pathIsEmpty(ackPath) && serverCache.isFullyInitialized()) ||\r\n            serverCache.isCompleteForPath(ackPath)) {\r\n            return viewProcessorApplyServerOverwrite(viewProcessor, viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);\r\n        }\r\n        else if (pathIsEmpty(ackPath)) {\r\n            // This is a goofy edge case where we are acking data at this location but don't have full data.  We\r\n            // should just re-apply whatever we have in our cache as a merge.\r\n            let changedChildren = new ImmutableTree(null);\r\n            serverCache.getNode().forEachChild(KEY_INDEX, (name, node) => {\r\n                changedChildren = changedChildren.set(new Path(name), node);\r\n            });\r\n            return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren, writesCache, completeCache, filterServerNode, accumulator);\r\n        }\r\n        else {\r\n            return viewCache;\r\n        }\r\n    }\r\n    else {\r\n        // This is a merge.\r\n        let changedChildren = new ImmutableTree(null);\r\n        affectedTree.foreach((mergePath, value) => {\r\n            const serverCachePath = pathChild(ackPath, mergePath);\r\n            if (serverCache.isCompleteForPath(serverCachePath)) {\r\n                changedChildren = changedChildren.set(mergePath, serverCache.getNode().getChild(serverCachePath));\r\n            }\r\n        });\r\n        return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren, writesCache, completeCache, filterServerNode, accumulator);\r\n    }\r\n}\r\nfunction viewProcessorListenComplete(viewProcessor, viewCache, path, writesCache, accumulator) {\r\n    const oldServerNode = viewCache.serverCache;\r\n    const newViewCache = viewCacheUpdateServerSnap(viewCache, oldServerNode.getNode(), oldServerNode.isFullyInitialized() || pathIsEmpty(path), oldServerNode.isFiltered());\r\n    return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache, path, writesCache, NO_COMPLETE_CHILD_SOURCE, accumulator);\r\n}\r\nfunction viewProcessorRevertUserWrite(viewProcessor, viewCache, path, writesCache, completeServerCache, accumulator) {\r\n    let complete;\r\n    if (writeTreeRefShadowingWrite(writesCache, path) != null) {\r\n        return viewCache;\r\n    }\r\n    else {\r\n        const source = new WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);\r\n        const oldEventCache = viewCache.eventCache.getNode();\r\n        let newEventCache;\r\n        if (pathIsEmpty(path) || pathGetFront(path) === '.priority') {\r\n            let newNode;\r\n            if (viewCache.serverCache.isFullyInitialized()) {\r\n                newNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));\r\n            }\r\n            else {\r\n                const serverChildren = viewCache.serverCache.getNode();\r\n                index_esm2017_assert(serverChildren instanceof ChildrenNode, 'serverChildren would be complete if leaf node');\r\n                newNode = writeTreeRefCalcCompleteEventChildren(writesCache, serverChildren);\r\n            }\r\n            newNode = newNode;\r\n            newEventCache = viewProcessor.filter.updateFullNode(oldEventCache, newNode, accumulator);\r\n        }\r\n        else {\r\n            const childKey = pathGetFront(path);\r\n            let newChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);\r\n            if (newChild == null &&\r\n                viewCache.serverCache.isCompleteForChild(childKey)) {\r\n                newChild = oldEventCache.getImmediateChild(childKey);\r\n            }\r\n            if (newChild != null) {\r\n                newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, newChild, pathPopFront(path), source, accumulator);\r\n            }\r\n            else if (viewCache.eventCache.getNode().hasChild(childKey)) {\r\n                // No complete child available, delete the existing one, if any\r\n                newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, ChildrenNode.EMPTY_NODE, pathPopFront(path), source, accumulator);\r\n            }\r\n            else {\r\n                newEventCache = oldEventCache;\r\n            }\r\n            if (newEventCache.isEmpty() &&\r\n                viewCache.serverCache.isFullyInitialized()) {\r\n                // We might have reverted all child writes. Maybe the old event was a leaf node\r\n                complete = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));\r\n                if (complete.isLeafNode()) {\r\n                    newEventCache = viewProcessor.filter.updateFullNode(newEventCache, complete, accumulator);\r\n                }\r\n            }\r\n        }\r\n        complete =\r\n            viewCache.serverCache.isFullyInitialized() ||\r\n                writeTreeRefShadowingWrite(writesCache, newEmptyPath()) != null;\r\n        return viewCacheUpdateEventSnap(viewCache, newEventCache, complete, viewProcessor.filter.filtersNodes());\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A view represents a specific location and query that has 1 or more event registrations.\r\n *\r\n * It does several things:\r\n *  - Maintains the list of event registrations for this location/query.\r\n *  - Maintains a cache of the data visible for this location/query.\r\n *  - Applies new operations (via applyOperation), updates the cache, and based on the event\r\n *    registrations returns the set of events to be raised.\r\n */\r\nclass View {\r\n    constructor(query_, initialViewCache) {\r\n        this.query_ = query_;\r\n        this.eventRegistrations_ = [];\r\n        const params = this.query_._queryParams;\r\n        const indexFilter = new IndexedFilter(params.getIndex());\r\n        const filter = queryParamsGetNodeFilter(params);\r\n        this.processor_ = newViewProcessor(filter);\r\n        const initialServerCache = initialViewCache.serverCache;\r\n        const initialEventCache = initialViewCache.eventCache;\r\n        // Don't filter server node with other filter than index, wait for tagged listen\r\n        const serverSnap = indexFilter.updateFullNode(ChildrenNode.EMPTY_NODE, initialServerCache.getNode(), null);\r\n        const eventSnap = filter.updateFullNode(ChildrenNode.EMPTY_NODE, initialEventCache.getNode(), null);\r\n        const newServerCache = new CacheNode(serverSnap, initialServerCache.isFullyInitialized(), indexFilter.filtersNodes());\r\n        const newEventCache = new CacheNode(eventSnap, initialEventCache.isFullyInitialized(), filter.filtersNodes());\r\n        this.viewCache_ = newViewCache(newEventCache, newServerCache);\r\n        this.eventGenerator_ = new EventGenerator(this.query_);\r\n    }\r\n    get query() {\r\n        return this.query_;\r\n    }\r\n}\r\nfunction viewGetServerCache(view) {\r\n    return view.viewCache_.serverCache.getNode();\r\n}\r\nfunction viewGetCompleteNode(view) {\r\n    return viewCacheGetCompleteEventSnap(view.viewCache_);\r\n}\r\nfunction viewGetCompleteServerCache(view, path) {\r\n    const cache = viewCacheGetCompleteServerSnap(view.viewCache_);\r\n    if (cache) {\r\n        // If this isn't a \"loadsAllData\" view, then cache isn't actually a complete cache and\r\n        // we need to see if it contains the child we're interested in.\r\n        if (view.query._queryParams.loadsAllData() ||\r\n            (!pathIsEmpty(path) &&\r\n                !cache.getImmediateChild(pathGetFront(path)).isEmpty())) {\r\n            return cache.getChild(path);\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction viewIsEmpty(view) {\r\n    return view.eventRegistrations_.length === 0;\r\n}\r\nfunction viewAddEventRegistration(view, eventRegistration) {\r\n    view.eventRegistrations_.push(eventRegistration);\r\n}\r\n/**\r\n * @param eventRegistration - If null, remove all callbacks.\r\n * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.\r\n * @returns Cancel events, if cancelError was provided.\r\n */\r\nfunction viewRemoveEventRegistration(view, eventRegistration, cancelError) {\r\n    const cancelEvents = [];\r\n    if (cancelError) {\r\n        index_esm2017_assert(eventRegistration == null, 'A cancel should cancel all event registrations.');\r\n        const path = view.query._path;\r\n        view.eventRegistrations_.forEach(registration => {\r\n            const maybeEvent = registration.createCancelEvent(cancelError, path);\r\n            if (maybeEvent) {\r\n                cancelEvents.push(maybeEvent);\r\n            }\r\n        });\r\n    }\r\n    if (eventRegistration) {\r\n        let remaining = [];\r\n        for (let i = 0; i < view.eventRegistrations_.length; ++i) {\r\n            const existing = view.eventRegistrations_[i];\r\n            if (!existing.matches(eventRegistration)) {\r\n                remaining.push(existing);\r\n            }\r\n            else if (eventRegistration.hasAnyCallback()) {\r\n                // We're removing just this one\r\n                remaining = remaining.concat(view.eventRegistrations_.slice(i + 1));\r\n                break;\r\n            }\r\n        }\r\n        view.eventRegistrations_ = remaining;\r\n    }\r\n    else {\r\n        view.eventRegistrations_ = [];\r\n    }\r\n    return cancelEvents;\r\n}\r\n/**\r\n * Applies the given Operation, updates our cache, and returns the appropriate events.\r\n */\r\nfunction viewApplyOperation(view, operation, writesCache, completeServerCache) {\r\n    if (operation.type === OperationType.MERGE &&\r\n        operation.source.queryId !== null) {\r\n        index_esm2017_assert(viewCacheGetCompleteServerSnap(view.viewCache_), 'We should always have a full cache before handling merges');\r\n        index_esm2017_assert(viewCacheGetCompleteEventSnap(view.viewCache_), 'Missing event cache, even though we have a server cache');\r\n    }\r\n    const oldViewCache = view.viewCache_;\r\n    const result = viewProcessorApplyOperation(view.processor_, oldViewCache, operation, writesCache, completeServerCache);\r\n    viewProcessorAssertIndexed(view.processor_, result.viewCache);\r\n    index_esm2017_assert(result.viewCache.serverCache.isFullyInitialized() ||\r\n        !oldViewCache.serverCache.isFullyInitialized(), 'Once a server snap is complete, it should never go back');\r\n    view.viewCache_ = result.viewCache;\r\n    return viewGenerateEventsForChanges_(view, result.changes, result.viewCache.eventCache.getNode(), null);\r\n}\r\nfunction viewGetInitialEvents(view, registration) {\r\n    const eventSnap = view.viewCache_.eventCache;\r\n    const initialChanges = [];\r\n    if (!eventSnap.getNode().isLeafNode()) {\r\n        const eventNode = eventSnap.getNode();\r\n        eventNode.forEachChild(PRIORITY_INDEX, (key, childNode) => {\r\n            initialChanges.push(changeChildAdded(key, childNode));\r\n        });\r\n    }\r\n    if (eventSnap.isFullyInitialized()) {\r\n        initialChanges.push(changeValue(eventSnap.getNode()));\r\n    }\r\n    return viewGenerateEventsForChanges_(view, initialChanges, eventSnap.getNode(), registration);\r\n}\r\nfunction viewGenerateEventsForChanges_(view, changes, eventCache, eventRegistration) {\r\n    const registrations = eventRegistration\r\n        ? [eventRegistration]\r\n        : view.eventRegistrations_;\r\n    return eventGeneratorGenerateEventsForChanges(view.eventGenerator_, changes, eventCache, registrations);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nlet referenceConstructor$1;\r\n/**\r\n * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to\r\n * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes\r\n * and user writes (set, transaction, update).\r\n *\r\n * It's responsible for:\r\n *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).\r\n *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,\r\n *    applyUserOverwrite, etc.)\r\n */\r\nclass SyncPoint {\r\n    constructor() {\r\n        /**\r\n         * The Views being tracked at this location in the tree, stored as a map where the key is a\r\n         * queryId and the value is the View for that query.\r\n         *\r\n         * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).\r\n         */\r\n        this.views = new Map();\r\n    }\r\n}\r\nfunction syncPointSetReferenceConstructor(val) {\r\n    index_esm2017_assert(!referenceConstructor$1, '__referenceConstructor has already been defined');\r\n    referenceConstructor$1 = val;\r\n}\r\nfunction syncPointGetReferenceConstructor() {\r\n    index_esm2017_assert(referenceConstructor$1, 'Reference.ts has not been loaded');\r\n    return referenceConstructor$1;\r\n}\r\nfunction syncPointIsEmpty(syncPoint) {\r\n    return syncPoint.views.size === 0;\r\n}\r\nfunction syncPointApplyOperation(syncPoint, operation, writesCache, optCompleteServerCache) {\r\n    const queryId = operation.source.queryId;\r\n    if (queryId !== null) {\r\n        const view = syncPoint.views.get(queryId);\r\n        index_esm2017_assert(view != null, 'SyncTree gave us an op for an invalid query.');\r\n        return viewApplyOperation(view, operation, writesCache, optCompleteServerCache);\r\n    }\r\n    else {\r\n        let events = [];\r\n        for (const view of syncPoint.views.values()) {\r\n            events = events.concat(viewApplyOperation(view, operation, writesCache, optCompleteServerCache));\r\n        }\r\n        return events;\r\n    }\r\n}\r\n/**\r\n * Get a view for the specified query.\r\n *\r\n * @param query - The query to return a view for\r\n * @param writesCache\r\n * @param serverCache\r\n * @param serverCacheComplete\r\n * @returns Events to raise.\r\n */\r\nfunction syncPointGetView(syncPoint, query, writesCache, serverCache, serverCacheComplete) {\r\n    const queryId = query._queryIdentifier;\r\n    const view = syncPoint.views.get(queryId);\r\n    if (!view) {\r\n        // TODO: make writesCache take flag for complete server node\r\n        let eventCache = writeTreeRefCalcCompleteEventCache(writesCache, serverCacheComplete ? serverCache : null);\r\n        let eventCacheComplete = false;\r\n        if (eventCache) {\r\n            eventCacheComplete = true;\r\n        }\r\n        else if (serverCache instanceof ChildrenNode) {\r\n            eventCache = writeTreeRefCalcCompleteEventChildren(writesCache, serverCache);\r\n            eventCacheComplete = false;\r\n        }\r\n        else {\r\n            eventCache = ChildrenNode.EMPTY_NODE;\r\n            eventCacheComplete = false;\r\n        }\r\n        const viewCache = newViewCache(new CacheNode(eventCache, eventCacheComplete, false), new CacheNode(serverCache, serverCacheComplete, false));\r\n        return new View(query, viewCache);\r\n    }\r\n    return view;\r\n}\r\n/**\r\n * Add an event callback for the specified query.\r\n *\r\n * @param query\r\n * @param eventRegistration\r\n * @param writesCache\r\n * @param serverCache - Complete server cache, if we have it.\r\n * @param serverCacheComplete\r\n * @returns Events to raise.\r\n */\r\nfunction syncPointAddEventRegistration(syncPoint, query, eventRegistration, writesCache, serverCache, serverCacheComplete) {\r\n    const view = syncPointGetView(syncPoint, query, writesCache, serverCache, serverCacheComplete);\r\n    if (!syncPoint.views.has(query._queryIdentifier)) {\r\n        syncPoint.views.set(query._queryIdentifier, view);\r\n    }\r\n    // This is guaranteed to exist now, we just created anything that was missing\r\n    viewAddEventRegistration(view, eventRegistration);\r\n    return viewGetInitialEvents(view, eventRegistration);\r\n}\r\n/**\r\n * Remove event callback(s).  Return cancelEvents if a cancelError is specified.\r\n *\r\n * If query is the default query, we'll check all views for the specified eventRegistration.\r\n * If eventRegistration is null, we'll remove all callbacks for the specified view(s).\r\n *\r\n * @param eventRegistration - If null, remove all callbacks.\r\n * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.\r\n * @returns removed queries and any cancel events\r\n */\r\nfunction syncPointRemoveEventRegistration(syncPoint, query, eventRegistration, cancelError) {\r\n    const queryId = query._queryIdentifier;\r\n    const removed = [];\r\n    let cancelEvents = [];\r\n    const hadCompleteView = syncPointHasCompleteView(syncPoint);\r\n    if (queryId === 'default') {\r\n        // When you do ref.off(...), we search all views for the registration to remove.\r\n        for (const [viewQueryId, view] of syncPoint.views.entries()) {\r\n            cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));\r\n            if (viewIsEmpty(view)) {\r\n                syncPoint.views.delete(viewQueryId);\r\n                // We'll deal with complete views later.\r\n                if (!view.query._queryParams.loadsAllData()) {\r\n                    removed.push(view.query);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // remove the callback from the specific view.\r\n        const view = syncPoint.views.get(queryId);\r\n        if (view) {\r\n            cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));\r\n            if (viewIsEmpty(view)) {\r\n                syncPoint.views.delete(queryId);\r\n                // We'll deal with complete views later.\r\n                if (!view.query._queryParams.loadsAllData()) {\r\n                    removed.push(view.query);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (hadCompleteView && !syncPointHasCompleteView(syncPoint)) {\r\n        // We removed our last complete view.\r\n        removed.push(new (syncPointGetReferenceConstructor())(query._repo, query._path));\r\n    }\r\n    return { removed, events: cancelEvents };\r\n}\r\nfunction syncPointGetQueryViews(syncPoint) {\r\n    const result = [];\r\n    for (const view of syncPoint.views.values()) {\r\n        if (!view.query._queryParams.loadsAllData()) {\r\n            result.push(view);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * @param path - The path to the desired complete snapshot\r\n * @returns A complete cache, if it exists\r\n */\r\nfunction syncPointGetCompleteServerCache(syncPoint, path) {\r\n    let serverCache = null;\r\n    for (const view of syncPoint.views.values()) {\r\n        serverCache = serverCache || viewGetCompleteServerCache(view, path);\r\n    }\r\n    return serverCache;\r\n}\r\nfunction syncPointViewForQuery(syncPoint, query) {\r\n    const params = query._queryParams;\r\n    if (params.loadsAllData()) {\r\n        return syncPointGetCompleteView(syncPoint);\r\n    }\r\n    else {\r\n        const queryId = query._queryIdentifier;\r\n        return syncPoint.views.get(queryId);\r\n    }\r\n}\r\nfunction syncPointViewExistsForQuery(syncPoint, query) {\r\n    return syncPointViewForQuery(syncPoint, query) != null;\r\n}\r\nfunction syncPointHasCompleteView(syncPoint) {\r\n    return syncPointGetCompleteView(syncPoint) != null;\r\n}\r\nfunction syncPointGetCompleteView(syncPoint) {\r\n    for (const view of syncPoint.views.values()) {\r\n        if (view.query._queryParams.loadsAllData()) {\r\n            return view;\r\n        }\r\n    }\r\n    return null;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nlet referenceConstructor;\r\nfunction syncTreeSetReferenceConstructor(val) {\r\n    index_esm2017_assert(!referenceConstructor, '__referenceConstructor has already been defined');\r\n    referenceConstructor = val;\r\n}\r\nfunction syncTreeGetReferenceConstructor() {\r\n    index_esm2017_assert(referenceConstructor, 'Reference.ts has not been loaded');\r\n    return referenceConstructor;\r\n}\r\n/**\r\n * Static tracker for next query tag.\r\n */\r\nlet syncTreeNextQueryTag_ = 1;\r\n/**\r\n * SyncTree is the central class for managing event callback registration, data caching, views\r\n * (query processing), and event generation.  There are typically two SyncTree instances for\r\n * each Repo, one for the normal Firebase data, and one for the .info data.\r\n *\r\n * It has a number of responsibilities, including:\r\n *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).\r\n *  - Applying and caching data changes for user set(), transaction(), and update() calls\r\n *    (applyUserOverwrite(), applyUserMerge()).\r\n *  - Applying and caching data changes for server data changes (applyServerOverwrite(),\r\n *    applyServerMerge()).\r\n *  - Generating user-facing events for server and user changes (all of the apply* methods\r\n *    return the set of events that need to be raised as a result).\r\n *  - Maintaining the appropriate set of server listens to ensure we are always subscribed\r\n *    to the correct set of paths and queries to satisfy the current set of user event\r\n *    callbacks (listens are started/stopped using the provided listenProvider).\r\n *\r\n * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual\r\n * events are returned to the caller rather than raised synchronously.\r\n *\r\n */\r\nclass SyncTree {\r\n    /**\r\n     * @param listenProvider_ - Used by SyncTree to start / stop listening\r\n     *   to server data.\r\n     */\r\n    constructor(listenProvider_) {\r\n        this.listenProvider_ = listenProvider_;\r\n        /**\r\n         * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.\r\n         */\r\n        this.syncPointTree_ = new ImmutableTree(null);\r\n        /**\r\n         * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).\r\n         */\r\n        this.pendingWriteTree_ = newWriteTree();\r\n        this.tagToQueryMap = new Map();\r\n        this.queryToTagMap = new Map();\r\n    }\r\n}\r\n/**\r\n * Apply the data changes for a user-generated set() or transaction() call.\r\n *\r\n * @returns Events to raise.\r\n */\r\nfunction syncTreeApplyUserOverwrite(syncTree, path, newData, writeId, visible) {\r\n    // Record pending write.\r\n    writeTreeAddOverwrite(syncTree.pendingWriteTree_, path, newData, writeId, visible);\r\n    if (!visible) {\r\n        return [];\r\n    }\r\n    else {\r\n        return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceUser(), path, newData));\r\n    }\r\n}\r\n/**\r\n * Apply the data from a user-generated update() call\r\n *\r\n * @returns Events to raise.\r\n */\r\nfunction syncTreeApplyUserMerge(syncTree, path, changedChildren, writeId) {\r\n    // Record pending merge.\r\n    writeTreeAddMerge(syncTree.pendingWriteTree_, path, changedChildren, writeId);\r\n    const changeTree = ImmutableTree.fromObject(changedChildren);\r\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceUser(), path, changeTree));\r\n}\r\n/**\r\n * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().\r\n *\r\n * @param revert - True if the given write failed and needs to be reverted\r\n * @returns Events to raise.\r\n */\r\nfunction syncTreeAckUserWrite(syncTree, writeId, revert = false) {\r\n    const write = writeTreeGetWrite(syncTree.pendingWriteTree_, writeId);\r\n    const needToReevaluate = writeTreeRemoveWrite(syncTree.pendingWriteTree_, writeId);\r\n    if (!needToReevaluate) {\r\n        return [];\r\n    }\r\n    else {\r\n        let affectedTree = new ImmutableTree(null);\r\n        if (write.snap != null) {\r\n            // overwrite\r\n            affectedTree = affectedTree.set(newEmptyPath(), true);\r\n        }\r\n        else {\r\n            each(write.children, (pathString) => {\r\n                affectedTree = affectedTree.set(new Path(pathString), true);\r\n            });\r\n        }\r\n        return syncTreeApplyOperationToSyncPoints_(syncTree, new AckUserWrite(write.path, affectedTree, revert));\r\n    }\r\n}\r\n/**\r\n * Apply new server data for the specified path..\r\n *\r\n * @returns Events to raise.\r\n */\r\nfunction syncTreeApplyServerOverwrite(syncTree, path, newData) {\r\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceServer(), path, newData));\r\n}\r\n/**\r\n * Apply new server data to be merged in at the specified path.\r\n *\r\n * @returns Events to raise.\r\n */\r\nfunction syncTreeApplyServerMerge(syncTree, path, changedChildren) {\r\n    const changeTree = ImmutableTree.fromObject(changedChildren);\r\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceServer(), path, changeTree));\r\n}\r\n/**\r\n * Apply a listen complete for a query\r\n *\r\n * @returns Events to raise.\r\n */\r\nfunction syncTreeApplyListenComplete(syncTree, path) {\r\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new ListenComplete(newOperationSourceServer(), path));\r\n}\r\n/**\r\n * Apply a listen complete for a tagged query\r\n *\r\n * @returns Events to raise.\r\n */\r\nfunction syncTreeApplyTaggedListenComplete(syncTree, path, tag) {\r\n    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);\r\n    if (queryKey) {\r\n        const r = syncTreeParseQueryKey_(queryKey);\r\n        const queryPath = r.path, queryId = r.queryId;\r\n        const relativePath = newRelativePath(queryPath, path);\r\n        const op = new ListenComplete(newOperationSourceServerTaggedQuery(queryId), relativePath);\r\n        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);\r\n    }\r\n    else {\r\n        // We've already removed the query. No big deal, ignore the update\r\n        return [];\r\n    }\r\n}\r\n/**\r\n * Remove event callback(s).\r\n *\r\n * If query is the default query, we'll check all queries for the specified eventRegistration.\r\n * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.\r\n *\r\n * @param eventRegistration - If null, all callbacks are removed.\r\n * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.\r\n * @param skipListenerDedup - When performing a `get()`, we don't add any new listeners, so no\r\n *  deduping needs to take place. This flag allows toggling of that behavior\r\n * @returns Cancel events, if cancelError was provided.\r\n */\r\nfunction syncTreeRemoveEventRegistration(syncTree, query, eventRegistration, cancelError, skipListenerDedup = false) {\r\n    // Find the syncPoint first. Then deal with whether or not it has matching listeners\r\n    const path = query._path;\r\n    const maybeSyncPoint = syncTree.syncPointTree_.get(path);\r\n    let cancelEvents = [];\r\n    // A removal on a default query affects all queries at that location. A removal on an indexed query, even one without\r\n    // other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and\r\n    // not loadsAllData().\r\n    if (maybeSyncPoint &&\r\n        (query._queryIdentifier === 'default' ||\r\n            syncPointViewExistsForQuery(maybeSyncPoint, query))) {\r\n        const removedAndEvents = syncPointRemoveEventRegistration(maybeSyncPoint, query, eventRegistration, cancelError);\r\n        if (syncPointIsEmpty(maybeSyncPoint)) {\r\n            syncTree.syncPointTree_ = syncTree.syncPointTree_.remove(path);\r\n        }\r\n        const removed = removedAndEvents.removed;\r\n        cancelEvents = removedAndEvents.events;\r\n        if (!skipListenerDedup) {\r\n            /**\r\n             * We may have just removed one of many listeners and can short-circuit this whole process\r\n             * We may also not have removed a default listener, in which case all of the descendant listeners should already be\r\n             * properly set up.\r\n             */\r\n            // Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of\r\n            // queryId === 'default'\r\n            const removingDefault = -1 !==\r\n                removed.findIndex(query => {\r\n                    return query._queryParams.loadsAllData();\r\n                });\r\n            const covered = syncTree.syncPointTree_.findOnPath(path, (relativePath, parentSyncPoint) => syncPointHasCompleteView(parentSyncPoint));\r\n            if (removingDefault && !covered) {\r\n                const subtree = syncTree.syncPointTree_.subtree(path);\r\n                // There are potentially child listeners. Determine what if any listens we need to send before executing the\r\n                // removal\r\n                if (!subtree.isEmpty()) {\r\n                    // We need to fold over our subtree and collect the listeners to send\r\n                    const newViews = syncTreeCollectDistinctViewsForSubTree_(subtree);\r\n                    // Ok, we've collected all the listens we need. Set them up.\r\n                    for (let i = 0; i < newViews.length; ++i) {\r\n                        const view = newViews[i], newQuery = view.query;\r\n                        const listener = syncTreeCreateListenerForView_(syncTree, view);\r\n                        syncTree.listenProvider_.startListening(syncTreeQueryForListening_(newQuery), syncTreeTagForQuery(syncTree, newQuery), listener.hashFn, listener.onComplete);\r\n                    }\r\n                }\r\n                // Otherwise there's nothing below us, so nothing we need to start listening on\r\n            }\r\n            // If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query\r\n            // The above block has us covered in terms of making sure we're set up on listens lower in the tree.\r\n            // Also, note that if we have a cancelError, it's already been removed at the provider level.\r\n            if (!covered && removed.length > 0 && !cancelError) {\r\n                // If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one\r\n                // default. Otherwise, we need to iterate through and cancel each individual query\r\n                if (removingDefault) {\r\n                    // We don't tag default listeners\r\n                    const defaultTag = null;\r\n                    syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(query), defaultTag);\r\n                }\r\n                else {\r\n                    removed.forEach((queryToRemove) => {\r\n                        const tagToRemove = syncTree.queryToTagMap.get(syncTreeMakeQueryKey_(queryToRemove));\r\n                        syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToRemove), tagToRemove);\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        // Now, clear all of the tags we're tracking for the removed listens\r\n        syncTreeRemoveTags_(syncTree, removed);\r\n    }\r\n    return cancelEvents;\r\n}\r\n/**\r\n * Apply new server data for the specified tagged query.\r\n *\r\n * @returns Events to raise.\r\n */\r\nfunction syncTreeApplyTaggedQueryOverwrite(syncTree, path, snap, tag) {\r\n    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);\r\n    if (queryKey != null) {\r\n        const r = syncTreeParseQueryKey_(queryKey);\r\n        const queryPath = r.path, queryId = r.queryId;\r\n        const relativePath = newRelativePath(queryPath, path);\r\n        const op = new Overwrite(newOperationSourceServerTaggedQuery(queryId), relativePath, snap);\r\n        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);\r\n    }\r\n    else {\r\n        // Query must have been removed already\r\n        return [];\r\n    }\r\n}\r\n/**\r\n * Apply server data to be merged in for the specified tagged query.\r\n *\r\n * @returns Events to raise.\r\n */\r\nfunction syncTreeApplyTaggedQueryMerge(syncTree, path, changedChildren, tag) {\r\n    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);\r\n    if (queryKey) {\r\n        const r = syncTreeParseQueryKey_(queryKey);\r\n        const queryPath = r.path, queryId = r.queryId;\r\n        const relativePath = newRelativePath(queryPath, path);\r\n        const changeTree = ImmutableTree.fromObject(changedChildren);\r\n        const op = new Merge(newOperationSourceServerTaggedQuery(queryId), relativePath, changeTree);\r\n        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);\r\n    }\r\n    else {\r\n        // We've already removed the query. No big deal, ignore the update\r\n        return [];\r\n    }\r\n}\r\n/**\r\n * Add an event callback for the specified query.\r\n *\r\n * @returns Events to raise.\r\n */\r\nfunction syncTreeAddEventRegistration(syncTree, query, eventRegistration, skipSetupListener = false) {\r\n    const path = query._path;\r\n    let serverCache = null;\r\n    let foundAncestorDefaultView = false;\r\n    // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.\r\n    // Consider optimizing this once there's a better understanding of what actual behavior will be.\r\n    syncTree.syncPointTree_.foreachOnPath(path, (pathToSyncPoint, sp) => {\r\n        const relativePath = newRelativePath(pathToSyncPoint, path);\r\n        serverCache =\r\n            serverCache || syncPointGetCompleteServerCache(sp, relativePath);\r\n        foundAncestorDefaultView =\r\n            foundAncestorDefaultView || syncPointHasCompleteView(sp);\r\n    });\r\n    let syncPoint = syncTree.syncPointTree_.get(path);\r\n    if (!syncPoint) {\r\n        syncPoint = new SyncPoint();\r\n        syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);\r\n    }\r\n    else {\r\n        foundAncestorDefaultView =\r\n            foundAncestorDefaultView || syncPointHasCompleteView(syncPoint);\r\n        serverCache =\r\n            serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\r\n    }\r\n    let serverCacheComplete;\r\n    if (serverCache != null) {\r\n        serverCacheComplete = true;\r\n    }\r\n    else {\r\n        serverCacheComplete = false;\r\n        serverCache = ChildrenNode.EMPTY_NODE;\r\n        const subtree = syncTree.syncPointTree_.subtree(path);\r\n        subtree.foreachChild((childName, childSyncPoint) => {\r\n            const completeCache = syncPointGetCompleteServerCache(childSyncPoint, newEmptyPath());\r\n            if (completeCache) {\r\n                serverCache = serverCache.updateImmediateChild(childName, completeCache);\r\n            }\r\n        });\r\n    }\r\n    const viewAlreadyExists = syncPointViewExistsForQuery(syncPoint, query);\r\n    if (!viewAlreadyExists && !query._queryParams.loadsAllData()) {\r\n        // We need to track a tag for this query\r\n        const queryKey = syncTreeMakeQueryKey_(query);\r\n        index_esm2017_assert(!syncTree.queryToTagMap.has(queryKey), 'View does not exist, but we have a tag');\r\n        const tag = syncTreeGetNextQueryTag_();\r\n        syncTree.queryToTagMap.set(queryKey, tag);\r\n        syncTree.tagToQueryMap.set(tag, queryKey);\r\n    }\r\n    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, path);\r\n    let events = syncPointAddEventRegistration(syncPoint, query, eventRegistration, writesCache, serverCache, serverCacheComplete);\r\n    if (!viewAlreadyExists && !foundAncestorDefaultView && !skipSetupListener) {\r\n        const view = syncPointViewForQuery(syncPoint, query);\r\n        events = events.concat(syncTreeSetupListener_(syncTree, query, view));\r\n    }\r\n    return events;\r\n}\r\n/**\r\n * Returns a complete cache, if we have one, of the data at a particular path. If the location does not have a\r\n * listener above it, we will get a false \"null\". This shouldn't be a problem because transactions will always\r\n * have a listener above, and atomic operations would correctly show a jitter of <increment value> ->\r\n *     <incremented total> as the write is applied locally and then acknowledged at the server.\r\n *\r\n * Note: this method will *include* hidden writes from transaction with applyLocally set to false.\r\n *\r\n * @param path - The path to the data we want\r\n * @param writeIdsToExclude - A specific set to be excluded\r\n */\r\nfunction syncTreeCalcCompleteEventCache(syncTree, path, writeIdsToExclude) {\r\n    const includeHiddenSets = true;\r\n    const writeTree = syncTree.pendingWriteTree_;\r\n    const serverCache = syncTree.syncPointTree_.findOnPath(path, (pathSoFar, syncPoint) => {\r\n        const relativePath = newRelativePath(pathSoFar, path);\r\n        const serverCache = syncPointGetCompleteServerCache(syncPoint, relativePath);\r\n        if (serverCache) {\r\n            return serverCache;\r\n        }\r\n    });\r\n    return writeTreeCalcCompleteEventCache(writeTree, path, serverCache, writeIdsToExclude, includeHiddenSets);\r\n}\r\nfunction syncTreeGetServerValue(syncTree, query) {\r\n    const path = query._path;\r\n    let serverCache = null;\r\n    // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.\r\n    // Consider optimizing this once there's a better understanding of what actual behavior will be.\r\n    syncTree.syncPointTree_.foreachOnPath(path, (pathToSyncPoint, sp) => {\r\n        const relativePath = newRelativePath(pathToSyncPoint, path);\r\n        serverCache =\r\n            serverCache || syncPointGetCompleteServerCache(sp, relativePath);\r\n    });\r\n    let syncPoint = syncTree.syncPointTree_.get(path);\r\n    if (!syncPoint) {\r\n        syncPoint = new SyncPoint();\r\n        syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);\r\n    }\r\n    else {\r\n        serverCache =\r\n            serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\r\n    }\r\n    const serverCacheComplete = serverCache != null;\r\n    const serverCacheNode = serverCacheComplete\r\n        ? new CacheNode(serverCache, true, false)\r\n        : null;\r\n    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, query._path);\r\n    const view = syncPointGetView(syncPoint, query, writesCache, serverCacheComplete ? serverCacheNode.getNode() : ChildrenNode.EMPTY_NODE, serverCacheComplete);\r\n    return viewGetCompleteNode(view);\r\n}\r\n/**\r\n * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.\r\n *\r\n * NOTES:\r\n * - Descendant SyncPoints will be visited first (since we raise events depth-first).\r\n *\r\n * - We call applyOperation() on each SyncPoint passing three things:\r\n *   1. A version of the Operation that has been made relative to the SyncPoint location.\r\n *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.\r\n *   3. A snapshot Node with cached server data, if we have it.\r\n *\r\n * - We concatenate all of the events returned by each SyncPoint and return the result.\r\n */\r\nfunction syncTreeApplyOperationToSyncPoints_(syncTree, operation) {\r\n    return syncTreeApplyOperationHelper_(operation, syncTree.syncPointTree_, \r\n    /*serverCache=*/ null, writeTreeChildWrites(syncTree.pendingWriteTree_, newEmptyPath()));\r\n}\r\n/**\r\n * Recursive helper for applyOperationToSyncPoints_\r\n */\r\nfunction syncTreeApplyOperationHelper_(operation, syncPointTree, serverCache, writesCache) {\r\n    if (pathIsEmpty(operation.path)) {\r\n        return syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);\r\n    }\r\n    else {\r\n        const syncPoint = syncPointTree.get(newEmptyPath());\r\n        // If we don't have cached server data, see if we can get it from this SyncPoint.\r\n        if (serverCache == null && syncPoint != null) {\r\n            serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\r\n        }\r\n        let events = [];\r\n        const childName = pathGetFront(operation.path);\r\n        const childOperation = operation.operationForChild(childName);\r\n        const childTree = syncPointTree.children.get(childName);\r\n        if (childTree && childOperation) {\r\n            const childServerCache = serverCache\r\n                ? serverCache.getImmediateChild(childName)\r\n                : null;\r\n            const childWritesCache = writeTreeRefChild(writesCache, childName);\r\n            events = events.concat(syncTreeApplyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));\r\n        }\r\n        if (syncPoint) {\r\n            events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));\r\n        }\r\n        return events;\r\n    }\r\n}\r\n/**\r\n * Recursive helper for applyOperationToSyncPoints_\r\n */\r\nfunction syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache) {\r\n    const syncPoint = syncPointTree.get(newEmptyPath());\r\n    // If we don't have cached server data, see if we can get it from this SyncPoint.\r\n    if (serverCache == null && syncPoint != null) {\r\n        serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\r\n    }\r\n    let events = [];\r\n    syncPointTree.children.inorderTraversal((childName, childTree) => {\r\n        const childServerCache = serverCache\r\n            ? serverCache.getImmediateChild(childName)\r\n            : null;\r\n        const childWritesCache = writeTreeRefChild(writesCache, childName);\r\n        const childOperation = operation.operationForChild(childName);\r\n        if (childOperation) {\r\n            events = events.concat(syncTreeApplyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));\r\n        }\r\n    });\r\n    if (syncPoint) {\r\n        events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));\r\n    }\r\n    return events;\r\n}\r\nfunction syncTreeCreateListenerForView_(syncTree, view) {\r\n    const query = view.query;\r\n    const tag = syncTreeTagForQuery(syncTree, query);\r\n    return {\r\n        hashFn: () => {\r\n            const cache = viewGetServerCache(view) || ChildrenNode.EMPTY_NODE;\r\n            return cache.hash();\r\n        },\r\n        onComplete: (status) => {\r\n            if (status === 'ok') {\r\n                if (tag) {\r\n                    return syncTreeApplyTaggedListenComplete(syncTree, query._path, tag);\r\n                }\r\n                else {\r\n                    return syncTreeApplyListenComplete(syncTree, query._path);\r\n                }\r\n            }\r\n            else {\r\n                // If a listen failed, kill all of the listeners here, not just the one that triggered the error.\r\n                // Note that this may need to be scoped to just this listener if we change permissions on filtered children\r\n                const error = errorForServerCode(status, query);\r\n                return syncTreeRemoveEventRegistration(syncTree, query, \r\n                /*eventRegistration*/ null, error);\r\n            }\r\n        }\r\n    };\r\n}\r\n/**\r\n * Return the tag associated with the given query.\r\n */\r\nfunction syncTreeTagForQuery(syncTree, query) {\r\n    const queryKey = syncTreeMakeQueryKey_(query);\r\n    return syncTree.queryToTagMap.get(queryKey);\r\n}\r\n/**\r\n * Given a query, computes a \"queryKey\" suitable for use in our queryToTagMap_.\r\n */\r\nfunction syncTreeMakeQueryKey_(query) {\r\n    return query._path.toString() + '$' + query._queryIdentifier;\r\n}\r\n/**\r\n * Return the query associated with the given tag, if we have one\r\n */\r\nfunction syncTreeQueryKeyForTag_(syncTree, tag) {\r\n    return syncTree.tagToQueryMap.get(tag);\r\n}\r\n/**\r\n * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.\r\n */\r\nfunction syncTreeParseQueryKey_(queryKey) {\r\n    const splitIndex = queryKey.indexOf('$');\r\n    index_esm2017_assert(splitIndex !== -1 && splitIndex < queryKey.length - 1, 'Bad queryKey.');\r\n    return {\r\n        queryId: queryKey.substr(splitIndex + 1),\r\n        path: new Path(queryKey.substr(0, splitIndex))\r\n    };\r\n}\r\n/**\r\n * A helper method to apply tagged operations\r\n */\r\nfunction syncTreeApplyTaggedOperation_(syncTree, queryPath, operation) {\r\n    const syncPoint = syncTree.syncPointTree_.get(queryPath);\r\n    index_esm2017_assert(syncPoint, \"Missing sync point for query tag that we're tracking\");\r\n    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, queryPath);\r\n    return syncPointApplyOperation(syncPoint, operation, writesCache, null);\r\n}\r\n/**\r\n * This collapses multiple unfiltered views into a single view, since we only need a single\r\n * listener for them.\r\n */\r\nfunction syncTreeCollectDistinctViewsForSubTree_(subtree) {\r\n    return subtree.fold((relativePath, maybeChildSyncPoint, childMap) => {\r\n        if (maybeChildSyncPoint && syncPointHasCompleteView(maybeChildSyncPoint)) {\r\n            const completeView = syncPointGetCompleteView(maybeChildSyncPoint);\r\n            return [completeView];\r\n        }\r\n        else {\r\n            // No complete view here, flatten any deeper listens into an array\r\n            let views = [];\r\n            if (maybeChildSyncPoint) {\r\n                views = syncPointGetQueryViews(maybeChildSyncPoint);\r\n            }\r\n            each(childMap, (_key, childViews) => {\r\n                views = views.concat(childViews);\r\n            });\r\n            return views;\r\n        }\r\n    });\r\n}\r\n/**\r\n * Normalizes a query to a query we send the server for listening\r\n *\r\n * @returns The normalized query\r\n */\r\nfunction syncTreeQueryForListening_(query) {\r\n    if (query._queryParams.loadsAllData() && !query._queryParams.isDefault()) {\r\n        // We treat queries that load all data as default queries\r\n        // Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits\r\n        // from Query\r\n        return new (syncTreeGetReferenceConstructor())(query._repo, query._path);\r\n    }\r\n    else {\r\n        return query;\r\n    }\r\n}\r\nfunction syncTreeRemoveTags_(syncTree, queries) {\r\n    for (let j = 0; j < queries.length; ++j) {\r\n        const removedQuery = queries[j];\r\n        if (!removedQuery._queryParams.loadsAllData()) {\r\n            // We should have a tag for this\r\n            const removedQueryKey = syncTreeMakeQueryKey_(removedQuery);\r\n            const removedQueryTag = syncTree.queryToTagMap.get(removedQueryKey);\r\n            syncTree.queryToTagMap.delete(removedQueryKey);\r\n            syncTree.tagToQueryMap.delete(removedQueryTag);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Static accessor for query tags.\r\n */\r\nfunction syncTreeGetNextQueryTag_() {\r\n    return syncTreeNextQueryTag_++;\r\n}\r\n/**\r\n * For a given new listen, manage the de-duplication of outstanding subscriptions.\r\n *\r\n * @returns This method can return events to support synchronous data sources\r\n */\r\nfunction syncTreeSetupListener_(syncTree, query, view) {\r\n    const path = query._path;\r\n    const tag = syncTreeTagForQuery(syncTree, query);\r\n    const listener = syncTreeCreateListenerForView_(syncTree, view);\r\n    const events = syncTree.listenProvider_.startListening(syncTreeQueryForListening_(query), tag, listener.hashFn, listener.onComplete);\r\n    const subtree = syncTree.syncPointTree_.subtree(path);\r\n    // The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we\r\n    // may need to shadow other listens as well.\r\n    if (tag) {\r\n        index_esm2017_assert(!syncPointHasCompleteView(subtree.value), \"If we're adding a query, it shouldn't be shadowed\");\r\n    }\r\n    else {\r\n        // Shadow everything at or below this location, this is a default listener.\r\n        const queriesToStop = subtree.fold((relativePath, maybeChildSyncPoint, childMap) => {\r\n            if (!pathIsEmpty(relativePath) &&\r\n                maybeChildSyncPoint &&\r\n                syncPointHasCompleteView(maybeChildSyncPoint)) {\r\n                return [syncPointGetCompleteView(maybeChildSyncPoint).query];\r\n            }\r\n            else {\r\n                // No default listener here, flatten any deeper queries into an array\r\n                let queries = [];\r\n                if (maybeChildSyncPoint) {\r\n                    queries = queries.concat(syncPointGetQueryViews(maybeChildSyncPoint).map(view => view.query));\r\n                }\r\n                each(childMap, (_key, childQueries) => {\r\n                    queries = queries.concat(childQueries);\r\n                });\r\n                return queries;\r\n            }\r\n        });\r\n        for (let i = 0; i < queriesToStop.length; ++i) {\r\n            const queryToStop = queriesToStop[i];\r\n            syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToStop), syncTreeTagForQuery(syncTree, queryToStop));\r\n        }\r\n    }\r\n    return events;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nclass ExistingValueProvider {\r\n    constructor(node_) {\r\n        this.node_ = node_;\r\n    }\r\n    getImmediateChild(childName) {\r\n        const child = this.node_.getImmediateChild(childName);\r\n        return new ExistingValueProvider(child);\r\n    }\r\n    node() {\r\n        return this.node_;\r\n    }\r\n}\r\nclass DeferredValueProvider {\r\n    constructor(syncTree, path) {\r\n        this.syncTree_ = syncTree;\r\n        this.path_ = path;\r\n    }\r\n    getImmediateChild(childName) {\r\n        const childPath = pathChild(this.path_, childName);\r\n        return new DeferredValueProvider(this.syncTree_, childPath);\r\n    }\r\n    node() {\r\n        return syncTreeCalcCompleteEventCache(this.syncTree_, this.path_);\r\n    }\r\n}\r\n/**\r\n * Generate placeholders for deferred values.\r\n */\r\nconst generateWithValues = function (values) {\r\n    values = values || {};\r\n    values['timestamp'] = values['timestamp'] || new Date().getTime();\r\n    return values;\r\n};\r\n/**\r\n * Value to use when firing local events. When writing server values, fire\r\n * local events with an approximate value, otherwise return value as-is.\r\n */\r\nconst resolveDeferredLeafValue = function (value, existingVal, serverValues) {\r\n    if (!value || typeof value !== 'object') {\r\n        return value;\r\n    }\r\n    index_esm2017_assert('.sv' in value, 'Unexpected leaf node or priority contents');\r\n    if (typeof value['.sv'] === 'string') {\r\n        return resolveScalarDeferredValue(value['.sv'], existingVal, serverValues);\r\n    }\r\n    else if (typeof value['.sv'] === 'object') {\r\n        return resolveComplexDeferredValue(value['.sv'], existingVal);\r\n    }\r\n    else {\r\n        index_esm2017_assert(false, 'Unexpected server value: ' + JSON.stringify(value, null, 2));\r\n    }\r\n};\r\nconst resolveScalarDeferredValue = function (op, existing, serverValues) {\r\n    switch (op) {\r\n        case 'timestamp':\r\n            return serverValues['timestamp'];\r\n        default:\r\n            index_esm2017_assert(false, 'Unexpected server value: ' + op);\r\n    }\r\n};\r\nconst resolveComplexDeferredValue = function (op, existing, unused) {\r\n    if (!op.hasOwnProperty('increment')) {\r\n        index_esm2017_assert(false, 'Unexpected server value: ' + JSON.stringify(op, null, 2));\r\n    }\r\n    const delta = op['increment'];\r\n    if (typeof delta !== 'number') {\r\n        index_esm2017_assert(false, 'Unexpected increment value: ' + delta);\r\n    }\r\n    const existingNode = existing.node();\r\n    index_esm2017_assert(existingNode !== null && typeof existingNode !== 'undefined', 'Expected ChildrenNode.EMPTY_NODE for nulls');\r\n    // Incrementing a non-number sets the value to the incremented amount\r\n    if (!existingNode.isLeafNode()) {\r\n        return delta;\r\n    }\r\n    const leaf = existingNode;\r\n    const existingVal = leaf.getValue();\r\n    if (typeof existingVal !== 'number') {\r\n        return delta;\r\n    }\r\n    // No need to do over/underflow arithmetic here because JS only handles floats under the covers\r\n    return existingVal + delta;\r\n};\r\n/**\r\n * Recursively replace all deferred values and priorities in the tree with the\r\n * specified generated replacement values.\r\n * @param path - path to which write is relative\r\n * @param node - new data written at path\r\n * @param syncTree - current data\r\n */\r\nconst resolveDeferredValueTree = function (path, node, syncTree, serverValues) {\r\n    return resolveDeferredValue(node, new DeferredValueProvider(syncTree, path), serverValues);\r\n};\r\n/**\r\n * Recursively replace all deferred values and priorities in the node with the\r\n * specified generated replacement values.  If there are no server values in the node,\r\n * it'll be returned as-is.\r\n */\r\nconst resolveDeferredValueSnapshot = function (node, existing, serverValues) {\r\n    return resolveDeferredValue(node, new ExistingValueProvider(existing), serverValues);\r\n};\r\nfunction resolveDeferredValue(node, existingVal, serverValues) {\r\n    const rawPri = node.getPriority().val();\r\n    const priority = resolveDeferredLeafValue(rawPri, existingVal.getImmediateChild('.priority'), serverValues);\r\n    let newNode;\r\n    if (node.isLeafNode()) {\r\n        const leafNode = node;\r\n        const value = resolveDeferredLeafValue(leafNode.getValue(), existingVal, serverValues);\r\n        if (value !== leafNode.getValue() ||\r\n            priority !== leafNode.getPriority().val()) {\r\n            return new LeafNode(value, nodeFromJSON(priority));\r\n        }\r\n        else {\r\n            return node;\r\n        }\r\n    }\r\n    else {\r\n        const childrenNode = node;\r\n        newNode = childrenNode;\r\n        if (priority !== childrenNode.getPriority().val()) {\r\n            newNode = newNode.updatePriority(new LeafNode(priority));\r\n        }\r\n        childrenNode.forEachChild(PRIORITY_INDEX, (childName, childNode) => {\r\n            const newChildNode = resolveDeferredValue(childNode, existingVal.getImmediateChild(childName), serverValues);\r\n            if (newChildNode !== childNode) {\r\n                newNode = newNode.updateImmediateChild(childName, newChildNode);\r\n            }\r\n        });\r\n        return newNode;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A light-weight tree, traversable by path.  Nodes can have both values and children.\r\n * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty\r\n * children.\r\n */\r\nclass Tree {\r\n    /**\r\n     * @param name - Optional name of the node.\r\n     * @param parent - Optional parent node.\r\n     * @param node - Optional node to wrap.\r\n     */\r\n    constructor(name = '', parent = null, node = { children: {}, childCount: 0 }) {\r\n        this.name = name;\r\n        this.parent = parent;\r\n        this.node = node;\r\n    }\r\n}\r\n/**\r\n * Returns a sub-Tree for the given path.\r\n *\r\n * @param pathObj - Path to look up.\r\n * @returns Tree for path.\r\n */\r\nfunction treeSubTree(tree, pathObj) {\r\n    // TODO: Require pathObj to be Path?\r\n    let path = pathObj instanceof Path ? pathObj : new Path(pathObj);\r\n    let child = tree, next = pathGetFront(path);\r\n    while (next !== null) {\r\n        const childNode = index_esm2017_safeGet(child.node.children, next) || {\r\n            children: {},\r\n            childCount: 0\r\n        };\r\n        child = new Tree(next, child, childNode);\r\n        path = pathPopFront(path);\r\n        next = pathGetFront(path);\r\n    }\r\n    return child;\r\n}\r\n/**\r\n * Returns the data associated with this tree node.\r\n *\r\n * @returns The data or null if no data exists.\r\n */\r\nfunction treeGetValue(tree) {\r\n    return tree.node.value;\r\n}\r\n/**\r\n * Sets data to this tree node.\r\n *\r\n * @param value - Value to set.\r\n */\r\nfunction treeSetValue(tree, value) {\r\n    tree.node.value = value;\r\n    treeUpdateParents(tree);\r\n}\r\n/**\r\n * @returns Whether the tree has any children.\r\n */\r\nfunction treeHasChildren(tree) {\r\n    return tree.node.childCount > 0;\r\n}\r\n/**\r\n * @returns Whether the tree is empty (no value or children).\r\n */\r\nfunction treeIsEmpty(tree) {\r\n    return treeGetValue(tree) === undefined && !treeHasChildren(tree);\r\n}\r\n/**\r\n * Calls action for each child of this tree node.\r\n *\r\n * @param action - Action to be called for each child.\r\n */\r\nfunction treeForEachChild(tree, action) {\r\n    each(tree.node.children, (child, childTree) => {\r\n        action(new Tree(child, tree, childTree));\r\n    });\r\n}\r\n/**\r\n * Does a depth-first traversal of this node's descendants, calling action for each one.\r\n *\r\n * @param action - Action to be called for each child.\r\n * @param includeSelf - Whether to call action on this node as well. Defaults to\r\n *   false.\r\n * @param childrenFirst - Whether to call action on children before calling it on\r\n *   parent.\r\n */\r\nfunction treeForEachDescendant(tree, action, includeSelf, childrenFirst) {\r\n    if (includeSelf && !childrenFirst) {\r\n        action(tree);\r\n    }\r\n    treeForEachChild(tree, child => {\r\n        treeForEachDescendant(child, action, true, childrenFirst);\r\n    });\r\n    if (includeSelf && childrenFirst) {\r\n        action(tree);\r\n    }\r\n}\r\n/**\r\n * Calls action on each ancestor node.\r\n *\r\n * @param action - Action to be called on each parent; return\r\n *   true to abort.\r\n * @param includeSelf - Whether to call action on this node as well.\r\n * @returns true if the action callback returned true.\r\n */\r\nfunction treeForEachAncestor(tree, action, includeSelf) {\r\n    let node = includeSelf ? tree : tree.parent;\r\n    while (node !== null) {\r\n        if (action(node)) {\r\n            return true;\r\n        }\r\n        node = node.parent;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * @returns The path of this tree node, as a Path.\r\n */\r\nfunction treeGetPath(tree) {\r\n    return new Path(tree.parent === null\r\n        ? tree.name\r\n        : treeGetPath(tree.parent) + '/' + tree.name);\r\n}\r\n/**\r\n * Adds or removes this child from its parent based on whether it's empty or not.\r\n */\r\nfunction treeUpdateParents(tree) {\r\n    if (tree.parent !== null) {\r\n        treeUpdateChild(tree.parent, tree.name, tree);\r\n    }\r\n}\r\n/**\r\n * Adds or removes the passed child to this tree node, depending on whether it's empty.\r\n *\r\n * @param childName - The name of the child to update.\r\n * @param child - The child to update.\r\n */\r\nfunction treeUpdateChild(tree, childName, child) {\r\n    const childEmpty = treeIsEmpty(child);\r\n    const childExists = index_esm2017_contains(tree.node.children, childName);\r\n    if (childEmpty && childExists) {\r\n        delete tree.node.children[childName];\r\n        tree.node.childCount--;\r\n        treeUpdateParents(tree);\r\n    }\r\n    else if (!childEmpty && !childExists) {\r\n        tree.node.children[childName] = child.node;\r\n        tree.node.childCount++;\r\n        treeUpdateParents(tree);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * True for invalid Firebase keys\r\n */\r\nconst INVALID_KEY_REGEX_ = /[\\[\\].#$\\/\\u0000-\\u001F\\u007F]/;\r\n/**\r\n * True for invalid Firebase paths.\r\n * Allows '/' in paths.\r\n */\r\nconst INVALID_PATH_REGEX_ = /[\\[\\].#$\\u0000-\\u001F\\u007F]/;\r\n/**\r\n * Maximum number of characters to allow in leaf value\r\n */\r\nconst MAX_LEAF_SIZE_ = 10 * 1024 * 1024;\r\nconst index_esm2017_isValidKey = function (key) {\r\n    return (typeof key === 'string' && key.length !== 0 && !INVALID_KEY_REGEX_.test(key));\r\n};\r\nconst isValidPathString = function (pathString) {\r\n    return (typeof pathString === 'string' &&\r\n        pathString.length !== 0 &&\r\n        !INVALID_PATH_REGEX_.test(pathString));\r\n};\r\nconst isValidRootPathString = function (pathString) {\r\n    if (pathString) {\r\n        // Allow '/.info/' at the beginning.\r\n        pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\r\n    }\r\n    return isValidPathString(pathString);\r\n};\r\nconst isValidPriority = function (priority) {\r\n    return (priority === null ||\r\n        typeof priority === 'string' ||\r\n        (typeof priority === 'number' && !isInvalidJSONNumber(priority)) ||\r\n        (priority &&\r\n            typeof priority === 'object' &&\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            index_esm2017_contains(priority, '.sv')));\r\n};\r\n/**\r\n * Pre-validate a datum passed as an argument to Firebase function.\r\n */\r\nconst validateFirebaseDataArg = function (fnName, value, path, optional) {\r\n    if (optional && value === undefined) {\r\n        return;\r\n    }\r\n    validateFirebaseData(index_esm2017_errorPrefix(fnName, 'value'), value, path);\r\n};\r\n/**\r\n * Validate a data object client-side before sending to server.\r\n */\r\nconst validateFirebaseData = function (errorPrefix, data, path_) {\r\n    const path = path_ instanceof Path ? new ValidationPath(path_, errorPrefix) : path_;\r\n    if (data === undefined) {\r\n        throw new Error(errorPrefix + 'contains undefined ' + validationPathToErrorString(path));\r\n    }\r\n    if (typeof data === 'function') {\r\n        throw new Error(errorPrefix +\r\n            'contains a function ' +\r\n            validationPathToErrorString(path) +\r\n            ' with contents = ' +\r\n            data.toString());\r\n    }\r\n    if (isInvalidJSONNumber(data)) {\r\n        throw new Error(errorPrefix +\r\n            'contains ' +\r\n            data.toString() +\r\n            ' ' +\r\n            validationPathToErrorString(path));\r\n    }\r\n    // Check max leaf size, but try to avoid the utf8 conversion if we can.\r\n    if (typeof data === 'string' &&\r\n        data.length > MAX_LEAF_SIZE_ / 3 &&\r\n        stringLength(data) > MAX_LEAF_SIZE_) {\r\n        throw new Error(errorPrefix +\r\n            'contains a string greater than ' +\r\n            MAX_LEAF_SIZE_ +\r\n            ' utf8 bytes ' +\r\n            validationPathToErrorString(path) +\r\n            \" ('\" +\r\n            data.substring(0, 50) +\r\n            \"...')\");\r\n    }\r\n    // TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON\r\n    // to save extra walking of large objects.\r\n    if (data && typeof data === 'object') {\r\n        let hasDotValue = false;\r\n        let hasActualChild = false;\r\n        each(data, (key, value) => {\r\n            if (key === '.value') {\r\n                hasDotValue = true;\r\n            }\r\n            else if (key !== '.priority' && key !== '.sv') {\r\n                hasActualChild = true;\r\n                if (!index_esm2017_isValidKey(key)) {\r\n                    throw new Error(errorPrefix +\r\n                        ' contains an invalid key (' +\r\n                        key +\r\n                        ') ' +\r\n                        validationPathToErrorString(path) +\r\n                        '.  Keys must be non-empty strings ' +\r\n                        'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"');\r\n                }\r\n            }\r\n            validationPathPush(path, key);\r\n            validateFirebaseData(errorPrefix, value, path);\r\n            validationPathPop(path);\r\n        });\r\n        if (hasDotValue && hasActualChild) {\r\n            throw new Error(errorPrefix +\r\n                ' contains \".value\" child ' +\r\n                validationPathToErrorString(path) +\r\n                ' in addition to actual children.');\r\n        }\r\n    }\r\n};\r\n/**\r\n * Pre-validate paths passed in the firebase function.\r\n */\r\nconst validateFirebaseMergePaths = function (errorPrefix, mergePaths) {\r\n    let i, curPath;\r\n    for (i = 0; i < mergePaths.length; i++) {\r\n        curPath = mergePaths[i];\r\n        const keys = pathSlice(curPath);\r\n        for (let j = 0; j < keys.length; j++) {\r\n            if (keys[j] === '.priority' && j === keys.length - 1) ;\r\n            else if (!index_esm2017_isValidKey(keys[j])) {\r\n                throw new Error(errorPrefix +\r\n                    'contains an invalid key (' +\r\n                    keys[j] +\r\n                    ') in path ' +\r\n                    curPath.toString() +\r\n                    '. Keys must be non-empty strings ' +\r\n                    'and can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\"');\r\n            }\r\n        }\r\n    }\r\n    // Check that update keys are not descendants of each other.\r\n    // We rely on the property that sorting guarantees that ancestors come\r\n    // right before descendants.\r\n    mergePaths.sort(pathCompare);\r\n    let prevPath = null;\r\n    for (i = 0; i < mergePaths.length; i++) {\r\n        curPath = mergePaths[i];\r\n        if (prevPath !== null && pathContains(prevPath, curPath)) {\r\n            throw new Error(errorPrefix +\r\n                'contains a path ' +\r\n                prevPath.toString() +\r\n                ' that is ancestor of another path ' +\r\n                curPath.toString());\r\n        }\r\n        prevPath = curPath;\r\n    }\r\n};\r\n/**\r\n * pre-validate an object passed as an argument to firebase function (\r\n * must be an object - e.g. for firebase.update()).\r\n */\r\nconst validateFirebaseMergeDataArg = function (fnName, data, path, optional) {\r\n    if (optional && data === undefined) {\r\n        return;\r\n    }\r\n    const errorPrefix$1 = errorPrefix(fnName, 'values');\r\n    if (!(data && typeof data === 'object') || Array.isArray(data)) {\r\n        throw new Error(errorPrefix$1 + ' must be an object containing the children to replace.');\r\n    }\r\n    const mergePaths = [];\r\n    each(data, (key, value) => {\r\n        const curPath = new Path(key);\r\n        validateFirebaseData(errorPrefix$1, value, pathChild(path, curPath));\r\n        if (pathGetBack(curPath) === '.priority') {\r\n            if (!isValidPriority(value)) {\r\n                throw new Error(errorPrefix$1 +\r\n                    \"contains an invalid value for '\" +\r\n                    curPath.toString() +\r\n                    \"', which must be a valid \" +\r\n                    'Firebase priority (a string, finite number, server value, or null).');\r\n            }\r\n        }\r\n        mergePaths.push(curPath);\r\n    });\r\n    validateFirebaseMergePaths(errorPrefix$1, mergePaths);\r\n};\r\nconst validatePriority = function (fnName, priority, optional) {\r\n    if (optional && priority === undefined) {\r\n        return;\r\n    }\r\n    if (isInvalidJSONNumber(priority)) {\r\n        throw new Error(errorPrefix(fnName, 'priority') +\r\n            'is ' +\r\n            priority.toString() +\r\n            ', but must be a valid Firebase priority (a string, finite number, ' +\r\n            'server value, or null).');\r\n    }\r\n    // Special case to allow importing data with a .sv.\r\n    if (!isValidPriority(priority)) {\r\n        throw new Error(errorPrefix(fnName, 'priority') +\r\n            'must be a valid Firebase priority ' +\r\n            '(a string, finite number, server value, or null).');\r\n    }\r\n};\r\nconst validateKey = function (fnName, argumentName, key, optional) {\r\n    if (optional && key === undefined) {\r\n        return;\r\n    }\r\n    if (!index_esm2017_isValidKey(key)) {\r\n        throw new Error(errorPrefix(fnName, argumentName) +\r\n            'was an invalid key = \"' +\r\n            key +\r\n            '\".  Firebase keys must be non-empty strings and ' +\r\n            'can\\'t contain \".\", \"#\", \"$\", \"/\", \"[\", or \"]\").');\r\n    }\r\n};\r\n/**\r\n * @internal\r\n */\r\nconst validatePathString = function (fnName, argumentName, pathString, optional) {\r\n    if (optional && pathString === undefined) {\r\n        return;\r\n    }\r\n    if (!isValidPathString(pathString)) {\r\n        throw new Error(index_esm2017_errorPrefix(fnName, argumentName) +\r\n            'was an invalid path = \"' +\r\n            pathString +\r\n            '\". Paths must be non-empty strings and ' +\r\n            'can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\"');\r\n    }\r\n};\r\nconst validateRootPathString = function (fnName, argumentName, pathString, optional) {\r\n    if (pathString) {\r\n        // Allow '/.info/' at the beginning.\r\n        pathString = pathString.replace(/^\\/*\\.info(\\/|$)/, '/');\r\n    }\r\n    validatePathString(fnName, argumentName, pathString, optional);\r\n};\r\n/**\r\n * @internal\r\n */\r\nconst validateWritablePath = function (fnName, path) {\r\n    if (pathGetFront(path) === '.info') {\r\n        throw new Error(fnName + \" failed = Can't modify data under /.info/\");\r\n    }\r\n};\r\nconst validateUrl = function (fnName, parsedUrl) {\r\n    // TODO = Validate server better.\r\n    const pathString = parsedUrl.path.toString();\r\n    if (!(typeof parsedUrl.repoInfo.host === 'string') ||\r\n        parsedUrl.repoInfo.host.length === 0 ||\r\n        (!index_esm2017_isValidKey(parsedUrl.repoInfo.namespace) &&\r\n            parsedUrl.repoInfo.host.split(':')[0] !== 'localhost') ||\r\n        (pathString.length !== 0 && !isValidRootPathString(pathString))) {\r\n        throw new Error(index_esm2017_errorPrefix(fnName, 'url') +\r\n            'must be a valid firebase URL and ' +\r\n            'the path can\\'t contain \".\", \"#\", \"$\", \"[\", or \"]\".');\r\n    }\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The event queue serves a few purposes:\r\n * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more\r\n *    events being queued.\r\n * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,\r\n *    raiseQueuedEvents() is called again, the \"inner\" call will pick up raising events where the \"outer\" call\r\n *    left off, ensuring that the events are still raised synchronously and in order.\r\n * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued\r\n *    events are raised synchronously.\r\n *\r\n * NOTE: This can all go away if/when we move to async events.\r\n *\r\n */\r\nclass EventQueue {\r\n    constructor() {\r\n        this.eventLists_ = [];\r\n        /**\r\n         * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.\r\n         */\r\n        this.recursionDepth_ = 0;\r\n    }\r\n}\r\n/**\r\n * @param eventDataList - The new events to queue.\r\n */\r\nfunction eventQueueQueueEvents(eventQueue, eventDataList) {\r\n    // We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.\r\n    let currList = null;\r\n    for (let i = 0; i < eventDataList.length; i++) {\r\n        const data = eventDataList[i];\r\n        const path = data.getPath();\r\n        if (currList !== null && !pathEquals(path, currList.path)) {\r\n            eventQueue.eventLists_.push(currList);\r\n            currList = null;\r\n        }\r\n        if (currList === null) {\r\n            currList = { events: [], path };\r\n        }\r\n        currList.events.push(data);\r\n    }\r\n    if (currList) {\r\n        eventQueue.eventLists_.push(currList);\r\n    }\r\n}\r\n/**\r\n * Queues the specified events and synchronously raises all events (including previously queued ones)\r\n * for the specified path.\r\n *\r\n * It is assumed that the new events are all for the specified path.\r\n *\r\n * @param path - The path to raise events for.\r\n * @param eventDataList - The new events to raise.\r\n */\r\nfunction eventQueueRaiseEventsAtPath(eventQueue, path, eventDataList) {\r\n    eventQueueQueueEvents(eventQueue, eventDataList);\r\n    eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, eventPath => pathEquals(eventPath, path));\r\n}\r\n/**\r\n * Queues the specified events and synchronously raises all events (including previously queued ones) for\r\n * locations related to the specified change path (i.e. all ancestors and descendants).\r\n *\r\n * It is assumed that the new events are all related (ancestor or descendant) to the specified path.\r\n *\r\n * @param changedPath - The path to raise events for.\r\n * @param eventDataList - The events to raise\r\n */\r\nfunction eventQueueRaiseEventsForChangedPath(eventQueue, changedPath, eventDataList) {\r\n    eventQueueQueueEvents(eventQueue, eventDataList);\r\n    eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, eventPath => pathContains(eventPath, changedPath) ||\r\n        pathContains(changedPath, eventPath));\r\n}\r\nfunction eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, predicate) {\r\n    eventQueue.recursionDepth_++;\r\n    let sentAll = true;\r\n    for (let i = 0; i < eventQueue.eventLists_.length; i++) {\r\n        const eventList = eventQueue.eventLists_[i];\r\n        if (eventList) {\r\n            const eventPath = eventList.path;\r\n            if (predicate(eventPath)) {\r\n                eventListRaise(eventQueue.eventLists_[i]);\r\n                eventQueue.eventLists_[i] = null;\r\n            }\r\n            else {\r\n                sentAll = false;\r\n            }\r\n        }\r\n    }\r\n    if (sentAll) {\r\n        eventQueue.eventLists_ = [];\r\n    }\r\n    eventQueue.recursionDepth_--;\r\n}\r\n/**\r\n * Iterates through the list and raises each event\r\n */\r\nfunction eventListRaise(eventList) {\r\n    for (let i = 0; i < eventList.events.length; i++) {\r\n        const eventData = eventList.events[i];\r\n        if (eventData !== null) {\r\n            eventList.events[i] = null;\r\n            const eventFn = eventData.getEventRunner();\r\n            if (index_esm2017_logger) {\r\n                log('event: ' + eventData.toString());\r\n            }\r\n            exceptionGuard(eventFn);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst INTERRUPT_REASON = 'repo_interrupt';\r\n/**\r\n * If a transaction does not succeed after 25 retries, we abort it. Among other\r\n * things this ensure that if there's ever a bug causing a mismatch between\r\n * client / server hashes for some data, we won't retry indefinitely.\r\n */\r\nconst MAX_TRANSACTION_RETRIES = 25;\r\n/**\r\n * A connection to a single data repository.\r\n */\r\nclass Repo {\r\n    constructor(repoInfo_, forceRestClient_, authTokenProvider_, appCheckProvider_) {\r\n        this.repoInfo_ = repoInfo_;\r\n        this.forceRestClient_ = forceRestClient_;\r\n        this.authTokenProvider_ = authTokenProvider_;\r\n        this.appCheckProvider_ = appCheckProvider_;\r\n        this.dataUpdateCount = 0;\r\n        this.statsListener_ = null;\r\n        this.eventQueue_ = new EventQueue();\r\n        this.nextWriteId_ = 1;\r\n        this.interceptServerDataCallback_ = null;\r\n        /** A list of data pieces and paths to be set when this client disconnects. */\r\n        this.onDisconnect_ = newSparseSnapshotTree();\r\n        /** Stores queues of outstanding transactions for Firebase locations. */\r\n        this.transactionQueueTree_ = new Tree();\r\n        // TODO: This should be @private but it's used by test_access.js and internal.js\r\n        this.persistentConnection_ = null;\r\n        // This key is intentionally not updated if RepoInfo is later changed or replaced\r\n        this.key = this.repoInfo_.toURLString();\r\n    }\r\n    /**\r\n     * @returns The URL corresponding to the root of this Firebase.\r\n     */\r\n    toString() {\r\n        return ((this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host);\r\n    }\r\n}\r\nfunction repoStart(repo, appId, authOverride) {\r\n    repo.stats_ = statsManagerGetCollection(repo.repoInfo_);\r\n    if (repo.forceRestClient_ || beingCrawled()) {\r\n        repo.server_ = new ReadonlyRestClient(repo.repoInfo_, (pathString, data, isMerge, tag) => {\r\n            repoOnDataUpdate(repo, pathString, data, isMerge, tag);\r\n        }, repo.authTokenProvider_, repo.appCheckProvider_);\r\n        // Minor hack: Fire onConnect immediately, since there's no actual connection.\r\n        setTimeout(() => repoOnConnectStatus(repo, /* connectStatus= */ true), 0);\r\n    }\r\n    else {\r\n        // Validate authOverride\r\n        if (typeof authOverride !== 'undefined' && authOverride !== null) {\r\n            if (typeof authOverride !== 'object') {\r\n                throw new Error('Only objects are supported for option databaseAuthVariableOverride');\r\n            }\r\n            try {\r\n                index_esm2017_stringify(authOverride);\r\n            }\r\n            catch (e) {\r\n                throw new Error('Invalid authOverride provided: ' + e);\r\n            }\r\n        }\r\n        repo.persistentConnection_ = new PersistentConnection(repo.repoInfo_, appId, (pathString, data, isMerge, tag) => {\r\n            repoOnDataUpdate(repo, pathString, data, isMerge, tag);\r\n        }, (connectStatus) => {\r\n            repoOnConnectStatus(repo, connectStatus);\r\n        }, (updates) => {\r\n            repoOnServerInfoUpdate(repo, updates);\r\n        }, repo.authTokenProvider_, repo.appCheckProvider_, authOverride);\r\n        repo.server_ = repo.persistentConnection_;\r\n    }\r\n    repo.authTokenProvider_.addTokenChangeListener(token => {\r\n        repo.server_.refreshAuthToken(token);\r\n    });\r\n    repo.appCheckProvider_.addTokenChangeListener(result => {\r\n        repo.server_.refreshAppCheckToken(result.token);\r\n    });\r\n    // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),\r\n    // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.\r\n    repo.statsReporter_ = statsManagerGetOrCreateReporter(repo.repoInfo_, () => new StatsReporter(repo.stats_, repo.server_));\r\n    // Used for .info.\r\n    repo.infoData_ = new SnapshotHolder();\r\n    repo.infoSyncTree_ = new SyncTree({\r\n        startListening: (query, tag, currentHashFn, onComplete) => {\r\n            let infoEvents = [];\r\n            const node = repo.infoData_.getNode(query._path);\r\n            // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events\r\n            // on initial data...\r\n            if (!node.isEmpty()) {\r\n                infoEvents = syncTreeApplyServerOverwrite(repo.infoSyncTree_, query._path, node);\r\n                setTimeout(() => {\r\n                    onComplete('ok');\r\n                }, 0);\r\n            }\r\n            return infoEvents;\r\n        },\r\n        stopListening: () => { }\r\n    });\r\n    repoUpdateInfo(repo, 'connected', false);\r\n    repo.serverSyncTree_ = new SyncTree({\r\n        startListening: (query, tag, currentHashFn, onComplete) => {\r\n            repo.server_.listen(query, currentHashFn, tag, (status, data) => {\r\n                const events = onComplete(status, data);\r\n                eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query._path, events);\r\n            });\r\n            // No synchronous events for network-backed sync trees\r\n            return [];\r\n        },\r\n        stopListening: (query, tag) => {\r\n            repo.server_.unlisten(query, tag);\r\n        }\r\n    });\r\n}\r\n/**\r\n * @returns The time in milliseconds, taking the server offset into account if we have one.\r\n */\r\nfunction repoServerTime(repo) {\r\n    const offsetNode = repo.infoData_.getNode(new Path('.info/serverTimeOffset'));\r\n    const offset = offsetNode.val() || 0;\r\n    return new Date().getTime() + offset;\r\n}\r\n/**\r\n * Generate ServerValues using some variables from the repo object.\r\n */\r\nfunction repoGenerateServerValues(repo) {\r\n    return generateWithValues({\r\n        timestamp: repoServerTime(repo)\r\n    });\r\n}\r\n/**\r\n * Called by realtime when we get new messages from the server.\r\n */\r\nfunction repoOnDataUpdate(repo, pathString, data, isMerge, tag) {\r\n    // For testing.\r\n    repo.dataUpdateCount++;\r\n    const path = new Path(pathString);\r\n    data = repo.interceptServerDataCallback_\r\n        ? repo.interceptServerDataCallback_(pathString, data)\r\n        : data;\r\n    let events = [];\r\n    if (tag) {\r\n        if (isMerge) {\r\n            const taggedChildren = map(data, (raw) => nodeFromJSON(raw));\r\n            events = syncTreeApplyTaggedQueryMerge(repo.serverSyncTree_, path, taggedChildren, tag);\r\n        }\r\n        else {\r\n            const taggedSnap = nodeFromJSON(data);\r\n            events = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, path, taggedSnap, tag);\r\n        }\r\n    }\r\n    else if (isMerge) {\r\n        const changedChildren = map(data, (raw) => nodeFromJSON(raw));\r\n        events = syncTreeApplyServerMerge(repo.serverSyncTree_, path, changedChildren);\r\n    }\r\n    else {\r\n        const snap = nodeFromJSON(data);\r\n        events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap);\r\n    }\r\n    let affectedPath = path;\r\n    if (events.length > 0) {\r\n        // Since we have a listener outstanding for each transaction, receiving any events\r\n        // is a proxy for some change having occurred.\r\n        affectedPath = repoRerunTransactions(repo, path);\r\n    }\r\n    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, events);\r\n}\r\nfunction repoOnConnectStatus(repo, connectStatus) {\r\n    repoUpdateInfo(repo, 'connected', connectStatus);\r\n    if (connectStatus === false) {\r\n        repoRunOnDisconnectEvents(repo);\r\n    }\r\n}\r\nfunction repoOnServerInfoUpdate(repo, updates) {\r\n    each(updates, (key, value) => {\r\n        repoUpdateInfo(repo, key, value);\r\n    });\r\n}\r\nfunction repoUpdateInfo(repo, pathString, value) {\r\n    const path = new Path('/.info/' + pathString);\r\n    const newNode = nodeFromJSON(value);\r\n    repo.infoData_.updateSnapshot(path, newNode);\r\n    const events = syncTreeApplyServerOverwrite(repo.infoSyncTree_, path, newNode);\r\n    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);\r\n}\r\nfunction repoGetNextWriteId(repo) {\r\n    return repo.nextWriteId_++;\r\n}\r\n/**\r\n * The purpose of `getValue` is to return the latest known value\r\n * satisfying `query`.\r\n *\r\n * This method will first check for in-memory cached values\r\n * belonging to active listeners. If they are found, such values\r\n * are considered to be the most up-to-date.\r\n *\r\n * If the client is not connected, this method will wait until the\r\n *  repo has established a connection and then request the value for `query`.\r\n * If the client is not able to retrieve the query result for another reason,\r\n * it reports an error.\r\n *\r\n * @param query - The query to surface a value for.\r\n */\r\nfunction repoGetValue(repo, query, eventRegistration) {\r\n    // Only active queries are cached. There is no persisted cache.\r\n    const cached = syncTreeGetServerValue(repo.serverSyncTree_, query);\r\n    if (cached != null) {\r\n        return Promise.resolve(cached);\r\n    }\r\n    return repo.server_.get(query).then(payload => {\r\n        const node = nodeFromJSON(payload).withIndex(query._queryParams.getIndex());\r\n        /**\r\n         * Below we simulate the actions of an `onlyOnce` `onValue()` event where:\r\n         * Add an event registration,\r\n         * Update data at the path,\r\n         * Raise any events,\r\n         * Cleanup the SyncTree\r\n         */\r\n        syncTreeAddEventRegistration(repo.serverSyncTree_, query, eventRegistration, true);\r\n        let events;\r\n        if (query._queryParams.loadsAllData()) {\r\n            events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, query._path, node);\r\n        }\r\n        else {\r\n            const tag = syncTreeTagForQuery(repo.serverSyncTree_, query);\r\n            events = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, query._path, node, tag);\r\n        }\r\n        /*\r\n         * We need to raise events in the scenario where `get()` is called at a parent path, and\r\n         * while the `get()` is pending, `onValue` is called at a child location. While get() is waiting\r\n         * for the data, `onValue` will register a new event. Then, get() will come back, and update the syncTree\r\n         * and its corresponding serverCache, including the child location where `onValue` is called. Then,\r\n         * `onValue` will receive the event from the server, but look at the syncTree and see that the data received\r\n         * from the server is already at the SyncPoint, and so the `onValue` callback will never get fired.\r\n         * Calling `eventQueueRaiseEventsForChangedPath()` is the correct way to propagate the events and\r\n         * ensure the corresponding child events will get fired.\r\n         */\r\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query._path, events);\r\n        syncTreeRemoveEventRegistration(repo.serverSyncTree_, query, eventRegistration, null, true);\r\n        return node;\r\n    }, err => {\r\n        repoLog(repo, 'get for query ' + stringify(query) + ' failed: ' + err);\r\n        return Promise.reject(new Error(err));\r\n    });\r\n}\r\nfunction repoSetWithPriority(repo, path, newVal, newPriority, onComplete) {\r\n    repoLog(repo, 'set', {\r\n        path: path.toString(),\r\n        value: newVal,\r\n        priority: newPriority\r\n    });\r\n    // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or\r\n    // (b) store unresolved paths on JSON parse\r\n    const serverValues = repoGenerateServerValues(repo);\r\n    const newNodeUnresolved = nodeFromJSON(newVal, newPriority);\r\n    const existing = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path);\r\n    const newNode = resolveDeferredValueSnapshot(newNodeUnresolved, existing, serverValues);\r\n    const writeId = repoGetNextWriteId(repo);\r\n    const events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, writeId, true);\r\n    eventQueueQueueEvents(repo.eventQueue_, events);\r\n    repo.server_.put(path.toString(), newNodeUnresolved.val(/*export=*/ true), (status, errorReason) => {\r\n        const success = status === 'ok';\r\n        if (!success) {\r\n            warn('set at ' + path + ' failed: ' + status);\r\n        }\r\n        const clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId, !success);\r\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, clearEvents);\r\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\r\n    });\r\n    const affectedPath = repoAbortTransactions(repo, path);\r\n    repoRerunTransactions(repo, affectedPath);\r\n    // We queued the events above, so just flush the queue here\r\n    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, []);\r\n}\r\nfunction repoUpdate(repo, path, childrenToMerge, onComplete) {\r\n    repoLog(repo, 'update', { path: path.toString(), value: childrenToMerge });\r\n    // Start with our existing data and merge each child into it.\r\n    let empty = true;\r\n    const serverValues = repoGenerateServerValues(repo);\r\n    const changedChildren = {};\r\n    each(childrenToMerge, (changedKey, changedValue) => {\r\n        empty = false;\r\n        changedChildren[changedKey] = resolveDeferredValueTree(pathChild(path, changedKey), nodeFromJSON(changedValue), repo.serverSyncTree_, serverValues);\r\n    });\r\n    if (!empty) {\r\n        const writeId = repoGetNextWriteId(repo);\r\n        const events = syncTreeApplyUserMerge(repo.serverSyncTree_, path, changedChildren, writeId);\r\n        eventQueueQueueEvents(repo.eventQueue_, events);\r\n        repo.server_.merge(path.toString(), childrenToMerge, (status, errorReason) => {\r\n            const success = status === 'ok';\r\n            if (!success) {\r\n                warn('update at ' + path + ' failed: ' + status);\r\n            }\r\n            const clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId, !success);\r\n            const affectedPath = clearEvents.length > 0 ? repoRerunTransactions(repo, path) : path;\r\n            eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, clearEvents);\r\n            repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\r\n        });\r\n        each(childrenToMerge, (changedPath) => {\r\n            const affectedPath = repoAbortTransactions(repo, pathChild(path, changedPath));\r\n            repoRerunTransactions(repo, affectedPath);\r\n        });\r\n        // We queued the events above, so just flush the queue here\r\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, []);\r\n    }\r\n    else {\r\n        log(\"update() called with empty data.  Don't do anything.\");\r\n        repoCallOnCompleteCallback(repo, onComplete, 'ok', undefined);\r\n    }\r\n}\r\n/**\r\n * Applies all of the changes stored up in the onDisconnect_ tree.\r\n */\r\nfunction repoRunOnDisconnectEvents(repo) {\r\n    repoLog(repo, 'onDisconnectEvents');\r\n    const serverValues = repoGenerateServerValues(repo);\r\n    const resolvedOnDisconnectTree = newSparseSnapshotTree();\r\n    sparseSnapshotTreeForEachTree(repo.onDisconnect_, newEmptyPath(), (path, node) => {\r\n        const resolved = resolveDeferredValueTree(path, node, repo.serverSyncTree_, serverValues);\r\n        sparseSnapshotTreeRemember(resolvedOnDisconnectTree, path, resolved);\r\n    });\r\n    let events = [];\r\n    sparseSnapshotTreeForEachTree(resolvedOnDisconnectTree, newEmptyPath(), (path, snap) => {\r\n        events = events.concat(syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap));\r\n        const affectedPath = repoAbortTransactions(repo, path);\r\n        repoRerunTransactions(repo, affectedPath);\r\n    });\r\n    repo.onDisconnect_ = newSparseSnapshotTree();\r\n    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, newEmptyPath(), events);\r\n}\r\nfunction repoOnDisconnectCancel(repo, path, onComplete) {\r\n    repo.server_.onDisconnectCancel(path.toString(), (status, errorReason) => {\r\n        if (status === 'ok') {\r\n            sparseSnapshotTreeForget(repo.onDisconnect_, path);\r\n        }\r\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\r\n    });\r\n}\r\nfunction repoOnDisconnectSet(repo, path, value, onComplete) {\r\n    const newNode = nodeFromJSON(value);\r\n    repo.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), (status, errorReason) => {\r\n        if (status === 'ok') {\r\n            sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);\r\n        }\r\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\r\n    });\r\n}\r\nfunction repoOnDisconnectSetWithPriority(repo, path, value, priority, onComplete) {\r\n    const newNode = nodeFromJSON(value, priority);\r\n    repo.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), (status, errorReason) => {\r\n        if (status === 'ok') {\r\n            sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);\r\n        }\r\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\r\n    });\r\n}\r\nfunction repoOnDisconnectUpdate(repo, path, childrenToMerge, onComplete) {\r\n    if (isEmpty(childrenToMerge)) {\r\n        log(\"onDisconnect().update() called with empty data.  Don't do anything.\");\r\n        repoCallOnCompleteCallback(repo, onComplete, 'ok', undefined);\r\n        return;\r\n    }\r\n    repo.server_.onDisconnectMerge(path.toString(), childrenToMerge, (status, errorReason) => {\r\n        if (status === 'ok') {\r\n            each(childrenToMerge, (childName, childNode) => {\r\n                const newChildNode = nodeFromJSON(childNode);\r\n                sparseSnapshotTreeRemember(repo.onDisconnect_, pathChild(path, childName), newChildNode);\r\n            });\r\n        }\r\n        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);\r\n    });\r\n}\r\nfunction repoAddEventCallbackForQuery(repo, query, eventRegistration) {\r\n    let events;\r\n    if (pathGetFront(query._path) === '.info') {\r\n        events = syncTreeAddEventRegistration(repo.infoSyncTree_, query, eventRegistration);\r\n    }\r\n    else {\r\n        events = syncTreeAddEventRegistration(repo.serverSyncTree_, query, eventRegistration);\r\n    }\r\n    eventQueueRaiseEventsAtPath(repo.eventQueue_, query._path, events);\r\n}\r\nfunction repoRemoveEventCallbackForQuery(repo, query, eventRegistration) {\r\n    // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof\r\n    // a little bit by handling the return values anyways.\r\n    let events;\r\n    if (pathGetFront(query._path) === '.info') {\r\n        events = syncTreeRemoveEventRegistration(repo.infoSyncTree_, query, eventRegistration);\r\n    }\r\n    else {\r\n        events = syncTreeRemoveEventRegistration(repo.serverSyncTree_, query, eventRegistration);\r\n    }\r\n    eventQueueRaiseEventsAtPath(repo.eventQueue_, query._path, events);\r\n}\r\nfunction repoInterrupt(repo) {\r\n    if (repo.persistentConnection_) {\r\n        repo.persistentConnection_.interrupt(INTERRUPT_REASON);\r\n    }\r\n}\r\nfunction repoResume(repo) {\r\n    if (repo.persistentConnection_) {\r\n        repo.persistentConnection_.resume(INTERRUPT_REASON);\r\n    }\r\n}\r\nfunction repoLog(repo, ...varArgs) {\r\n    let prefix = '';\r\n    if (repo.persistentConnection_) {\r\n        prefix = repo.persistentConnection_.id + ':';\r\n    }\r\n    log(prefix, ...varArgs);\r\n}\r\nfunction repoCallOnCompleteCallback(repo, callback, status, errorReason) {\r\n    if (callback) {\r\n        exceptionGuard(() => {\r\n            if (status === 'ok') {\r\n                callback(null);\r\n            }\r\n            else {\r\n                const code = (status || 'error').toUpperCase();\r\n                let message = code;\r\n                if (errorReason) {\r\n                    message += ': ' + errorReason;\r\n                }\r\n                const error = new Error(message);\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                error.code = code;\r\n                callback(error);\r\n            }\r\n        });\r\n    }\r\n}\r\n/**\r\n * Creates a new transaction, adds it to the transactions we're tracking, and\r\n * sends it to the server if possible.\r\n *\r\n * @param path - Path at which to do transaction.\r\n * @param transactionUpdate - Update callback.\r\n * @param onComplete - Completion callback.\r\n * @param unwatcher - Function that will be called when the transaction no longer\r\n * need data updates for `path`.\r\n * @param applyLocally - Whether or not to make intermediate results visible\r\n */\r\nfunction repoStartTransaction(repo, path, transactionUpdate, onComplete, unwatcher, applyLocally) {\r\n    repoLog(repo, 'transaction on ' + path);\r\n    // Initialize transaction.\r\n    const transaction = {\r\n        path,\r\n        update: transactionUpdate,\r\n        onComplete,\r\n        // One of TransactionStatus enums.\r\n        status: null,\r\n        // Used when combining transactions at different locations to figure out\r\n        // which one goes first.\r\n        order: LUIDGenerator(),\r\n        // Whether to raise local events for this transaction.\r\n        applyLocally,\r\n        // Count of how many times we've retried the transaction.\r\n        retryCount: 0,\r\n        // Function to call to clean up our .on() listener.\r\n        unwatcher,\r\n        // Stores why a transaction was aborted.\r\n        abortReason: null,\r\n        currentWriteId: null,\r\n        currentInputSnapshot: null,\r\n        currentOutputSnapshotRaw: null,\r\n        currentOutputSnapshotResolved: null\r\n    };\r\n    // Run transaction initially.\r\n    const currentState = repoGetLatestState(repo, path, undefined);\r\n    transaction.currentInputSnapshot = currentState;\r\n    const newVal = transaction.update(currentState.val());\r\n    if (newVal === undefined) {\r\n        // Abort transaction.\r\n        transaction.unwatcher();\r\n        transaction.currentOutputSnapshotRaw = null;\r\n        transaction.currentOutputSnapshotResolved = null;\r\n        if (transaction.onComplete) {\r\n            transaction.onComplete(null, false, transaction.currentInputSnapshot);\r\n        }\r\n    }\r\n    else {\r\n        validateFirebaseData('transaction failed: Data returned ', newVal, transaction.path);\r\n        // Mark as run and add to our queue.\r\n        transaction.status = 0 /* TransactionStatus.RUN */;\r\n        const queueNode = treeSubTree(repo.transactionQueueTree_, path);\r\n        const nodeQueue = treeGetValue(queueNode) || [];\r\n        nodeQueue.push(transaction);\r\n        treeSetValue(queueNode, nodeQueue);\r\n        // Update visibleData and raise events\r\n        // Note: We intentionally raise events after updating all of our\r\n        // transaction state, since the user could start new transactions from the\r\n        // event callbacks.\r\n        let priorityForNode;\r\n        if (typeof newVal === 'object' &&\r\n            newVal !== null &&\r\n            contains(newVal, '.priority')) {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            priorityForNode = safeGet(newVal, '.priority');\r\n            assert(isValidPriority(priorityForNode), 'Invalid priority returned by transaction. ' +\r\n                'Priority must be a valid string, finite number, server value, or null.');\r\n        }\r\n        else {\r\n            const currentNode = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path) ||\r\n                ChildrenNode.EMPTY_NODE;\r\n            priorityForNode = currentNode.getPriority().val();\r\n        }\r\n        const serverValues = repoGenerateServerValues(repo);\r\n        const newNodeUnresolved = nodeFromJSON(newVal, priorityForNode);\r\n        const newNode = resolveDeferredValueSnapshot(newNodeUnresolved, currentState, serverValues);\r\n        transaction.currentOutputSnapshotRaw = newNodeUnresolved;\r\n        transaction.currentOutputSnapshotResolved = newNode;\r\n        transaction.currentWriteId = repoGetNextWriteId(repo);\r\n        const events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, transaction.currentWriteId, transaction.applyLocally);\r\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);\r\n        repoSendReadyTransactions(repo, repo.transactionQueueTree_);\r\n    }\r\n}\r\n/**\r\n * @param excludeSets - A specific set to exclude\r\n */\r\nfunction repoGetLatestState(repo, path, excludeSets) {\r\n    return (syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path, excludeSets) ||\r\n        ChildrenNode.EMPTY_NODE);\r\n}\r\n/**\r\n * Sends any already-run transactions that aren't waiting for outstanding\r\n * transactions to complete.\r\n *\r\n * Externally it's called with no arguments, but it calls itself recursively\r\n * with a particular transactionQueueTree node to recurse through the tree.\r\n *\r\n * @param node - transactionQueueTree node to start at.\r\n */\r\nfunction repoSendReadyTransactions(repo, node = repo.transactionQueueTree_) {\r\n    // Before recursing, make sure any completed transactions are removed.\r\n    if (!node) {\r\n        repoPruneCompletedTransactionsBelowNode(repo, node);\r\n    }\r\n    if (treeGetValue(node)) {\r\n        const queue = repoBuildTransactionQueue(repo, node);\r\n        index_esm2017_assert(queue.length > 0, 'Sending zero length transaction queue');\r\n        const allRun = queue.every((transaction) => transaction.status === 0 /* TransactionStatus.RUN */);\r\n        // If they're all run (and not sent), we can send them.  Else, we must wait.\r\n        if (allRun) {\r\n            repoSendTransactionQueue(repo, treeGetPath(node), queue);\r\n        }\r\n    }\r\n    else if (treeHasChildren(node)) {\r\n        treeForEachChild(node, childNode => {\r\n            repoSendReadyTransactions(repo, childNode);\r\n        });\r\n    }\r\n}\r\n/**\r\n * Given a list of run transactions, send them to the server and then handle\r\n * the result (success or failure).\r\n *\r\n * @param path - The location of the queue.\r\n * @param queue - Queue of transactions under the specified location.\r\n */\r\nfunction repoSendTransactionQueue(repo, path, queue) {\r\n    // Mark transactions as sent and increment retry count!\r\n    const setsToIgnore = queue.map(txn => {\r\n        return txn.currentWriteId;\r\n    });\r\n    const latestState = repoGetLatestState(repo, path, setsToIgnore);\r\n    let snapToSend = latestState;\r\n    const latestHash = latestState.hash();\r\n    for (let i = 0; i < queue.length; i++) {\r\n        const txn = queue[i];\r\n        index_esm2017_assert(txn.status === 0 /* TransactionStatus.RUN */, 'tryToSendTransactionQueue_: items in queue should all be run.');\r\n        txn.status = 1 /* TransactionStatus.SENT */;\r\n        txn.retryCount++;\r\n        const relativePath = newRelativePath(path, txn.path);\r\n        // If we've gotten to this point, the output snapshot must be defined.\r\n        snapToSend = snapToSend.updateChild(relativePath /** @type {!Node} */, txn.currentOutputSnapshotRaw);\r\n    }\r\n    const dataToSend = snapToSend.val(true);\r\n    const pathToSend = path;\r\n    // Send the put.\r\n    repo.server_.put(pathToSend.toString(), dataToSend, (status) => {\r\n        repoLog(repo, 'transaction put response', {\r\n            path: pathToSend.toString(),\r\n            status\r\n        });\r\n        let events = [];\r\n        if (status === 'ok') {\r\n            // Queue up the callbacks and fire them after cleaning up all of our\r\n            // transaction state, since the callback could trigger more\r\n            // transactions or sets.\r\n            const callbacks = [];\r\n            for (let i = 0; i < queue.length; i++) {\r\n                queue[i].status = 2 /* TransactionStatus.COMPLETED */;\r\n                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId));\r\n                if (queue[i].onComplete) {\r\n                    // We never unset the output snapshot, and given that this\r\n                    // transaction is complete, it should be set\r\n                    callbacks.push(() => queue[i].onComplete(null, true, queue[i].currentOutputSnapshotResolved));\r\n                }\r\n                queue[i].unwatcher();\r\n            }\r\n            // Now remove the completed transactions.\r\n            repoPruneCompletedTransactionsBelowNode(repo, treeSubTree(repo.transactionQueueTree_, path));\r\n            // There may be pending transactions that we can now send.\r\n            repoSendReadyTransactions(repo, repo.transactionQueueTree_);\r\n            eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);\r\n            // Finally, trigger onComplete callbacks.\r\n            for (let i = 0; i < callbacks.length; i++) {\r\n                exceptionGuard(callbacks[i]);\r\n            }\r\n        }\r\n        else {\r\n            // transactions are no longer sent.  Update their status appropriately.\r\n            if (status === 'datastale') {\r\n                for (let i = 0; i < queue.length; i++) {\r\n                    if (queue[i].status === 3 /* TransactionStatus.SENT_NEEDS_ABORT */) {\r\n                        queue[i].status = 4 /* TransactionStatus.NEEDS_ABORT */;\r\n                    }\r\n                    else {\r\n                        queue[i].status = 0 /* TransactionStatus.RUN */;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                warn('transaction at ' + pathToSend.toString() + ' failed: ' + status);\r\n                for (let i = 0; i < queue.length; i++) {\r\n                    queue[i].status = 4 /* TransactionStatus.NEEDS_ABORT */;\r\n                    queue[i].abortReason = status;\r\n                }\r\n            }\r\n            repoRerunTransactions(repo, path);\r\n        }\r\n    }, latestHash);\r\n}\r\n/**\r\n * Finds all transactions dependent on the data at changedPath and reruns them.\r\n *\r\n * Should be called any time cached data changes.\r\n *\r\n * Return the highest path that was affected by rerunning transactions. This\r\n * is the path at which events need to be raised for.\r\n *\r\n * @param changedPath - The path in mergedData that changed.\r\n * @returns The rootmost path that was affected by rerunning transactions.\r\n */\r\nfunction repoRerunTransactions(repo, changedPath) {\r\n    const rootMostTransactionNode = repoGetAncestorTransactionNode(repo, changedPath);\r\n    const path = treeGetPath(rootMostTransactionNode);\r\n    const queue = repoBuildTransactionQueue(repo, rootMostTransactionNode);\r\n    repoRerunTransactionQueue(repo, queue, path);\r\n    return path;\r\n}\r\n/**\r\n * Does all the work of rerunning transactions (as well as cleans up aborted\r\n * transactions and whatnot).\r\n *\r\n * @param queue - The queue of transactions to run.\r\n * @param path - The path the queue is for.\r\n */\r\nfunction repoRerunTransactionQueue(repo, queue, path) {\r\n    if (queue.length === 0) {\r\n        return; // Nothing to do!\r\n    }\r\n    // Queue up the callbacks and fire them after cleaning up all of our\r\n    // transaction state, since the callback could trigger more transactions or\r\n    // sets.\r\n    const callbacks = [];\r\n    let events = [];\r\n    // Ignore all of the sets we're going to re-run.\r\n    const txnsToRerun = queue.filter(q => {\r\n        return q.status === 0 /* TransactionStatus.RUN */;\r\n    });\r\n    const setsToIgnore = txnsToRerun.map(q => {\r\n        return q.currentWriteId;\r\n    });\r\n    for (let i = 0; i < queue.length; i++) {\r\n        const transaction = queue[i];\r\n        const relativePath = newRelativePath(path, transaction.path);\r\n        let abortTransaction = false, abortReason;\r\n        index_esm2017_assert(relativePath !== null, 'rerunTransactionsUnderNode_: relativePath should not be null.');\r\n        if (transaction.status === 4 /* TransactionStatus.NEEDS_ABORT */) {\r\n            abortTransaction = true;\r\n            abortReason = transaction.abortReason;\r\n            events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));\r\n        }\r\n        else if (transaction.status === 0 /* TransactionStatus.RUN */) {\r\n            if (transaction.retryCount >= MAX_TRANSACTION_RETRIES) {\r\n                abortTransaction = true;\r\n                abortReason = 'maxretry';\r\n                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));\r\n            }\r\n            else {\r\n                // This code reruns a transaction\r\n                const currentNode = repoGetLatestState(repo, transaction.path, setsToIgnore);\r\n                transaction.currentInputSnapshot = currentNode;\r\n                const newData = queue[i].update(currentNode.val());\r\n                if (newData !== undefined) {\r\n                    validateFirebaseData('transaction failed: Data returned ', newData, transaction.path);\r\n                    let newDataNode = nodeFromJSON(newData);\r\n                    const hasExplicitPriority = typeof newData === 'object' &&\r\n                        newData != null &&\r\n                        index_esm2017_contains(newData, '.priority');\r\n                    if (!hasExplicitPriority) {\r\n                        // Keep the old priority if there wasn't a priority explicitly specified.\r\n                        newDataNode = newDataNode.updatePriority(currentNode.getPriority());\r\n                    }\r\n                    const oldWriteId = transaction.currentWriteId;\r\n                    const serverValues = repoGenerateServerValues(repo);\r\n                    const newNodeResolved = resolveDeferredValueSnapshot(newDataNode, currentNode, serverValues);\r\n                    transaction.currentOutputSnapshotRaw = newDataNode;\r\n                    transaction.currentOutputSnapshotResolved = newNodeResolved;\r\n                    transaction.currentWriteId = repoGetNextWriteId(repo);\r\n                    // Mutates setsToIgnore in place\r\n                    setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);\r\n                    events = events.concat(syncTreeApplyUserOverwrite(repo.serverSyncTree_, transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));\r\n                    events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, oldWriteId, true));\r\n                }\r\n                else {\r\n                    abortTransaction = true;\r\n                    abortReason = 'nodata';\r\n                    events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));\r\n                }\r\n            }\r\n        }\r\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);\r\n        events = [];\r\n        if (abortTransaction) {\r\n            // Abort.\r\n            queue[i].status = 2 /* TransactionStatus.COMPLETED */;\r\n            // Removing a listener can trigger pruning which can muck with\r\n            // mergedData/visibleData (as it prunes data). So defer the unwatcher\r\n            // until we're done.\r\n            (function (unwatcher) {\r\n                setTimeout(unwatcher, Math.floor(0));\r\n            })(queue[i].unwatcher);\r\n            if (queue[i].onComplete) {\r\n                if (abortReason === 'nodata') {\r\n                    callbacks.push(() => queue[i].onComplete(null, false, queue[i].currentInputSnapshot));\r\n                }\r\n                else {\r\n                    callbacks.push(() => queue[i].onComplete(new Error(abortReason), false, null));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Clean up completed transactions.\r\n    repoPruneCompletedTransactionsBelowNode(repo, repo.transactionQueueTree_);\r\n    // Now fire callbacks, now that we're in a good, known state.\r\n    for (let i = 0; i < callbacks.length; i++) {\r\n        exceptionGuard(callbacks[i]);\r\n    }\r\n    // Try to send the transaction result to the server.\r\n    repoSendReadyTransactions(repo, repo.transactionQueueTree_);\r\n}\r\n/**\r\n * Returns the rootmost ancestor node of the specified path that has a pending\r\n * transaction on it, or just returns the node for the given path if there are\r\n * no pending transactions on any ancestor.\r\n *\r\n * @param path - The location to start at.\r\n * @returns The rootmost node with a transaction.\r\n */\r\nfunction repoGetAncestorTransactionNode(repo, path) {\r\n    let front;\r\n    // Start at the root and walk deeper into the tree towards path until we\r\n    // find a node with pending transactions.\r\n    let transactionNode = repo.transactionQueueTree_;\r\n    front = pathGetFront(path);\r\n    while (front !== null && treeGetValue(transactionNode) === undefined) {\r\n        transactionNode = treeSubTree(transactionNode, front);\r\n        path = pathPopFront(path);\r\n        front = pathGetFront(path);\r\n    }\r\n    return transactionNode;\r\n}\r\n/**\r\n * Builds the queue of all transactions at or below the specified\r\n * transactionNode.\r\n *\r\n * @param transactionNode\r\n * @returns The generated queue.\r\n */\r\nfunction repoBuildTransactionQueue(repo, transactionNode) {\r\n    // Walk any child transaction queues and aggregate them into a single queue.\r\n    const transactionQueue = [];\r\n    repoAggregateTransactionQueuesForNode(repo, transactionNode, transactionQueue);\r\n    // Sort them by the order the transactions were created.\r\n    transactionQueue.sort((a, b) => a.order - b.order);\r\n    return transactionQueue;\r\n}\r\nfunction repoAggregateTransactionQueuesForNode(repo, node, queue) {\r\n    const nodeQueue = treeGetValue(node);\r\n    if (nodeQueue) {\r\n        for (let i = 0; i < nodeQueue.length; i++) {\r\n            queue.push(nodeQueue[i]);\r\n        }\r\n    }\r\n    treeForEachChild(node, child => {\r\n        repoAggregateTransactionQueuesForNode(repo, child, queue);\r\n    });\r\n}\r\n/**\r\n * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.\r\n */\r\nfunction repoPruneCompletedTransactionsBelowNode(repo, node) {\r\n    const queue = treeGetValue(node);\r\n    if (queue) {\r\n        let to = 0;\r\n        for (let from = 0; from < queue.length; from++) {\r\n            if (queue[from].status !== 2 /* TransactionStatus.COMPLETED */) {\r\n                queue[to] = queue[from];\r\n                to++;\r\n            }\r\n        }\r\n        queue.length = to;\r\n        treeSetValue(node, queue.length > 0 ? queue : undefined);\r\n    }\r\n    treeForEachChild(node, childNode => {\r\n        repoPruneCompletedTransactionsBelowNode(repo, childNode);\r\n    });\r\n}\r\n/**\r\n * Aborts all transactions on ancestors or descendants of the specified path.\r\n * Called when doing a set() or update() since we consider them incompatible\r\n * with transactions.\r\n *\r\n * @param path - Path for which we want to abort related transactions.\r\n */\r\nfunction repoAbortTransactions(repo, path) {\r\n    const affectedPath = treeGetPath(repoGetAncestorTransactionNode(repo, path));\r\n    const transactionNode = treeSubTree(repo.transactionQueueTree_, path);\r\n    treeForEachAncestor(transactionNode, (node) => {\r\n        repoAbortTransactionsOnNode(repo, node);\r\n    });\r\n    repoAbortTransactionsOnNode(repo, transactionNode);\r\n    treeForEachDescendant(transactionNode, (node) => {\r\n        repoAbortTransactionsOnNode(repo, node);\r\n    });\r\n    return affectedPath;\r\n}\r\n/**\r\n * Abort transactions stored in this transaction queue node.\r\n *\r\n * @param node - Node to abort transactions for.\r\n */\r\nfunction repoAbortTransactionsOnNode(repo, node) {\r\n    const queue = treeGetValue(node);\r\n    if (queue) {\r\n        // Queue up the callbacks and fire them after cleaning up all of our\r\n        // transaction state, since the callback could trigger more transactions\r\n        // or sets.\r\n        const callbacks = [];\r\n        // Go through queue.  Any already-sent transactions must be marked for\r\n        // abort, while the unsent ones can be immediately aborted and removed.\r\n        let events = [];\r\n        let lastSent = -1;\r\n        for (let i = 0; i < queue.length; i++) {\r\n            if (queue[i].status === 3 /* TransactionStatus.SENT_NEEDS_ABORT */) ;\r\n            else if (queue[i].status === 1 /* TransactionStatus.SENT */) {\r\n                index_esm2017_assert(lastSent === i - 1, 'All SENT items should be at beginning of queue.');\r\n                lastSent = i;\r\n                // Mark transaction for abort when it comes back.\r\n                queue[i].status = 3 /* TransactionStatus.SENT_NEEDS_ABORT */;\r\n                queue[i].abortReason = 'set';\r\n            }\r\n            else {\r\n                index_esm2017_assert(queue[i].status === 0 /* TransactionStatus.RUN */, 'Unexpected transaction status in abort');\r\n                // We can abort it immediately.\r\n                queue[i].unwatcher();\r\n                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId, true));\r\n                if (queue[i].onComplete) {\r\n                    callbacks.push(queue[i].onComplete.bind(null, new Error('set'), false, null));\r\n                }\r\n            }\r\n        }\r\n        if (lastSent === -1) {\r\n            // We're not waiting for any sent transactions.  We can clear the queue.\r\n            treeSetValue(node, undefined);\r\n        }\r\n        else {\r\n            // Remove the transactions we aborted.\r\n            queue.length = lastSent + 1;\r\n        }\r\n        // Now fire the callbacks.\r\n        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, treeGetPath(node), events);\r\n        for (let i = 0; i < callbacks.length; i++) {\r\n            exceptionGuard(callbacks[i]);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction decodePath(pathString) {\r\n    let pathStringDecoded = '';\r\n    const pieces = pathString.split('/');\r\n    for (let i = 0; i < pieces.length; i++) {\r\n        if (pieces[i].length > 0) {\r\n            let piece = pieces[i];\r\n            try {\r\n                piece = decodeURIComponent(piece.replace(/\\+/g, ' '));\r\n            }\r\n            catch (e) { }\r\n            pathStringDecoded += '/' + piece;\r\n        }\r\n    }\r\n    return pathStringDecoded;\r\n}\r\n/**\r\n * @returns key value hash\r\n */\r\nfunction decodeQuery(queryString) {\r\n    const results = {};\r\n    if (queryString.charAt(0) === '?') {\r\n        queryString = queryString.substring(1);\r\n    }\r\n    for (const segment of queryString.split('&')) {\r\n        if (segment.length === 0) {\r\n            continue;\r\n        }\r\n        const kv = segment.split('=');\r\n        if (kv.length === 2) {\r\n            results[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);\r\n        }\r\n        else {\r\n            warn(`Invalid query segment '${segment}' in query '${queryString}'`);\r\n        }\r\n    }\r\n    return results;\r\n}\r\nconst parseRepoInfo = function (dataURL, nodeAdmin) {\r\n    const parsedUrl = parseDatabaseURL(dataURL), namespace = parsedUrl.namespace;\r\n    if (parsedUrl.domain === 'firebase.com') {\r\n        fatal(parsedUrl.host +\r\n            ' is no longer supported. ' +\r\n            'Please use <YOUR FIREBASE>.firebaseio.com instead');\r\n    }\r\n    // Catch common error of uninitialized namespace value.\r\n    if ((!namespace || namespace === 'undefined') &&\r\n        parsedUrl.domain !== 'localhost') {\r\n        fatal('Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com');\r\n    }\r\n    if (!parsedUrl.secure) {\r\n        warnIfPageIsSecure();\r\n    }\r\n    const webSocketOnly = parsedUrl.scheme === 'ws' || parsedUrl.scheme === 'wss';\r\n    return {\r\n        repoInfo: new RepoInfo(parsedUrl.host, parsedUrl.secure, namespace, webSocketOnly, nodeAdmin, \r\n        /*persistenceKey=*/ '', \r\n        /*includeNamespaceInQueryParams=*/ namespace !== parsedUrl.subdomain),\r\n        path: new Path(parsedUrl.pathString)\r\n    };\r\n};\r\nconst parseDatabaseURL = function (dataURL) {\r\n    // Default to empty strings in the event of a malformed string.\r\n    let host = '', domain = '', subdomain = '', pathString = '', namespace = '';\r\n    // Always default to SSL, unless otherwise specified.\r\n    let secure = true, scheme = 'https', port = 443;\r\n    // Don't do any validation here. The caller is responsible for validating the result of parsing.\r\n    if (typeof dataURL === 'string') {\r\n        // Parse scheme.\r\n        let colonInd = dataURL.indexOf('//');\r\n        if (colonInd >= 0) {\r\n            scheme = dataURL.substring(0, colonInd - 1);\r\n            dataURL = dataURL.substring(colonInd + 2);\r\n        }\r\n        // Parse host, path, and query string.\r\n        let slashInd = dataURL.indexOf('/');\r\n        if (slashInd === -1) {\r\n            slashInd = dataURL.length;\r\n        }\r\n        let questionMarkInd = dataURL.indexOf('?');\r\n        if (questionMarkInd === -1) {\r\n            questionMarkInd = dataURL.length;\r\n        }\r\n        host = dataURL.substring(0, Math.min(slashInd, questionMarkInd));\r\n        if (slashInd < questionMarkInd) {\r\n            // For pathString, questionMarkInd will always come after slashInd\r\n            pathString = decodePath(dataURL.substring(slashInd, questionMarkInd));\r\n        }\r\n        const queryParams = decodeQuery(dataURL.substring(Math.min(dataURL.length, questionMarkInd)));\r\n        // If we have a port, use scheme for determining if it's secure.\r\n        colonInd = host.indexOf(':');\r\n        if (colonInd >= 0) {\r\n            secure = scheme === 'https' || scheme === 'wss';\r\n            port = parseInt(host.substring(colonInd + 1), 10);\r\n        }\r\n        else {\r\n            colonInd = host.length;\r\n        }\r\n        const hostWithoutPort = host.slice(0, colonInd);\r\n        if (hostWithoutPort.toLowerCase() === 'localhost') {\r\n            domain = 'localhost';\r\n        }\r\n        else if (hostWithoutPort.split('.').length <= 2) {\r\n            domain = hostWithoutPort;\r\n        }\r\n        else {\r\n            // Interpret the subdomain of a 3 or more component URL as the namespace name.\r\n            const dotInd = host.indexOf('.');\r\n            subdomain = host.substring(0, dotInd).toLowerCase();\r\n            domain = host.substring(dotInd + 1);\r\n            // Normalize namespaces to lowercase to share storage / connection.\r\n            namespace = subdomain;\r\n        }\r\n        // Always treat the value of the `ns` as the namespace name if it is present.\r\n        if ('ns' in queryParams) {\r\n            namespace = queryParams['ns'];\r\n        }\r\n    }\r\n    return {\r\n        host,\r\n        port,\r\n        domain,\r\n        subdomain,\r\n        secure,\r\n        scheme,\r\n        pathString,\r\n        namespace\r\n    };\r\n};\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Modeled after base64 web-safe chars, but ordered by ASCII.\r\nconst PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';\r\n/**\r\n * Fancy ID generator that creates 20-character string identifiers with the\r\n * following properties:\r\n *\r\n * 1. They're based on timestamp so that they sort *after* any existing ids.\r\n * 2. They contain 72-bits of random data after the timestamp so that IDs won't\r\n *    collide with other clients' IDs.\r\n * 3. They sort *lexicographically* (so the timestamp is converted to characters\r\n *    that will sort properly).\r\n * 4. They're monotonically increasing. Even if you generate more than one in\r\n *    the same timestamp, the latter ones will sort after the former ones. We do\r\n *    this by using the previous random bits but \"incrementing\" them by 1 (only\r\n *    in the case of a timestamp collision).\r\n */\r\nconst nextPushId = (function () {\r\n    // Timestamp of last push, used to prevent local collisions if you push twice\r\n    // in one ms.\r\n    let lastPushTime = 0;\r\n    // We generate 72-bits of randomness which get turned into 12 characters and\r\n    // appended to the timestamp to prevent collisions with other clients. We\r\n    // store the last characters we generated because in the event of a collision,\r\n    // we'll use those same characters except \"incremented\" by one.\r\n    const lastRandChars = [];\r\n    return function (now) {\r\n        const duplicateTime = now === lastPushTime;\r\n        lastPushTime = now;\r\n        let i;\r\n        const timeStampChars = new Array(8);\r\n        for (i = 7; i >= 0; i--) {\r\n            timeStampChars[i] = PUSH_CHARS.charAt(now % 64);\r\n            // NOTE: Can't use << here because javascript will convert to int and lose\r\n            // the upper bits.\r\n            now = Math.floor(now / 64);\r\n        }\r\n        index_esm2017_assert(now === 0, 'Cannot push at time == 0');\r\n        let id = timeStampChars.join('');\r\n        if (!duplicateTime) {\r\n            for (i = 0; i < 12; i++) {\r\n                lastRandChars[i] = Math.floor(Math.random() * 64);\r\n            }\r\n        }\r\n        else {\r\n            // If the timestamp hasn't changed since last push, use the same random\r\n            // number, except incremented by 1.\r\n            for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {\r\n                lastRandChars[i] = 0;\r\n            }\r\n            lastRandChars[i]++;\r\n        }\r\n        for (i = 0; i < 12; i++) {\r\n            id += PUSH_CHARS.charAt(lastRandChars[i]);\r\n        }\r\n        index_esm2017_assert(id.length === 20, 'nextPushId: Length should be 20.');\r\n        return id;\r\n    };\r\n})();\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Encapsulates the data needed to raise an event\r\n */\r\nclass DataEvent {\r\n    /**\r\n     * @param eventType - One of: value, child_added, child_changed, child_moved, child_removed\r\n     * @param eventRegistration - The function to call to with the event data. User provided\r\n     * @param snapshot - The data backing the event\r\n     * @param prevName - Optional, the name of the previous child for child_* events.\r\n     */\r\n    constructor(eventType, eventRegistration, snapshot, prevName) {\r\n        this.eventType = eventType;\r\n        this.eventRegistration = eventRegistration;\r\n        this.snapshot = snapshot;\r\n        this.prevName = prevName;\r\n    }\r\n    getPath() {\r\n        const ref = this.snapshot.ref;\r\n        if (this.eventType === 'value') {\r\n            return ref._path;\r\n        }\r\n        else {\r\n            return ref.parent._path;\r\n        }\r\n    }\r\n    getEventType() {\r\n        return this.eventType;\r\n    }\r\n    getEventRunner() {\r\n        return this.eventRegistration.getEventRunner(this);\r\n    }\r\n    toString() {\r\n        return (this.getPath().toString() +\r\n            ':' +\r\n            this.eventType +\r\n            ':' +\r\n            index_esm2017_stringify(this.snapshot.exportVal()));\r\n    }\r\n}\r\nclass CancelEvent {\r\n    constructor(eventRegistration, error, path) {\r\n        this.eventRegistration = eventRegistration;\r\n        this.error = error;\r\n        this.path = path;\r\n    }\r\n    getPath() {\r\n        return this.path;\r\n    }\r\n    getEventType() {\r\n        return 'cancel';\r\n    }\r\n    getEventRunner() {\r\n        return this.eventRegistration.getEventRunner(this);\r\n    }\r\n    toString() {\r\n        return this.path.toString() + ':cancel';\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A wrapper class that converts events from the database@exp SDK to the legacy\r\n * Database SDK. Events are not converted directly as event registration relies\r\n * on reference comparison of the original user callback (see `matches()`) and\r\n * relies on equality of the legacy SDK's `context` object.\r\n */\r\nclass CallbackContext {\r\n    constructor(snapshotCallback, cancelCallback) {\r\n        this.snapshotCallback = snapshotCallback;\r\n        this.cancelCallback = cancelCallback;\r\n    }\r\n    onValue(expDataSnapshot, previousChildName) {\r\n        this.snapshotCallback.call(null, expDataSnapshot, previousChildName);\r\n    }\r\n    onCancel(error) {\r\n        index_esm2017_assert(this.hasCancelCallback, 'Raising a cancel event on a listener with no cancel callback');\r\n        return this.cancelCallback.call(null, error);\r\n    }\r\n    get hasCancelCallback() {\r\n        return !!this.cancelCallback;\r\n    }\r\n    matches(other) {\r\n        return (this.snapshotCallback === other.snapshotCallback ||\r\n            (this.snapshotCallback.userCallback !== undefined &&\r\n                this.snapshotCallback.userCallback ===\r\n                    other.snapshotCallback.userCallback &&\r\n                this.snapshotCallback.context === other.snapshotCallback.context));\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * The `onDisconnect` class allows you to write or clear data when your client\r\n * disconnects from the Database server. These updates occur whether your\r\n * client disconnects cleanly or not, so you can rely on them to clean up data\r\n * even if a connection is dropped or a client crashes.\r\n *\r\n * The `onDisconnect` class is most commonly used to manage presence in\r\n * applications where it is useful to detect how many clients are connected and\r\n * when other clients disconnect. See\r\n * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}\r\n * for more information.\r\n *\r\n * To avoid problems when a connection is dropped before the requests can be\r\n * transferred to the Database server, these functions should be called before\r\n * writing any data.\r\n *\r\n * Note that `onDisconnect` operations are only triggered once. If you want an\r\n * operation to occur each time a disconnect occurs, you'll need to re-establish\r\n * the `onDisconnect` operations each time you reconnect.\r\n */\r\nclass OnDisconnect {\r\n    /** @hideconstructor */\r\n    constructor(_repo, _path) {\r\n        this._repo = _repo;\r\n        this._path = _path;\r\n    }\r\n    /**\r\n     * Cancels all previously queued `onDisconnect()` set or update events for this\r\n     * location and all children.\r\n     *\r\n     * If a write has been queued for this location via a `set()` or `update()` at a\r\n     * parent location, the write at this location will be canceled, though writes\r\n     * to sibling locations will still occur.\r\n     *\r\n     * @returns Resolves when synchronization to the server is complete.\r\n     */\r\n    cancel() {\r\n        const deferred = new Deferred();\r\n        repoOnDisconnectCancel(this._repo, this._path, deferred.wrapCallback(() => { }));\r\n        return deferred.promise;\r\n    }\r\n    /**\r\n     * Ensures the data at this location is deleted when the client is disconnected\r\n     * (due to closing the browser, navigating to a new page, or network issues).\r\n     *\r\n     * @returns Resolves when synchronization to the server is complete.\r\n     */\r\n    remove() {\r\n        validateWritablePath('OnDisconnect.remove', this._path);\r\n        const deferred = new Deferred();\r\n        repoOnDisconnectSet(this._repo, this._path, null, deferred.wrapCallback(() => { }));\r\n        return deferred.promise;\r\n    }\r\n    /**\r\n     * Ensures the data at this location is set to the specified value when the\r\n     * client is disconnected (due to closing the browser, navigating to a new page,\r\n     * or network issues).\r\n     *\r\n     * `set()` is especially useful for implementing \"presence\" systems, where a\r\n     * value should be changed or cleared when a user disconnects so that they\r\n     * appear \"offline\" to other users. See\r\n     * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}\r\n     * for more information.\r\n     *\r\n     * Note that `onDisconnect` operations are only triggered once. If you want an\r\n     * operation to occur each time a disconnect occurs, you'll need to re-establish\r\n     * the `onDisconnect` operations each time.\r\n     *\r\n     * @param value - The value to be written to this location on disconnect (can\r\n     * be an object, array, string, number, boolean, or null).\r\n     * @returns Resolves when synchronization to the Database is complete.\r\n     */\r\n    set(value) {\r\n        validateWritablePath('OnDisconnect.set', this._path);\r\n        validateFirebaseDataArg('OnDisconnect.set', value, this._path, false);\r\n        const deferred = new Deferred();\r\n        repoOnDisconnectSet(this._repo, this._path, value, deferred.wrapCallback(() => { }));\r\n        return deferred.promise;\r\n    }\r\n    /**\r\n     * Ensures the data at this location is set to the specified value and priority\r\n     * when the client is disconnected (due to closing the browser, navigating to a\r\n     * new page, or network issues).\r\n     *\r\n     * @param value - The value to be written to this location on disconnect (can\r\n     * be an object, array, string, number, boolean, or null).\r\n     * @param priority - The priority to be written (string, number, or null).\r\n     * @returns Resolves when synchronization to the Database is complete.\r\n     */\r\n    setWithPriority(value, priority) {\r\n        validateWritablePath('OnDisconnect.setWithPriority', this._path);\r\n        validateFirebaseDataArg('OnDisconnect.setWithPriority', value, this._path, false);\r\n        validatePriority('OnDisconnect.setWithPriority', priority, false);\r\n        const deferred = new Deferred();\r\n        repoOnDisconnectSetWithPriority(this._repo, this._path, value, priority, deferred.wrapCallback(() => { }));\r\n        return deferred.promise;\r\n    }\r\n    /**\r\n     * Writes multiple values at this location when the client is disconnected (due\r\n     * to closing the browser, navigating to a new page, or network issues).\r\n     *\r\n     * The `values` argument contains multiple property-value pairs that will be\r\n     * written to the Database together. Each child property can either be a simple\r\n     * property (for example, \"name\") or a relative path (for example, \"name/first\")\r\n     * from the current location to the data to update.\r\n     *\r\n     * As opposed to the `set()` method, `update()` can be use to selectively update\r\n     * only the referenced properties at the current location (instead of replacing\r\n     * all the child properties at the current location).\r\n     *\r\n     * @param values - Object containing multiple values.\r\n     * @returns Resolves when synchronization to the Database is complete.\r\n     */\r\n    update(values) {\r\n        validateWritablePath('OnDisconnect.update', this._path);\r\n        validateFirebaseMergeDataArg('OnDisconnect.update', values, this._path, false);\r\n        const deferred = new Deferred();\r\n        repoOnDisconnectUpdate(this._repo, this._path, values, deferred.wrapCallback(() => { }));\r\n        return deferred.promise;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * @internal\r\n */\r\nclass QueryImpl {\r\n    /**\r\n     * @hideconstructor\r\n     */\r\n    constructor(_repo, _path, _queryParams, _orderByCalled) {\r\n        this._repo = _repo;\r\n        this._path = _path;\r\n        this._queryParams = _queryParams;\r\n        this._orderByCalled = _orderByCalled;\r\n    }\r\n    get key() {\r\n        if (pathIsEmpty(this._path)) {\r\n            return null;\r\n        }\r\n        else {\r\n            return pathGetBack(this._path);\r\n        }\r\n    }\r\n    get ref() {\r\n        return new ReferenceImpl(this._repo, this._path);\r\n    }\r\n    get _queryIdentifier() {\r\n        const obj = queryParamsGetQueryObject(this._queryParams);\r\n        const id = ObjectToUniqueKey(obj);\r\n        return id === '{}' ? 'default' : id;\r\n    }\r\n    /**\r\n     * An object representation of the query parameters used by this Query.\r\n     */\r\n    get _queryObject() {\r\n        return queryParamsGetQueryObject(this._queryParams);\r\n    }\r\n    isEqual(other) {\r\n        other = index_esm2017_getModularInstance(other);\r\n        if (!(other instanceof QueryImpl)) {\r\n            return false;\r\n        }\r\n        const sameRepo = this._repo === other._repo;\r\n        const samePath = pathEquals(this._path, other._path);\r\n        const sameQueryIdentifier = this._queryIdentifier === other._queryIdentifier;\r\n        return sameRepo && samePath && sameQueryIdentifier;\r\n    }\r\n    toJSON() {\r\n        return this.toString();\r\n    }\r\n    toString() {\r\n        return this._repo.toString() + pathToUrlEncodedString(this._path);\r\n    }\r\n}\r\n/**\r\n * Validates that no other order by call has been made\r\n */\r\nfunction validateNoPreviousOrderByCall(query, fnName) {\r\n    if (query._orderByCalled === true) {\r\n        throw new Error(fnName + \": You can't combine multiple orderBy calls.\");\r\n    }\r\n}\r\n/**\r\n * Validates start/end values for queries.\r\n */\r\nfunction validateQueryEndpoints(params) {\r\n    let startNode = null;\r\n    let endNode = null;\r\n    if (params.hasStart()) {\r\n        startNode = params.getIndexStartValue();\r\n    }\r\n    if (params.hasEnd()) {\r\n        endNode = params.getIndexEndValue();\r\n    }\r\n    if (params.getIndex() === KEY_INDEX) {\r\n        const tooManyArgsError = 'Query: When ordering by key, you may only pass one argument to ' +\r\n            'startAt(), endAt(), or equalTo().';\r\n        const wrongArgTypeError = 'Query: When ordering by key, the argument passed to startAt(), startAfter(), ' +\r\n            'endAt(), endBefore(), or equalTo() must be a string.';\r\n        if (params.hasStart()) {\r\n            const startName = params.getIndexStartName();\r\n            if (startName !== MIN_NAME) {\r\n                throw new Error(tooManyArgsError);\r\n            }\r\n            else if (typeof startNode !== 'string') {\r\n                throw new Error(wrongArgTypeError);\r\n            }\r\n        }\r\n        if (params.hasEnd()) {\r\n            const endName = params.getIndexEndName();\r\n            if (endName !== MAX_NAME) {\r\n                throw new Error(tooManyArgsError);\r\n            }\r\n            else if (typeof endNode !== 'string') {\r\n                throw new Error(wrongArgTypeError);\r\n            }\r\n        }\r\n    }\r\n    else if (params.getIndex() === PRIORITY_INDEX) {\r\n        if ((startNode != null && !isValidPriority(startNode)) ||\r\n            (endNode != null && !isValidPriority(endNode))) {\r\n            throw new Error('Query: When ordering by priority, the first argument passed to startAt(), ' +\r\n                'startAfter() endAt(), endBefore(), or equalTo() must be a valid priority value ' +\r\n                '(null, a number, or a string).');\r\n        }\r\n    }\r\n    else {\r\n        index_esm2017_assert(params.getIndex() instanceof PathIndex ||\r\n            params.getIndex() === VALUE_INDEX, 'unknown index type.');\r\n        if ((startNode != null && typeof startNode === 'object') ||\r\n            (endNode != null && typeof endNode === 'object')) {\r\n            throw new Error('Query: First argument passed to startAt(), startAfter(), endAt(), endBefore(), or ' +\r\n                'equalTo() cannot be an object.');\r\n        }\r\n    }\r\n}\r\n/**\r\n * Validates that limit* has been called with the correct combination of parameters\r\n */\r\nfunction validateLimit(params) {\r\n    if (params.hasStart() &&\r\n        params.hasEnd() &&\r\n        params.hasLimit() &&\r\n        !params.hasAnchoredLimit()) {\r\n        throw new Error(\"Query: Can't combine startAt(), startAfter(), endAt(), endBefore(), and limit(). Use \" +\r\n            'limitToFirst() or limitToLast() instead.');\r\n    }\r\n}\r\n/**\r\n * @internal\r\n */\r\nclass ReferenceImpl extends QueryImpl {\r\n    /** @hideconstructor */\r\n    constructor(repo, path) {\r\n        super(repo, path, new QueryParams(), false);\r\n    }\r\n    get parent() {\r\n        const parentPath = pathParent(this._path);\r\n        return parentPath === null\r\n            ? null\r\n            : new ReferenceImpl(this._repo, parentPath);\r\n    }\r\n    get root() {\r\n        let ref = this;\r\n        while (ref.parent !== null) {\r\n            ref = ref.parent;\r\n        }\r\n        return ref;\r\n    }\r\n}\r\n/**\r\n * A `DataSnapshot` contains data from a Database location.\r\n *\r\n * Any time you read data from the Database, you receive the data as a\r\n * `DataSnapshot`. A `DataSnapshot` is passed to the event callbacks you attach\r\n * with `on()` or `once()`. You can extract the contents of the snapshot as a\r\n * JavaScript object by calling the `val()` method. Alternatively, you can\r\n * traverse into the snapshot by calling `child()` to return child snapshots\r\n * (which you could then call `val()` on).\r\n *\r\n * A `DataSnapshot` is an efficiently generated, immutable copy of the data at\r\n * a Database location. It cannot be modified and will never change (to modify\r\n * data, you always call the `set()` method on a `Reference` directly).\r\n */\r\nclass DataSnapshot {\r\n    /**\r\n     * @param _node - A SnapshotNode to wrap.\r\n     * @param ref - The location this snapshot came from.\r\n     * @param _index - The iteration order for this snapshot\r\n     * @hideconstructor\r\n     */\r\n    constructor(_node, \r\n    /**\r\n     * The location of this DataSnapshot.\r\n     */\r\n    ref, _index) {\r\n        this._node = _node;\r\n        this.ref = ref;\r\n        this._index = _index;\r\n    }\r\n    /**\r\n     * Gets the priority value of the data in this `DataSnapshot`.\r\n     *\r\n     * Applications need not use priority but can order collections by\r\n     * ordinary properties (see\r\n     * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data |Sorting and filtering data}\r\n     * ).\r\n     */\r\n    get priority() {\r\n        // typecast here because we never return deferred values or internal priorities (MAX_PRIORITY)\r\n        return this._node.getPriority().val();\r\n    }\r\n    /**\r\n     * The key (last part of the path) of the location of this `DataSnapshot`.\r\n     *\r\n     * The last token in a Database location is considered its key. For example,\r\n     * \"ada\" is the key for the /users/ada/ node. Accessing the key on any\r\n     * `DataSnapshot` will return the key for the location that generated it.\r\n     * However, accessing the key on the root URL of a Database will return\r\n     * `null`.\r\n     */\r\n    get key() {\r\n        return this.ref.key;\r\n    }\r\n    /** Returns the number of child properties of this `DataSnapshot`. */\r\n    get size() {\r\n        return this._node.numChildren();\r\n    }\r\n    /**\r\n     * Gets another `DataSnapshot` for the location at the specified relative path.\r\n     *\r\n     * Passing a relative path to the `child()` method of a DataSnapshot returns\r\n     * another `DataSnapshot` for the location at the specified relative path. The\r\n     * relative path can either be a simple child name (for example, \"ada\") or a\r\n     * deeper, slash-separated path (for example, \"ada/name/first\"). If the child\r\n     * location has no data, an empty `DataSnapshot` (that is, a `DataSnapshot`\r\n     * whose value is `null`) is returned.\r\n     *\r\n     * @param path - A relative path to the location of child data.\r\n     */\r\n    child(path) {\r\n        const childPath = new Path(path);\r\n        const childRef = child(this.ref, path);\r\n        return new DataSnapshot(this._node.getChild(childPath), childRef, PRIORITY_INDEX);\r\n    }\r\n    /**\r\n     * Returns true if this `DataSnapshot` contains any data. It is slightly more\r\n     * efficient than using `snapshot.val() !== null`.\r\n     */\r\n    exists() {\r\n        return !this._node.isEmpty();\r\n    }\r\n    /**\r\n     * Exports the entire contents of the DataSnapshot as a JavaScript object.\r\n     *\r\n     * The `exportVal()` method is similar to `val()`, except priority information\r\n     * is included (if available), making it suitable for backing up your data.\r\n     *\r\n     * @returns The DataSnapshot's contents as a JavaScript value (Object,\r\n     *   Array, string, number, boolean, or `null`).\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    exportVal() {\r\n        return this._node.val(true);\r\n    }\r\n    /**\r\n     * Enumerates the top-level children in the `IteratedDataSnapshot`.\r\n     *\r\n     * Because of the way JavaScript objects work, the ordering of data in the\r\n     * JavaScript object returned by `val()` is not guaranteed to match the\r\n     * ordering on the server nor the ordering of `onChildAdded()` events. That is\r\n     * where `forEach()` comes in handy. It guarantees the children of a\r\n     * `DataSnapshot` will be iterated in their query order.\r\n     *\r\n     * If no explicit `orderBy*()` method is used, results are returned\r\n     * ordered by key (unless priorities are used, in which case, results are\r\n     * returned by priority).\r\n     *\r\n     * @param action - A function that will be called for each child DataSnapshot.\r\n     * The callback can return true to cancel further enumeration.\r\n     * @returns true if enumeration was canceled due to your callback returning\r\n     * true.\r\n     */\r\n    forEach(action) {\r\n        if (this._node.isLeafNode()) {\r\n            return false;\r\n        }\r\n        const childrenNode = this._node;\r\n        // Sanitize the return value to a boolean. ChildrenNode.forEachChild has a weird return type...\r\n        return !!childrenNode.forEachChild(this._index, (key, node) => {\r\n            return action(new DataSnapshot(node, child(this.ref, key), PRIORITY_INDEX));\r\n        });\r\n    }\r\n    /**\r\n     * Returns true if the specified child path has (non-null) data.\r\n     *\r\n     * @param path - A relative path to the location of a potential child.\r\n     * @returns `true` if data exists at the specified child path; else\r\n     *  `false`.\r\n     */\r\n    hasChild(path) {\r\n        const childPath = new Path(path);\r\n        return !this._node.getChild(childPath).isEmpty();\r\n    }\r\n    /**\r\n     * Returns whether or not the `DataSnapshot` has any non-`null` child\r\n     * properties.\r\n     *\r\n     * You can use `hasChildren()` to determine if a `DataSnapshot` has any\r\n     * children. If it does, you can enumerate them using `forEach()`. If it\r\n     * doesn't, then either this snapshot contains a primitive value (which can be\r\n     * retrieved with `val()`) or it is empty (in which case, `val()` will return\r\n     * `null`).\r\n     *\r\n     * @returns true if this snapshot has any children; else false.\r\n     */\r\n    hasChildren() {\r\n        if (this._node.isLeafNode()) {\r\n            return false;\r\n        }\r\n        else {\r\n            return !this._node.isEmpty();\r\n        }\r\n    }\r\n    /**\r\n     * Returns a JSON-serializable representation of this object.\r\n     */\r\n    toJSON() {\r\n        return this.exportVal();\r\n    }\r\n    /**\r\n     * Extracts a JavaScript value from a `DataSnapshot`.\r\n     *\r\n     * Depending on the data in a `DataSnapshot`, the `val()` method may return a\r\n     * scalar type (string, number, or boolean), an array, or an object. It may\r\n     * also return null, indicating that the `DataSnapshot` is empty (contains no\r\n     * data).\r\n     *\r\n     * @returns The DataSnapshot's contents as a JavaScript value (Object,\r\n     *   Array, string, number, boolean, or `null`).\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    val() {\r\n        return this._node.val();\r\n    }\r\n}\r\n/**\r\n *\r\n * Returns a `Reference` representing the location in the Database\r\n * corresponding to the provided path. If no path is provided, the `Reference`\r\n * will point to the root of the Database.\r\n *\r\n * @param db - The database instance to obtain a reference for.\r\n * @param path - Optional path representing the location the returned\r\n *   `Reference` will point. If not provided, the returned `Reference` will\r\n *   point to the root of the Database.\r\n * @returns If a path is provided, a `Reference`\r\n *   pointing to the provided path. Otherwise, a `Reference` pointing to the\r\n *   root of the Database.\r\n */\r\nfunction ref(db, path) {\r\n    db = index_esm2017_getModularInstance(db);\r\n    db._checkNotDeleted('ref');\r\n    return path !== undefined ? child(db._root, path) : db._root;\r\n}\r\n/**\r\n * Returns a `Reference` representing the location in the Database\r\n * corresponding to the provided Firebase URL.\r\n *\r\n * An exception is thrown if the URL is not a valid Firebase Database URL or it\r\n * has a different domain than the current `Database` instance.\r\n *\r\n * Note that all query parameters (`orderBy`, `limitToLast`, etc.) are ignored\r\n * and are not applied to the returned `Reference`.\r\n *\r\n * @param db - The database instance to obtain a reference for.\r\n * @param url - The Firebase URL at which the returned `Reference` will\r\n *   point.\r\n * @returns A `Reference` pointing to the provided\r\n *   Firebase URL.\r\n */\r\nfunction refFromURL(db, url) {\r\n    db = getModularInstance(db);\r\n    db._checkNotDeleted('refFromURL');\r\n    const parsedURL = parseRepoInfo(url, db._repo.repoInfo_.nodeAdmin);\r\n    validateUrl('refFromURL', parsedURL);\r\n    const repoInfo = parsedURL.repoInfo;\r\n    if (!db._repo.repoInfo_.isCustomHost() &&\r\n        repoInfo.host !== db._repo.repoInfo_.host) {\r\n        fatal('refFromURL' +\r\n            ': Host name does not match the current database: ' +\r\n            '(found ' +\r\n            repoInfo.host +\r\n            ' but expected ' +\r\n            db._repo.repoInfo_.host +\r\n            ')');\r\n    }\r\n    return ref(db, parsedURL.path.toString());\r\n}\r\n/**\r\n * Gets a `Reference` for the location at the specified relative path.\r\n *\r\n * The relative path can either be a simple child name (for example, \"ada\") or\r\n * a deeper slash-separated path (for example, \"ada/name/first\").\r\n *\r\n * @param parent - The parent location.\r\n * @param path - A relative path from this location to the desired child\r\n *   location.\r\n * @returns The specified child location.\r\n */\r\nfunction child(parent, path) {\r\n    parent = index_esm2017_getModularInstance(parent);\r\n    if (pathGetFront(parent._path) === null) {\r\n        validateRootPathString('child', 'path', path, false);\r\n    }\r\n    else {\r\n        validatePathString('child', 'path', path, false);\r\n    }\r\n    return new ReferenceImpl(parent._repo, pathChild(parent._path, path));\r\n}\r\n/**\r\n * Returns an `OnDisconnect` object - see\r\n * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}\r\n * for more information on how to use it.\r\n *\r\n * @param ref - The reference to add OnDisconnect triggers for.\r\n */\r\nfunction onDisconnect(ref) {\r\n    ref = getModularInstance(ref);\r\n    return new OnDisconnect(ref._repo, ref._path);\r\n}\r\n/**\r\n * Generates a new child location using a unique key and returns its\r\n * `Reference`.\r\n *\r\n * This is the most common pattern for adding data to a collection of items.\r\n *\r\n * If you provide a value to `push()`, the value is written to the\r\n * generated location. If you don't pass a value, nothing is written to the\r\n * database and the child remains empty (but you can use the `Reference`\r\n * elsewhere).\r\n *\r\n * The unique keys generated by `push()` are ordered by the current time, so the\r\n * resulting list of items is chronologically sorted. The keys are also\r\n * designed to be unguessable (they contain 72 random bits of entropy).\r\n *\r\n * See {@link https://firebase.google.com/docs/database/web/lists-of-data#append_to_a_list_of_data | Append to a list of data}.\r\n * See {@link https://firebase.googleblog.com/2015/02/the-2120-ways-to-ensure-unique_68.html | The 2^120 Ways to Ensure Unique Identifiers}.\r\n *\r\n * @param parent - The parent location.\r\n * @param value - Optional value to be written at the generated location.\r\n * @returns Combined `Promise` and `Reference`; resolves when write is complete,\r\n * but can be used immediately as the `Reference` to the child location.\r\n */\r\nfunction push(parent, value) {\r\n    parent = getModularInstance(parent);\r\n    validateWritablePath('push', parent._path);\r\n    validateFirebaseDataArg('push', value, parent._path, true);\r\n    const now = repoServerTime(parent._repo);\r\n    const name = nextPushId(now);\r\n    // push() returns a ThennableReference whose promise is fulfilled with a\r\n    // regular Reference. We use child() to create handles to two different\r\n    // references. The first is turned into a ThennableReference below by adding\r\n    // then() and catch() methods and is used as the return value of push(). The\r\n    // second remains a regular Reference and is used as the fulfilled value of\r\n    // the first ThennableReference.\r\n    const thenablePushRef = child(parent, name);\r\n    const pushRef = child(parent, name);\r\n    let promise;\r\n    if (value != null) {\r\n        promise = set(pushRef, value).then(() => pushRef);\r\n    }\r\n    else {\r\n        promise = Promise.resolve(pushRef);\r\n    }\r\n    thenablePushRef.then = promise.then.bind(promise);\r\n    thenablePushRef.catch = promise.then.bind(promise, undefined);\r\n    return thenablePushRef;\r\n}\r\n/**\r\n * Removes the data at this Database location.\r\n *\r\n * Any data at child locations will also be deleted.\r\n *\r\n * The effect of the remove will be visible immediately and the corresponding\r\n * event 'value' will be triggered. Synchronization of the remove to the\r\n * Firebase servers will also be started, and the returned Promise will resolve\r\n * when complete. If provided, the onComplete callback will be called\r\n * asynchronously after synchronization has finished.\r\n *\r\n * @param ref - The location to remove.\r\n * @returns Resolves when remove on server is complete.\r\n */\r\nfunction remove(ref) {\r\n    validateWritablePath('remove', ref._path);\r\n    return set(ref, null);\r\n}\r\n/**\r\n * Writes data to this Database location.\r\n *\r\n * This will overwrite any data at this location and all child locations.\r\n *\r\n * The effect of the write will be visible immediately, and the corresponding\r\n * events (\"value\", \"child_added\", etc.) will be triggered. Synchronization of\r\n * the data to the Firebase servers will also be started, and the returned\r\n * Promise will resolve when complete. If provided, the `onComplete` callback\r\n * will be called asynchronously after synchronization has finished.\r\n *\r\n * Passing `null` for the new value is equivalent to calling `remove()`; namely,\r\n * all data at this location and all child locations will be deleted.\r\n *\r\n * `set()` will remove any priority stored at this location, so if priority is\r\n * meant to be preserved, you need to use `setWithPriority()` instead.\r\n *\r\n * Note that modifying data with `set()` will cancel any pending transactions\r\n * at that location, so extreme care should be taken if mixing `set()` and\r\n * `transaction()` to modify the same data.\r\n *\r\n * A single `set()` will generate a single \"value\" event at the location where\r\n * the `set()` was performed.\r\n *\r\n * @param ref - The location to write to.\r\n * @param value - The value to be written (string, number, boolean, object,\r\n *   array, or null).\r\n * @returns Resolves when write to server is complete.\r\n */\r\nfunction set(ref, value) {\r\n    ref = getModularInstance(ref);\r\n    validateWritablePath('set', ref._path);\r\n    validateFirebaseDataArg('set', value, ref._path, false);\r\n    const deferred = new Deferred();\r\n    repoSetWithPriority(ref._repo, ref._path, value, \r\n    /*priority=*/ null, deferred.wrapCallback(() => { }));\r\n    return deferred.promise;\r\n}\r\n/**\r\n * Sets a priority for the data at this Database location.\r\n *\r\n * Applications need not use priority but can order collections by\r\n * ordinary properties (see\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data | Sorting and filtering data}\r\n * ).\r\n *\r\n * @param ref - The location to write to.\r\n * @param priority - The priority to be written (string, number, or null).\r\n * @returns Resolves when write to server is complete.\r\n */\r\nfunction setPriority(ref, priority) {\r\n    ref = getModularInstance(ref);\r\n    validateWritablePath('setPriority', ref._path);\r\n    validatePriority('setPriority', priority, false);\r\n    const deferred = new Deferred();\r\n    repoSetWithPriority(ref._repo, pathChild(ref._path, '.priority'), priority, null, deferred.wrapCallback(() => { }));\r\n    return deferred.promise;\r\n}\r\n/**\r\n * Writes data the Database location. Like `set()` but also specifies the\r\n * priority for that data.\r\n *\r\n * Applications need not use priority but can order collections by\r\n * ordinary properties (see\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data | Sorting and filtering data}\r\n * ).\r\n *\r\n * @param ref - The location to write to.\r\n * @param value - The value to be written (string, number, boolean, object,\r\n *   array, or null).\r\n * @param priority - The priority to be written (string, number, or null).\r\n * @returns Resolves when write to server is complete.\r\n */\r\nfunction setWithPriority(ref, value, priority) {\r\n    validateWritablePath('setWithPriority', ref._path);\r\n    validateFirebaseDataArg('setWithPriority', value, ref._path, false);\r\n    validatePriority('setWithPriority', priority, false);\r\n    if (ref.key === '.length' || ref.key === '.keys') {\r\n        throw 'setWithPriority failed: ' + ref.key + ' is a read-only object.';\r\n    }\r\n    const deferred = new Deferred();\r\n    repoSetWithPriority(ref._repo, ref._path, value, priority, deferred.wrapCallback(() => { }));\r\n    return deferred.promise;\r\n}\r\n/**\r\n * Writes multiple values to the Database at once.\r\n *\r\n * The `values` argument contains multiple property-value pairs that will be\r\n * written to the Database together. Each child property can either be a simple\r\n * property (for example, \"name\") or a relative path (for example,\r\n * \"name/first\") from the current location to the data to update.\r\n *\r\n * As opposed to the `set()` method, `update()` can be use to selectively update\r\n * only the referenced properties at the current location (instead of replacing\r\n * all the child properties at the current location).\r\n *\r\n * The effect of the write will be visible immediately, and the corresponding\r\n * events ('value', 'child_added', etc.) will be triggered. Synchronization of\r\n * the data to the Firebase servers will also be started, and the returned\r\n * Promise will resolve when complete. If provided, the `onComplete` callback\r\n * will be called asynchronously after synchronization has finished.\r\n *\r\n * A single `update()` will generate a single \"value\" event at the location\r\n * where the `update()` was performed, regardless of how many children were\r\n * modified.\r\n *\r\n * Note that modifying data with `update()` will cancel any pending\r\n * transactions at that location, so extreme care should be taken if mixing\r\n * `update()` and `transaction()` to modify the same data.\r\n *\r\n * Passing `null` to `update()` will remove the data at this location.\r\n *\r\n * See\r\n * {@link https://firebase.googleblog.com/2015/09/introducing-multi-location-updates-and_86.html | Introducing multi-location updates and more}.\r\n *\r\n * @param ref - The location to write to.\r\n * @param values - Object containing multiple values.\r\n * @returns Resolves when update on server is complete.\r\n */\r\nfunction update(ref, values) {\r\n    validateFirebaseMergeDataArg('update', values, ref._path, false);\r\n    const deferred = new Deferred();\r\n    repoUpdate(ref._repo, ref._path, values, deferred.wrapCallback(() => { }));\r\n    return deferred.promise;\r\n}\r\n/**\r\n * Gets the most up-to-date result for this query.\r\n *\r\n * @param query - The query to run.\r\n * @returns A `Promise` which resolves to the resulting DataSnapshot if a value is\r\n * available, or rejects if the client is unable to return a value (e.g., if the\r\n * server is unreachable and there is nothing cached).\r\n */\r\nfunction get(query) {\r\n    query = getModularInstance(query);\r\n    const callbackContext = new CallbackContext(() => { });\r\n    const container = new ValueEventRegistration(callbackContext);\r\n    return repoGetValue(query._repo, query, container).then(node => {\r\n        return new DataSnapshot(node, new ReferenceImpl(query._repo, query._path), query._queryParams.getIndex());\r\n    });\r\n}\r\n/**\r\n * Represents registration for 'value' events.\r\n */\r\nclass ValueEventRegistration {\r\n    constructor(callbackContext) {\r\n        this.callbackContext = callbackContext;\r\n    }\r\n    respondsTo(eventType) {\r\n        return eventType === 'value';\r\n    }\r\n    createEvent(change, query) {\r\n        const index = query._queryParams.getIndex();\r\n        return new DataEvent('value', this, new DataSnapshot(change.snapshotNode, new ReferenceImpl(query._repo, query._path), index));\r\n    }\r\n    getEventRunner(eventData) {\r\n        if (eventData.getEventType() === 'cancel') {\r\n            return () => this.callbackContext.onCancel(eventData.error);\r\n        }\r\n        else {\r\n            return () => this.callbackContext.onValue(eventData.snapshot, null);\r\n        }\r\n    }\r\n    createCancelEvent(error, path) {\r\n        if (this.callbackContext.hasCancelCallback) {\r\n            return new CancelEvent(this, error, path);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    matches(other) {\r\n        if (!(other instanceof ValueEventRegistration)) {\r\n            return false;\r\n        }\r\n        else if (!other.callbackContext || !this.callbackContext) {\r\n            // If no callback specified, we consider it to match any callback.\r\n            return true;\r\n        }\r\n        else {\r\n            return other.callbackContext.matches(this.callbackContext);\r\n        }\r\n    }\r\n    hasAnyCallback() {\r\n        return this.callbackContext !== null;\r\n    }\r\n}\r\n/**\r\n * Represents the registration of a child_x event.\r\n */\r\nclass ChildEventRegistration {\r\n    constructor(eventType, callbackContext) {\r\n        this.eventType = eventType;\r\n        this.callbackContext = callbackContext;\r\n    }\r\n    respondsTo(eventType) {\r\n        let eventToCheck = eventType === 'children_added' ? 'child_added' : eventType;\r\n        eventToCheck =\r\n            eventToCheck === 'children_removed' ? 'child_removed' : eventToCheck;\r\n        return this.eventType === eventToCheck;\r\n    }\r\n    createCancelEvent(error, path) {\r\n        if (this.callbackContext.hasCancelCallback) {\r\n            return new CancelEvent(this, error, path);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    createEvent(change, query) {\r\n        index_esm2017_assert(change.childName != null, 'Child events should have a childName.');\r\n        const childRef = child(new ReferenceImpl(query._repo, query._path), change.childName);\r\n        const index = query._queryParams.getIndex();\r\n        return new DataEvent(change.type, this, new DataSnapshot(change.snapshotNode, childRef, index), change.prevName);\r\n    }\r\n    getEventRunner(eventData) {\r\n        if (eventData.getEventType() === 'cancel') {\r\n            return () => this.callbackContext.onCancel(eventData.error);\r\n        }\r\n        else {\r\n            return () => this.callbackContext.onValue(eventData.snapshot, eventData.prevName);\r\n        }\r\n    }\r\n    matches(other) {\r\n        if (other instanceof ChildEventRegistration) {\r\n            return (this.eventType === other.eventType &&\r\n                (!this.callbackContext ||\r\n                    !other.callbackContext ||\r\n                    this.callbackContext.matches(other.callbackContext)));\r\n        }\r\n        return false;\r\n    }\r\n    hasAnyCallback() {\r\n        return !!this.callbackContext;\r\n    }\r\n}\r\nfunction addEventListener(query, eventType, callback, cancelCallbackOrListenOptions, options) {\r\n    let cancelCallback;\r\n    if (typeof cancelCallbackOrListenOptions === 'object') {\r\n        cancelCallback = undefined;\r\n        options = cancelCallbackOrListenOptions;\r\n    }\r\n    if (typeof cancelCallbackOrListenOptions === 'function') {\r\n        cancelCallback = cancelCallbackOrListenOptions;\r\n    }\r\n    if (options && options.onlyOnce) {\r\n        const userCallback = callback;\r\n        const onceCallback = (dataSnapshot, previousChildName) => {\r\n            repoRemoveEventCallbackForQuery(query._repo, query, container);\r\n            userCallback(dataSnapshot, previousChildName);\r\n        };\r\n        onceCallback.userCallback = callback.userCallback;\r\n        onceCallback.context = callback.context;\r\n        callback = onceCallback;\r\n    }\r\n    const callbackContext = new CallbackContext(callback, cancelCallback || undefined);\r\n    const container = eventType === 'value'\r\n        ? new ValueEventRegistration(callbackContext)\r\n        : new ChildEventRegistration(eventType, callbackContext);\r\n    repoAddEventCallbackForQuery(query._repo, query, container);\r\n    return () => repoRemoveEventCallbackForQuery(query._repo, query, container);\r\n}\r\nfunction onValue(query, callback, cancelCallbackOrListenOptions, options) {\r\n    return addEventListener(query, 'value', callback, cancelCallbackOrListenOptions, options);\r\n}\r\nfunction onChildAdded(query, callback, cancelCallbackOrListenOptions, options) {\r\n    return addEventListener(query, 'child_added', callback, cancelCallbackOrListenOptions, options);\r\n}\r\nfunction onChildChanged(query, callback, cancelCallbackOrListenOptions, options) {\r\n    return addEventListener(query, 'child_changed', callback, cancelCallbackOrListenOptions, options);\r\n}\r\nfunction onChildMoved(query, callback, cancelCallbackOrListenOptions, options) {\r\n    return addEventListener(query, 'child_moved', callback, cancelCallbackOrListenOptions, options);\r\n}\r\nfunction onChildRemoved(query, callback, cancelCallbackOrListenOptions, options) {\r\n    return addEventListener(query, 'child_removed', callback, cancelCallbackOrListenOptions, options);\r\n}\r\n/**\r\n * Detaches a callback previously attached with the corresponding `on*()` (`onValue`, `onChildAdded`) listener.\r\n * Note: This is not the recommended way to remove a listener. Instead, please use the returned callback function from\r\n * the respective `on*` callbacks.\r\n *\r\n * Detach a callback previously attached with `on*()`. Calling `off()` on a parent listener\r\n * will not automatically remove listeners registered on child nodes, `off()`\r\n * must also be called on any child listeners to remove the callback.\r\n *\r\n * If a callback is not specified, all callbacks for the specified eventType\r\n * will be removed. Similarly, if no eventType is specified, all callbacks\r\n * for the `Reference` will be removed.\r\n *\r\n * Individual listeners can also be removed by invoking their unsubscribe\r\n * callbacks.\r\n *\r\n * @param query - The query that the listener was registered with.\r\n * @param eventType - One of the following strings: \"value\", \"child_added\",\r\n * \"child_changed\", \"child_removed\", or \"child_moved.\" If omitted, all callbacks\r\n * for the `Reference` will be removed.\r\n * @param callback - The callback function that was passed to `on()` or\r\n * `undefined` to remove all callbacks.\r\n */\r\nfunction off(query, eventType, callback) {\r\n    let container = null;\r\n    const expCallback = callback ? new CallbackContext(callback) : null;\r\n    if (eventType === 'value') {\r\n        container = new ValueEventRegistration(expCallback);\r\n    }\r\n    else if (eventType) {\r\n        container = new ChildEventRegistration(eventType, expCallback);\r\n    }\r\n    repoRemoveEventCallbackForQuery(query._repo, query, container);\r\n}\r\n/**\r\n * A `QueryConstraint` is used to narrow the set of documents returned by a\r\n * Database query. `QueryConstraint`s are created by invoking {@link endAt},\r\n * {@link endBefore}, {@link startAt}, {@link startAfter}, {@link\r\n * limitToFirst}, {@link limitToLast}, {@link orderByChild},\r\n * {@link orderByChild}, {@link orderByKey} , {@link orderByPriority} ,\r\n * {@link orderByValue}  or {@link equalTo} and\r\n * can then be passed to {@link query} to create a new query instance that\r\n * also contains this `QueryConstraint`.\r\n */\r\nclass QueryConstraint {\r\n}\r\nclass QueryEndAtConstraint extends QueryConstraint {\r\n    constructor(_value, _key) {\r\n        super();\r\n        this._value = _value;\r\n        this._key = _key;\r\n        this.type = 'endAt';\r\n    }\r\n    _apply(query) {\r\n        validateFirebaseDataArg('endAt', this._value, query._path, true);\r\n        const newParams = queryParamsEndAt(query._queryParams, this._value, this._key);\r\n        validateLimit(newParams);\r\n        validateQueryEndpoints(newParams);\r\n        if (query._queryParams.hasEnd()) {\r\n            throw new Error('endAt: Starting point was already set (by another call to endAt, ' +\r\n                'endBefore or equalTo).');\r\n        }\r\n        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);\r\n    }\r\n}\r\n/**\r\n * Creates a `QueryConstraint` with the specified ending point.\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The ending point is inclusive, so children with exactly the specified value\r\n * will be included in the query. The optional key argument can be used to\r\n * further limit the range of the query. If it is specified, then children that\r\n * have exactly the specified value must also have a key name less than or equal\r\n * to the specified key.\r\n *\r\n * You can read more about `endAt()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param value - The value to end at. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to end at, among the children with the previously\r\n * specified priority. This argument is only allowed if ordering by child,\r\n * value, or priority.\r\n */\r\nfunction endAt(value, key) {\r\n    validateKey('endAt', 'key', key, true);\r\n    return new QueryEndAtConstraint(value, key);\r\n}\r\nclass QueryEndBeforeConstraint extends QueryConstraint {\r\n    constructor(_value, _key) {\r\n        super();\r\n        this._value = _value;\r\n        this._key = _key;\r\n        this.type = 'endBefore';\r\n    }\r\n    _apply(query) {\r\n        validateFirebaseDataArg('endBefore', this._value, query._path, false);\r\n        const newParams = queryParamsEndBefore(query._queryParams, this._value, this._key);\r\n        validateLimit(newParams);\r\n        validateQueryEndpoints(newParams);\r\n        if (query._queryParams.hasEnd()) {\r\n            throw new Error('endBefore: Starting point was already set (by another call to endAt, ' +\r\n                'endBefore or equalTo).');\r\n        }\r\n        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);\r\n    }\r\n}\r\n/**\r\n * Creates a `QueryConstraint` with the specified ending point (exclusive).\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The ending point is exclusive. If only a value is provided, children\r\n * with a value less than the specified value will be included in the query.\r\n * If a key is specified, then children must have a value less than or equal\r\n * to the specified value and a key name less than the specified key.\r\n *\r\n * @param value - The value to end before. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to end before, among the children with the\r\n * previously specified priority. This argument is only allowed if ordering by\r\n * child, value, or priority.\r\n */\r\nfunction endBefore(value, key) {\r\n    validateKey('endBefore', 'key', key, true);\r\n    return new QueryEndBeforeConstraint(value, key);\r\n}\r\nclass QueryStartAtConstraint extends QueryConstraint {\r\n    constructor(_value, _key) {\r\n        super();\r\n        this._value = _value;\r\n        this._key = _key;\r\n        this.type = 'startAt';\r\n    }\r\n    _apply(query) {\r\n        validateFirebaseDataArg('startAt', this._value, query._path, true);\r\n        const newParams = queryParamsStartAt(query._queryParams, this._value, this._key);\r\n        validateLimit(newParams);\r\n        validateQueryEndpoints(newParams);\r\n        if (query._queryParams.hasStart()) {\r\n            throw new Error('startAt: Starting point was already set (by another call to startAt, ' +\r\n                'startBefore or equalTo).');\r\n        }\r\n        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);\r\n    }\r\n}\r\n/**\r\n * Creates a `QueryConstraint` with the specified starting point.\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The starting point is inclusive, so children with exactly the specified value\r\n * will be included in the query. The optional key argument can be used to\r\n * further limit the range of the query. If it is specified, then children that\r\n * have exactly the specified value must also have a key name greater than or\r\n * equal to the specified key.\r\n *\r\n * You can read more about `startAt()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param value - The value to start at. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to start at. This argument is only allowed if\r\n * ordering by child, value, or priority.\r\n */\r\nfunction startAt(value = null, key) {\r\n    validateKey('startAt', 'key', key, true);\r\n    return new QueryStartAtConstraint(value, key);\r\n}\r\nclass QueryStartAfterConstraint extends QueryConstraint {\r\n    constructor(_value, _key) {\r\n        super();\r\n        this._value = _value;\r\n        this._key = _key;\r\n        this.type = 'startAfter';\r\n    }\r\n    _apply(query) {\r\n        validateFirebaseDataArg('startAfter', this._value, query._path, false);\r\n        const newParams = queryParamsStartAfter(query._queryParams, this._value, this._key);\r\n        validateLimit(newParams);\r\n        validateQueryEndpoints(newParams);\r\n        if (query._queryParams.hasStart()) {\r\n            throw new Error('startAfter: Starting point was already set (by another call to startAt, ' +\r\n                'startAfter, or equalTo).');\r\n        }\r\n        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);\r\n    }\r\n}\r\n/**\r\n * Creates a `QueryConstraint` with the specified starting point (exclusive).\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The starting point is exclusive. If only a value is provided, children\r\n * with a value greater than the specified value will be included in the query.\r\n * If a key is specified, then children must have a value greater than or equal\r\n * to the specified value and a a key name greater than the specified key.\r\n *\r\n * @param value - The value to start after. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to start after. This argument is only allowed if\r\n * ordering by child, value, or priority.\r\n */\r\nfunction startAfter(value, key) {\r\n    validateKey('startAfter', 'key', key, true);\r\n    return new QueryStartAfterConstraint(value, key);\r\n}\r\nclass QueryLimitToFirstConstraint extends QueryConstraint {\r\n    constructor(_limit) {\r\n        super();\r\n        this._limit = _limit;\r\n        this.type = 'limitToFirst';\r\n    }\r\n    _apply(query) {\r\n        if (query._queryParams.hasLimit()) {\r\n            throw new Error('limitToFirst: Limit was already set (by another call to limitToFirst ' +\r\n                'or limitToLast).');\r\n        }\r\n        return new QueryImpl(query._repo, query._path, queryParamsLimitToFirst(query._queryParams, this._limit), query._orderByCalled);\r\n    }\r\n}\r\n/**\r\n * Creates a new `QueryConstraint` that if limited to the first specific number\r\n * of children.\r\n *\r\n * The `limitToFirst()` method is used to set a maximum number of children to be\r\n * synced for a given callback. If we set a limit of 100, we will initially only\r\n * receive up to 100 `child_added` events. If we have fewer than 100 messages\r\n * stored in our Database, a `child_added` event will fire for each message.\r\n * However, if we have over 100 messages, we will only receive a `child_added`\r\n * event for the first 100 ordered messages. As items change, we will receive\r\n * `child_removed` events for each item that drops out of the active list so\r\n * that the total number stays at 100.\r\n *\r\n * You can read more about `limitToFirst()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param limit - The maximum number of nodes to include in this query.\r\n */\r\nfunction limitToFirst(limit) {\r\n    if (typeof limit !== 'number' || Math.floor(limit) !== limit || limit <= 0) {\r\n        throw new Error('limitToFirst: First argument must be a positive integer.');\r\n    }\r\n    return new QueryLimitToFirstConstraint(limit);\r\n}\r\nclass QueryLimitToLastConstraint extends QueryConstraint {\r\n    constructor(_limit) {\r\n        super();\r\n        this._limit = _limit;\r\n        this.type = 'limitToLast';\r\n    }\r\n    _apply(query) {\r\n        if (query._queryParams.hasLimit()) {\r\n            throw new Error('limitToLast: Limit was already set (by another call to limitToFirst ' +\r\n                'or limitToLast).');\r\n        }\r\n        return new QueryImpl(query._repo, query._path, queryParamsLimitToLast(query._queryParams, this._limit), query._orderByCalled);\r\n    }\r\n}\r\n/**\r\n * Creates a new `QueryConstraint` that is limited to return only the last\r\n * specified number of children.\r\n *\r\n * The `limitToLast()` method is used to set a maximum number of children to be\r\n * synced for a given callback. If we set a limit of 100, we will initially only\r\n * receive up to 100 `child_added` events. If we have fewer than 100 messages\r\n * stored in our Database, a `child_added` event will fire for each message.\r\n * However, if we have over 100 messages, we will only receive a `child_added`\r\n * event for the last 100 ordered messages. As items change, we will receive\r\n * `child_removed` events for each item that drops out of the active list so\r\n * that the total number stays at 100.\r\n *\r\n * You can read more about `limitToLast()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param limit - The maximum number of nodes to include in this query.\r\n */\r\nfunction limitToLast(limit) {\r\n    if (typeof limit !== 'number' || Math.floor(limit) !== limit || limit <= 0) {\r\n        throw new Error('limitToLast: First argument must be a positive integer.');\r\n    }\r\n    return new QueryLimitToLastConstraint(limit);\r\n}\r\nclass QueryOrderByChildConstraint extends QueryConstraint {\r\n    constructor(_path) {\r\n        super();\r\n        this._path = _path;\r\n        this.type = 'orderByChild';\r\n    }\r\n    _apply(query) {\r\n        validateNoPreviousOrderByCall(query, 'orderByChild');\r\n        const parsedPath = new Path(this._path);\r\n        if (pathIsEmpty(parsedPath)) {\r\n            throw new Error('orderByChild: cannot pass in empty path. Use orderByValue() instead.');\r\n        }\r\n        const index = new PathIndex(parsedPath);\r\n        const newParams = queryParamsOrderBy(query._queryParams, index);\r\n        validateQueryEndpoints(newParams);\r\n        return new QueryImpl(query._repo, query._path, newParams, \r\n        /*orderByCalled=*/ true);\r\n    }\r\n}\r\n/**\r\n * Creates a new `QueryConstraint` that orders by the specified child key.\r\n *\r\n * Queries can only order by one key at a time. Calling `orderByChild()`\r\n * multiple times on the same query is an error.\r\n *\r\n * Firebase queries allow you to order your data by any child key on the fly.\r\n * However, if you know in advance what your indexes will be, you can define\r\n * them via the .indexOn rule in your Security Rules for better performance. See\r\n * the{@link https://firebase.google.com/docs/database/security/indexing-data}\r\n * rule for more information.\r\n *\r\n * You can read more about `orderByChild()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.\r\n *\r\n * @param path - The path to order by.\r\n */\r\nfunction orderByChild(path) {\r\n    if (path === '$key') {\r\n        throw new Error('orderByChild: \"$key\" is invalid.  Use orderByKey() instead.');\r\n    }\r\n    else if (path === '$priority') {\r\n        throw new Error('orderByChild: \"$priority\" is invalid.  Use orderByPriority() instead.');\r\n    }\r\n    else if (path === '$value') {\r\n        throw new Error('orderByChild: \"$value\" is invalid.  Use orderByValue() instead.');\r\n    }\r\n    validatePathString('orderByChild', 'path', path, false);\r\n    return new QueryOrderByChildConstraint(path);\r\n}\r\nclass QueryOrderByKeyConstraint extends QueryConstraint {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = 'orderByKey';\r\n    }\r\n    _apply(query) {\r\n        validateNoPreviousOrderByCall(query, 'orderByKey');\r\n        const newParams = queryParamsOrderBy(query._queryParams, KEY_INDEX);\r\n        validateQueryEndpoints(newParams);\r\n        return new QueryImpl(query._repo, query._path, newParams, \r\n        /*orderByCalled=*/ true);\r\n    }\r\n}\r\n/**\r\n * Creates a new `QueryConstraint` that orders by the key.\r\n *\r\n * Sorts the results of a query by their (ascending) key values.\r\n *\r\n * You can read more about `orderByKey()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.\r\n */\r\nfunction orderByKey() {\r\n    return new QueryOrderByKeyConstraint();\r\n}\r\nclass QueryOrderByPriorityConstraint extends QueryConstraint {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = 'orderByPriority';\r\n    }\r\n    _apply(query) {\r\n        validateNoPreviousOrderByCall(query, 'orderByPriority');\r\n        const newParams = queryParamsOrderBy(query._queryParams, PRIORITY_INDEX);\r\n        validateQueryEndpoints(newParams);\r\n        return new QueryImpl(query._repo, query._path, newParams, \r\n        /*orderByCalled=*/ true);\r\n    }\r\n}\r\n/**\r\n * Creates a new `QueryConstraint` that orders by priority.\r\n *\r\n * Applications need not use priority but can order collections by\r\n * ordinary properties (see\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}\r\n * for alternatives to priority.\r\n */\r\nfunction orderByPriority() {\r\n    return new QueryOrderByPriorityConstraint();\r\n}\r\nclass QueryOrderByValueConstraint extends QueryConstraint {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = 'orderByValue';\r\n    }\r\n    _apply(query) {\r\n        validateNoPreviousOrderByCall(query, 'orderByValue');\r\n        const newParams = queryParamsOrderBy(query._queryParams, VALUE_INDEX);\r\n        validateQueryEndpoints(newParams);\r\n        return new QueryImpl(query._repo, query._path, newParams, \r\n        /*orderByCalled=*/ true);\r\n    }\r\n}\r\n/**\r\n * Creates a new `QueryConstraint` that orders by value.\r\n *\r\n * If the children of a query are all scalar values (string, number, or\r\n * boolean), you can order the results by their (ascending) values.\r\n *\r\n * You can read more about `orderByValue()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.\r\n */\r\nfunction orderByValue() {\r\n    return new QueryOrderByValueConstraint();\r\n}\r\nclass QueryEqualToValueConstraint extends QueryConstraint {\r\n    constructor(_value, _key) {\r\n        super();\r\n        this._value = _value;\r\n        this._key = _key;\r\n        this.type = 'equalTo';\r\n    }\r\n    _apply(query) {\r\n        validateFirebaseDataArg('equalTo', this._value, query._path, false);\r\n        if (query._queryParams.hasStart()) {\r\n            throw new Error('equalTo: Starting point was already set (by another call to startAt/startAfter or ' +\r\n                'equalTo).');\r\n        }\r\n        if (query._queryParams.hasEnd()) {\r\n            throw new Error('equalTo: Ending point was already set (by another call to endAt/endBefore or ' +\r\n                'equalTo).');\r\n        }\r\n        return new QueryEndAtConstraint(this._value, this._key)._apply(new QueryStartAtConstraint(this._value, this._key)._apply(query));\r\n    }\r\n}\r\n/**\r\n * Creates a `QueryConstraint` that includes children that match the specified\r\n * value.\r\n *\r\n * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`\r\n * allows you to choose arbitrary starting and ending points for your queries.\r\n *\r\n * The optional key argument can be used to further limit the range of the\r\n * query. If it is specified, then children that have exactly the specified\r\n * value must also have exactly the specified key as their key name. This can be\r\n * used to filter result sets with many matches for the same value.\r\n *\r\n * You can read more about `equalTo()` in\r\n * {@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.\r\n *\r\n * @param value - The value to match for. The argument type depends on which\r\n * `orderBy*()` function was used in this query. Specify a value that matches\r\n * the `orderBy*()` type. When used in combination with `orderByKey()`, the\r\n * value must be a string.\r\n * @param key - The child key to start at, among the children with the\r\n * previously specified priority. This argument is only allowed if ordering by\r\n * child, value, or priority.\r\n */\r\nfunction equalTo(value, key) {\r\n    validateKey('equalTo', 'key', key, true);\r\n    return new QueryEqualToValueConstraint(value, key);\r\n}\r\n/**\r\n * Creates a new immutable instance of `Query` that is extended to also include\r\n * additional query constraints.\r\n *\r\n * @param query - The Query instance to use as a base for the new constraints.\r\n * @param queryConstraints - The list of `QueryConstraint`s to apply.\r\n * @throws if any of the provided query constraints cannot be combined with the\r\n * existing or new constraints.\r\n */\r\nfunction query(query, ...queryConstraints) {\r\n    let queryImpl = getModularInstance(query);\r\n    for (const constraint of queryConstraints) {\r\n        queryImpl = constraint._apply(queryImpl);\r\n    }\r\n    return queryImpl;\r\n}\r\n/**\r\n * Define reference constructor in various modules\r\n *\r\n * We are doing this here to avoid several circular\r\n * dependency issues\r\n */\r\nsyncPointSetReferenceConstructor(ReferenceImpl);\r\nsyncTreeSetReferenceConstructor(ReferenceImpl);\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * This variable is also defined in the firebase Node.js Admin SDK. Before\r\n * modifying this definition, consult the definition in:\r\n *\r\n * https://github.com/firebase/firebase-admin-node\r\n *\r\n * and make sure the two are consistent.\r\n */\r\nconst FIREBASE_DATABASE_EMULATOR_HOST_VAR = 'FIREBASE_DATABASE_EMULATOR_HOST';\r\n/**\r\n * Creates and caches `Repo` instances.\r\n */\r\nconst repos = {};\r\n/**\r\n * If true, any new `Repo` will be created to use `ReadonlyRestClient` (for testing purposes).\r\n */\r\nlet useRestClient = false;\r\n/**\r\n * Update an existing `Repo` in place to point to a new host/port.\r\n */\r\nfunction repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider) {\r\n    repo.repoInfo_ = new RepoInfo(`${host}:${port}`, \r\n    /* secure= */ false, repo.repoInfo_.namespace, repo.repoInfo_.webSocketOnly, repo.repoInfo_.nodeAdmin, repo.repoInfo_.persistenceKey, repo.repoInfo_.includeNamespaceInQueryParams, \r\n    /*isUsingEmulator=*/ true);\r\n    if (tokenProvider) {\r\n        repo.authTokenProvider_ = tokenProvider;\r\n    }\r\n}\r\n/**\r\n * This function should only ever be called to CREATE a new database instance.\r\n * @internal\r\n */\r\nfunction repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url, nodeAdmin) {\r\n    let dbUrl = url || app.options.databaseURL;\r\n    if (dbUrl === undefined) {\r\n        if (!app.options.projectId) {\r\n            fatal(\"Can't determine Firebase Database URL. Be sure to include \" +\r\n                ' a Project ID when calling firebase.initializeApp().');\r\n        }\r\n        log('Using default host for project ', app.options.projectId);\r\n        dbUrl = `${app.options.projectId}-default-rtdb.firebaseio.com`;\r\n    }\r\n    let parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);\r\n    let repoInfo = parsedUrl.repoInfo;\r\n    let isEmulator;\r\n    let dbEmulatorHost = undefined;\r\n    if (typeof process !== 'undefined' && process.env) {\r\n        dbEmulatorHost = process.env[FIREBASE_DATABASE_EMULATOR_HOST_VAR];\r\n    }\r\n    if (dbEmulatorHost) {\r\n        isEmulator = true;\r\n        dbUrl = `http://${dbEmulatorHost}?ns=${repoInfo.namespace}`;\r\n        parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);\r\n        repoInfo = parsedUrl.repoInfo;\r\n    }\r\n    else {\r\n        isEmulator = !parsedUrl.repoInfo.secure;\r\n    }\r\n    const authTokenProvider = nodeAdmin && isEmulator\r\n        ? new EmulatorTokenProvider(EmulatorTokenProvider.OWNER)\r\n        : new FirebaseAuthTokenProvider(app.name, app.options, authProvider);\r\n    validateUrl('Invalid Firebase Database URL', parsedUrl);\r\n    if (!pathIsEmpty(parsedUrl.path)) {\r\n        fatal('Database URL must point to the root of a Firebase Database ' +\r\n            '(not including a child path).');\r\n    }\r\n    const repo = repoManagerCreateRepo(repoInfo, app, authTokenProvider, new AppCheckTokenProvider(app.name, appCheckProvider));\r\n    return new Database(repo, app);\r\n}\r\n/**\r\n * Remove the repo and make sure it is disconnected.\r\n *\r\n */\r\nfunction repoManagerDeleteRepo(repo, appName) {\r\n    const appRepos = repos[appName];\r\n    // This should never happen...\r\n    if (!appRepos || appRepos[repo.key] !== repo) {\r\n        fatal(`Database ${appName}(${repo.repoInfo_}) has already been deleted.`);\r\n    }\r\n    repoInterrupt(repo);\r\n    delete appRepos[repo.key];\r\n}\r\n/**\r\n * Ensures a repo doesn't already exist and then creates one using the\r\n * provided app.\r\n *\r\n * @param repoInfo - The metadata about the Repo\r\n * @returns The Repo object for the specified server / repoName.\r\n */\r\nfunction repoManagerCreateRepo(repoInfo, app, authTokenProvider, appCheckProvider) {\r\n    let appRepos = repos[app.name];\r\n    if (!appRepos) {\r\n        appRepos = {};\r\n        repos[app.name] = appRepos;\r\n    }\r\n    let repo = appRepos[repoInfo.toURLString()];\r\n    if (repo) {\r\n        fatal('Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.');\r\n    }\r\n    repo = new Repo(repoInfo, useRestClient, authTokenProvider, appCheckProvider);\r\n    appRepos[repoInfo.toURLString()] = repo;\r\n    return repo;\r\n}\r\n/**\r\n * Forces us to use ReadonlyRestClient instead of PersistentConnection for new Repos.\r\n */\r\nfunction repoManagerForceRestClient(forceRestClient) {\r\n    useRestClient = forceRestClient;\r\n}\r\n/**\r\n * Class representing a Firebase Realtime Database.\r\n */\r\nclass Database {\r\n    /** @hideconstructor */\r\n    constructor(_repoInternal, \r\n    /** The {@link @firebase/app#FirebaseApp} associated with this Realtime Database instance. */\r\n    app) {\r\n        this._repoInternal = _repoInternal;\r\n        this.app = app;\r\n        /** Represents a `Database` instance. */\r\n        this['type'] = 'database';\r\n        /** Track if the instance has been used (root or repo accessed) */\r\n        this._instanceStarted = false;\r\n    }\r\n    get _repo() {\r\n        if (!this._instanceStarted) {\r\n            repoStart(this._repoInternal, this.app.options.appId, this.app.options['databaseAuthVariableOverride']);\r\n            this._instanceStarted = true;\r\n        }\r\n        return this._repoInternal;\r\n    }\r\n    get _root() {\r\n        if (!this._rootInternal) {\r\n            this._rootInternal = new ReferenceImpl(this._repo, newEmptyPath());\r\n        }\r\n        return this._rootInternal;\r\n    }\r\n    _delete() {\r\n        if (this._rootInternal !== null) {\r\n            repoManagerDeleteRepo(this._repo, this.app.name);\r\n            this._repoInternal = null;\r\n            this._rootInternal = null;\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    _checkNotDeleted(apiName) {\r\n        if (this._rootInternal === null) {\r\n            fatal('Cannot call ' + apiName + ' on a deleted database.');\r\n        }\r\n    }\r\n}\r\nfunction checkTransportInit() {\r\n    if (TransportManager.IS_TRANSPORT_INITIALIZED) {\r\n        warn('Transport has already been initialized. Please call this function before calling ref or setting up a listener');\r\n    }\r\n}\r\n/**\r\n * Force the use of websockets instead of longPolling.\r\n */\r\nfunction forceWebSockets() {\r\n    checkTransportInit();\r\n    BrowserPollConnection.forceDisallow();\r\n}\r\n/**\r\n * Force the use of longPolling instead of websockets. This will be ignored if websocket protocol is used in databaseURL.\r\n */\r\nfunction forceLongPolling() {\r\n    checkTransportInit();\r\n    WebSocketConnection.forceDisallow();\r\n    BrowserPollConnection.forceAllow();\r\n}\r\n/**\r\n * Returns the instance of the Realtime Database SDK that is associated with the provided\r\n * {@link @firebase/app#FirebaseApp}. Initializes a new instance with default settings if\r\n * no instance exists or if the existing instance uses a custom database URL.\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} instance that the returned Realtime\r\n * Database instance is associated with.\r\n * @param url - The URL of the Realtime Database instance to connect to. If not\r\n * provided, the SDK connects to the default instance of the Firebase App.\r\n * @returns The `Database` instance of the provided app.\r\n */\r\nfunction getDatabase(app = getApp(), url) {\r\n    const db = _getProvider(app, 'database').getImmediate({\r\n        identifier: url\r\n    });\r\n    if (!db._instanceStarted) {\r\n        const emulator = getDefaultEmulatorHostnameAndPort('database');\r\n        if (emulator) {\r\n            connectDatabaseEmulator(db, ...emulator);\r\n        }\r\n    }\r\n    return db;\r\n}\r\n/**\r\n * Modify the provided instance to communicate with the Realtime Database\r\n * emulator.\r\n *\r\n * <p>Note: This method must be called before performing any other operation.\r\n *\r\n * @param db - The instance to modify.\r\n * @param host - The emulator host (ex: localhost)\r\n * @param port - The emulator port (ex: 8080)\r\n * @param options.mockUserToken - the mock auth token to use for unit testing Security Rules\r\n */\r\nfunction connectDatabaseEmulator(db, host, port, options = {}) {\r\n    db = index_esm2017_getModularInstance(db);\r\n    db._checkNotDeleted('useEmulator');\r\n    if (db._instanceStarted) {\r\n        fatal('Cannot call useEmulator() after instance has already been initialized.');\r\n    }\r\n    const repo = db._repoInternal;\r\n    let tokenProvider = undefined;\r\n    if (repo.repoInfo_.nodeAdmin) {\r\n        if (options.mockUserToken) {\r\n            fatal('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the \"firebase\" package instead of \"firebase-admin\".');\r\n        }\r\n        tokenProvider = new EmulatorTokenProvider(EmulatorTokenProvider.OWNER);\r\n    }\r\n    else if (options.mockUserToken) {\r\n        const token = typeof options.mockUserToken === 'string'\r\n            ? options.mockUserToken\r\n            : createMockUserToken(options.mockUserToken, db.app.options.projectId);\r\n        tokenProvider = new EmulatorTokenProvider(token);\r\n    }\r\n    // Modify the repo to apply emulator settings\r\n    repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider);\r\n}\r\n/**\r\n * Disconnects from the server (all Database operations will be completed\r\n * offline).\r\n *\r\n * The client automatically maintains a persistent connection to the Database\r\n * server, which will remain active indefinitely and reconnect when\r\n * disconnected. However, the `goOffline()` and `goOnline()` methods may be used\r\n * to control the client connection in cases where a persistent connection is\r\n * undesirable.\r\n *\r\n * While offline, the client will no longer receive data updates from the\r\n * Database. However, all Database operations performed locally will continue to\r\n * immediately fire events, allowing your application to continue behaving\r\n * normally. Additionally, each operation performed locally will automatically\r\n * be queued and retried upon reconnection to the Database server.\r\n *\r\n * To reconnect to the Database and begin receiving remote events, see\r\n * `goOnline()`.\r\n *\r\n * @param db - The instance to disconnect.\r\n */\r\nfunction goOffline(db) {\r\n    db = getModularInstance(db);\r\n    db._checkNotDeleted('goOffline');\r\n    repoInterrupt(db._repo);\r\n}\r\n/**\r\n * Reconnects to the server and synchronizes the offline Database state\r\n * with the server state.\r\n *\r\n * This method should be used after disabling the active connection with\r\n * `goOffline()`. Once reconnected, the client will transmit the proper data\r\n * and fire the appropriate events so that your client \"catches up\"\r\n * automatically.\r\n *\r\n * @param db - The instance to reconnect.\r\n */\r\nfunction goOnline(db) {\r\n    db = getModularInstance(db);\r\n    db._checkNotDeleted('goOnline');\r\n    repoResume(db._repo);\r\n}\r\nfunction enableLogging(logger, persistent) {\r\n    enableLogging$1(logger, persistent);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction registerDatabase(variant) {\r\n    setSDKVersion(SDK_VERSION);\r\n    _registerComponent(new index_esm2017_Component('database', (container, { instanceIdentifier: url }) => {\r\n        const app = container.getProvider('app').getImmediate();\r\n        const authProvider = container.getProvider('auth-internal');\r\n        const appCheckProvider = container.getProvider('app-check-internal');\r\n        return repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url);\r\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */).setMultipleInstances(true));\r\n    registerVersion(database_dist_index_esm2017_name, dist_index_esm2017_version, variant);\r\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\r\n    registerVersion(database_dist_index_esm2017_name, dist_index_esm2017_version, 'esm2017');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst SERVER_TIMESTAMP = {\r\n    '.sv': 'timestamp'\r\n};\r\n/**\r\n * Returns a placeholder value for auto-populating the current timestamp (time\r\n * since the Unix epoch, in milliseconds) as determined by the Firebase\r\n * servers.\r\n */\r\nfunction serverTimestamp() {\r\n    return SERVER_TIMESTAMP;\r\n}\r\n/**\r\n * Returns a placeholder value that can be used to atomically increment the\r\n * current database value by the provided delta.\r\n *\r\n * @param delta - the amount to modify the current value atomically.\r\n * @returns A placeholder value for modifying data atomically server-side.\r\n */\r\nfunction increment(delta) {\r\n    return {\r\n        '.sv': {\r\n            'increment': delta\r\n        }\r\n    };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * A type for the resolve value of {@link runTransaction}.\r\n */\r\nclass TransactionResult {\r\n    /** @hideconstructor */\r\n    constructor(\r\n    /** Whether the transaction was successfully committed. */\r\n    committed, \r\n    /** The resulting data snapshot. */\r\n    snapshot) {\r\n        this.committed = committed;\r\n        this.snapshot = snapshot;\r\n    }\r\n    /** Returns a JSON-serializable representation of this object. */\r\n    toJSON() {\r\n        return { committed: this.committed, snapshot: this.snapshot.toJSON() };\r\n    }\r\n}\r\n/**\r\n * Atomically modifies the data at this location.\r\n *\r\n * Atomically modify the data at this location. Unlike a normal `set()`, which\r\n * just overwrites the data regardless of its previous value, `runTransaction()` is\r\n * used to modify the existing value to a new value, ensuring there are no\r\n * conflicts with other clients writing to the same location at the same time.\r\n *\r\n * To accomplish this, you pass `runTransaction()` an update function which is\r\n * used to transform the current value into a new value. If another client\r\n * writes to the location before your new value is successfully written, your\r\n * update function will be called again with the new current value, and the\r\n * write will be retried. This will happen repeatedly until your write succeeds\r\n * without conflict or you abort the transaction by not returning a value from\r\n * your update function.\r\n *\r\n * Note: Modifying data with `set()` will cancel any pending transactions at\r\n * that location, so extreme care should be taken if mixing `set()` and\r\n * `runTransaction()` to update the same data.\r\n *\r\n * Note: When using transactions with Security and Firebase Rules in place, be\r\n * aware that a client needs `.read` access in addition to `.write` access in\r\n * order to perform a transaction. This is because the client-side nature of\r\n * transactions requires the client to read the data in order to transactionally\r\n * update it.\r\n *\r\n * @param ref - The location to atomically modify.\r\n * @param transactionUpdate - A developer-supplied function which will be passed\r\n * the current data stored at this location (as a JavaScript object). The\r\n * function should return the new value it would like written (as a JavaScript\r\n * object). If `undefined` is returned (i.e. you return with no arguments) the\r\n * transaction will be aborted and the data at this location will not be\r\n * modified.\r\n * @param options - An options object to configure transactions.\r\n * @returns A `Promise` that can optionally be used instead of the `onComplete`\r\n * callback to handle success and failure.\r\n */\r\nfunction runTransaction(ref, \r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\ntransactionUpdate, options) {\r\n    var _a;\r\n    ref = getModularInstance(ref);\r\n    validateWritablePath('Reference.transaction', ref._path);\r\n    if (ref.key === '.length' || ref.key === '.keys') {\r\n        throw ('Reference.transaction failed: ' + ref.key + ' is a read-only object.');\r\n    }\r\n    const applyLocally = (_a = options === null || options === void 0 ? void 0 : options.applyLocally) !== null && _a !== void 0 ? _a : true;\r\n    const deferred = new Deferred();\r\n    const promiseComplete = (error, committed, node) => {\r\n        let dataSnapshot = null;\r\n        if (error) {\r\n            deferred.reject(error);\r\n        }\r\n        else {\r\n            dataSnapshot = new DataSnapshot(node, new ReferenceImpl(ref._repo, ref._path), PRIORITY_INDEX);\r\n            deferred.resolve(new TransactionResult(committed, dataSnapshot));\r\n        }\r\n    };\r\n    // Add a watch to make sure we get server updates.\r\n    const unwatcher = onValue(ref, () => { });\r\n    repoStartTransaction(ref._repo, ref._path, transactionUpdate, promiseComplete, unwatcher, applyLocally);\r\n    return deferred.promise;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nPersistentConnection;\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nPersistentConnection.prototype.simpleListen = function (pathString, onComplete) {\r\n    this.sendRequest('q', { p: pathString }, onComplete);\r\n};\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nPersistentConnection.prototype.echo = function (data, onEcho) {\r\n    this.sendRequest('echo', { d: data }, onEcho);\r\n};\r\n// RealTimeConnection properties that we use in tests.\r\nConnection;\r\n/**\r\n * @internal\r\n */\r\nconst hijackHash = function (newHash) {\r\n    const oldPut = PersistentConnection.prototype.put;\r\n    PersistentConnection.prototype.put = function (pathString, data, onComplete, hash) {\r\n        if (hash !== undefined) {\r\n            hash = newHash();\r\n        }\r\n        oldPut.call(this, pathString, data, onComplete, hash);\r\n    };\r\n    return function () {\r\n        PersistentConnection.prototype.put = oldPut;\r\n    };\r\n};\r\nRepoInfo;\r\n/**\r\n * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.\r\n * @internal\r\n */\r\nconst forceRestClient = function (forceRestClient) {\r\n    repoManagerForceRestClient(forceRestClient);\r\n};\n\n/**\r\n * @license\r\n * Copyright 2023 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Used by console to create a database based on the app,\r\n * passed database URL and a custom auth implementation.\r\n * @internal\r\n * @param app - A valid FirebaseApp-like object\r\n * @param url - A valid Firebase databaseURL\r\n * @param version - custom version e.g. firebase-admin version\r\n * @param customAppCheckImpl - custom app check implementation\r\n * @param customAuthImpl - custom auth implementation\r\n */\r\nfunction _initStandalone({ app, url, version, customAuthImpl, customAppCheckImpl, nodeAdmin = false }) {\r\n    setSDKVersion(version);\r\n    /**\r\n     * ComponentContainer('database-standalone') is just a placeholder that doesn't perform\r\n     * any actual function.\r\n     */\r\n    const componentContainer = new ComponentContainer('database-standalone');\r\n    const authProvider = new Provider('auth-internal', componentContainer);\r\n    let appCheckProvider;\r\n    if (customAppCheckImpl) {\r\n        appCheckProvider = new Provider('app-check-internal', componentContainer);\r\n        appCheckProvider.setComponent(new Component('app-check-internal', () => customAppCheckImpl, \"PRIVATE\" /* ComponentType.PRIVATE */));\r\n    }\r\n    authProvider.setComponent(new Component('auth-internal', () => customAuthImpl, \"PRIVATE\" /* ComponentType.PRIVATE */));\r\n    return repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url, nodeAdmin);\r\n}\n\n/**\r\n * Firebase Realtime Database\r\n *\r\n * @packageDocumentation\r\n */\r\nregisterDatabase();\n\n\n//# sourceMappingURL=index.esm2017.js.map\n\n;// CONCATENATED MODULE: ./node_modules/firebase/database/dist/esm/index.esm.js\n\n//# sourceMappingURL=index.esm.js.map\n\n;// CONCATENATED MODULE: ./src/index.js\n\n\n\n\nconst firebaseConfig = {\n  apiKey: \"AIzaSyAegBd_qulAcOvbIbjOeQtyzQw5dygKEX4\",\n  authDomain: \"solartest-7875a.firebaseapp.com\",\n  databaseURL: \"https://solartest-7875a-default-rtdb.firebaseio.com\",\n  projectId: \"solartest-7875a\",\n  storageBucket: \"solartest-7875a.appspot.com\",\n  messagingSenderId: \"510830787909\",\n  appId: \"1:510830787909:web:05406f7adb94f069ded22c\"\n};\n\nconst app = initializeApp(firebaseConfig);\nconst functions = getFunctions(app);\nconst database = getDatabase();\n\n// Database reference\nconst cellRef = ref(database, \"/cells\");\n\nvar cachedCells = {};\n\n// Event listener - Listens to added cells and updates realtime\n// TODO: 1. Remove cache, implement uses of cache with firebase's once() function\nonChildAdded(cellRef, (cellData) => {\n\t// Data of adopted cell\n\tlet val = cellData.val();\n\t// Cache the cell (Should be removed and use firebase once() or get())\n\tcachedCells[val[\"cell\"]] = {\"name\": val[\"name\"], \"message\": val[\"message\"], \"color\": val[\"color\"]}\n\t//Update color of the cell\n\tdocument.getElementById(val.cell).style.backgroundColor = val.color;\n});\n\n// Holds currently selected tile\nvar clickedTile = document.getElementById(\"p1\");\n\n// Tile selector\n// TODO: 1. Unadopted cells need a default color and a selected color\n// \t 2. Check database for if the cell is adopted instead of checking if there is a color\ndocument.getElementsByClassName(\"outer\")[0].onclick = (event) => {\n\n\t// Previously selected tile is set back to normal\n\tclickedTile.style.backgroundColor = clickedTile.style.backgroundColor == \"white\" ? \"\" : clickedTile.style.backgroundColor;\n\tclickedTile.style.transform = 'scale(1)';\n\n\t// Selects a new tile if the target element clicked is a tile\n\tclickedTile = event.target.className == \"cell\" ? event.target : clickedTile;\n\t\n\t// Modifies the selected cell to show user it is selected\n\tclickedTile.style.backgroundColor = clickedTile.style.backgroundColor == \"\" ? \"white\": clickedTile.style.backgroundColor;\n\tclickedTile.style.transform = 'scale(1.2)';\n\n\t// Updates text fields with cell information \n\tdocument.getElementById(\"cell-id\").innerHTML = \"Cell #\" + clickedTile.id.substring(1);\n\tif(clickedTile.id in cachedCells) {\n\t\tdocument.getElementById(\"cell-name\").innerHTML = cachedCells[clickedTile.id][\"name\"];\n\t\tdocument.getElementById(\"cell-message\").innerHTML = cachedCells[clickedTile.id][\"message\"];\n\t} else {\n\t\tdocument.getElementById(\"cell-name\").innerHTML = \"\";\n\t\tdocument.getElementById(\"cell-message\").innerHTML = \"\";\n\t}\n}\n\n// Adoption form\n// TODO: 1. Prevent adoption of adopted cells\n// \t 2. Integrate payment stuff\ndocument.getElementById(\"adopt-form-submit\").onclick = async () => {\n\t\n\t// Takes user input and cell id to make JSON object\n\tvar cellData = {\"cell\": clickedTile.id};\n\tfor (const input of document.getElementById(\"adopt-form\").querySelectorAll('input')) {\n\t\tcellData[input.name] = input.value;\n\t\tinput.value = \"\";\n\t}\n\t//once()\n\t\n\t// Calls backend to store the JSON object in the database\n\tconst adoptCell = httpsCallable(functions, 'adopt_cell');\n\tadoptCell(cellData);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE2LmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvQkFBTTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFNO0FBQ3JCLGVBQWUscUJBQU07QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsRUFBRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsWUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0Esd0NBQXdDLE1BQU07QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRLHdFQUF3RSxLQUFLOztBQUVoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sc0JBQVE7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MscUJBQU07QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsdUJBQVM7QUFDbEIsNENBQTRDLHlCQUFXO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5QkFBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxNQUFNO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUJBQWlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhLEdBQUcsS0FBSztBQUNqRDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCLElBQUksU0FBUyxHQUFHLFNBQVM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSTtBQUN2RCxLQUFLO0FBQ0w7QUFDQSxtQkFBbUIsTUFBTSxJQUFJOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLEdBQUc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxZQUFZLFFBQVE7QUFDcEI7QUFDQSxTQUFTLHVCQUFTO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQWEsV0FBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsc0JBQVE7QUFDakI7QUFDQTtBQUNBLFNBQVMscUJBQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFCQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNCQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQiw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUJBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlCQUFXO0FBQ3BCLGNBQWMsUUFBUSxVQUFVLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUFXO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLFlBQVksb0JBQU07QUFDbEIsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtFQUFrQixJQUFFO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsRUFBRTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdDQUFrQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeStCO0FBQ3orQjs7O0FDeGtFMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdUJBQVM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sc0JBQVE7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNCQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnQkFBZ0IsZUFBZSxVQUFVO0FBQzFGO0FBQ0E7QUFDQSx5Q0FBeUMsV0FBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsd0NBQXdDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBLDJCQUEyQixVQUFVLEdBQUcscUJBQXFCO0FBQzdEO0FBQ0E7QUFDQSxxQ0FBcUMsV0FBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQ0FBa0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0NBQWtCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQixtQ0FBbUMsVUFBVTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtRDtBQUNuRDs7O0FDeFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLElBQUksS0FBSyxjQUFjO0FBQ25EO0FBQ0E7QUFDQSxzRkFBc0YsUUFBUTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxJQUFJO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxTQUFTLCtCQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEQ7QUFDNUQ7OztBQzFOQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBSTtBQUNuQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUJBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFHOzs7QUN4TGxDO0FBQ047O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlDQUF5QyxJQUFJO0FBQzlFO0FBQ0Esd0JBQXdCLG1CQUFJO0FBQzVCO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQUksc0RBQXNELG1CQUFJO0FBQ2xGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVSxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRTJCOzs7QUM5RndDO0FBQ3VCO0FBQzBHO0FBQ3RKO0FBQ2xCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCLEdBQUcsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTTs7QUFFekI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTSxrQkFBSTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0NBQWtCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssa0JBQUk7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdCQUFnQixzQ0FBc0MsU0FBUztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxjQUFjO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsZ0NBQWtCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxTQUFTO0FBQ2xFO0FBQ0EsdUVBQXVFLFNBQVM7QUFDaEYsMEVBQTBFLFNBQVM7QUFDbkYsc0VBQXNFLFNBQVM7QUFDL0U7QUFDQTtBQUNBLDZFQUE2RSxTQUFTO0FBQ3RGO0FBQ0E7QUFDQSxpR0FBaUcsc0JBQXNCO0FBQ3ZILG9HQUFvRyxzQkFBc0I7QUFDMUgsb0dBQW9HLHNCQUFzQjtBQUMxSCwyR0FBMkcsc0JBQXNCO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsdUJBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLHFCQUFxQjtBQUN4RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGdDQUFnQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLG1DQUFtQyxNQUFNLGdDQUFrQix5Q0FBeUM7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGVBQWU7QUFDdEc7QUFDQTtBQUNBLDBCQUEwQixnQ0FBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1JQUFtSTtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlDQUFpQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0NBQWtCO0FBQ3pDO0FBQ0EseUJBQXlCLGdDQUFrQixJQUFJLG1CQUFtQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsZUFBZTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUSxrQkFBa0IsUUFBUTtBQUM3RTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUFTLElBQUksUUFBUSxvQkFBb0Isa0JBQWtCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlCQUFXO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUyxHQUFHLGtCQUFrQjtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxhQUFhO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQWtDO0FBQ3RELGlDQUFpQyw2QkFBNkIsa0JBQWtCLDBDQUEwQztBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2QkFBNkI7QUFDeEM7QUFDQSxxQkFBcUIseUNBQXlDO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQVM7QUFDcEMsMkJBQTJCLHVCQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtVztBQUNuVzs7O0FDaG9DZ0Q7QUFDbEI7O0FBRTlCLElBQUksY0FBSTtBQUNSLElBQUksaUJBQU87O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLENBQUMsY0FBSSxFQUFFLGlCQUFPO0FBQzdCOzs7QUN2QjBGO0FBQ1k7QUFDdEQ7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx1QkFBdUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9CQUFNO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQkFBTTtBQUNuQztBQUNBO0FBQ0Esb0NBQW9DLG9CQUFNO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixlQUFlLEdBQUcsS0FBSztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTyxHQUFHLFVBQVUsR0FBRyxZQUFZLEdBQUcsS0FBSztBQUNqRTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQixHQUFHLEtBQUs7QUFDaEQ7QUFDQSwwQkFBMEIsWUFBWSxHQUFHLFVBQVUsc0JBQXNCLEtBQUs7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUssR0FBRyxLQUFLO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBTTtBQUM5QixhQUFhO0FBQ2I7O0FBRUEsTUFBTSx1QkFBSTtBQUNWLE1BQU0scUJBQU87O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywwQ0FBMEM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0JBQWtCLEtBQUssdUJBQVM7QUFDcEMsSUFBSSxlQUFlLENBQUMsdUJBQUksRUFBRSxxQkFBTztBQUNqQztBQUNBLElBQUksZUFBZSxDQUFDLHVCQUFJLEVBQUUscUJBQU87QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CLHFCQUFxQixpQ0FBaUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0EsOEJBQThCLFlBQVksQ0FBQyxnQ0FBa0I7QUFDN0Q7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQkFBcUIsaUNBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQ0FBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0NBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVGO0FBQ3ZGOzs7QUM1c0JvQztBQUNwQzs7O0FDRHdIO0FBQzFDO0FBQzBSO0FBQ3BUOztBQUVwRCxNQUFNLGdDQUFJO0FBQ1YsTUFBTSwwQkFBTzs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx5QkFBVztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHlCQUFXO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsdUJBQVM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkMscUJBQXFCLElBQUk7QUFDekI7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvQkFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvQkFBTTtBQUNWO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckMsUUFBUSxvQkFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9CQUFNO0FBQ2Q7QUFDQTtBQUNBLFFBQVEsb0JBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQU07QUFDZDtBQUNBLFFBQVEsb0JBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNkJBQTZCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSx1QkFBUztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9CQUFNLGtEQUFrRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsR0FBRztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsR0FBRztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsS0FBSztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRILGdCQUFnQjtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsY0FBYztBQUMvRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQSxrQkFBa0IsU0FBUyxFQUFFLFVBQVUsR0FBRyxNQUFNO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0JBQU07QUFDVixJQUFJLG9CQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0JBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix1QkFBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQ0FBcUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxpQkFBaUIsR0FBRyx5QkFBVyxDQUFDLEdBQUcsaUJBQWlCLEdBQUcsT0FBTztBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZUFBZTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsR0FBRyxRQUFRLEdBQUc7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGFBQWEsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWEsd0JBQXdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixhQUFhLDhCQUE4QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUNBQXFDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYSxrQkFBa0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtQkFBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQU07QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMseUJBQXlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlCQUF5QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNkJBQTZCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx5QkFBeUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlDQUFpQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkNBQTZDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsMEJBQTBCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hELGdDQUFnQyxZQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQU07QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCxrREFBa0Q7QUFDbEQ7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQix1QkFBUztBQUMzQixRQUFRLG9CQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0JBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBTTtBQUNkLFFBQVEsb0JBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzREFBc0Qsc0JBQVE7QUFDOUQ7QUFDQSw2QkFBNkIscUJBQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsV0FBVztBQUMxRSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxXQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsV0FBVztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDhCQUE4QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx1QkFBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlCQUF5QjtBQUM1RDtBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0NBQWtDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0NBQWtDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMseUJBQVc7QUFDckQsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQU07QUFDZDtBQUNBLHdDQUF3QyxzQkFBUTtBQUNoRDtBQUNBO0FBQ0EsUUFBUSxvQkFBTTtBQUNkO0FBQ0E7QUFDQSxJQUFJLG9CQUFNO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9CQUFNO0FBQ2QsUUFBUSxvQkFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9CQUFNO0FBQ2Q7QUFDQTtBQUNBLCtCQUErQiw2QkFBNkIsSUFBSSw2QkFBNkI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBUTtBQUN2QjtBQUNBO0FBQ0EsUUFBUSxvQkFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixHQUFHO0FBQzlCLDBCQUEwQixxQkFBTztBQUNqQyxZQUFZLG9CQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEdBQUc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9CQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLDZCQUE2QixJQUFJLDZCQUE2QjtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9CQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9CQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9CQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9CQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBTTtBQUNkO0FBQ0E7QUFDQSx3REFBd0QsdUJBQVM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQVM7QUFDbEM7QUFDQSxvQ0FBb0MsdUJBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUFTO0FBQ2hDO0FBQ0Esa0NBQWtDLHVCQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFNO0FBQ2xCLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGFBQWE7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9CQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLG9CQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9CQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBTTtBQUNkO0FBQ0E7QUFDQSxRQUFRLG9CQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsSUFBSSxvQkFBTTtBQUNWLElBQUksb0JBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFDQUFxQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBTTtBQUNkLFFBQVEsb0JBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0JBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0JBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9CQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0JBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9CQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9CQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvQkFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxvQkFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVCx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9CQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9CQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQU07QUFDZDtBQUNBO0FBQ0EsSUFBSSxvQkFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxZQUFZLGlCQUFpQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBTztBQUNqQyx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx3QkFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUJBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsWUFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQSxzQkFBc0Isd0JBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdCQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3QkFBVTtBQUNwQjtBQUNBO0FBQ0Esd0JBQXdCLHlCQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1DQUFtQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxHQUFHO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsR0FBRztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrQ0FBK0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBLFFBQVEsb0JBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxPQUFPO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRLGNBQWMsWUFBWTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQU07QUFDZDtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1DQUFtQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQSxRQUFRLG9CQUFNO0FBQ2Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSDtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQ0FBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdDQUFrQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0NBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNIQUFzSDtBQUM5SCxRQUFRLG1JQUFtSTtBQUMzSTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxSEFBcUg7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMklBQTJJO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsWUFBWTtBQUMzRSxJQUFJLGdCQUFnQixHQUFHLGNBQWMsR0FBRyxpQkFBaUIsR0FBRztBQUM1RCxnQkFBZ0IsR0FBRyxrQkFBa0IsR0FBRyxtQkFBbUI7QUFDM0QsSUFBSSxtQkFBbUIsR0FBRyxrQkFBa0IsR0FBRyx1QkFBdUI7QUFDdEUsSUFBSSxxQkFBcUIsSUFBSSxlQUFlO0FBQzVDLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0dBQWtHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0dBQWtHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0dBQWtHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrR0FBa0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3RkFBd0Y7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksd0ZBQXdGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3RkFBd0Y7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtHQUFrRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxLQUFLLEdBQUcsS0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWUsTUFBTSxtQkFBbUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUSxHQUFHLGVBQWU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlDQUFpQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdDQUFnQztBQUNwQztBQUNBO0FBQ0EscUJBQXFCLGlDQUFpQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE1BQU07QUFDakMsZUFBZSxZQUFZO0FBQzNCO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUJBQXlCLGlDQUFpQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELFNBQVMsZ0NBQWtCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFhO0FBQy9CLElBQUksa0JBQWtCLEtBQUssdUJBQVMsMkJBQTJCLHlCQUF5QjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGVBQWUsQ0FBQyxnQ0FBSSxFQUFFLDBCQUFPO0FBQ2pDO0FBQ0EsSUFBSSxlQUFlLENBQUMsZ0NBQUksRUFBRSwwQkFBTztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MscUJBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwRUFBMEU7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNDVCO0FBQzU1Qjs7O0FDcHJibUM7QUFDbkM7OztBQ0Q2QztBQUNvQjtBQUNPOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxhQUFhO0FBQ3pCLGtCQUFrQixZQUFZO0FBQzlCLGlCQUFpQixXQUFXOztBQUU1QjtBQUNBLGdCQUFnQixHQUFHOztBQUVuQjs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmx1ZS1za3ktc29sYXIvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9pbmRleC5lc20yMDE3LmpzPzFmZDUiLCJ3ZWJwYWNrOi8vYmx1ZS1za3ktc29sYXIvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2NvbXBvbmVudC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzP2UwZTciLCJ3ZWJwYWNrOi8vYmx1ZS1za3ktc29sYXIvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2xvZ2dlci9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzPzVlNzkiLCJ3ZWJwYWNrOi8vYmx1ZS1za3ktc29sYXIvLi9ub2RlX21vZHVsZXMvaWRiL2J1aWxkL3dyYXAtaWRiLXZhbHVlLmpzPzM5MmEiLCJ3ZWJwYWNrOi8vYmx1ZS1za3ktc29sYXIvLi9ub2RlX21vZHVsZXMvaWRiL2J1aWxkL2luZGV4LmpzPzk4NWQiLCJ3ZWJwYWNrOi8vYmx1ZS1za3ktc29sYXIvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzPzUxYWQiLCJ3ZWJwYWNrOi8vYmx1ZS1za3ktc29sYXIvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2UvYXBwL2Rpc3QvZXNtL2luZGV4LmVzbS5qcz83N2NlIiwid2VicGFjazovL2JsdWUtc2t5LXNvbGFyLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9mdW5jdGlvbnMvZGlzdC9pbmRleC5lc20yMDE3LmpzPzIyODUiLCJ3ZWJwYWNrOi8vYmx1ZS1za3ktc29sYXIvLi9ub2RlX21vZHVsZXMvZmlyZWJhc2UvZnVuY3Rpb25zL2Rpc3QvZXNtL2luZGV4LmVzbS5qcz8zZTI4Iiwid2VicGFjazovL2JsdWUtc2t5LXNvbGFyLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2luZGV4LmVzbTIwMTcuanM/NTFiMCIsIndlYnBhY2s6Ly9ibHVlLXNreS1zb2xhci8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9kYXRhYmFzZS9kaXN0L2VzbS9pbmRleC5lc20uanM/YTE1YiIsIndlYnBhY2s6Ly9ibHVlLXNreS1zb2xhci8uL3NyYy9pbmRleC5qcz9iNjM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IEZpcmViYXNlIGNvbnN0YW50cy4gIFNvbWUgb2YgdGhlc2UgKEBkZWZpbmVzKSBjYW4gYmUgb3ZlcnJpZGRlbiBhdCBjb21waWxlLXRpbWUuXHJcbiAqL1xyXG5jb25zdCBDT05TVEFOVFMgPSB7XHJcbiAgICAvKipcclxuICAgICAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBpcyB0aGUgY2xpZW50IE5vZGUuanMgU0RLLlxyXG4gICAgICovXHJcbiAgICBOT0RFX0NMSUVOVDogZmFsc2UsXHJcbiAgICAvKipcclxuICAgICAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBpcyB0aGUgQWRtaW4gTm9kZS5qcyBTREsuXHJcbiAgICAgKi9cclxuICAgIE5PREVfQURNSU46IGZhbHNlLFxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlYmFzZSBTREsgVmVyc2lvblxyXG4gICAgICovXHJcbiAgICBTREtfVkVSU0lPTjogJyR7SlNDT1JFX1ZFUlNJT059J1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBwcm92aWRlZCBhc3NlcnRpb24gaXMgZmFsc3lcclxuICovXHJcbmNvbnN0IGFzc2VydCA9IGZ1bmN0aW9uIChhc3NlcnRpb24sIG1lc3NhZ2UpIHtcclxuICAgIGlmICghYXNzZXJ0aW9uKSB7XHJcbiAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IobWVzc2FnZSk7XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIEVycm9yIG9iamVjdCBzdWl0YWJsZSBmb3IgdGhyb3dpbmcuXHJcbiAqL1xyXG5jb25zdCBhc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICByZXR1cm4gbmV3IEVycm9yKCdGaXJlYmFzZSBEYXRhYmFzZSAoJyArXHJcbiAgICAgICAgQ09OU1RBTlRTLlNES19WRVJTSU9OICtcclxuICAgICAgICAnKSBJTlRFUk5BTCBBU1NFUlQgRkFJTEVEOiAnICtcclxuICAgICAgICBtZXNzYWdlKTtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3Qgc3RyaW5nVG9CeXRlQXJyYXkkMSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIC8vIFRPRE8odXNlcik6IFVzZSBuYXRpdmUgaW1wbGVtZW50YXRpb25zIGlmL3doZW4gYXZhaWxhYmxlXHJcbiAgICBjb25zdCBvdXQgPSBbXTtcclxuICAgIGxldCBwID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoYyA8IDEyOCkge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IGM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KSB7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gNikgfCAxOTI7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmXHJcbiAgICAgICAgICAgIGkgKyAxIDwgc3RyLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAoc3RyLmNoYXJDb2RlQXQoaSArIDEpICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XHJcbiAgICAgICAgICAgIC8vIFN1cnJvZ2F0ZSBQYWlyXHJcbiAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKChjICYgMHgwM2ZmKSA8PCAxMCkgKyAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4MDNmZik7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gMTgpIHwgMjQwO1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiAxMikgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxMikgfCAyMjQ7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvdXQ7XHJcbn07XHJcbi8qKlxyXG4gKiBUdXJucyBhbiBhcnJheSBvZiBudW1iZXJzIGludG8gdGhlIHN0cmluZyBnaXZlbiBieSB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGVcclxuICogY2hhcmFjdGVycyB0byB3aGljaCB0aGUgbnVtYmVycyBjb3JyZXNwb25kLlxyXG4gKiBAcGFyYW0gYnl0ZXMgQXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgY2hhcmFjdGVycy5cclxuICogQHJldHVybiBTdHJpbmdpZmljYXRpb24gb2YgdGhlIGFycmF5LlxyXG4gKi9cclxuY29uc3QgYnl0ZUFycmF5VG9TdHJpbmcgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcclxuICAgIC8vIFRPRE8odXNlcik6IFVzZSBuYXRpdmUgaW1wbGVtZW50YXRpb25zIGlmL3doZW4gYXZhaWxhYmxlXHJcbiAgICBjb25zdCBvdXQgPSBbXTtcclxuICAgIGxldCBwb3MgPSAwLCBjID0gMDtcclxuICAgIHdoaWxlIChwb3MgPCBieXRlcy5sZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBjMSA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICBpZiAoYzEgPCAxMjgpIHtcclxuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYzEgPiAxOTEgJiYgYzEgPCAyMjQpIHtcclxuICAgICAgICAgICAgY29uc3QgYzIgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMxICYgMzEpIDw8IDYpIHwgKGMyICYgNjMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYzEgPiAyMzkgJiYgYzEgPCAzNjUpIHtcclxuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcclxuICAgICAgICAgICAgY29uc3QgYzIgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgICAgIGNvbnN0IGMzID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBjb25zdCBjNCA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICAgICAgY29uc3QgdSA9ICgoKGMxICYgNykgPDwgMTgpIHwgKChjMiAmIDYzKSA8PCAxMikgfCAoKGMzICYgNjMpIDw8IDYpIHwgKGM0ICYgNjMpKSAtXHJcbiAgICAgICAgICAgICAgICAweDEwMDAwO1xyXG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODAwICsgKHUgPj4gMTApKTtcclxuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZGMwMCArICh1ICYgMTAyMykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgYzIgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgICAgIGNvbnN0IGMzID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjMSAmIDE1KSA8PCAxMikgfCAoKGMyICYgNjMpIDw8IDYpIHwgKGMzICYgNjMpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0LmpvaW4oJycpO1xyXG59O1xyXG4vLyBXZSBkZWZpbmUgaXQgYXMgYW4gb2JqZWN0IGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNsYXNzIGJlY2F1c2UgYSBjbGFzcyBjb21waWxlZCBkb3duIHRvIGVzNSBjYW4ndFxyXG4vLyBiZSB0cmVlc2hha2VkLiBodHRwczovL2dpdGh1Yi5jb20vcm9sbHVwL3JvbGx1cC9pc3N1ZXMvMTY5MVxyXG4vLyBTdGF0aWMgbG9va3VwIG1hcHMsIGxhemlseSBwb3B1bGF0ZWQgYnkgaW5pdF8oKVxyXG5jb25zdCBiYXNlNjQgPSB7XHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYnl0ZXMgdG8gY2hhcmFjdGVycy5cclxuICAgICAqL1xyXG4gICAgYnl0ZVRvQ2hhck1hcF86IG51bGwsXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgY2hhcmFjdGVycyB0byBieXRlcy5cclxuICAgICAqL1xyXG4gICAgY2hhclRvQnl0ZU1hcF86IG51bGwsXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgYnl0ZXMgdG8gd2Vic2FmZSBjaGFyYWN0ZXJzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgYnl0ZVRvQ2hhck1hcFdlYlNhZmVfOiBudWxsLFxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIHdlYnNhZmUgY2hhcmFjdGVycyB0byBieXRlcy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNoYXJUb0J5dGVNYXBXZWJTYWZlXzogbnVsbCxcclxuICAgIC8qKlxyXG4gICAgICogT3VyIGRlZmF1bHQgYWxwaGFiZXQsIHNoYXJlZCBiZXR3ZWVuXHJcbiAgICAgKiBFTkNPREVEX1ZBTFMgYW5kIEVOQ09ERURfVkFMU19XRUJTQUZFXHJcbiAgICAgKi9cclxuICAgIEVOQ09ERURfVkFMU19CQVNFOiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonICsgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyArICcwMTIzNDU2Nzg5JyxcclxuICAgIC8qKlxyXG4gICAgICogT3VyIGRlZmF1bHQgYWxwaGFiZXQuIFZhbHVlIDY0ICg9KSBpcyBzcGVjaWFsOyBpdCBtZWFucyBcIm5vdGhpbmcuXCJcclxuICAgICAqL1xyXG4gICAgZ2V0IEVOQ09ERURfVkFMUygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRSArICcrLz0nO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogT3VyIHdlYnNhZmUgYWxwaGFiZXQuXHJcbiAgICAgKi9cclxuICAgIGdldCBFTkNPREVEX1ZBTFNfV0VCU0FGRSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRSArICctXy4nO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgdGhlIGF0b2IgYW5kIGJ0b2EgZnVuY3Rpb25zLiBUaGlzIGV4dGVuc2lvblxyXG4gICAgICogc3RhcnRlZCBhdCBNb3ppbGxhIGJ1dCBpcyBub3cgaW1wbGVtZW50ZWQgYnkgbWFueSBicm93c2Vycy4gV2UgdXNlIHRoZVxyXG4gICAgICogQVNTVU1FXyogdmFyaWFibGVzIHRvIGF2b2lkIHB1bGxpbmcgaW4gdGhlIGZ1bGwgdXNlcmFnZW50IGRldGVjdGlvbiBsaWJyYXJ5XHJcbiAgICAgKiBidXQgc3RpbGwgYWxsb3dpbmcgdGhlIHN0YW5kYXJkIHBlci1icm93c2VyIGNvbXBpbGF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIEhBU19OQVRJVkVfU1VQUE9SVDogdHlwZW9mIGF0b2IgPT09ICdmdW5jdGlvbicsXHJcbiAgICAvKipcclxuICAgICAqIEJhc2U2NC1lbmNvZGUgYW4gYXJyYXkgb2YgYnl0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlucHV0IEFuIGFycmF5IG9mIGJ5dGVzIChudW1iZXJzIHdpdGhcclxuICAgICAqICAgICB2YWx1ZSBpbiBbMCwgMjU1XSkgdG8gZW5jb2RlLlxyXG4gICAgICogQHBhcmFtIHdlYlNhZmUgQm9vbGVhbiBpbmRpY2F0aW5nIHdlIHNob3VsZCB1c2UgdGhlXHJcbiAgICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIGVuY29kZUJ5dGVBcnJheShpbnB1dCwgd2ViU2FmZSkge1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ2VuY29kZUJ5dGVBcnJheSB0YWtlcyBhbiBhcnJheSBhcyBhIHBhcmFtZXRlcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmluaXRfKCk7XHJcbiAgICAgICAgY29uc3QgYnl0ZVRvQ2hhck1hcCA9IHdlYlNhZmVcclxuICAgICAgICAgICAgPyB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlX1xyXG4gICAgICAgICAgICA6IHRoaXMuYnl0ZVRvQ2hhck1hcF87XHJcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgICAgICAgICBjb25zdCBieXRlMSA9IGlucHV0W2ldO1xyXG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTIgPSBpICsgMSA8IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTIgPSBoYXZlQnl0ZTIgPyBpbnB1dFtpICsgMV0gOiAwO1xyXG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTMgPSBpICsgMiA8IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTMgPSBoYXZlQnl0ZTMgPyBpbnB1dFtpICsgMl0gOiAwO1xyXG4gICAgICAgICAgICBjb25zdCBvdXRCeXRlMSA9IGJ5dGUxID4+IDI7XHJcbiAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUyID0gKChieXRlMSAmIDB4MDMpIDw8IDQpIHwgKGJ5dGUyID4+IDQpO1xyXG4gICAgICAgICAgICBsZXQgb3V0Qnl0ZTMgPSAoKGJ5dGUyICYgMHgwZikgPDwgMikgfCAoYnl0ZTMgPj4gNik7XHJcbiAgICAgICAgICAgIGxldCBvdXRCeXRlNCA9IGJ5dGUzICYgMHgzZjtcclxuICAgICAgICAgICAgaWYgKCFoYXZlQnl0ZTMpIHtcclxuICAgICAgICAgICAgICAgIG91dEJ5dGU0ID0gNjQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhdmVCeXRlMikge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dEJ5dGUzID0gNjQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3V0cHV0LnB1c2goYnl0ZVRvQ2hhck1hcFtvdXRCeXRlMV0sIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTJdLCBieXRlVG9DaGFyTWFwW291dEJ5dGUzXSwgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlNF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogQmFzZTY0LWVuY29kZSBhIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5wdXQgQSBzdHJpbmcgdG8gZW5jb2RlLlxyXG4gICAgICogQHBhcmFtIHdlYlNhZmUgSWYgdHJ1ZSwgd2Ugc2hvdWxkIHVzZSB0aGVcclxuICAgICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cclxuICAgICAqIEByZXR1cm4gVGhlIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgZW5jb2RlU3RyaW5nKGlucHV0LCB3ZWJTYWZlKSB7XHJcbiAgICAgICAgLy8gU2hvcnRjdXQgZm9yIE1vemlsbGEgYnJvd3NlcnMgdGhhdCBpbXBsZW1lbnRcclxuICAgICAgICAvLyBhIG5hdGl2ZSBiYXNlNjQgZW5jb2RlciBpbiB0aGUgZm9ybSBvZiBcImJ0b2EvYXRvYlwiXHJcbiAgICAgICAgaWYgKHRoaXMuSEFTX05BVElWRV9TVVBQT1JUICYmICF3ZWJTYWZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBidG9hKGlucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlQnl0ZUFycmF5KHN0cmluZ1RvQnl0ZUFycmF5JDEoaW5wdXQpLCB3ZWJTYWZlKTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEJhc2U2NC1kZWNvZGUgYSBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlucHV0IHRvIGRlY29kZS5cclxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIFRydWUgaWYgd2Ugc2hvdWxkIHVzZSB0aGVcclxuICAgICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cclxuICAgICAqIEByZXR1cm4gc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZGVjb2RlZCB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgZGVjb2RlU3RyaW5nKGlucHV0LCB3ZWJTYWZlKSB7XHJcbiAgICAgICAgLy8gU2hvcnRjdXQgZm9yIE1vemlsbGEgYnJvd3NlcnMgdGhhdCBpbXBsZW1lbnRcclxuICAgICAgICAvLyBhIG5hdGl2ZSBiYXNlNjQgZW5jb2RlciBpbiB0aGUgZm9ybSBvZiBcImJ0b2EvYXRvYlwiXHJcbiAgICAgICAgaWYgKHRoaXMuSEFTX05BVElWRV9TVVBQT1JUICYmICF3ZWJTYWZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhdG9iKGlucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJ5dGVBcnJheVRvU3RyaW5nKHRoaXMuZGVjb2RlU3RyaW5nVG9CeXRlQXJyYXkoaW5wdXQsIHdlYlNhZmUpKTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEJhc2U2NC1kZWNvZGUgYSBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogSW4gYmFzZS02NCBkZWNvZGluZywgZ3JvdXBzIG9mIGZvdXIgY2hhcmFjdGVycyBhcmUgY29udmVydGVkIGludG8gdGhyZWVcclxuICAgICAqIGJ5dGVzLiAgSWYgdGhlIGVuY29kZXIgZGlkIG5vdCBhcHBseSBwYWRkaW5nLCB0aGUgaW5wdXQgbGVuZ3RoIG1heSBub3RcclxuICAgICAqIGJlIGEgbXVsdGlwbGUgb2YgNC5cclxuICAgICAqXHJcbiAgICAgKiBJbiB0aGlzIGNhc2UsIHRoZSBsYXN0IGdyb3VwIHdpbGwgaGF2ZSBmZXdlciB0aGFuIDQgY2hhcmFjdGVycywgYW5kXHJcbiAgICAgKiBwYWRkaW5nIHdpbGwgYmUgaW5mZXJyZWQuICBJZiB0aGUgZ3JvdXAgaGFzIG9uZSBvciB0d28gY2hhcmFjdGVycywgaXQgZGVjb2Rlc1xyXG4gICAgICogdG8gb25lIGJ5dGUuICBJZiB0aGUgZ3JvdXAgaGFzIHRocmVlIGNoYXJhY3RlcnMsIGl0IGRlY29kZXMgdG8gdHdvIGJ5dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbnB1dCBJbnB1dCB0byBkZWNvZGUuXHJcbiAgICAgKiBAcGFyYW0gd2ViU2FmZSBUcnVlIGlmIHdlIHNob3VsZCB1c2UgdGhlIHdlYi1zYWZlIGFscGhhYmV0LlxyXG4gICAgICogQHJldHVybiBieXRlcyByZXByZXNlbnRpbmcgdGhlIGRlY29kZWQgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIGRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSB7XHJcbiAgICAgICAgdGhpcy5pbml0XygpO1xyXG4gICAgICAgIGNvbnN0IGNoYXJUb0J5dGVNYXAgPSB3ZWJTYWZlXHJcbiAgICAgICAgICAgID8gdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV9cclxuICAgICAgICAgICAgOiB0aGlzLmNoYXJUb0J5dGVNYXBfO1xyXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOykge1xyXG4gICAgICAgICAgICBjb25zdCBieXRlMSA9IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkrKyldO1xyXG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTIgPSBpIDwgaW5wdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBieXRlMiA9IGhhdmVCeXRlMiA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDA7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUzID0gaSA8IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZTMgPSBoYXZlQnl0ZTMgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiA2NDtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTQgPSBpIDwgaW5wdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBieXRlNCA9IGhhdmVCeXRlNCA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDY0O1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGlmIChieXRlMSA9PSBudWxsIHx8IGJ5dGUyID09IG51bGwgfHwgYnl0ZTMgPT0gbnVsbCB8fCBieXRlNCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBvdXRCeXRlMSA9IChieXRlMSA8PCAyKSB8IChieXRlMiA+PiA0KTtcclxuICAgICAgICAgICAgb3V0cHV0LnB1c2gob3V0Qnl0ZTEpO1xyXG4gICAgICAgICAgICBpZiAoYnl0ZTMgIT09IDY0KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRCeXRlMiA9ICgoYnl0ZTIgPDwgNCkgJiAweGYwKSB8IChieXRlMyA+PiAyKTtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUyKTtcclxuICAgICAgICAgICAgICAgIGlmIChieXRlNCAhPT0gNjQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRCeXRlMyA9ICgoYnl0ZTMgPDwgNikgJiAweGMwKSB8IGJ5dGU0O1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogTGF6eSBzdGF0aWMgaW5pdGlhbGl6YXRpb24gZnVuY3Rpb24uIENhbGxlZCBiZWZvcmVcclxuICAgICAqIGFjY2Vzc2luZyBhbnkgb2YgdGhlIHN0YXRpYyBtYXAgdmFyaWFibGVzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgaW5pdF8oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmJ5dGVUb0NoYXJNYXBfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcF8gPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwXyA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlXyA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlXyA9IHt9O1xyXG4gICAgICAgICAgICAvLyBXZSB3YW50IHF1aWNrIG1hcHBpbmdzIGJhY2sgYW5kIGZvcnRoLCBzbyB3ZSBwcmVjb21wdXRlIHR3byBtYXBzLlxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRU5DT0RFRF9WQUxTLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBfW2ldID0gdGhpcy5FTkNPREVEX1ZBTFMuY2hhckF0KGkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwX1t0aGlzLmJ5dGVUb0NoYXJNYXBfW2ldXSA9IGk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlX1tpXSA9IHRoaXMuRU5DT0RFRF9WQUxTX1dFQlNBRkUuY2hhckF0KGkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV9bdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9baV1dID0gaTtcclxuICAgICAgICAgICAgICAgIC8vIEJlIGZvcmdpdmluZyB3aGVuIGRlY29kaW5nIGFuZCBjb3JyZWN0bHkgZGVjb2RlIGJvdGggZW5jb2RpbmdzLlxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfW3RoaXMuRU5DT0RFRF9WQUxTX1dFQlNBRkUuY2hhckF0KGkpXSA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV9bdGhpcy5FTkNPREVEX1ZBTFMuY2hhckF0KGkpXSA9IGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBBbiBlcnJvciBlbmNvdW50ZXJlZCB3aGlsZSBkZWNvZGluZyBiYXNlNjQgc3RyaW5nLlxyXG4gKi9cclxuY2xhc3MgRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdEZWNvZGVCYXNlNjRTdHJpbmdFcnJvcic7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZ1xyXG4gKi9cclxuY29uc3QgYmFzZTY0RW5jb2RlID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgY29uc3QgdXRmOEJ5dGVzID0gc3RyaW5nVG9CeXRlQXJyYXkkMShzdHIpO1xyXG4gICAgcmV0dXJuIGJhc2U2NC5lbmNvZGVCeXRlQXJyYXkodXRmOEJ5dGVzLCB0cnVlKTtcclxufTtcclxuLyoqXHJcbiAqIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZyAod2l0aG91dCBcIi5cIiBwYWRkaW5nIGluIHRoZSBlbmQpLlxyXG4gKiBlLmcuIFVzZWQgaW4gSlNPTiBXZWIgVG9rZW4gKEpXVCkgcGFydHMuXHJcbiAqL1xyXG5jb25zdCBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIC8vIFVzZSBiYXNlNjR1cmwgZW5jb2RpbmcgYW5kIHJlbW92ZSBwYWRkaW5nIGluIHRoZSBlbmQgKGRvdCBjaGFyYWN0ZXJzKS5cclxuICAgIHJldHVybiBiYXNlNjRFbmNvZGUoc3RyKS5yZXBsYWNlKC9cXC4vZywgJycpO1xyXG59O1xyXG4vKipcclxuICogVVJMLXNhZmUgYmFzZTY0IGRlY29kaW5nXHJcbiAqXHJcbiAqIE5PVEU6IERPIE5PVCB1c2UgdGhlIGdsb2JhbCBhdG9iKCkgZnVuY3Rpb24gLSBpdCBkb2VzIE5PVCBzdXBwb3J0IHRoZVxyXG4gKiBiYXNlNjRVcmwgdmFyaWFudCBlbmNvZGluZy5cclxuICpcclxuICogQHBhcmFtIHN0ciBUbyBiZSBkZWNvZGVkXHJcbiAqIEByZXR1cm4gRGVjb2RlZCByZXN1bHQsIGlmIHBvc3NpYmxlXHJcbiAqL1xyXG5jb25zdCBiYXNlNjREZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBiYXNlNjQuZGVjb2RlU3RyaW5nKHN0ciwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2Jhc2U2NERlY29kZSBmYWlsZWQ6ICcsIGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBEbyBhIGRlZXAtY29weSBvZiBiYXNpYyBKYXZhU2NyaXB0IE9iamVjdHMgb3IgQXJyYXlzLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcENvcHkodmFsdWUpIHtcclxuICAgIHJldHVybiBkZWVwRXh0ZW5kKHVuZGVmaW5lZCwgdmFsdWUpO1xyXG59XHJcbi8qKlxyXG4gKiBDb3B5IHByb3BlcnRpZXMgZnJvbSBzb3VyY2UgdG8gdGFyZ2V0IChyZWN1cnNpdmVseSBhbGxvd3MgZXh0ZW5zaW9uXHJcbiAqIG9mIE9iamVjdHMgYW5kIEFycmF5cykuICBTY2FsYXIgdmFsdWVzIGluIHRoZSB0YXJnZXQgYXJlIG92ZXItd3JpdHRlbi5cclxuICogSWYgdGFyZ2V0IGlzIHVuZGVmaW5lZCwgYW4gb2JqZWN0IG9mIHRoZSBhcHByb3ByaWF0ZSB0eXBlIHdpbGwgYmUgY3JlYXRlZFxyXG4gKiAoYW5kIHJldHVybmVkKS5cclxuICpcclxuICogV2UgcmVjdXJzaXZlbHkgY29weSBhbGwgY2hpbGQgcHJvcGVydGllcyBvZiBwbGFpbiBPYmplY3RzIGluIHRoZSBzb3VyY2UtIHNvXHJcbiAqIHRoYXQgbmFtZXNwYWNlLSBsaWtlIGRpY3Rpb25hcmllcyBhcmUgbWVyZ2VkLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgdGhlIHRhcmdldCBjYW4gYmUgYSBmdW5jdGlvbiwgaW4gd2hpY2ggY2FzZSB0aGUgcHJvcGVydGllcyBpblxyXG4gKiB0aGUgc291cmNlIE9iamVjdCBhcmUgY29waWVkIG9udG8gaXQgYXMgc3RhdGljIHByb3BlcnRpZXMgb2YgdGhlIEZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBOb3RlOiB3ZSBkb24ndCBtZXJnZSBfX3Byb3RvX18gdG8gcHJldmVudCBwcm90b3R5cGUgcG9sbHV0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwRXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XHJcbiAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcclxuICAgIH1cclxuICAgIHN3aXRjaCAoc291cmNlLmNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgY2FzZSBEYXRlOlxyXG4gICAgICAgICAgICAvLyBUcmVhdCBEYXRlcyBsaWtlIHNjYWxhcnM7IGlmIHRoZSB0YXJnZXQgZGF0ZSBvYmplY3QgaGFkIGFueSBjaGlsZFxyXG4gICAgICAgICAgICAvLyBwcm9wZXJ0aWVzIC0gdGhleSB3aWxsIGJlIGxvc3QhXHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGVWYWx1ZSA9IHNvdXJjZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGVWYWx1ZS5nZXRUaW1lKCkpO1xyXG4gICAgICAgIGNhc2UgT2JqZWN0OlxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldCA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgQXJyYXk6XHJcbiAgICAgICAgICAgIC8vIEFsd2F5cyBjb3B5IHRoZSBhcnJheSBzb3VyY2UgYW5kIG92ZXJ3cml0ZSB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAgICB0YXJnZXQgPSBbXTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgLy8gTm90IGEgcGxhaW4gT2JqZWN0IC0gdHJlYXQgaXQgYXMgYSBzY2FsYXIuXHJcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gc291cmNlKSB7XHJcbiAgICAgICAgLy8gdXNlIGlzVmFsaWRLZXkgdG8gZ3VhcmQgYWdhaW5zdCBwcm90b3R5cGUgcG9sbHV0aW9uLiBTZWUgaHR0cHM6Ly9zbnlrLmlvL3Z1bG4vU05ZSy1KUy1MT0RBU0gtNDUwMjAyXHJcbiAgICAgICAgaWYgKCFzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcCkgfHwgIWlzVmFsaWRLZXkocHJvcCkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IGRlZXBFeHRlbmQodGFyZ2V0W3Byb3BdLCBzb3VyY2VbcHJvcF0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxyXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xyXG4gICAgcmV0dXJuIGtleSAhPT0gJ19fcHJvdG9fXyc7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFBvbHlmaWxsIGZvciBgZ2xvYmFsVGhpc2Agb2JqZWN0LlxyXG4gKiBAcmV0dXJucyB0aGUgYGdsb2JhbFRoaXNgIG9iamVjdCBmb3IgdGhlIGdpdmVuIGVudmlyb25tZW50LlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRHbG9iYWwoKSB7XHJcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gd2luZG93O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0LicpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IGdldERlZmF1bHRzRnJvbUdsb2JhbCA9ICgpID0+IGdldEdsb2JhbCgpLl9fRklSRUJBU0VfREVGQVVMVFNfXztcclxuLyoqXHJcbiAqIEF0dGVtcHQgdG8gcmVhZCBkZWZhdWx0cyBmcm9tIGEgSlNPTiBzdHJpbmcgcHJvdmlkZWQgdG9cclxuICogcHJvY2VzcyguKWVudiguKV9fRklSRUJBU0VfREVGQVVMVFNfXyBvciBhIEpTT04gZmlsZSB3aG9zZSBwYXRoIGlzIGluXHJcbiAqIHByb2Nlc3MoLillbnYoLilfX0ZJUkVCQVNFX0RFRkFVTFRTX1BBVEhfX1xyXG4gKiBUaGUgZG90cyBhcmUgaW4gcGFyZW5zIGJlY2F1c2UgY2VydGFpbiBjb21waWxlcnMgKFZpdGU/KSBjYW5ub3RcclxuICogaGFuZGxlIHNlZWluZyB0aGF0IHZhcmlhYmxlIGluIGNvbW1lbnRzLlxyXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWpzLXNkay9pc3N1ZXMvNjgzOFxyXG4gKi9cclxuY29uc3QgZ2V0RGVmYXVsdHNGcm9tRW52VmFyaWFibGUgPSAoKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBwcm9jZXNzLmVudiA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBkZWZhdWx0c0pzb25TdHJpbmcgPSBwcm9jZXNzLmVudi5fX0ZJUkVCQVNFX0RFRkFVTFRTX187XHJcbiAgICBpZiAoZGVmYXVsdHNKc29uU3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGVmYXVsdHNKc29uU3RyaW5nKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgZ2V0RGVmYXVsdHNGcm9tQ29va2llID0gKCkgPT4ge1xyXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgbWF0Y2g7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKC9fX0ZJUkVCQVNFX0RFRkFVTFRTX189KFteO10rKS8pO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyBTb21lIGVudmlyb25tZW50cyBzdWNoIGFzIEFuZ3VsYXIgVW5pdmVyc2FsIFNTUiBoYXZlIGFcclxuICAgICAgICAvLyBgZG9jdW1lbnRgIG9iamVjdCBidXQgZXJyb3Igb24gYWNjZXNzaW5nIGBkb2N1bWVudC5jb29raWVgLlxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGRlY29kZWQgPSBtYXRjaCAmJiBiYXNlNjREZWNvZGUobWF0Y2hbMV0pO1xyXG4gICAgcmV0dXJuIGRlY29kZWQgJiYgSlNPTi5wYXJzZShkZWNvZGVkKTtcclxufTtcclxuLyoqXHJcbiAqIEdldCB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdC4gSXQgY2hlY2tzIGluIG9yZGVyOlxyXG4gKiAoMSkgaWYgc3VjaCBhbiBvYmplY3QgZXhpc3RzIGFzIGEgcHJvcGVydHkgb2YgYGdsb2JhbFRoaXNgXHJcbiAqICgyKSBpZiBzdWNoIGFuIG9iamVjdCB3YXMgcHJvdmlkZWQgb24gYSBzaGVsbCBlbnZpcm9ubWVudCB2YXJpYWJsZVxyXG4gKiAoMykgaWYgc3VjaCBhbiBvYmplY3QgZXhpc3RzIGluIGEgY29va2llXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IGdldERlZmF1bHRzID0gKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gKGdldERlZmF1bHRzRnJvbUdsb2JhbCgpIHx8XHJcbiAgICAgICAgICAgIGdldERlZmF1bHRzRnJvbUVudlZhcmlhYmxlKCkgfHxcclxuICAgICAgICAgICAgZ2V0RGVmYXVsdHNGcm9tQ29va2llKCkpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYXRjaC1hbGwgZm9yIGJlaW5nIHVuYWJsZSB0byBnZXQgX19GSVJFQkFTRV9ERUZBVUxUU19fIGR1ZVxyXG4gICAgICAgICAqIHRvIGFueSBlbnZpcm9ubWVudCBjYXNlIHdlIGhhdmUgbm90IGFjY291bnRlZCBmb3IuIExvZyB0b1xyXG4gICAgICAgICAqIGluZm8gaW5zdGVhZCBvZiBzd2FsbG93aW5nIHNvIHdlIGNhbiBmaW5kIHRoZXNlIHVua25vd24gY2FzZXNcclxuICAgICAgICAgKiBhbmQgYWRkIHBhdGhzIGZvciB0aGVtIGlmIG5lZWRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb25zb2xlLmluZm8oYFVuYWJsZSB0byBnZXQgX19GSVJFQkFTRV9ERUZBVUxUU19fIGR1ZSB0bzogJHtlfWApO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFJldHVybnMgZW11bGF0b3IgaG9zdCBzdG9yZWQgaW4gdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3RcclxuICogZm9yIHRoZSBnaXZlbiBwcm9kdWN0LlxyXG4gKiBAcmV0dXJucyBhIFVSTCBob3N0IGZvcm1hdHRlZCBsaWtlIGAxMjcuMC4wLjE6OTk5OWAgb3IgYFs6OjFdOjQwMDBgIGlmIGF2YWlsYWJsZVxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBnZXREZWZhdWx0RW11bGF0b3JIb3N0ID0gKHByb2R1Y3ROYW1lKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSBnZXREZWZhdWx0cygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW11bGF0b3JIb3N0cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW3Byb2R1Y3ROYW1lXTsgfTtcclxuLyoqXHJcbiAqIFJldHVybnMgZW11bGF0b3IgaG9zdG5hbWUgYW5kIHBvcnQgc3RvcmVkIGluIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0XHJcbiAqIGZvciB0aGUgZ2l2ZW4gcHJvZHVjdC5cclxuICogQHJldHVybnMgYSBwYWlyIG9mIGhvc3RuYW1lIGFuZCBwb3J0IGxpa2UgYFtcIjo6MVwiLCA0MDAwXWAgaWYgYXZhaWxhYmxlXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCA9IChwcm9kdWN0TmFtZSkgPT4ge1xyXG4gICAgY29uc3QgaG9zdCA9IGdldERlZmF1bHRFbXVsYXRvckhvc3QocHJvZHVjdE5hbWUpO1xyXG4gICAgaWYgKCFob3N0KSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGNvbnN0IHNlcGFyYXRvckluZGV4ID0gaG9zdC5sYXN0SW5kZXhPZignOicpOyAvLyBGaW5kaW5nIHRoZSBsYXN0IHNpbmNlIElQdjYgYWRkciBhbHNvIGhhcyBjb2xvbnMuXHJcbiAgICBpZiAoc2VwYXJhdG9ySW5kZXggPD0gMCB8fCBzZXBhcmF0b3JJbmRleCArIDEgPT09IGhvc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGhvc3QgJHtob3N0fSB3aXRoIG5vIHNlcGFyYXRlIGhvc3RuYW1lIGFuZCBwb3J0IWApO1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xyXG4gICAgY29uc3QgcG9ydCA9IHBhcnNlSW50KGhvc3Quc3Vic3RyaW5nKHNlcGFyYXRvckluZGV4ICsgMSksIDEwKTtcclxuICAgIGlmIChob3N0WzBdID09PSAnWycpIHtcclxuICAgICAgICAvLyBCcmFja2V0LXF1b3RlZCBgW2lwdjZhZGRyXTpwb3J0YCA9PiByZXR1cm4gXCJpcHY2YWRkclwiICh3aXRob3V0IGJyYWNrZXRzKS5cclxuICAgICAgICByZXR1cm4gW2hvc3Quc3Vic3RyaW5nKDEsIHNlcGFyYXRvckluZGV4IC0gMSksIHBvcnRdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFtob3N0LnN1YnN0cmluZygwLCBzZXBhcmF0b3JJbmRleCksIHBvcnRdO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogUmV0dXJucyBGaXJlYmFzZSBhcHAgY29uZmlnIHN0b3JlZCBpbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdC5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgZ2V0RGVmYXVsdEFwcENvbmZpZyA9ICgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gZ2V0RGVmYXVsdHMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbmZpZzsgfTtcclxuLyoqXHJcbiAqIFJldHVybnMgYW4gZXhwZXJpbWVudGFsIHNldHRpbmcgb24gdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3QgKHByb3BlcnRpZXNcclxuICogcHJlZml4ZWQgYnkgXCJfXCIpXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IGdldEV4cGVyaW1lbnRhbFNldHRpbmcgPSAobmFtZSkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBnZXREZWZhdWx0cygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbYF8ke25hbWV9YF07IH07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIERlZmVycmVkIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucmVqZWN0ID0gKCkgPT4geyB9O1xyXG4gICAgICAgIHRoaXMucmVzb2x2ZSA9ICgpID0+IHsgfTtcclxuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdXIgQVBJIGludGVybmFscyBhcmUgbm90IHByb21pc2VpZmllZCBhbmQgY2Fubm90IGJlY2F1c2Ugb3VyIGNhbGxiYWNrIEFQSXMgaGF2ZSBzdWJ0bGUgZXhwZWN0YXRpb25zIGFyb3VuZFxyXG4gICAgICogaW52b2tpbmcgcHJvbWlzZXMgaW5saW5lLCB3aGljaCBQcm9taXNlcyBhcmUgZm9yYmlkZGVuIHRvIGRvLiBUaGlzIG1ldGhvZCBhY2NlcHRzIGFuIG9wdGlvbmFsIG5vZGUtc3R5bGUgY2FsbGJhY2tcclxuICAgICAqIGFuZCByZXR1cm5zIGEgbm9kZS1zdHlsZSBjYWxsYmFjayB3aGljaCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBEZWZlcnJlZCdzIHByb21pc2UuXHJcbiAgICAgKi9cclxuICAgIHdyYXBDYWxsYmFjayhjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiAoZXJyb3IsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBdHRhY2hpbmcgbm9vcCBoYW5kbGVyIGp1c3QgaW4gY2FzZSBkZXZlbG9wZXIgd2Fzbid0IGV4cGVjdGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gcHJvbWlzZXNcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvbWlzZS5jYXRjaCgoKSA9PiB7IH0pO1xyXG4gICAgICAgICAgICAgICAgLy8gU29tZSBvZiBvdXIgY2FsbGJhY2tzIGRvbid0IGV4cGVjdCBhIHZhbHVlIGFuZCBvdXIgb3duIHRlc3RzXHJcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQgdGhhdCB0aGUgcGFyYW1ldGVyIGxlbmd0aCBpcyAxXHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2subGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlTW9ja1VzZXJUb2tlbih0b2tlbiwgcHJvamVjdElkKSB7XHJcbiAgICBpZiAodG9rZW4udWlkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgXCJ1aWRcIiBmaWVsZCBpcyBubyBsb25nZXIgc3VwcG9ydGVkIGJ5IG1vY2tVc2VyVG9rZW4uIFBsZWFzZSB1c2UgXCJzdWJcIiBpbnN0ZWFkIGZvciBGaXJlYmFzZSBBdXRoIFVzZXIgSUQuJyk7XHJcbiAgICB9XHJcbiAgICAvLyBVbnNlY3VyZWQgSldUcyB1c2UgXCJub25lXCIgYXMgdGhlIGFsZ29yaXRobS5cclxuICAgIGNvbnN0IGhlYWRlciA9IHtcclxuICAgICAgICBhbGc6ICdub25lJyxcclxuICAgICAgICB0eXBlOiAnSldUJ1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHByb2plY3QgPSBwcm9qZWN0SWQgfHwgJ2RlbW8tcHJvamVjdCc7XHJcbiAgICBjb25zdCBpYXQgPSB0b2tlbi5pYXQgfHwgMDtcclxuICAgIGNvbnN0IHN1YiA9IHRva2VuLnN1YiB8fCB0b2tlbi51c2VyX2lkO1xyXG4gICAgaWYgKCFzdWIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb2NrVXNlclRva2VuIG11c3QgY29udGFpbiAnc3ViJyBvciAndXNlcl9pZCcgZmllbGQhXCIpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oeyBcclxuICAgICAgICAvLyBTZXQgYWxsIHJlcXVpcmVkIGZpZWxkcyB0byBkZWNlbnQgZGVmYXVsdHNcclxuICAgICAgICBpc3M6IGBodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vJHtwcm9qZWN0fWAsIGF1ZDogcHJvamVjdCwgaWF0LCBleHA6IGlhdCArIDM2MDAsIGF1dGhfdGltZTogaWF0LCBzdWIsIHVzZXJfaWQ6IHN1YiwgZmlyZWJhc2U6IHtcclxuICAgICAgICAgICAgc2lnbl9pbl9wcm92aWRlcjogJ2N1c3RvbScsXHJcbiAgICAgICAgICAgIGlkZW50aXRpZXM6IHt9XHJcbiAgICAgICAgfSB9LCB0b2tlbik7XHJcbiAgICAvLyBVbnNlY3VyZWQgSldUcyB1c2UgdGhlIGVtcHR5IHN0cmluZyBhcyBhIHNpZ25hdHVyZS5cclxuICAgIGNvbnN0IHNpZ25hdHVyZSA9ICcnO1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhKU09OLnN0cmluZ2lmeShoZWFkZXIpKSxcclxuICAgICAgICBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSksXHJcbiAgICAgICAgc2lnbmF0dXJlXHJcbiAgICBdLmpvaW4oJy4nKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmV0dXJucyBuYXZpZ2F0b3IudXNlckFnZW50IHN0cmluZyBvciAnJyBpZiBpdCdzIG5vdCBkZWZpbmVkLlxyXG4gKiBAcmV0dXJuIHVzZXIgYWdlbnQgc3RyaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRVQSgpIHtcclxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgIHR5cGVvZiBuYXZpZ2F0b3JbJ3VzZXJBZ2VudCddID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3JbJ3VzZXJBZ2VudCddO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBEZXRlY3QgQ29yZG92YSAvIFBob25lR2FwIC8gSW9uaWMgZnJhbWV3b3JrcyBvbiBhIG1vYmlsZSBkZXZpY2UuXHJcbiAqXHJcbiAqIERlbGliZXJhdGVseSBkb2VzIG5vdCByZWx5IG9uIGNoZWNraW5nIGBmaWxlOi8vYCBVUkxzIChhcyB0aGlzIGZhaWxzIFBob25lR2FwXHJcbiAqIGluIHRoZSBSaXBwbGUgZW11bGF0b3IpIG5vciBDb3Jkb3ZhIGBvbkRldmljZVJlYWR5YCwgd2hpY2ggd291bGQgbm9ybWFsbHlcclxuICogd2FpdCBmb3IgYSBjYWxsYmFjay5cclxuICovXHJcbmZ1bmN0aW9uIGlzTW9iaWxlQ29yZG92YSgpIHtcclxuICAgIHJldHVybiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAvLyBAdHMtaWdub3JlIFNldHRpbmcgdXAgYW4gYnJvYWRseSBhcHBsaWNhYmxlIGluZGV4IHNpZ25hdHVyZSBmb3IgV2luZG93XHJcbiAgICAgICAgLy8ganVzdCB0byBkZWFsIHdpdGggdGhpcyBjYXNlIHdvdWxkIHByb2JhYmx5IGJlIGEgYmFkIGlkZWEuXHJcbiAgICAgICAgISEod2luZG93Wydjb3Jkb3ZhJ10gfHwgd2luZG93WydwaG9uZWdhcCddIHx8IHdpbmRvd1snUGhvbmVHYXAnXSkgJiZcclxuICAgICAgICAvaW9zfGlwaG9uZXxpcG9kfGlwYWR8YW5kcm9pZHxibGFja2JlcnJ5fGllbW9iaWxlL2kudGVzdChnZXRVQSgpKSk7XHJcbn1cclxuLyoqXHJcbiAqIERldGVjdCBOb2RlLmpzLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHRydWUgaWYgTm9kZS5qcyBlbnZpcm9ubWVudCBpcyBkZXRlY3RlZCBvciBzcGVjaWZpZWQuXHJcbiAqL1xyXG4vLyBOb2RlIGRldGVjdGlvbiBsb2dpYyBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vaWxpYWthbi9kZXRlY3Qtbm9kZS9cclxuZnVuY3Rpb24gaXNOb2RlKCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgZm9yY2VFbnZpcm9ubWVudCA9IChfYSA9IGdldERlZmF1bHRzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JjZUVudmlyb25tZW50O1xyXG4gICAgaWYgKGZvcmNlRW52aXJvbm1lbnQgPT09ICdub2RlJykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZm9yY2VFbnZpcm9ubWVudCA9PT0gJ2Jyb3dzZXInKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJyk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRGV0ZWN0IEJyb3dzZXIgRW52aXJvbm1lbnRcclxuICovXHJcbmZ1bmN0aW9uIGlzQnJvd3NlcigpIHtcclxuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyB8fCBpc1dlYldvcmtlcigpO1xyXG59XHJcbi8qKlxyXG4gKiBEZXRlY3QgV2ViIFdvcmtlciBjb250ZXh0XHJcbiAqL1xyXG5mdW5jdGlvbiBpc1dlYldvcmtlcigpIHtcclxuICAgIHJldHVybiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSk7XHJcbn1cclxuZnVuY3Rpb24gaXNCcm93c2VyRXh0ZW5zaW9uKCkge1xyXG4gICAgY29uc3QgcnVudGltZSA9IHR5cGVvZiBjaHJvbWUgPT09ICdvYmplY3QnXHJcbiAgICAgICAgPyBjaHJvbWUucnVudGltZVxyXG4gICAgICAgIDogdHlwZW9mIGJyb3dzZXIgPT09ICdvYmplY3QnXHJcbiAgICAgICAgICAgID8gYnJvd3Nlci5ydW50aW1lXHJcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgcmV0dXJuIHR5cGVvZiBydW50aW1lID09PSAnb2JqZWN0JyAmJiBydW50aW1lLmlkICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuLyoqXHJcbiAqIERldGVjdCBSZWFjdCBOYXRpdmUuXHJcbiAqXHJcbiAqIEByZXR1cm4gdHJ1ZSBpZiBSZWFjdE5hdGl2ZSBlbnZpcm9ubWVudCBpcyBkZXRlY3RlZC5cclxuICovXHJcbmZ1bmN0aW9uIGlzUmVhY3ROYXRpdmUoKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmIG5hdmlnYXRvclsncHJvZHVjdCddID09PSAnUmVhY3ROYXRpdmUnKTtcclxufVxyXG4vKiogRGV0ZWN0cyBFbGVjdHJvbiBhcHBzLiAqL1xyXG5mdW5jdGlvbiBpc0VsZWN0cm9uKCkge1xyXG4gICAgcmV0dXJuIGdldFVBKCkuaW5kZXhPZignRWxlY3Ryb24vJykgPj0gMDtcclxufVxyXG4vKiogRGV0ZWN0cyBJbnRlcm5ldCBFeHBsb3Jlci4gKi9cclxuZnVuY3Rpb24gaXNJRSgpIHtcclxuICAgIGNvbnN0IHVhID0gZ2V0VUEoKTtcclxuICAgIHJldHVybiB1YS5pbmRleE9mKCdNU0lFICcpID49IDAgfHwgdWEuaW5kZXhPZignVHJpZGVudC8nKSA+PSAwO1xyXG59XHJcbi8qKiBEZXRlY3RzIFVuaXZlcnNhbCBXaW5kb3dzIFBsYXRmb3JtIGFwcHMuICovXHJcbmZ1bmN0aW9uIGlzVVdQKCkge1xyXG4gICAgcmV0dXJuIGdldFVBKCkuaW5kZXhPZignTVNBcHBIb3N0LycpID49IDA7XHJcbn1cclxuLyoqXHJcbiAqIERldGVjdCB3aGV0aGVyIHRoZSBjdXJyZW50IFNESyBidWlsZCBpcyB0aGUgTm9kZSB2ZXJzaW9uLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHRydWUgaWYgaXQncyB0aGUgTm9kZSBTREsgYnVpbGQuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc05vZGVTZGsoKSB7XHJcbiAgICByZXR1cm4gQ09OU1RBTlRTLk5PREVfQ0xJRU5UID09PSB0cnVlIHx8IENPTlNUQU5UUy5OT0RFX0FETUlOID09PSB0cnVlO1xyXG59XHJcbi8qKiBSZXR1cm5zIHRydWUgaWYgd2UgYXJlIHJ1bm5pbmcgaW4gU2FmYXJpLiAqL1xyXG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcclxuICAgIHJldHVybiAoIWlzTm9kZSgpICYmXHJcbiAgICAgICAgISFuYXZpZ2F0b3IudXNlckFnZW50ICYmXHJcbiAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcygnU2FmYXJpJykgJiZcclxuICAgICAgICAhbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcygnQ2hyb21lJykpO1xyXG59XHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBjaGVja3MgaWYgaW5kZXhlZERCIGlzIHN1cHBvcnRlZCBieSBjdXJyZW50IGJyb3dzZXIvc2VydmljZSB3b3JrZXIgY29udGV4dFxyXG4gKiBAcmV0dXJuIHRydWUgaWYgaW5kZXhlZERCIGlzIHN1cHBvcnRlZCBieSBjdXJyZW50IGJyb3dzZXIvc2VydmljZSB3b3JrZXIgY29udGV4dFxyXG4gKi9cclxuZnVuY3Rpb24gaXNJbmRleGVkREJBdmFpbGFibGUoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgaW5kZXhlZERCID09PSAnb2JqZWN0JztcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCB2YWxpZGF0ZXMgYnJvd3Nlci9zdyBjb250ZXh0IGZvciBpbmRleGVkREIgYnkgb3BlbmluZyBhIGR1bW15IGluZGV4ZWREQiBkYXRhYmFzZSBhbmQgcmVqZWN0XHJcbiAqIGlmIGVycm9ycyBvY2N1ciBkdXJpbmcgdGhlIGRhdGFiYXNlIG9wZW4gb3BlcmF0aW9uLlxyXG4gKlxyXG4gKiBAdGhyb3dzIGV4Y2VwdGlvbiBpZiBjdXJyZW50IGJyb3dzZXIvc3cgY29udGV4dCBjYW4ndCBydW4gaWRiLm9wZW4gKGV4OiBTYWZhcmkgaWZyYW1lLCBGaXJlZm94XHJcbiAqIHByaXZhdGUgYnJvd3NpbmcpXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBsZXQgcHJlRXhpc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCBEQl9DSEVDS19OQU1FID0gJ3ZhbGlkYXRlLWJyb3dzZXItY29udGV4dC1mb3ItaW5kZXhlZGRiLWFuYWx5dGljcy1tb2R1bGUnO1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gc2VsZi5pbmRleGVkREIub3BlbihEQl9DSEVDS19OQU1FKTtcclxuICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc3VsdC5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIGRhdGFiYXNlIG9ubHkgd2hlbiBpdCBkb2Vzbid0IHByZS1leGlzdFxyXG4gICAgICAgICAgICAgICAgaWYgKCFwcmVFeGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKERCX0NIRUNLX05BTUUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwcmVFeGlzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoKChfYSA9IHJlcXVlc3QuZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlKSB8fCAnJyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBUaGlzIG1ldGhvZCBjaGVja3Mgd2hldGhlciBjb29raWUgaXMgZW5hYmxlZCB3aXRoaW4gY3VycmVudCBicm93c2VyXHJcbiAqIEByZXR1cm4gdHJ1ZSBpZiBjb29raWUgaXMgZW5hYmxlZCB3aXRoaW4gY3VycmVudCBicm93c2VyXHJcbiAqL1xyXG5mdW5jdGlvbiBhcmVDb29raWVzRW5hYmxlZCgpIHtcclxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhbmF2aWdhdG9yLmNvb2tpZUVuYWJsZWQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBTdGFuZGFyZGl6ZWQgRmlyZWJhc2UgRXJyb3IuXHJcbiAqXHJcbiAqIFVzYWdlOlxyXG4gKlxyXG4gKiAgIC8vIFR5cGVzY3JpcHQgc3RyaW5nIGxpdGVyYWxzIGZvciB0eXBlLXNhZmUgY29kZXNcclxuICogICB0eXBlIEVyciA9XHJcbiAqICAgICAndW5rbm93bicgfFxyXG4gKiAgICAgJ29iamVjdC1ub3QtZm91bmQnXHJcbiAqICAgICA7XHJcbiAqXHJcbiAqICAgLy8gQ2xvc3VyZSBlbnVtIGZvciB0eXBlLXNhZmUgZXJyb3IgY29kZXNcclxuICogICAvLyBhdC1lbnVtIHtzdHJpbmd9XHJcbiAqICAgdmFyIEVyciA9IHtcclxuICogICAgIFVOS05PV046ICd1bmtub3duJyxcclxuICogICAgIE9CSkVDVF9OT1RfRk9VTkQ6ICdvYmplY3Qtbm90LWZvdW5kJyxcclxuICogICB9XHJcbiAqXHJcbiAqICAgbGV0IGVycm9yczogTWFwPEVyciwgc3RyaW5nPiA9IHtcclxuICogICAgICdnZW5lcmljLWVycm9yJzogXCJVbmtub3duIGVycm9yXCIsXHJcbiAqICAgICAnZmlsZS1ub3QtZm91bmQnOiBcIkNvdWxkIG5vdCBmaW5kIGZpbGU6IHskZmlsZX1cIixcclxuICogICB9O1xyXG4gKlxyXG4gKiAgIC8vIFR5cGUtc2FmZSBmdW5jdGlvbiAtIG11c3QgcGFzcyBhIHZhbGlkIGVycm9yIGNvZGUgYXMgcGFyYW0uXHJcbiAqICAgbGV0IGVycm9yID0gbmV3IEVycm9yRmFjdG9yeTxFcnI+KCdzZXJ2aWNlJywgJ1NlcnZpY2UnLCBlcnJvcnMpO1xyXG4gKlxyXG4gKiAgIC4uLlxyXG4gKiAgIHRocm93IGVycm9yLmNyZWF0ZShFcnIuR0VORVJJQyk7XHJcbiAqICAgLi4uXHJcbiAqICAgdGhyb3cgZXJyb3IuY3JlYXRlKEVyci5GSUxFX05PVF9GT1VORCwgeydmaWxlJzogZmlsZU5hbWV9KTtcclxuICogICAuLi5cclxuICogICAvLyBTZXJ2aWNlOiBDb3VsZCBub3QgZmlsZSBmaWxlOiBmb28udHh0IChzZXJ2aWNlL2ZpbGUtbm90LWZvdW5kKS5cclxuICpcclxuICogICBjYXRjaCAoZSkge1xyXG4gKiAgICAgYXNzZXJ0KGUubWVzc2FnZSA9PT0gXCJDb3VsZCBub3QgZmluZCBmaWxlOiBmb28udHh0LlwiKTtcclxuICogICAgIGlmICgoZSBhcyBGaXJlYmFzZUVycm9yKT8uY29kZSA9PT0gJ3NlcnZpY2UvZmlsZS1ub3QtZm91bmQnKSB7XHJcbiAqICAgICAgIGNvbnNvbGUubG9nKFwiQ291bGQgbm90IHJlYWQgZmlsZTogXCIgKyBlWydmaWxlJ10pO1xyXG4gKiAgICAgfVxyXG4gKiAgIH1cclxuICovXHJcbmNvbnN0IEVSUk9SX05BTUUgPSAnRmlyZWJhc2VFcnJvcic7XHJcbi8vIEJhc2VkIG9uIGNvZGUgZnJvbTpcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjQ3VzdG9tX0Vycm9yX1R5cGVzXHJcbmNsYXNzIEZpcmViYXNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKiBUaGUgZXJyb3IgY29kZSBmb3IgdGhpcyBlcnJvci4gKi9cclxuICAgIGNvZGUsIG1lc3NhZ2UsIFxyXG4gICAgLyoqIEN1c3RvbSBkYXRhIGZvciB0aGlzIGVycm9yLiAqL1xyXG4gICAgY3VzdG9tRGF0YSkge1xyXG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XHJcbiAgICAgICAgdGhpcy5jdXN0b21EYXRhID0gY3VzdG9tRGF0YTtcclxuICAgICAgICAvKiogVGhlIGN1c3RvbSBuYW1lIGZvciBhbGwgRmlyZWJhc2VFcnJvcnMuICovXHJcbiAgICAgICAgdGhpcy5uYW1lID0gRVJST1JfTkFNRTtcclxuICAgICAgICAvLyBGaXggRm9yIEVTNVxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC13aWtpL2Jsb2IvbWFzdGVyL0JyZWFraW5nLUNoYW5nZXMubWQjZXh0ZW5kaW5nLWJ1aWx0LWlucy1saWtlLWVycm9yLWFycmF5LWFuZC1tYXAtbWF5LW5vLWxvbmdlci13b3JrXHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEZpcmViYXNlRXJyb3IucHJvdG90eXBlKTtcclxuICAgICAgICAvLyBNYWludGFpbnMgcHJvcGVyIHN0YWNrIHRyYWNlIGZvciB3aGVyZSBvdXIgZXJyb3Igd2FzIHRocm93bi5cclxuICAgICAgICAvLyBPbmx5IGF2YWlsYWJsZSBvbiBWOC5cclxuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcclxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgRXJyb3JGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jbGFzcyBFcnJvckZhY3Rvcnkge1xyXG4gICAgY29uc3RydWN0b3Ioc2VydmljZSwgc2VydmljZU5hbWUsIGVycm9ycykge1xyXG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XHJcbiAgICAgICAgdGhpcy5zZXJ2aWNlTmFtZSA9IHNlcnZpY2VOYW1lO1xyXG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlKGNvZGUsIC4uLmRhdGEpIHtcclxuICAgICAgICBjb25zdCBjdXN0b21EYXRhID0gZGF0YVswXSB8fCB7fTtcclxuICAgICAgICBjb25zdCBmdWxsQ29kZSA9IGAke3RoaXMuc2VydmljZX0vJHtjb2RlfWA7XHJcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSB0aGlzLmVycm9yc1tjb2RlXTtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gdGVtcGxhdGUgPyByZXBsYWNlVGVtcGxhdGUodGVtcGxhdGUsIGN1c3RvbURhdGEpIDogJ0Vycm9yJztcclxuICAgICAgICAvLyBTZXJ2aWNlIE5hbWU6IEVycm9yIG1lc3NhZ2UgKHNlcnZpY2UvY29kZSkuXHJcbiAgICAgICAgY29uc3QgZnVsbE1lc3NhZ2UgPSBgJHt0aGlzLnNlcnZpY2VOYW1lfTogJHttZXNzYWdlfSAoJHtmdWxsQ29kZX0pLmA7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRmlyZWJhc2VFcnJvcihmdWxsQ29kZSwgZnVsbE1lc3NhZ2UsIGN1c3RvbURhdGEpO1xyXG4gICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXBsYWNlVGVtcGxhdGUodGVtcGxhdGUsIGRhdGEpIHtcclxuICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKFBBVFRFUk4sIChfLCBrZXkpID0+IHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGFba2V5XTtcclxuICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IFN0cmluZyh2YWx1ZSkgOiBgPCR7a2V5fT8+YDtcclxuICAgIH0pO1xyXG59XHJcbmNvbnN0IFBBVFRFUk4gPSAvXFx7XFwkKFtefV0rKX0vZztcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEV2YWx1YXRlcyBhIEpTT04gc3RyaW5nIGludG8gYSBqYXZhc2NyaXB0IG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBBIHN0cmluZyBjb250YWluaW5nIEpTT04uXHJcbiAqIEByZXR1cm4geyp9IFRoZSBqYXZhc2NyaXB0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBKU09OLlxyXG4gKi9cclxuZnVuY3Rpb24ganNvbkV2YWwoc3RyKSB7XHJcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIEpTT04gcmVwcmVzZW50aW5nIGEgamF2YXNjcmlwdCBvYmplY3QuXHJcbiAqIEBwYXJhbSB7Kn0gZGF0YSBKYXZhc2NyaXB0IG9iamVjdCB0byBiZSBzdHJpbmdpZmllZC5cclxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgSlNPTiBjb250ZW50cyBvZiB0aGUgb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gc3RyaW5naWZ5KGRhdGEpIHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGludG8gY29uc3RpdHVlbnQgcGFydHMuXHJcbiAqXHJcbiAqIE5vdGVzOlxyXG4gKiAtIE1heSByZXR1cm4gd2l0aCBpbnZhbGlkIC8gaW5jb21wbGV0ZSBjbGFpbXMgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXHJcbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXHJcbiAqL1xyXG5jb25zdCBkZWNvZGUgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgIGxldCBoZWFkZXIgPSB7fSwgY2xhaW1zID0ge30sIGRhdGEgPSB7fSwgc2lnbmF0dXJlID0gJyc7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHBhcnRzID0gdG9rZW4uc3BsaXQoJy4nKTtcclxuICAgICAgICBoZWFkZXIgPSBqc29uRXZhbChiYXNlNjREZWNvZGUocGFydHNbMF0pIHx8ICcnKTtcclxuICAgICAgICBjbGFpbXMgPSBqc29uRXZhbChiYXNlNjREZWNvZGUocGFydHNbMV0pIHx8ICcnKTtcclxuICAgICAgICBzaWduYXR1cmUgPSBwYXJ0c1syXTtcclxuICAgICAgICBkYXRhID0gY2xhaW1zWydkJ10gfHwge307XHJcbiAgICAgICAgZGVsZXRlIGNsYWltc1snZCddO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBoZWFkZXIsXHJcbiAgICAgICAgY2xhaW1zLFxyXG4gICAgICAgIGRhdGEsXHJcbiAgICAgICAgc2lnbmF0dXJlXHJcbiAgICB9O1xyXG59O1xyXG4vKipcclxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCBjaGVja3MgdGhlIHZhbGlkaXR5IG9mIGl0cyB0aW1lLWJhc2VkIGNsYWltcy4gV2lsbCByZXR1cm4gdHJ1ZSBpZiB0aGVcclxuICogdG9rZW4gaXMgd2l0aGluIHRoZSB0aW1lIHdpbmRvdyBhdXRob3JpemVkIGJ5IHRoZSAnbmJmJyAobm90LWJlZm9yZSkgYW5kICdpYXQnIChpc3N1ZWQtYXQpIGNsYWltcy5cclxuICpcclxuICogTm90ZXM6XHJcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxyXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxyXG4gKi9cclxuY29uc3QgaXNWYWxpZFRpbWVzdGFtcCA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgY29uc3QgY2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XHJcbiAgICBjb25zdCBub3cgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XHJcbiAgICBsZXQgdmFsaWRTaW5jZSA9IDAsIHZhbGlkVW50aWwgPSAwO1xyXG4gICAgaWYgKHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnbmJmJykpIHtcclxuICAgICAgICAgICAgdmFsaWRTaW5jZSA9IGNsYWltc1snbmJmJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0JykpIHtcclxuICAgICAgICAgICAgdmFsaWRTaW5jZSA9IGNsYWltc1snaWF0J107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2V4cCcpKSB7XHJcbiAgICAgICAgICAgIHZhbGlkVW50aWwgPSBjbGFpbXNbJ2V4cCddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdG9rZW4gd2lsbCBleHBpcmUgYWZ0ZXIgMjRoIGJ5IGRlZmF1bHRcclxuICAgICAgICAgICAgdmFsaWRVbnRpbCA9IHZhbGlkU2luY2UgKyA4NjQwMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKCEhbm93ICYmXHJcbiAgICAgICAgISF2YWxpZFNpbmNlICYmXHJcbiAgICAgICAgISF2YWxpZFVudGlsICYmXHJcbiAgICAgICAgbm93ID49IHZhbGlkU2luY2UgJiZcclxuICAgICAgICBub3cgPD0gdmFsaWRVbnRpbCk7XHJcbn07XHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIHJldHVybnMgaXRzIGlzc3VlZCBhdCB0aW1lIGlmIHZhbGlkLCBudWxsIG90aGVyd2lzZS5cclxuICpcclxuICogTm90ZXM6XHJcbiAqIC0gTWF5IHJldHVybiBudWxsIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxyXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxyXG4gKi9cclxuY29uc3QgaXNzdWVkQXRUaW1lID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICBjb25zdCBjbGFpbXMgPSBkZWNvZGUodG9rZW4pLmNsYWltcztcclxuICAgIGlmICh0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0JyAmJiBjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2lhdCcpKSB7XHJcbiAgICAgICAgcmV0dXJuIGNsYWltc1snaWF0J107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuLyoqXHJcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBhbmQgY2hlY2tzIHRoZSB2YWxpZGl0eSBvZiBpdHMgZm9ybWF0LiBFeHBlY3RzIGEgdmFsaWQgaXNzdWVkLWF0IHRpbWUuXHJcbiAqXHJcbiAqIE5vdGVzOlxyXG4gKiAtIE1heSByZXR1cm4gYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cclxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cclxuICovXHJcbmNvbnN0IGlzVmFsaWRGb3JtYXQgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGUodG9rZW4pLCBjbGFpbXMgPSBkZWNvZGVkLmNsYWltcztcclxuICAgIHJldHVybiAhIWNsYWltcyAmJiB0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0JyAmJiBjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2lhdCcpO1xyXG59O1xyXG4vKipcclxuICogQXR0ZW1wdHMgdG8gcGVlciBpbnRvIGFuIGF1dGggdG9rZW4gYW5kIGRldGVybWluZSBpZiBpdCdzIGFuIGFkbWluIGF1dGggdG9rZW4gYnkgbG9va2luZyBhdCB0aGUgY2xhaW1zIHBvcnRpb24uXHJcbiAqXHJcbiAqIE5vdGVzOlxyXG4gKiAtIE1heSByZXR1cm4gYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cclxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cclxuICovXHJcbmNvbnN0IGlzQWRtaW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgIGNvbnN0IGNsYWltcyA9IGRlY29kZSh0b2tlbikuY2xhaW1zO1xyXG4gICAgcmV0dXJuIHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltc1snYWRtaW4nXSA9PT0gdHJ1ZTtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gY29udGFpbnMob2JqLCBrZXkpIHtcclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xyXG59XHJcbmZ1bmN0aW9uIHNhZmVHZXQob2JqLCBrZXkpIHtcclxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIG9ialtrZXldO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc0VtcHR5KG9iaikge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIG1hcChvYmosIGZuLCBjb250ZXh0T2JqKSB7XHJcbiAgICBjb25zdCByZXMgPSB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJlc1trZXldID0gZm4uY2FsbChjb250ZXh0T2JqLCBvYmpba2V5XSwga2V5LCBvYmopO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuLyoqXHJcbiAqIERlZXAgZXF1YWwgdHdvIG9iamVjdHMuIFN1cHBvcnQgQXJyYXlzIGFuZCBPYmplY3RzLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcclxuICAgIGlmIChhID09PSBiKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhS2V5cyA9IE9iamVjdC5rZXlzKGEpO1xyXG4gICAgY29uc3QgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcclxuICAgIGZvciAoY29uc3QgayBvZiBhS2V5cykge1xyXG4gICAgICAgIGlmICghYktleXMuaW5jbHVkZXMoaykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhUHJvcCA9IGFba107XHJcbiAgICAgICAgY29uc3QgYlByb3AgPSBiW2tdO1xyXG4gICAgICAgIGlmIChpc09iamVjdChhUHJvcCkgJiYgaXNPYmplY3QoYlByb3ApKSB7XHJcbiAgICAgICAgICAgIGlmICghZGVlcEVxdWFsKGFQcm9wLCBiUHJvcCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhUHJvcCAhPT0gYlByb3ApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgayBvZiBiS2V5cykge1xyXG4gICAgICAgIGlmICghYUtleXMuaW5jbHVkZXMoaykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGlzT2JqZWN0KHRoaW5nKSB7XHJcbiAgICByZXR1cm4gdGhpbmcgIT09IG51bGwgJiYgdHlwZW9mIHRoaW5nID09PSAnb2JqZWN0JztcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmVqZWN0cyBpZiB0aGUgZ2l2ZW4gcHJvbWlzZSBkb2Vzbid0IHJlc29sdmUgaW4gdGltZUluTVMgbWlsbGlzZWNvbmRzLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIHByb21pc2VXaXRoVGltZW91dChwcm9taXNlLCB0aW1lSW5NUyA9IDIwMDApIHtcclxuICAgIGNvbnN0IGRlZmVycmVkUHJvbWlzZSA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiBkZWZlcnJlZFByb21pc2UucmVqZWN0KCd0aW1lb3V0IScpLCB0aW1lSW5NUyk7XHJcbiAgICBwcm9taXNlLnRoZW4oZGVmZXJyZWRQcm9taXNlLnJlc29sdmUsIGRlZmVycmVkUHJvbWlzZS5yZWplY3QpO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkUHJvbWlzZS5wcm9taXNlO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcXVlcnlzdHJpbmctZm9ybWF0dGVkIHN0cmluZyAoZS5nLiAmYXJnPXZhbCZhcmcyPXZhbDIpIGZyb20gYVxyXG4gKiBwYXJhbXMgb2JqZWN0IChlLmcuIHthcmc6ICd2YWwnLCBhcmcyOiAndmFsMid9KVxyXG4gKiBOb3RlOiBZb3UgbXVzdCBwcmVwZW5kIGl0IHdpdGggPyB3aGVuIGFkZGluZyBpdCB0byBhIFVSTC5cclxuICovXHJcbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHF1ZXJ5c3RyaW5nUGFyYW1zKSB7XHJcbiAgICBjb25zdCBwYXJhbXMgPSBbXTtcclxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHF1ZXJ5c3RyaW5nUGFyYW1zKSkge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGFycmF5VmFsID0+IHtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFycmF5VmFsKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFyYW1zLmxlbmd0aCA/ICcmJyArIHBhcmFtcy5qb2luKCcmJykgOiAnJztcclxufVxyXG4vKipcclxuICogRGVjb2RlcyBhIHF1ZXJ5c3RyaW5nIChlLmcuID9hcmc9dmFsJmFyZzI9dmFsMikgaW50byBhIHBhcmFtcyBvYmplY3RcclxuICogKGUuZy4ge2FyZzogJ3ZhbCcsIGFyZzI6ICd2YWwyJ30pXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeXN0cmluZ0RlY29kZShxdWVyeXN0cmluZykge1xyXG4gICAgY29uc3Qgb2JqID0ge307XHJcbiAgICBjb25zdCB0b2tlbnMgPSBxdWVyeXN0cmluZy5yZXBsYWNlKC9eXFw/LywgJycpLnNwbGl0KCcmJyk7XHJcbiAgICB0b2tlbnMuZm9yRWFjaCh0b2tlbiA9PiB7XHJcbiAgICAgICAgaWYgKHRva2VuKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHRva2VuLnNwbGl0KCc9Jyk7XHJcbiAgICAgICAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQoa2V5KV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG9iajtcclxufVxyXG4vKipcclxuICogRXh0cmFjdCB0aGUgcXVlcnkgc3RyaW5nIHBhcnQgb2YgYSBVUkwsIGluY2x1ZGluZyB0aGUgbGVhZGluZyBxdWVzdGlvbiBtYXJrIChpZiBwcmVzZW50KS5cclxuICovXHJcbmZ1bmN0aW9uIGV4dHJhY3RRdWVyeXN0cmluZyh1cmwpIHtcclxuICAgIGNvbnN0IHF1ZXJ5U3RhcnQgPSB1cmwuaW5kZXhPZignPycpO1xyXG4gICAgaWYgKCFxdWVyeVN0YXJ0KSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZnJhZ21lbnRTdGFydCA9IHVybC5pbmRleE9mKCcjJywgcXVlcnlTdGFydCk7XHJcbiAgICByZXR1cm4gdXJsLnN1YnN0cmluZyhxdWVyeVN0YXJ0LCBmcmFnbWVudFN0YXJ0ID4gMCA/IGZyYWdtZW50U3RhcnQgOiB1bmRlZmluZWQpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IFNIQS0xIGNyeXB0b2dyYXBoaWMgaGFzaC5cclxuICogVmFyaWFibGUgbmFtZXMgZm9sbG93IHRoZSBub3RhdGlvbiBpbiBGSVBTIFBVQiAxODAtMzpcclxuICogaHR0cDovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2ZpcHMvZmlwczE4MC0zL2ZpcHMxODAtM19maW5hbC5wZGYuXHJcbiAqXHJcbiAqIFVzYWdlOlxyXG4gKiAgIHZhciBzaGExID0gbmV3IHNoYTEoKTtcclxuICogICBzaGExLnVwZGF0ZShieXRlcyk7XHJcbiAqICAgdmFyIGhhc2ggPSBzaGExLmRpZ2VzdCgpO1xyXG4gKlxyXG4gKiBQZXJmb3JtYW5jZTpcclxuICogICBDaHJvbWUgMjM6ICAgfjQwMCBNYml0L3NcclxuICogICBGaXJlZm94IDE2OiAgfjI1MCBNYml0L3NcclxuICpcclxuICovXHJcbi8qKlxyXG4gKiBTSEEtMSBjcnlwdG9ncmFwaGljIGhhc2ggY29uc3RydWN0b3IuXHJcbiAqXHJcbiAqIFRoZSBwcm9wZXJ0aWVzIGRlY2xhcmVkIGhlcmUgYXJlIGRpc2N1c3NlZCBpbiB0aGUgYWJvdmUgYWxnb3JpdGhtIGRvY3VtZW50LlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGZpbmFsXHJcbiAqIEBzdHJ1Y3RcclxuICovXHJcbmNsYXNzIFNoYTEge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSG9sZHMgdGhlIHByZXZpb3VzIHZhbHVlcyBvZiBhY2N1bXVsYXRlZCB2YXJpYWJsZXMgYS1lIGluIHRoZSBjb21wcmVzc19cclxuICAgICAgICAgKiBmdW5jdGlvbi5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2hhaW5fID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBidWZmZXIgaG9sZGluZyB0aGUgcGFydGlhbGx5IGNvbXB1dGVkIGhhc2ggcmVzdWx0LlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5idWZfID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gYXJyYXkgb2YgODAgYnl0ZXMsIGVhY2ggYSBwYXJ0IG9mIHRoZSBtZXNzYWdlIHRvIGJlIGhhc2hlZC4gIFJlZmVycmVkIHRvXHJcbiAgICAgICAgICogYXMgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgaW4gdGhlIGRvY3MuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLldfID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udGFpbnMgZGF0YSBuZWVkZWQgdG8gcGFkIG1lc3NhZ2VzIGxlc3MgdGhhbiA2NCBieXRlcy5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGFkXyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pbmJ1Zl8gPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50b3RhbF8gPSAwO1xyXG4gICAgICAgIHRoaXMuYmxvY2tTaXplID0gNTEyIC8gODtcclxuICAgICAgICB0aGlzLnBhZF9bMF0gPSAxMjg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFkX1tpXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzBdID0gMHg2NzQ1MjMwMTtcclxuICAgICAgICB0aGlzLmNoYWluX1sxXSA9IDB4ZWZjZGFiODk7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bMl0gPSAweDk4YmFkY2ZlO1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzNdID0gMHgxMDMyNTQ3NjtcclxuICAgICAgICB0aGlzLmNoYWluX1s0XSA9IDB4YzNkMmUxZjA7XHJcbiAgICAgICAgdGhpcy5pbmJ1Zl8gPSAwO1xyXG4gICAgICAgIHRoaXMudG90YWxfID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgY29tcHJlc3MgaGVscGVyIGZ1bmN0aW9uLlxyXG4gICAgICogQHBhcmFtIGJ1ZiBCbG9jayB0byBjb21wcmVzcy5cclxuICAgICAqIEBwYXJhbSBvZmZzZXQgT2Zmc2V0IG9mIHRoZSBibG9jayBpbiB0aGUgYnVmZmVyLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY29tcHJlc3NfKGJ1Ziwgb2Zmc2V0KSB7XHJcbiAgICAgICAgaWYgKCFvZmZzZXQpIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgVyA9IHRoaXMuV187XHJcbiAgICAgICAgLy8gZ2V0IDE2IGJpZyBlbmRpYW4gd29yZHNcclxuICAgICAgICBpZiAodHlwZW9mIGJ1ZiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPKHVzZXIpOiBbYnVnIDgxNDAxMjJdIFJlY2VudCB2ZXJzaW9ucyBvZiBTYWZhcmkgZm9yIE1hYyBPUyBhbmQgaU9TXHJcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgYnVnIHRoYXQgdHVybnMgdGhlIHBvc3QtaW5jcmVtZW50ICsrIG9wZXJhdG9yIGludG8gcHJlLWluY3JlbWVudFxyXG4gICAgICAgICAgICAgICAgLy8gZHVyaW5nIEpJVCBjb21waWxhdGlvbi4gIFdlIGhhdmUgY29kZSB0aGF0IGRlcGVuZHMgaGVhdmlseSBvbiBTSEEtMSBmb3JcclxuICAgICAgICAgICAgICAgIC8vIGNvcnJlY3RuZXNzIGFuZCB3aGljaCBpcyBhZmZlY3RlZCBieSB0aGlzIGJ1Zywgc28gSSd2ZSByZW1vdmVkIGFsbCB1c2VzXHJcbiAgICAgICAgICAgICAgICAvLyBvZiBwb3N0LWluY3JlbWVudCArKyBpbiB3aGljaCB0aGUgcmVzdWx0IHZhbHVlIGlzIHVzZWQuICBXZSBjYW4gcmV2ZXJ0XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNoYW5nZSBvbmNlIHRoZSBTYWZhcmkgYnVnXHJcbiAgICAgICAgICAgICAgICAvLyAoaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEwOTAzNikgaGFzIGJlZW4gZml4ZWQgYW5kXHJcbiAgICAgICAgICAgICAgICAvLyBtb3N0IGNsaWVudHMgaGF2ZSBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgICAgICAgICAgICBXW2ldID1cclxuICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0KSA8PCAyNCkgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMSkgPDwgMTYpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1Zi5jaGFyQ29kZUF0KG9mZnNldCArIDIpIDw8IDgpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMyk7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBXW2ldID1cclxuICAgICAgICAgICAgICAgICAgICAoYnVmW29mZnNldF0gPDwgMjQpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1ZltvZmZzZXQgKyAxXSA8PCAxNikgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmW29mZnNldCArIDJdIDw8IDgpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmW29mZnNldCArIDNdO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZXhwYW5kIHRvIDgwIHdvcmRzXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XTtcclxuICAgICAgICAgICAgV1tpXSA9ICgodCA8PCAxKSB8ICh0ID4+PiAzMSkpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGEgPSB0aGlzLmNoYWluX1swXTtcclxuICAgICAgICBsZXQgYiA9IHRoaXMuY2hhaW5fWzFdO1xyXG4gICAgICAgIGxldCBjID0gdGhpcy5jaGFpbl9bMl07XHJcbiAgICAgICAgbGV0IGQgPSB0aGlzLmNoYWluX1szXTtcclxuICAgICAgICBsZXQgZSA9IHRoaXMuY2hhaW5fWzRdO1xyXG4gICAgICAgIGxldCBmLCBrO1xyXG4gICAgICAgIC8vIFRPRE8odXNlcik6IFRyeSB0byB1bnJvbGwgdGhpcyBsb29wIHRvIHNwZWVkIHVwIHRoZSBjb21wdXRhdGlvbi5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGkgPCA0MCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPCAyMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGYgPSBkIF4gKGIgJiAoYyBeIGQpKTtcclxuICAgICAgICAgICAgICAgICAgICBrID0gMHg1YTgyNzk5OTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgayA9IDB4NmVkOWViYTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDYwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IChiICYgYykgfCAoZCAmIChiIHwgYykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGsgPSAweDhmMWJiY2RjO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IGIgXiBjIF4gZDtcclxuICAgICAgICAgICAgICAgICAgICBrID0gMHhjYTYyYzFkNjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB0ID0gKCgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyBrICsgV1tpXSkgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgICAgICBlID0gZDtcclxuICAgICAgICAgICAgZCA9IGM7XHJcbiAgICAgICAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgICAgIGIgPSBhO1xyXG4gICAgICAgICAgICBhID0gdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bMF0gPSAodGhpcy5jaGFpbl9bMF0gKyBhKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bMV0gPSAodGhpcy5jaGFpbl9bMV0gKyBiKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bMl0gPSAodGhpcy5jaGFpbl9bMl0gKyBjKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bM10gPSAodGhpcy5jaGFpbl9bM10gKyBkKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bNF0gPSAodGhpcy5jaGFpbl9bNF0gKyBlKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoYnl0ZXMsIGxlbmd0aCkge1xyXG4gICAgICAgIC8vIFRPRE8oam9obmxlbnopOiB0aWdodGVuIHRoZSBmdW5jdGlvbiBzaWduYXR1cmUgYW5kIHJlbW92ZSB0aGlzIGNoZWNrXHJcbiAgICAgICAgaWYgKGJ5dGVzID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsZW5ndGhNaW51c0Jsb2NrID0gbGVuZ3RoIC0gdGhpcy5ibG9ja1NpemU7XHJcbiAgICAgICAgbGV0IG4gPSAwO1xyXG4gICAgICAgIC8vIFVzaW5nIGxvY2FsIGluc3RlYWQgb2YgbWVtYmVyIHZhcmlhYmxlcyBnaXZlcyB+NSUgc3BlZWR1cCBvbiBGaXJlZm94IDE2LlxyXG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuYnVmXztcclxuICAgICAgICBsZXQgaW5idWYgPSB0aGlzLmluYnVmXztcclxuICAgICAgICAvLyBUaGUgb3V0ZXIgd2hpbGUgbG9vcCBzaG91bGQgZXhlY3V0ZSBhdCBtb3N0IHR3aWNlLlxyXG4gICAgICAgIHdoaWxlIChuIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgaGF2ZSBubyBkYXRhIGluIHRoZSBibG9jayB0byB0b3AgdXAsIHdlIGNhbiBkaXJlY3RseSBwcm9jZXNzIHRoZVxyXG4gICAgICAgICAgICAvLyBpbnB1dCBidWZmZXIgKGFzc3VtaW5nIGl0IGNvbnRhaW5zIHN1ZmZpY2llbnQgZGF0YSkuIFRoaXMgZ2l2ZXMgfjI1JVxyXG4gICAgICAgICAgICAvLyBzcGVlZHVwIG9uIENocm9tZSAyMyBhbmQgfjE1JSBzcGVlZHVwIG9uIEZpcmVmb3ggMTYsIGJ1dCByZXF1aXJlcyB0aGF0XHJcbiAgICAgICAgICAgIC8vIHRoZSBkYXRhIGlzIHByb3ZpZGVkIGluIGxhcmdlIGNodW5rcyAob3IgaW4gbXVsdGlwbGVzIG9mIDY0IGJ5dGVzKS5cclxuICAgICAgICAgICAgaWYgKGluYnVmID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA8PSBsZW5ndGhNaW51c0Jsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzc18oYnl0ZXMsIG4pO1xyXG4gICAgICAgICAgICAgICAgICAgIG4gKz0gdGhpcy5ibG9ja1NpemU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChuIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmW2luYnVmXSA9IGJ5dGVzLmNoYXJDb2RlQXQobik7XHJcbiAgICAgICAgICAgICAgICAgICAgKytpbmJ1ZjtcclxuICAgICAgICAgICAgICAgICAgICArK247XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluYnVmID09PSB0aGlzLmJsb2NrU2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhidWYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmJ1ZiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1bXAgdG8gdGhlIG91dGVyIGxvb3Agc28gd2UgdXNlIHRoZSBmdWxsLWJsb2NrIG9wdGltaXphdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBidWZbaW5idWZdID0gYnl0ZXNbbl07XHJcbiAgICAgICAgICAgICAgICAgICAgKytpbmJ1ZjtcclxuICAgICAgICAgICAgICAgICAgICArK247XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluYnVmID09PSB0aGlzLmJsb2NrU2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhidWYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmJ1ZiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1bXAgdG8gdGhlIG91dGVyIGxvb3Agc28gd2UgdXNlIHRoZSBmdWxsLWJsb2NrIG9wdGltaXphdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaW5idWZfID0gaW5idWY7XHJcbiAgICAgICAgdGhpcy50b3RhbF8gKz0gbGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqIEBvdmVycmlkZSAqL1xyXG4gICAgZGlnZXN0KCkge1xyXG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IFtdO1xyXG4gICAgICAgIGxldCB0b3RhbEJpdHMgPSB0aGlzLnRvdGFsXyAqIDg7XHJcbiAgICAgICAgLy8gQWRkIHBhZCAweDgwIDB4MDAqLlxyXG4gICAgICAgIGlmICh0aGlzLmluYnVmXyA8IDU2KSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHRoaXMucGFkXywgNTYgLSB0aGlzLmluYnVmXyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLnBhZF8sIHRoaXMuYmxvY2tTaXplIC0gKHRoaXMuaW5idWZfIC0gNTYpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkICMgYml0cy5cclxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5ibG9ja1NpemUgLSAxOyBpID49IDU2OyBpLS0pIHtcclxuICAgICAgICAgICAgdGhpcy5idWZfW2ldID0gdG90YWxCaXRzICYgMjU1O1xyXG4gICAgICAgICAgICB0b3RhbEJpdHMgLz0gMjU2OyAvLyBEb24ndCB1c2UgYml0LXNoaWZ0aW5nIGhlcmUhXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29tcHJlc3NfKHRoaXMuYnVmXyk7XHJcbiAgICAgICAgbGV0IG4gPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAyNDsgaiA+PSAwOyBqIC09IDgpIHtcclxuICAgICAgICAgICAgICAgIGRpZ2VzdFtuXSA9ICh0aGlzLmNoYWluX1tpXSA+PiBqKSAmIDI1NTtcclxuICAgICAgICAgICAgICAgICsrbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGlnZXN0O1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBIZWxwZXIgdG8gbWFrZSBhIFN1YnNjcmliZSBmdW5jdGlvbiAoanVzdCBsaWtlIFByb21pc2UgaGVscHMgbWFrZSBhXHJcbiAqIFRoZW5hYmxlKS5cclxuICpcclxuICogQHBhcmFtIGV4ZWN1dG9yIEZ1bmN0aW9uIHdoaWNoIGNhbiBtYWtlIGNhbGxzIHRvIGEgc2luZ2xlIE9ic2VydmVyXHJcbiAqICAgICBhcyBhIHByb3h5LlxyXG4gKiBAcGFyYW0gb25Ob09ic2VydmVycyBDYWxsYmFjayB3aGVuIGNvdW50IG9mIE9ic2VydmVycyBnb2VzIHRvIHplcm8uXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVTdWJzY3JpYmUoZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpIHtcclxuICAgIGNvbnN0IHByb3h5ID0gbmV3IE9ic2VydmVyUHJveHkoZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpO1xyXG4gICAgcmV0dXJuIHByb3h5LnN1YnNjcmliZS5iaW5kKHByb3h5KTtcclxufVxyXG4vKipcclxuICogSW1wbGVtZW50IGZhbi1vdXQgZm9yIGFueSBudW1iZXIgb2YgT2JzZXJ2ZXJzIGF0dGFjaGVkIHZpYSBhIHN1YnNjcmliZVxyXG4gKiBmdW5jdGlvbi5cclxuICovXHJcbmNsYXNzIE9ic2VydmVyUHJveHkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZXhlY3V0b3IgRnVuY3Rpb24gd2hpY2ggY2FuIG1ha2UgY2FsbHMgdG8gYSBzaW5nbGUgT2JzZXJ2ZXJcclxuICAgICAqICAgICBhcyBhIHByb3h5LlxyXG4gICAgICogQHBhcmFtIG9uTm9PYnNlcnZlcnMgQ2FsbGJhY2sgd2hlbiBjb3VudCBvZiBPYnNlcnZlcnMgZ29lcyB0byB6ZXJvLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihleGVjdXRvciwgb25Ob09ic2VydmVycykge1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XHJcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZXMgPSBbXTtcclxuICAgICAgICB0aGlzLm9ic2VydmVyQ291bnQgPSAwO1xyXG4gICAgICAgIC8vIE1pY3JvLXRhc2sgc2NoZWR1bGluZyBieSBjYWxsaW5nIHRhc2sudGhlbigpLlxyXG4gICAgICAgIHRoaXMudGFzayA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIHRoaXMuZmluYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5vbk5vT2JzZXJ2ZXJzID0gb25Ob09ic2VydmVycztcclxuICAgICAgICAvLyBDYWxsIHRoZSBleGVjdXRvciBhc3luY2hyb25vdXNseSBzbyBzdWJzY3JpYmVycyB0aGF0IGFyZSBjYWxsZWRcclxuICAgICAgICAvLyBzeW5jaHJvbm91c2x5IGFmdGVyIHRoZSBjcmVhdGlvbiBvZiB0aGUgc3Vic2NyaWJlIGZ1bmN0aW9uXHJcbiAgICAgICAgLy8gY2FuIHN0aWxsIHJlY2VpdmUgdGhlIHZlcnkgZmlyc3QgdmFsdWUgZ2VuZXJhdGVkIGluIHRoZSBleGVjdXRvci5cclxuICAgICAgICB0aGlzLnRhc2tcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICBleGVjdXRvcih0aGlzKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBuZXh0KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoKG9ic2VydmVyKSA9PiB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQodmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZXJyb3IoZXJyb3IpIHtcclxuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXIpID0+IHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY2xvc2UoZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgY29tcGxldGUoKSB7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoKG9ic2VydmVyKSA9PiB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmUgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBhZGQgYW4gT2JzZXJ2ZXIgdG8gdGhlIGZhbi1vdXQgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiAtIFdlIHJlcXVpcmUgdGhhdCBubyBldmVudCBpcyBzZW50IHRvIGEgc3Vic2NyaWJlciBzeWNocm9ub3VzbHkgdG8gdGhlaXJcclxuICAgICAqICAgY2FsbCB0byBzdWJzY3JpYmUoKS5cclxuICAgICAqL1xyXG4gICAgc3Vic2NyaWJlKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcclxuICAgICAgICBsZXQgb2JzZXJ2ZXI7XHJcbiAgICAgICAgaWYgKG5leHRPck9ic2VydmVyID09PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgZXJyb3IgPT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICBjb21wbGV0ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBPYnNlcnZlci4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQXNzZW1ibGUgYW4gT2JzZXJ2ZXIgb2JqZWN0IHdoZW4gcGFzc2VkIGFzIGNhbGxiYWNrIGZ1bmN0aW9ucy5cclxuICAgICAgICBpZiAoaW1wbGVtZW50c0FueU1ldGhvZHMobmV4dE9yT2JzZXJ2ZXIsIFtcclxuICAgICAgICAgICAgJ25leHQnLFxyXG4gICAgICAgICAgICAnZXJyb3InLFxyXG4gICAgICAgICAgICAnY29tcGxldGUnXHJcbiAgICAgICAgXSkpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIgPSBuZXh0T3JPYnNlcnZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyID0ge1xyXG4gICAgICAgICAgICAgICAgbmV4dDogbmV4dE9yT2JzZXJ2ZXIsXHJcbiAgICAgICAgICAgICAgICBlcnJvcixcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYnNlcnZlci5uZXh0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCA9IG5vb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYnNlcnZlci5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yID0gbm9vcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9ic2VydmVyLmNvbXBsZXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUgPSBub29wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB1bnN1YiA9IHRoaXMudW5zdWJzY3JpYmVPbmUuYmluZCh0aGlzLCB0aGlzLm9ic2VydmVycy5sZW5ndGgpO1xyXG4gICAgICAgIC8vIEF0dGVtcHQgdG8gc3Vic2NyaWJlIHRvIGEgdGVybWluYXRlZCBPYnNlcnZhYmxlIC0gd2VcclxuICAgICAgICAvLyBqdXN0IHJlc3BvbmQgdG8gdGhlIE9ic2VydmVyIHdpdGggdGhlIGZpbmFsIGVycm9yIG9yIGNvbXBsZXRlXHJcbiAgICAgICAgLy8gZXZlbnQuXHJcbiAgICAgICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcclxuICAgICAgICAgICAgdGhpcy50YXNrLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5hbEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKHRoaXMuZmluYWxFcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90aGluZ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XHJcbiAgICAgICAgcmV0dXJuIHVuc3ViO1xyXG4gICAgfVxyXG4gICAgLy8gVW5zdWJzY3JpYmUgaXMgc3luY2hyb25vdXMgLSB3ZSBndWFyYW50ZWUgdGhhdCBubyBldmVudHMgYXJlIHNlbnQgdG9cclxuICAgIC8vIGFueSB1bnN1YnNjcmliZWQgT2JzZXJ2ZXIuXHJcbiAgICB1bnN1YnNjcmliZU9uZShpKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXJzID09PSB1bmRlZmluZWQgfHwgdGhpcy5vYnNlcnZlcnNbaV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLm9ic2VydmVyc1tpXTtcclxuICAgICAgICB0aGlzLm9ic2VydmVyQ291bnQgLT0gMTtcclxuICAgICAgICBpZiAodGhpcy5vYnNlcnZlckNvdW50ID09PSAwICYmIHRoaXMub25Ob09ic2VydmVycyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25Ob09ic2VydmVycyh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoT2JzZXJ2ZXIoZm4pIHtcclxuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcclxuICAgICAgICAgICAgLy8gQWxyZWFkeSBjbG9zZWQgYnkgcHJldmlvdXMgZXZlbnQuLi4uanVzdCBlYXQgdGhlIGFkZGl0aW9uYWwgdmFsdWVzLlxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNpbmNlIHNlbmRPbmUgY2FsbHMgYXN5bmNocm9ub3VzbHkgLSB0aGVyZSBpcyBubyBjaGFuY2UgdGhhdFxyXG4gICAgICAgIC8vIHRoaXMub2JzZXJ2ZXJzIHdpbGwgYmVjb21lIHVuZGVmaW5lZC5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub2JzZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE9uZShpLCBmbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQ2FsbCB0aGUgT2JzZXJ2ZXIgdmlhIG9uZSBvZiBpdCdzIGNhbGxiYWNrIGZ1bmN0aW9uLiBXZSBhcmUgY2FyZWZ1bCB0b1xyXG4gICAgLy8gY29uZmlybSB0aGF0IHRoZSBvYnNlcnZlIGhhcyBub3QgYmVlbiB1bnN1YnNjcmliZWQgc2luY2UgdGhpcyBhc3luY2hyb25vdXNcclxuICAgIC8vIGZ1bmN0aW9uIGhhZCBiZWVuIHF1ZXVlZC5cclxuICAgIHNlbmRPbmUoaSwgZm4pIHtcclxuICAgICAgICAvLyBFeGVjdXRlIHRoZSBjYWxsYmFjayBhc3luY2hyb25vdXNseVxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcclxuICAgICAgICB0aGlzLnRhc2sudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9ic2VydmVycyAhPT0gdW5kZWZpbmVkICYmIHRoaXMub2JzZXJ2ZXJzW2ldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm4odGhpcy5vYnNlcnZlcnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXhjZXB0aW9ucyByYWlzZWQgaW4gT2JzZXJ2ZXJzIG9yIG1pc3NpbmcgbWV0aG9kcyBvZiBhblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ic2VydmVyLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExvZyBlcnJvciB0byBjb25zb2xlLiBiLzMxNDA0ODA2XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjbG9zZShlcnIpIHtcclxuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZpbmFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmluYWxFcnJvciA9IGVycjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJveHkgaXMgbm8gbG9uZ2VyIG5lZWRlZCAtIGdhcmJhZ2UgY29sbGVjdCByZWZlcmVuY2VzXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xyXG4gICAgICAgIHRoaXMudGFzay50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRoaXMub25Ob09ic2VydmVycyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKiogVHVybiBzeW5jaHJvbm91cyBmdW5jdGlvbiBpbnRvIG9uZSBjYWxsZWQgYXN5bmNocm9ub3VzbHkuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXHJcbmZ1bmN0aW9uIGFzeW5jKGZuLCBvbkVycm9yKSB7XHJcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICBQcm9taXNlLnJlc29sdmUodHJ1ZSlcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICBmbiguLi5hcmdzKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChvbkVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIG9iamVjdCBwYXNzZWQgaW4gaW1wbGVtZW50cyBhbnkgb2YgdGhlIG5hbWVkIG1ldGhvZHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbXBsZW1lbnRzQW55TWV0aG9kcyhvYmosIG1ldGhvZHMpIHtcclxuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSB7XHJcbiAgICAgICAgaWYgKG1ldGhvZCBpbiBvYmogJiYgdHlwZW9mIG9ialttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBub29wKCkge1xyXG4gICAgLy8gZG8gbm90aGluZ1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDaGVjayB0byBtYWtlIHN1cmUgdGhlIGFwcHJvcHJpYXRlIG51bWJlciBvZiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIGZvciBhIHB1YmxpYyBmdW5jdGlvbi5cclxuICogVGhyb3dzIGFuIGVycm9yIGlmIGl0IGZhaWxzLlxyXG4gKlxyXG4gKiBAcGFyYW0gZm5OYW1lIFRoZSBmdW5jdGlvbiBuYW1lXHJcbiAqIEBwYXJhbSBtaW5Db3VudCBUaGUgbWluaW11bSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGFsbG93IGZvciB0aGUgZnVuY3Rpb24gY2FsbFxyXG4gKiBAcGFyYW0gbWF4Q291bnQgVGhlIG1heGltdW0gbnVtYmVyIG9mIGFyZ3VtZW50IHRvIGFsbG93IGZvciB0aGUgZnVuY3Rpb24gY2FsbFxyXG4gKiBAcGFyYW0gYXJnQ291bnQgVGhlIGFjdHVhbCBudW1iZXIgb2YgYXJndW1lbnRzIHByb3ZpZGVkLlxyXG4gKi9cclxuY29uc3QgdmFsaWRhdGVBcmdDb3VudCA9IGZ1bmN0aW9uIChmbk5hbWUsIG1pbkNvdW50LCBtYXhDb3VudCwgYXJnQ291bnQpIHtcclxuICAgIGxldCBhcmdFcnJvcjtcclxuICAgIGlmIChhcmdDb3VudCA8IG1pbkNvdW50KSB7XHJcbiAgICAgICAgYXJnRXJyb3IgPSAnYXQgbGVhc3QgJyArIG1pbkNvdW50O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYXJnQ291bnQgPiBtYXhDb3VudCkge1xyXG4gICAgICAgIGFyZ0Vycm9yID0gbWF4Q291bnQgPT09IDAgPyAnbm9uZScgOiAnbm8gbW9yZSB0aGFuICcgKyBtYXhDb3VudDtcclxuICAgIH1cclxuICAgIGlmIChhcmdFcnJvcikge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gZm5OYW1lICtcclxuICAgICAgICAgICAgJyBmYWlsZWQ6IFdhcyBjYWxsZWQgd2l0aCAnICtcclxuICAgICAgICAgICAgYXJnQ291bnQgK1xyXG4gICAgICAgICAgICAoYXJnQ291bnQgPT09IDEgPyAnIGFyZ3VtZW50LicgOiAnIGFyZ3VtZW50cy4nKSArXHJcbiAgICAgICAgICAgICcgRXhwZWN0cyAnICtcclxuICAgICAgICAgICAgYXJnRXJyb3IgK1xyXG4gICAgICAgICAgICAnLic7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHN0cmluZyB0byBwcmVmaXggYW4gZXJyb3IgbWVzc2FnZSBhYm91dCBmYWlsZWQgYXJndW1lbnQgdmFsaWRhdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0gZm5OYW1lIFRoZSBmdW5jdGlvbiBuYW1lXHJcbiAqIEBwYXJhbSBhcmdOYW1lIFRoZSBuYW1lIG9mIHRoZSBhcmd1bWVudFxyXG4gKiBAcmV0dXJuIFRoZSBwcmVmaXggdG8gYWRkIHRvIHRoZSBlcnJvciB0aHJvd24gZm9yIHZhbGlkYXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBlcnJvclByZWZpeChmbk5hbWUsIGFyZ05hbWUpIHtcclxuICAgIHJldHVybiBgJHtmbk5hbWV9IGZhaWxlZDogJHthcmdOYW1lfSBhcmd1bWVudCBgO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gZm5OYW1lXHJcbiAqIEBwYXJhbSBhcmd1bWVudE51bWJlclxyXG4gKiBAcGFyYW0gbmFtZXNwYWNlXHJcbiAqIEBwYXJhbSBvcHRpb25hbFxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVOYW1lc3BhY2UoZm5OYW1lLCBuYW1lc3BhY2UsIG9wdGlvbmFsKSB7XHJcbiAgICBpZiAob3B0aW9uYWwgJiYgIW5hbWVzcGFjZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIC8vVE9ETzogSSBzaG91bGQgZG8gbW9yZSB2YWxpZGF0aW9uIGhlcmUuIFdlIG9ubHkgYWxsb3cgY2VydGFpbiBjaGFycyBpbiBuYW1lc3BhY2VzLlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsICduYW1lc3BhY2UnKSArICdtdXN0IGJlIGEgdmFsaWQgZmlyZWJhc2UgbmFtZXNwYWNlLicpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ2FsbGJhY2soZm5OYW1lLCBhcmd1bWVudE5hbWUsIFxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xyXG5jYWxsYmFjaywgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiAhY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROYW1lKSArICdtdXN0IGJlIGEgdmFsaWQgZnVuY3Rpb24uJyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVDb250ZXh0T2JqZWN0KGZuTmFtZSwgYXJndW1lbnROYW1lLCBjb250ZXh0LCBvcHRpb25hbCkge1xyXG4gICAgaWYgKG9wdGlvbmFsICYmICFjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSAnb2JqZWN0JyB8fCBjb250ZXh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROYW1lKSArICdtdXN0IGJlIGEgdmFsaWQgY29udGV4dCBvYmplY3QuJyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gQ29kZSBvcmlnaW5hbGx5IGNhbWUgZnJvbSBnb29nLmNyeXB0LnN0cmluZ1RvVXRmOEJ5dGVBcnJheSwgYnV0IGZvciBzb21lIHJlYXNvbiB0aGV5XHJcbi8vIGF1dG9tYXRpY2FsbHkgcmVwbGFjZWQgJ1xcclxcbicgd2l0aCAnXFxuJywgYW5kIHRoZXkgZGlkbid0IGhhbmRsZSBzdXJyb2dhdGUgcGFpcnMsXHJcbi8vIHNvIGl0J3MgYmVlbiBtb2RpZmllZC5cclxuLy8gTm90ZSB0aGF0IG5vdCBhbGwgVW5pY29kZSBjaGFyYWN0ZXJzIGFwcGVhciBhcyBzaW5nbGUgY2hhcmFjdGVycyBpbiBKYXZhU2NyaXB0IHN0cmluZ3MuXHJcbi8vIGZyb21DaGFyQ29kZSByZXR1cm5zIHRoZSBVVEYtMTYgZW5jb2Rpbmcgb2YgYSBjaGFyYWN0ZXIgLSBzbyBzb21lIFVuaWNvZGUgY2hhcmFjdGVyc1xyXG4vLyB1c2UgMiBjaGFyYWN0ZXJzIGluIEphdmFzY3JpcHQuICBBbGwgNC1ieXRlIFVURi04IGNoYXJhY3RlcnMgYmVnaW4gd2l0aCBhIGZpcnN0XHJcbi8vIGNoYXJhY3RlciBpbiB0aGUgcmFuZ2UgMHhEODAwIC0gMHhEQkZGICh0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc28tY2FsbGVkIHN1cnJvZ2F0ZVxyXG4vLyBwYWlyKS5cclxuLy8gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy0xNS4xLjNcclxuLyoqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqL1xyXG5jb25zdCBzdHJpbmdUb0J5dGVBcnJheSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIGNvbnN0IG91dCA9IFtdO1xyXG4gICAgbGV0IHAgPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIC8vIElzIHRoaXMgdGhlIGxlYWQgc3Vycm9nYXRlIGluIGEgc3Vycm9nYXRlIHBhaXI/XHJcbiAgICAgICAgaWYgKGMgPj0gMHhkODAwICYmIGMgPD0gMHhkYmZmKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhpZ2ggPSBjIC0gMHhkODAwOyAvLyB0aGUgaGlnaCAxMCBiaXRzLlxyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIGFzc2VydChpIDwgc3RyLmxlbmd0aCwgJ1N1cnJvZ2F0ZSBwYWlyIG1pc3NpbmcgdHJhaWwgc3Vycm9nYXRlLicpO1xyXG4gICAgICAgICAgICBjb25zdCBsb3cgPSBzdHIuY2hhckNvZGVBdChpKSAtIDB4ZGMwMDsgLy8gdGhlIGxvdyAxMCBiaXRzLlxyXG4gICAgICAgICAgICBjID0gMHgxMDAwMCArIChoaWdoIDw8IDEwKSArIGxvdztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSBjO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OCkge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDYpIHwgMTkyO1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjIDwgNjU1MzYpIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxMikgfCAyMjQ7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxOCkgfCAyNDA7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDEyKSAmIDYzKSB8IDEyODtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuLyoqXHJcbiAqIENhbGN1bGF0ZSBsZW5ndGggd2l0aG91dCBhY3R1YWxseSBjb252ZXJ0aW5nOyB1c2VmdWwgZm9yIGRvaW5nIGNoZWFwZXIgdmFsaWRhdGlvbi5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAqL1xyXG5jb25zdCBzdHJpbmdMZW5ndGggPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICBsZXQgcCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoYyA8IDEyOCkge1xyXG4gICAgICAgICAgICBwKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KSB7XHJcbiAgICAgICAgICAgIHAgKz0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYyA+PSAweGQ4MDAgJiYgYyA8PSAweGRiZmYpIHtcclxuICAgICAgICAgICAgLy8gTGVhZCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpci4gIFRoZSBwYWlyIHRvZ2V0aGVyIHdpbGwgdGFrZSA0IGJ5dGVzIHRvIHJlcHJlc2VudC5cclxuICAgICAgICAgICAgcCArPSA0O1xyXG4gICAgICAgICAgICBpKys7IC8vIHNraXAgdHJhaWwgc3Vycm9nYXRlLlxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcCArPSAzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ29waWVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIxMTc1MjNcclxuICogR2VuZXJhdGVzIGEgbmV3IHV1aWQuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IHV1aWR2NCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGMgPT4ge1xyXG4gICAgICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDAsIHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4O1xyXG4gICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcclxuICAgIH0pO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gZXhwb25lbnRpYWxseSBpbmNyZWFzZS5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfSU5URVJWQUxfTUlMTElTID0gMTAwMDtcclxuLyoqXHJcbiAqIFRoZSBmYWN0b3IgdG8gYmFja29mZiBieS5cclxuICogU2hvdWxkIGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAxLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9CQUNLT0ZGX0ZBQ1RPUiA9IDI7XHJcbi8qKlxyXG4gKiBUaGUgbWF4aW11bSBtaWxsaXNlY29uZHMgdG8gaW5jcmVhc2UgdG8uXHJcbiAqXHJcbiAqIDxwPlZpc2libGUgZm9yIHRlc3RpbmdcclxuICovXHJcbmNvbnN0IE1BWF9WQUxVRV9NSUxMSVMgPSA0ICogNjAgKiA2MCAqIDEwMDA7IC8vIEZvdXIgaG91cnMsIGxpa2UgaU9TIGFuZCBBbmRyb2lkLlxyXG4vKipcclxuICogVGhlIHBlcmNlbnRhZ2Ugb2YgYmFja29mZiB0aW1lIHRvIHJhbmRvbWl6ZSBieS5cclxuICogU2VlXHJcbiAqIGh0dHA6Ly9nby9zYWZlLWNsaWVudC1iZWhhdmlvciNzdGVwLTEtZGV0ZXJtaW5lLXRoZS1hcHByb3ByaWF0ZS1yZXRyeS1pbnRlcnZhbC10by1oYW5kbGUtc3Bpa2UtdHJhZmZpY1xyXG4gKiBmb3IgY29udGV4dC5cclxuICpcclxuICogPHA+VmlzaWJsZSBmb3IgdGVzdGluZ1xyXG4gKi9cclxuY29uc3QgUkFORE9NX0ZBQ1RPUiA9IDAuNTtcclxuLyoqXHJcbiAqIEJhc2VkIG9uIHRoZSBiYWNrb2ZmIG1ldGhvZCBmcm9tXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1saWJyYXJ5L2Jsb2IvbWFzdGVyL2Nsb3N1cmUvZ29vZy9tYXRoL2V4cG9uZW50aWFsYmFja29mZi5qcy5cclxuICogRXh0cmFjdGVkIGhlcmUgc28gd2UgZG9uJ3QgbmVlZCB0byBwYXNzIG1ldGFkYXRhIGFuZCBhIHN0YXRlZnVsIEV4cG9uZW50aWFsQmFja29mZiBvYmplY3QgYXJvdW5kLlxyXG4gKi9cclxuZnVuY3Rpb24gY2FsY3VsYXRlQmFja29mZk1pbGxpcyhiYWNrb2ZmQ291bnQsIGludGVydmFsTWlsbGlzID0gREVGQVVMVF9JTlRFUlZBTF9NSUxMSVMsIGJhY2tvZmZGYWN0b3IgPSBERUZBVUxUX0JBQ0tPRkZfRkFDVE9SKSB7XHJcbiAgICAvLyBDYWxjdWxhdGVzIGFuIGV4cG9uZW50aWFsbHkgaW5jcmVhc2luZyB2YWx1ZS5cclxuICAgIC8vIERldmlhdGlvbjogY2FsY3VsYXRlcyB2YWx1ZSBmcm9tIGNvdW50IGFuZCBhIGNvbnN0YW50IGludGVydmFsLCBzbyB3ZSBvbmx5IG5lZWQgdG8gc2F2ZSB2YWx1ZVxyXG4gICAgLy8gYW5kIGNvdW50IHRvIHJlc3RvcmUgc3RhdGUuXHJcbiAgICBjb25zdCBjdXJyQmFzZVZhbHVlID0gaW50ZXJ2YWxNaWxsaXMgKiBNYXRoLnBvdyhiYWNrb2ZmRmFjdG9yLCBiYWNrb2ZmQ291bnQpO1xyXG4gICAgLy8gQSByYW5kb20gXCJmdXp6XCIgdG8gYXZvaWQgd2F2ZXMgb2YgcmV0cmllcy5cclxuICAgIC8vIERldmlhdGlvbjogcmFuZG9tRmFjdG9yIGlzIHJlcXVpcmVkLlxyXG4gICAgY29uc3QgcmFuZG9tV2FpdCA9IE1hdGgucm91bmQoXHJcbiAgICAvLyBBIGZyYWN0aW9uIG9mIHRoZSBiYWNrb2ZmIHZhbHVlIHRvIGFkZC9zdWJ0cmFjdC5cclxuICAgIC8vIERldmlhdGlvbjogY2hhbmdlcyBtdWx0aXBsaWNhdGlvbiBvcmRlciB0byBpbXByb3ZlIHJlYWRhYmlsaXR5LlxyXG4gICAgUkFORE9NX0ZBQ1RPUiAqXHJcbiAgICAgICAgY3VyckJhc2VWYWx1ZSAqXHJcbiAgICAgICAgLy8gQSByYW5kb20gZmxvYXQgKHJvdW5kZWQgdG8gaW50IGJ5IE1hdGgucm91bmQgYWJvdmUpIGluIHRoZSByYW5nZSBbLTEsIDFdLiBEZXRlcm1pbmVzXHJcbiAgICAgICAgLy8gaWYgd2UgYWRkIG9yIHN1YnRyYWN0LlxyXG4gICAgICAgIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqXHJcbiAgICAgICAgMik7XHJcbiAgICAvLyBMaW1pdHMgYmFja29mZiB0byBtYXggdG8gYXZvaWQgZWZmZWN0aXZlbHkgcGVybWFuZW50IGJhY2tvZmYuXHJcbiAgICByZXR1cm4gTWF0aC5taW4oTUFYX1ZBTFVFX01JTExJUywgY3VyckJhc2VWYWx1ZSArIHJhbmRvbVdhaXQpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlIEVuZ2xpc2ggb3JkaW5hbCBsZXR0ZXJzIGFmdGVyIGEgbnVtYmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBvcmRpbmFsKGkpIHtcclxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke2l9YDtcclxuICAgIH1cclxuICAgIHJldHVybiBpICsgaW5kaWNhdG9yKGkpO1xyXG59XHJcbmZ1bmN0aW9uIGluZGljYXRvcihpKSB7XHJcbiAgICBpID0gTWF0aC5hYnMoaSk7XHJcbiAgICBjb25zdCBjZW50ID0gaSAlIDEwMDtcclxuICAgIGlmIChjZW50ID49IDEwICYmIGNlbnQgPD0gMjApIHtcclxuICAgICAgICByZXR1cm4gJ3RoJztcclxuICAgIH1cclxuICAgIGNvbnN0IGRlYyA9IGkgJSAxMDtcclxuICAgIGlmIChkZWMgPT09IDEpIHtcclxuICAgICAgICByZXR1cm4gJ3N0JztcclxuICAgIH1cclxuICAgIGlmIChkZWMgPT09IDIpIHtcclxuICAgICAgICByZXR1cm4gJ25kJztcclxuICAgIH1cclxuICAgIGlmIChkZWMgPT09IDMpIHtcclxuICAgICAgICByZXR1cm4gJ3JkJztcclxuICAgIH1cclxuICAgIHJldHVybiAndGgnO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGdldE1vZHVsYXJJbnN0YW5jZShzZXJ2aWNlKSB7XHJcbiAgICBpZiAoc2VydmljZSAmJiBzZXJ2aWNlLl9kZWxlZ2F0ZSkge1xyXG4gICAgICAgIHJldHVybiBzZXJ2aWNlLl9kZWxlZ2F0ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBzZXJ2aWNlO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IENPTlNUQU5UUywgRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IsIERlZmVycmVkLCBFcnJvckZhY3RvcnksIEZpcmViYXNlRXJyb3IsIE1BWF9WQUxVRV9NSUxMSVMsIFJBTkRPTV9GQUNUT1IsIFNoYTEsIGFyZUNvb2tpZXNFbmFibGVkLCBhc3NlcnQsIGFzc2VydGlvbkVycm9yLCBhc3luYywgYmFzZTY0LCBiYXNlNjREZWNvZGUsIGJhc2U2NEVuY29kZSwgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcsIGNhbGN1bGF0ZUJhY2tvZmZNaWxsaXMsIGNvbnRhaW5zLCBjcmVhdGVNb2NrVXNlclRva2VuLCBjcmVhdGVTdWJzY3JpYmUsIGRlY29kZSwgZGVlcENvcHksIGRlZXBFcXVhbCwgZGVlcEV4dGVuZCwgZXJyb3JQcmVmaXgsIGV4dHJhY3RRdWVyeXN0cmluZywgZ2V0RGVmYXVsdEFwcENvbmZpZywgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdCwgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0LCBnZXREZWZhdWx0cywgZ2V0RXhwZXJpbWVudGFsU2V0dGluZywgZ2V0R2xvYmFsLCBnZXRNb2R1bGFySW5zdGFuY2UsIGdldFVBLCBpc0FkbWluLCBpc0Jyb3dzZXIsIGlzQnJvd3NlckV4dGVuc2lvbiwgaXNFbGVjdHJvbiwgaXNFbXB0eSwgaXNJRSwgaXNJbmRleGVkREJBdmFpbGFibGUsIGlzTW9iaWxlQ29yZG92YSwgaXNOb2RlLCBpc05vZGVTZGssIGlzUmVhY3ROYXRpdmUsIGlzU2FmYXJpLCBpc1VXUCwgaXNWYWxpZEZvcm1hdCwgaXNWYWxpZFRpbWVzdGFtcCwgaXNXZWJXb3JrZXIsIGlzc3VlZEF0VGltZSwganNvbkV2YWwsIG1hcCwgb3JkaW5hbCwgcHJvbWlzZVdpdGhUaW1lb3V0LCBxdWVyeXN0cmluZywgcXVlcnlzdHJpbmdEZWNvZGUsIHNhZmVHZXQsIHN0cmluZ0xlbmd0aCwgc3RyaW5nVG9CeXRlQXJyYXksIHN0cmluZ2lmeSwgdXVpZHY0LCB2YWxpZGF0ZUFyZ0NvdW50LCB2YWxpZGF0ZUNhbGxiYWNrLCB2YWxpZGF0ZUNvbnRleHRPYmplY3QsIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUsIHZhbGlkYXRlTmFtZXNwYWNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20yMDE3LmpzLm1hcFxuIiwiaW1wb3J0IHsgRGVmZXJyZWQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5cbi8qKlxyXG4gKiBDb21wb25lbnQgZm9yIHNlcnZpY2UgbmFtZSBULCBlLmcuIGBhdXRoYCwgYGF1dGgtaW50ZXJuYWxgXHJcbiAqL1xyXG5jbGFzcyBDb21wb25lbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIHB1YmxpYyBzZXJ2aWNlIG5hbWUsIGUuZy4gYXBwLCBhdXRoLCBmaXJlc3RvcmUsIGRhdGFiYXNlXHJcbiAgICAgKiBAcGFyYW0gaW5zdGFuY2VGYWN0b3J5IFNlcnZpY2UgZmFjdG9yeSByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhlIHB1YmxpYyBpbnRlcmZhY2VcclxuICAgICAqIEBwYXJhbSB0eXBlIHdoZXRoZXIgdGhlIHNlcnZpY2UgcHJvdmlkZWQgYnkgdGhlIGNvbXBvbmVudCBpcyBwdWJsaWMgb3IgcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBpbnN0YW5jZUZhY3RvcnksIHR5cGUpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VGYWN0b3J5ID0gaW5zdGFuY2VGYWN0b3J5O1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5tdWx0aXBsZUluc3RhbmNlcyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb3BlcnRpZXMgdG8gYmUgYWRkZWQgdG8gdGhlIHNlcnZpY2UgbmFtZXNwYWNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zZXJ2aWNlUHJvcHMgPSB7fTtcclxuICAgICAgICB0aGlzLmluc3RhbnRpYXRpb25Nb2RlID0gXCJMQVpZXCIgLyogSW5zdGFudGlhdGlvbk1vZGUuTEFaWSAqLztcclxuICAgICAgICB0aGlzLm9uSW5zdGFuY2VDcmVhdGVkID0gbnVsbDtcclxuICAgIH1cclxuICAgIHNldEluc3RhbnRpYXRpb25Nb2RlKG1vZGUpIHtcclxuICAgICAgICB0aGlzLmluc3RhbnRpYXRpb25Nb2RlID0gbW9kZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHNldE11bHRpcGxlSW5zdGFuY2VzKG11bHRpcGxlSW5zdGFuY2VzKSB7XHJcbiAgICAgICAgdGhpcy5tdWx0aXBsZUluc3RhbmNlcyA9IG11bHRpcGxlSW5zdGFuY2VzO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0U2VydmljZVByb3BzKHByb3BzKSB7XHJcbiAgICAgICAgdGhpcy5zZXJ2aWNlUHJvcHMgPSBwcm9wcztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHNldEluc3RhbmNlQ3JlYXRlZENhbGxiYWNrKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5vbkluc3RhbmNlQ3JlYXRlZCA9IGNhbGxiYWNrO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfRU5UUllfTkFNRSA9ICdbREVGQVVMVF0nO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUHJvdmlkZXIgZm9yIGluc3RhbmNlIGZvciBzZXJ2aWNlIG5hbWUgVCwgZS5nLiAnYXV0aCcsICdhdXRoLWludGVybmFsJ1xyXG4gKiBOYW1lU2VydmljZU1hcHBpbmdbVF0gaXMgYW4gYWxpYXMgZm9yIHRoZSB0eXBlIG9mIHRoZSBpbnN0YW5jZVxyXG4gKi9cclxuY2xhc3MgUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IobmFtZSwgY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5vbkluaXRDYWxsYmFja3MgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBpZGVudGlmaWVyIEEgcHJvdmlkZXIgY2FuIHByb3ZpZGUgbXVsaXRwbGUgaW5zdGFuY2VzIG9mIGEgc2VydmljZVxyXG4gICAgICogaWYgdGhpcy5jb21wb25lbnQubXVsdGlwbGVJbnN0YW5jZXMgaXMgdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgZ2V0KGlkZW50aWZpZXIpIHtcclxuICAgICAgICAvLyBpZiBtdWx0aXBsZUluc3RhbmNlcyBpcyBub3Qgc3VwcG9ydGVkLCB1c2UgdGhlIGRlZmF1bHQgbmFtZVxyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XHJcbiAgICAgICAgaWYgKCF0aGlzLmluc3RhbmNlc0RlZmVycmVkLmhhcyhub3JtYWxpemVkSWRlbnRpZmllcikpIHtcclxuICAgICAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5zZXQobm9ybWFsaXplZElkZW50aWZpZXIsIGRlZmVycmVkKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZChub3JtYWxpemVkSWRlbnRpZmllcikgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvdWxkQXV0b0luaXRpYWxpemUoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgc2VydmljZSBpZiBpdCBjYW4gYmUgYXV0by1pbml0aWFsaXplZFxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBpbnN0YW5jZSBmYWN0b3J5IHRocm93cyBhbiBleGNlcHRpb24gZHVyaW5nIGdldCgpLCBpdCBzaG91bGQgbm90IGNhdXNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBmYXRhbCBlcnJvci4gV2UganVzdCByZXR1cm4gdGhlIHVucmVzb2x2ZWQgcHJvbWlzZSBpbiB0aGlzIGNhc2UuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZ2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyKS5wcm9taXNlO1xyXG4gICAgfVxyXG4gICAgZ2V0SW1tZWRpYXRlKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgLy8gaWYgbXVsdGlwbGVJbnN0YW5jZXMgaXMgbm90IHN1cHBvcnRlZCwgdXNlIHRoZSBkZWZhdWx0IG5hbWVcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pZGVudGlmaWVyKTtcclxuICAgICAgICBjb25zdCBvcHRpb25hbCA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vcHRpb25hbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZChub3JtYWxpemVkSWRlbnRpZmllcikgfHxcclxuICAgICAgICAgICAgdGhpcy5zaG91bGRBdXRvSW5pdGlhbGl6ZSgpKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZWRJZGVudGlmaWVyXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJbiBjYXNlIGEgY29tcG9uZW50IGlzIG5vdCBpbml0aWFsaXplZCBhbmQgc2hvdWxkL2NhbiBub3QgYmUgYXV0by1pbml0aWFsaXplZCBhdCB0aGUgbW9tZW50LCByZXR1cm4gbnVsbCBpZiB0aGUgb3B0aW9uYWwgZmxhZyBpcyBzZXQsIG9yIHRocm93XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25hbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgU2VydmljZSAke3RoaXMubmFtZX0gaXMgbm90IGF2YWlsYWJsZWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0Q29tcG9uZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudDtcclxuICAgIH1cclxuICAgIHNldENvbXBvbmVudChjb21wb25lbnQpIHtcclxuICAgICAgICBpZiAoY29tcG9uZW50Lm5hbWUgIT09IHRoaXMubmFtZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgTWlzbWF0Y2hpbmcgQ29tcG9uZW50ICR7Y29tcG9uZW50Lm5hbWV9IGZvciBQcm92aWRlciAke3RoaXMubmFtZX0uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgQ29tcG9uZW50IGZvciAke3RoaXMubmFtZX0gaGFzIGFscmVhZHkgYmVlbiBwcm92aWRlZGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgICAvLyByZXR1cm4gZWFybHkgd2l0aG91dCBhdHRlbXB0aW5nIHRvIGluaXRpYWxpemUgdGhlIGNvbXBvbmVudCBpZiB0aGUgY29tcG9uZW50IHJlcXVpcmVzIGV4cGxpY2l0IGluaXRpYWxpemF0aW9uIChjYWxsaW5nIGBQcm92aWRlci5pbml0aWFsaXplKClgKVxyXG4gICAgICAgIGlmICghdGhpcy5zaG91bGRBdXRvSW5pdGlhbGl6ZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdGhlIHNlcnZpY2UgaXMgZWFnZXIsIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgaW5zdGFuY2VcclxuICAgICAgICBpZiAoaXNDb21wb25lbnRFYWdlcihjb21wb25lbnQpKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2UoeyBpbnN0YW5jZUlkZW50aWZpZXI6IERFRkFVTFRfRU5UUllfTkFNRSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgaW5zdGFuY2UgZmFjdG9yeSBmb3IgYW4gZWFnZXIgQ29tcG9uZW50IHRocm93cyBhbiBleGNlcHRpb24gZHVyaW5nIHRoZSBlYWdlclxyXG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6YXRpb24sIGl0IHNob3VsZCBub3QgY2F1c2UgYSBmYXRhbCBlcnJvci5cclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IEludmVzdGlnYXRlIGlmIHdlIG5lZWQgdG8gbWFrZSBpdCBjb25maWd1cmFibGUsIGJlY2F1c2Ugc29tZSBjb21wb25lbnQgbWF5IHdhbnQgdG8gY2F1c2VcclxuICAgICAgICAgICAgICAgIC8vIGEgZmF0YWwgZXJyb3IgaW4gdGhpcyBjYXNlP1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENyZWF0ZSBzZXJ2aWNlIGluc3RhbmNlcyBmb3IgdGhlIHBlbmRpbmcgcHJvbWlzZXMgYW5kIHJlc29sdmUgdGhlbVxyXG4gICAgICAgIC8vIE5PVEU6IGlmIHRoaXMubXVsdGlwbGVJbnN0YW5jZXMgaXMgZmFsc2UsIG9ubHkgdGhlIGRlZmF1bHQgaW5zdGFuY2Ugd2lsbCBiZSBjcmVhdGVkXHJcbiAgICAgICAgLy8gYW5kIGFsbCBwcm9taXNlcyB3aXRoIHJlc29sdmUgd2l0aCBpdCByZWdhcmRsZXNzIG9mIHRoZSBpZGVudGlmaWVyLlxyXG4gICAgICAgIGZvciAoY29uc3QgW2luc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2VEZWZlcnJlZF0gb2YgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpbnN0YW5jZUlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgLy8gYGdldE9ySW5pdGlhbGl6ZVNlcnZpY2UoKWAgc2hvdWxkIGFsd2F5cyByZXR1cm4gYSB2YWxpZCBpbnN0YW5jZSBzaW5jZSBhIGNvbXBvbmVudCBpcyBndWFyYW50ZWVkLiB1c2UgISB0byBtYWtlIHR5cGVzY3JpcHQgaGFwcHkuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVkSWRlbnRpZmllclxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZURlZmVycmVkLnJlc29sdmUoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBpbnN0YW5jZSBmYWN0b3J5IHRocm93cyBhbiBleGNlcHRpb24sIGl0IHNob3VsZCBub3QgY2F1c2VcclxuICAgICAgICAgICAgICAgIC8vIGEgZmF0YWwgZXJyb3IuIFdlIGp1c3QgbGVhdmUgdGhlIHByb21pc2UgdW5yZXNvbHZlZC5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNsZWFySW5zdGFuY2UoaWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZGVsZXRlKGlkZW50aWZpZXIpO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VzT3B0aW9ucy5kZWxldGUoaWRlbnRpZmllcik7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZXMuZGVsZXRlKGlkZW50aWZpZXIpO1xyXG4gICAgfVxyXG4gICAgLy8gYXBwLmRlbGV0ZSgpIHdpbGwgY2FsbCB0aGlzIG1ldGhvZCBvbiBldmVyeSBwcm92aWRlciB0byBkZWxldGUgdGhlIHNlcnZpY2VzXHJcbiAgICAvLyBUT0RPOiBzaG91bGQgd2UgbWFyayB0aGUgcHJvdmlkZXIgYXMgZGVsZXRlZD9cclxuICAgIGFzeW5jIGRlbGV0ZSgpIHtcclxuICAgICAgICBjb25zdCBzZXJ2aWNlcyA9IEFycmF5LmZyb20odGhpcy5pbnN0YW5jZXMudmFsdWVzKCkpO1xyXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgLi4uc2VydmljZXNcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoc2VydmljZSA9PiAnSU5URVJOQUwnIGluIHNlcnZpY2UpIC8vIGxlZ2FjeSBzZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgICAgIC5tYXAoc2VydmljZSA9PiBzZXJ2aWNlLklOVEVSTkFMLmRlbGV0ZSgpKSxcclxuICAgICAgICAgICAgLi4uc2VydmljZXNcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoc2VydmljZSA9PiAnX2RlbGV0ZScgaW4gc2VydmljZSkgLy8gbW9kdWxhcml6ZWQgc2VydmljZXNcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgICAubWFwKHNlcnZpY2UgPT4gc2VydmljZS5fZGVsZXRlKCkpXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICBpc0NvbXBvbmVudFNldCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQgIT0gbnVsbDtcclxuICAgIH1cclxuICAgIGlzSW5pdGlhbGl6ZWQoaWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlcy5oYXMoaWRlbnRpZmllcik7XHJcbiAgICB9XHJcbiAgICBnZXRPcHRpb25zKGlkZW50aWZpZXIgPSBERUZBVUxUX0VOVFJZX05BTUUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZXNPcHRpb25zLmdldChpZGVudGlmaWVyKSB8fCB7fTtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUob3B0cyA9IHt9KSB7XHJcbiAgICAgICAgY29uc3QgeyBvcHRpb25zID0ge30gfSA9IG9wdHM7XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihvcHRzLmluc3RhbmNlSWRlbnRpZmllcik7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZChub3JtYWxpemVkSWRlbnRpZmllcikpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYCR7dGhpcy5uYW1lfSgke25vcm1hbGl6ZWRJZGVudGlmaWVyfSkgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuaXNDb21wb25lbnRTZXQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgQ29tcG9uZW50ICR7dGhpcy5uYW1lfSBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZCB5ZXRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2Uoe1xyXG4gICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZWRJZGVudGlmaWVyLFxyXG4gICAgICAgICAgICBvcHRpb25zXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gcmVzb2x2ZSBhbnkgcGVuZGluZyBwcm9taXNlIHdhaXRpbmcgZm9yIHRoZSBzZXJ2aWNlIGluc3RhbmNlXHJcbiAgICAgICAgZm9yIChjb25zdCBbaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZURlZmVycmVkXSBvZiB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkRGVmZXJyZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaW5zdGFuY2VJZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRJZGVudGlmaWVyID09PSBub3JtYWxpemVkRGVmZXJyZWRJZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZURlZmVycmVkLnJlc29sdmUoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWQgIGFmdGVyIHRoZSBwcm92aWRlciBoYXMgYmVlbiBpbml0aWFsaXplZCBieSBjYWxsaW5nIHByb3ZpZGVyLmluaXRpYWxpemUoKS5cclxuICAgICAqIFRoZSBmdW5jdGlvbiBpcyBpbnZva2VkIFNZTkNIUk9OT1VTTFksIHNvIGl0IHNob3VsZCBub3QgZXhlY3V0ZSBhbnkgbG9uZ3J1bm5pbmcgdGFza3MgaW4gb3JkZXIgdG8gbm90IGJsb2NrIHRoZSBwcm9ncmFtLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpZGVudGlmaWVyIEFuIG9wdGlvbmFsIGluc3RhbmNlIGlkZW50aWZpZXJcclxuICAgICAqIEByZXR1cm5zIGEgZnVuY3Rpb24gdG8gdW5yZWdpc3RlciB0aGUgY2FsbGJhY2tcclxuICAgICAqL1xyXG4gICAgb25Jbml0KGNhbGxiYWNrLCBpZGVudGlmaWVyKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdDYWxsYmFja3MgPSAoX2EgPSB0aGlzLm9uSW5pdENhbGxiYWNrcy5nZXQobm9ybWFsaXplZElkZW50aWZpZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgU2V0KCk7XHJcbiAgICAgICAgZXhpc3RpbmdDYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcclxuICAgICAgICB0aGlzLm9uSW5pdENhbGxiYWNrcy5zZXQobm9ybWFsaXplZElkZW50aWZpZXIsIGV4aXN0aW5nQ2FsbGJhY2tzKTtcclxuICAgICAgICBjb25zdCBleGlzdGluZ0luc3RhbmNlID0gdGhpcy5pbnN0YW5jZXMuZ2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAoZXhpc3RpbmdJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayhleGlzdGluZ0luc3RhbmNlLCBub3JtYWxpemVkSWRlbnRpZmllcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGV4aXN0aW5nQ2FsbGJhY2tzLmRlbGV0ZShjYWxsYmFjayk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW52b2tlIG9uSW5pdCBjYWxsYmFja3Mgc3luY2hyb25vdXNseVxyXG4gICAgICogQHBhcmFtIGluc3RhbmNlIHRoZSBzZXJ2aWNlIGluc3RhbmNlYFxyXG4gICAgICovXHJcbiAgICBpbnZva2VPbkluaXRDYWxsYmFja3MoaW5zdGFuY2UsIGlkZW50aWZpZXIpIHtcclxuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLm9uSW5pdENhbGxiYWNrcy5nZXQoaWRlbnRpZmllcik7XHJcbiAgICAgICAgaWYgKCFjYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soaW5zdGFuY2UsIGlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIGVycm9ycyBpbiB0aGUgb25Jbml0IGNhbGxiYWNrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRPckluaXRpYWxpemVTZXJ2aWNlKHsgaW5zdGFuY2VJZGVudGlmaWVyLCBvcHRpb25zID0ge30gfSkge1xyXG4gICAgICAgIGxldCBpbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2VzLmdldChpbnN0YW5jZUlkZW50aWZpZXIpO1xyXG4gICAgICAgIGlmICghaW5zdGFuY2UgJiYgdGhpcy5jb21wb25lbnQpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UgPSB0aGlzLmNvbXBvbmVudC5pbnN0YW5jZUZhY3RvcnkodGhpcy5jb250YWluZXIsIHtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplSWRlbnRpZmllckZvckZhY3RvcnkoaW5zdGFuY2VJZGVudGlmaWVyKSxcclxuICAgICAgICAgICAgICAgIG9wdGlvbnNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VzLnNldChpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXNPcHRpb25zLnNldChpbnN0YW5jZUlkZW50aWZpZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW52b2tlIG9uSW5pdCBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICAgICAqIE5vdGUgdGhpcy5jb21wb25lbnQub25JbnN0YW5jZUNyZWF0ZWQgaXMgZGlmZmVyZW50LCB3aGljaCBpcyB1c2VkIGJ5IHRoZSBjb21wb25lbnQgY3JlYXRvcixcclxuICAgICAgICAgICAgICogd2hpbGUgb25Jbml0IGxpc3RlbmVycyBhcmUgcmVnaXN0ZXJlZCBieSBjb25zdW1lcnMgb2YgdGhlIHByb3ZpZGVyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5pbnZva2VPbkluaXRDYWxsYmFja3MoaW5zdGFuY2UsIGluc3RhbmNlSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPcmRlciBpcyBpbXBvcnRhbnRcclxuICAgICAgICAgICAgICogb25JbnN0YW5jZUNyZWF0ZWQoKSBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHRoaXMuaW5zdGFuY2VzLnNldChpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlKTsgd2hpY2hcclxuICAgICAgICAgICAgICogbWFrZXMgYGlzSW5pdGlhbGl6ZWQoKWAgcmV0dXJuIHRydWUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb25lbnQub25JbnN0YW5jZUNyZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnQub25JbnN0YW5jZUNyZWF0ZWQodGhpcy5jb250YWluZXIsIGluc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIGVycm9ycyBpbiB0aGUgb25JbnN0YW5jZUNyZWF0ZWRDYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgbm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGlkZW50aWZpZXIgPSBERUZBVUxUX0VOVFJZX05BTUUpIHtcclxuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50Lm11bHRpcGxlSW5zdGFuY2VzID8gaWRlbnRpZmllciA6IERFRkFVTFRfRU5UUllfTkFNRTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpZGVudGlmaWVyOyAvLyBhc3N1bWUgbXVsdGlwbGUgaW5zdGFuY2VzIGFyZSBzdXBwb3J0ZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgcHJvdmlkZWQuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2hvdWxkQXV0b0luaXRpYWxpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuICghIXRoaXMuY29tcG9uZW50ICYmXHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50Lmluc3RhbnRpYXRpb25Nb2RlICE9PSBcIkVYUExJQ0lUXCIgLyogSW5zdGFudGlhdGlvbk1vZGUuRVhQTElDSVQgKi8pO1xyXG4gICAgfVxyXG59XHJcbi8vIHVuZGVmaW5lZCBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSBzZXJ2aWNlIGZhY3RvcnkgZm9yIHRoZSBkZWZhdWx0IGluc3RhbmNlXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUlkZW50aWZpZXJGb3JGYWN0b3J5KGlkZW50aWZpZXIpIHtcclxuICAgIHJldHVybiBpZGVudGlmaWVyID09PSBERUZBVUxUX0VOVFJZX05BTUUgPyB1bmRlZmluZWQgOiBpZGVudGlmaWVyO1xyXG59XHJcbmZ1bmN0aW9uIGlzQ29tcG9uZW50RWFnZXIoY29tcG9uZW50KSB7XHJcbiAgICByZXR1cm4gY29tcG9uZW50Lmluc3RhbnRpYXRpb25Nb2RlID09PSBcIkVBR0VSXCIgLyogSW5zdGFudGlhdGlvbk1vZGUuRUFHRVIgKi87XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIENvbXBvbmVudENvbnRhaW5lciB0aGF0IHByb3ZpZGVzIFByb3ZpZGVycyBmb3Igc2VydmljZSBuYW1lIFQsIGUuZy4gYGF1dGhgLCBgYXV0aC1pbnRlcm5hbGBcclxuICovXHJcbmNsYXNzIENvbXBvbmVudENvbnRhaW5lciB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb21wb25lbnQgQ29tcG9uZW50IGJlaW5nIGFkZGVkXHJcbiAgICAgKiBAcGFyYW0gb3ZlcndyaXRlIFdoZW4gYSBjb21wb25lbnQgd2l0aCB0aGUgc2FtZSBuYW1lIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCxcclxuICAgICAqIGlmIG92ZXJ3cml0ZSBpcyB0cnVlOiBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIGNvbXBvbmVudCB3aXRoIHRoZSBuZXcgY29tcG9uZW50IGFuZCBjcmVhdGUgYSBuZXdcclxuICAgICAqIHByb3ZpZGVyIHdpdGggdGhlIG5ldyBjb21wb25lbnQuIEl0IGNhbiBiZSB1c2VmdWwgaW4gdGVzdHMgd2hlcmUgeW91IHdhbnQgdG8gdXNlIGRpZmZlcmVudCBtb2Nrc1xyXG4gICAgICogZm9yIGRpZmZlcmVudCB0ZXN0cy5cclxuICAgICAqIGlmIG92ZXJ3cml0ZSBpcyBmYWxzZTogdGhyb3cgYW4gZXhjZXB0aW9uXHJcbiAgICAgKi9cclxuICAgIGFkZENvbXBvbmVudChjb21wb25lbnQpIHtcclxuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIoY29tcG9uZW50Lm5hbWUpO1xyXG4gICAgICAgIGlmIChwcm92aWRlci5pc0NvbXBvbmVudFNldCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29tcG9uZW50ICR7Y29tcG9uZW50Lm5hbWV9IGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCB3aXRoICR7dGhpcy5uYW1lfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm92aWRlci5zZXRDb21wb25lbnQoY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIGFkZE9yT3ZlcndyaXRlQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihjb21wb25lbnQubmFtZSk7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVyLmlzQ29tcG9uZW50U2V0KCkpIHtcclxuICAgICAgICAgICAgLy8gZGVsZXRlIHRoZSBleGlzdGluZyBwcm92aWRlciBmcm9tIHRoZSBjb250YWluZXIsIHNvIHdlIGNhbiByZWdpc3RlciB0aGUgbmV3IGNvbXBvbmVudFxyXG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycy5kZWxldGUoY29tcG9uZW50Lm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBnZXRQcm92aWRlciBwcm92aWRlcyBhIHR5cGUgc2FmZSBpbnRlcmZhY2Ugd2hlcmUgaXQgY2FuIG9ubHkgYmUgY2FsbGVkIHdpdGggYSBmaWVsZCBuYW1lXHJcbiAgICAgKiBwcmVzZW50IGluIE5hbWVTZXJ2aWNlTWFwcGluZyBpbnRlcmZhY2UuXHJcbiAgICAgKlxyXG4gICAgICogRmlyZWJhc2UgU0RLcyBwcm92aWRpbmcgc2VydmljZXMgc2hvdWxkIGV4dGVuZCBOYW1lU2VydmljZU1hcHBpbmcgaW50ZXJmYWNlIHRvIHJlZ2lzdGVyXHJcbiAgICAgKiB0aGVtc2VsdmVzLlxyXG4gICAgICovXHJcbiAgICBnZXRQcm92aWRlcihuYW1lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvdmlkZXJzLmhhcyhuYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlcnMuZ2V0KG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjcmVhdGUgYSBQcm92aWRlciBmb3IgYSBzZXJ2aWNlIHRoYXQgaGFzbid0IHJlZ2lzdGVyZWQgd2l0aCBGaXJlYmFzZVxyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IFByb3ZpZGVyKG5hbWUsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuYW1lLCBwcm92aWRlcik7XHJcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyO1xyXG4gICAgfVxyXG4gICAgZ2V0UHJvdmlkZXJzKCkge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucHJvdmlkZXJzLnZhbHVlcygpKTtcclxuICAgIH1cclxufVxuXG5leHBvcnQgeyBDb21wb25lbnQsIENvbXBvbmVudENvbnRhaW5lciwgUHJvdmlkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbTIwMTcuanMubWFwXG4iLCIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSBjb250YWluZXIgZm9yIGFsbCBvZiB0aGUgTG9nZ2VyIGluc3RhbmNlc1xyXG4gKi9cclxuY29uc3QgaW5zdGFuY2VzID0gW107XHJcbi8qKlxyXG4gKiBUaGUgSlMgU0RLIHN1cHBvcnRzIDUgbG9nIGxldmVscyBhbmQgYWxzbyBhbGxvd3MgYSB1c2VyIHRoZSBhYmlsaXR5IHRvXHJcbiAqIHNpbGVuY2UgdGhlIGxvZ3MgYWx0b2dldGhlci5cclxuICpcclxuICogVGhlIG9yZGVyIGlzIGEgZm9sbG93czpcclxuICogREVCVUcgPCBWRVJCT1NFIDwgSU5GTyA8IFdBUk4gPCBFUlJPUlxyXG4gKlxyXG4gKiBBbGwgb2YgdGhlIGxvZyB0eXBlcyBhYm92ZSB0aGUgY3VycmVudCBsb2cgbGV2ZWwgd2lsbCBiZSBjYXB0dXJlZCAoaS5lLiBpZlxyXG4gKiB5b3Ugc2V0IHRoZSBsb2cgbGV2ZWwgdG8gYElORk9gLCBlcnJvcnMgd2lsbCBzdGlsbCBiZSBsb2dnZWQsIGJ1dCBgREVCVUdgIGFuZFxyXG4gKiBgVkVSQk9TRWAgbG9ncyB3aWxsIG5vdClcclxuICovXHJcbnZhciBMb2dMZXZlbDtcclxuKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJERUJVR1wiXSA9IDBdID0gXCJERUJVR1wiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJWRVJCT1NFXCJdID0gMV0gPSBcIlZFUkJPU0VcIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiSU5GT1wiXSA9IDJdID0gXCJJTkZPXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIldBUk5cIl0gPSAzXSA9IFwiV0FSTlwiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJFUlJPUlwiXSA9IDRdID0gXCJFUlJPUlwiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJTSUxFTlRcIl0gPSA1XSA9IFwiU0lMRU5UXCI7XHJcbn0pKExvZ0xldmVsIHx8IChMb2dMZXZlbCA9IHt9KSk7XHJcbmNvbnN0IGxldmVsU3RyaW5nVG9FbnVtID0ge1xyXG4gICAgJ2RlYnVnJzogTG9nTGV2ZWwuREVCVUcsXHJcbiAgICAndmVyYm9zZSc6IExvZ0xldmVsLlZFUkJPU0UsXHJcbiAgICAnaW5mbyc6IExvZ0xldmVsLklORk8sXHJcbiAgICAnd2Fybic6IExvZ0xldmVsLldBUk4sXHJcbiAgICAnZXJyb3InOiBMb2dMZXZlbC5FUlJPUixcclxuICAgICdzaWxlbnQnOiBMb2dMZXZlbC5TSUxFTlRcclxufTtcclxuLyoqXHJcbiAqIFRoZSBkZWZhdWx0IGxvZyBsZXZlbFxyXG4gKi9cclxuY29uc3QgZGVmYXVsdExvZ0xldmVsID0gTG9nTGV2ZWwuSU5GTztcclxuLyoqXHJcbiAqIEJ5IGRlZmF1bHQsIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgZGlzcGxheWVkIGluIHRoZSBkZXZlbG9wZXIgY29uc29sZSAoaW5cclxuICogY2hyb21lKS4gVG8gYXZvaWQgZm9yY2luZyB1c2VycyB0byBoYXZlIHRvIG9wdC1pbiB0byB0aGVzZSBsb2dzIHR3aWNlXHJcbiAqIChpLmUuIG9uY2UgZm9yIGZpcmViYXNlLCBhbmQgb25jZSBpbiB0aGUgY29uc29sZSksIHdlIGFyZSBzZW5kaW5nIGBERUJVR2BcclxuICogbG9ncyB0byB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbi5cclxuICovXHJcbmNvbnN0IENvbnNvbGVNZXRob2QgPSB7XHJcbiAgICBbTG9nTGV2ZWwuREVCVUddOiAnbG9nJyxcclxuICAgIFtMb2dMZXZlbC5WRVJCT1NFXTogJ2xvZycsXHJcbiAgICBbTG9nTGV2ZWwuSU5GT106ICdpbmZvJyxcclxuICAgIFtMb2dMZXZlbC5XQVJOXTogJ3dhcm4nLFxyXG4gICAgW0xvZ0xldmVsLkVSUk9SXTogJ2Vycm9yJ1xyXG59O1xyXG4vKipcclxuICogVGhlIGRlZmF1bHQgbG9nIGhhbmRsZXIgd2lsbCBmb3J3YXJkIERFQlVHLCBWRVJCT1NFLCBJTkZPLCBXQVJOLCBhbmQgRVJST1JcclxuICogbWVzc2FnZXMgb24gdG8gdGhlaXIgY29ycmVzcG9uZGluZyBjb25zb2xlIGNvdW50ZXJwYXJ0cyAoaWYgdGhlIGxvZyBtZXRob2RcclxuICogaXMgc3VwcG9ydGVkIGJ5IHRoZSBjdXJyZW50IGxvZyBsZXZlbClcclxuICovXHJcbmNvbnN0IGRlZmF1bHRMb2dIYW5kbGVyID0gKGluc3RhbmNlLCBsb2dUeXBlLCAuLi5hcmdzKSA9PiB7XHJcbiAgICBpZiAobG9nVHlwZSA8IGluc3RhbmNlLmxvZ0xldmVsKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xyXG4gICAgY29uc3QgbWV0aG9kID0gQ29uc29sZU1ldGhvZFtsb2dUeXBlXTtcclxuICAgIGlmIChtZXRob2QpIHtcclxuICAgICAgICBjb25zb2xlW21ldGhvZF0oYFske25vd31dICAke2luc3RhbmNlLm5hbWV9OmAsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0ZWQgdG8gbG9nIGEgbWVzc2FnZSB3aXRoIGFuIGludmFsaWQgbG9nVHlwZSAodmFsdWU6ICR7bG9nVHlwZX0pYCk7XHJcbiAgICB9XHJcbn07XHJcbmNsYXNzIExvZ2dlciB7XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVzIHlvdSBhbiBpbnN0YW5jZSBvZiBhIExvZ2dlciB0byBjYXB0dXJlIG1lc3NhZ2VzIGFjY29yZGluZyB0b1xyXG4gICAgICogRmlyZWJhc2UncyBsb2dnaW5nIHNjaGVtZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSB0aGF0IHRoZSBsb2dzIHdpbGwgYmUgYXNzb2NpYXRlZCB3aXRoXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsb2cgbGV2ZWwgb2YgdGhlIGdpdmVuIExvZ2dlciBpbnN0YW5jZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IGRlZmF1bHRMb2dMZXZlbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWFpbiAoaW50ZXJuYWwpIGxvZyBoYW5kbGVyIGZvciB0aGUgTG9nZ2VyIGluc3RhbmNlLlxyXG4gICAgICAgICAqIENhbiBiZSBzZXQgdG8gYSBuZXcgZnVuY3Rpb24gaW4gaW50ZXJuYWwgcGFja2FnZSBjb2RlIGJ1dCBub3QgYnkgdXNlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyID0gZGVmYXVsdExvZ0hhbmRsZXI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG9wdGlvbmFsLCBhZGRpdGlvbmFsLCB1c2VyLWRlZmluZWQgbG9nIGhhbmRsZXIgZm9yIHRoZSBMb2dnZXIgaW5zdGFuY2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhcHR1cmUgdGhlIGN1cnJlbnQgaW5zdGFuY2UgZm9yIGxhdGVyIHVzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluc3RhbmNlcy5wdXNoKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxvZ0xldmVsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dMZXZlbDtcclxuICAgIH1cclxuICAgIHNldCBsb2dMZXZlbCh2YWwpIHtcclxuICAgICAgICBpZiAoISh2YWwgaW4gTG9nTGV2ZWwpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgdmFsdWUgXCIke3ZhbH1cIiBhc3NpZ25lZCB0byBcXGBsb2dMZXZlbFxcYGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IHZhbDtcclxuICAgIH1cclxuICAgIC8vIFdvcmthcm91bmQgZm9yIHNldHRlci9nZXR0ZXIgaGF2aW5nIHRvIGJlIHRoZSBzYW1lIHR5cGUuXHJcbiAgICBzZXRMb2dMZXZlbCh2YWwpIHtcclxuICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gbGV2ZWxTdHJpbmdUb0VudW1bdmFsXSA6IHZhbDtcclxuICAgIH1cclxuICAgIGdldCBsb2dIYW5kbGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dIYW5kbGVyO1xyXG4gICAgfVxyXG4gICAgc2V0IGxvZ0hhbmRsZXIodmFsKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVmFsdWUgYXNzaWduZWQgdG8gYGxvZ0hhbmRsZXJgIG11c3QgYmUgYSBmdW5jdGlvbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyID0gdmFsO1xyXG4gICAgfVxyXG4gICAgZ2V0IHVzZXJMb2dIYW5kbGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl91c2VyTG9nSGFuZGxlcjtcclxuICAgIH1cclxuICAgIHNldCB1c2VyTG9nSGFuZGxlcih2YWwpIHtcclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciA9IHZhbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZ1bmN0aW9ucyBiZWxvdyBhcmUgYWxsIGJhc2VkIG9uIHRoZSBgY29uc29sZWAgaW50ZXJmYWNlXHJcbiAgICAgKi9cclxuICAgIGRlYnVnKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5ERUJVRywgLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5ERUJVRywgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBsb2coLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmXHJcbiAgICAgICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLlZFUkJPU0UsIC4uLmFyZ3MpO1xyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuVkVSQk9TRSwgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBpbmZvKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5JTkZPLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLklORk8sIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgd2FybiguLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiYgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuV0FSTiwgLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5XQVJOLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIGVycm9yKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5FUlJPUiwgLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5FUlJPUiwgLi4uYXJncyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWwpIHtcclxuICAgIGluc3RhbmNlcy5mb3JFYWNoKGluc3QgPT4ge1xyXG4gICAgICAgIGluc3Quc2V0TG9nTGV2ZWwobGV2ZWwpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gc2V0VXNlckxvZ0hhbmRsZXIobG9nQ2FsbGJhY2ssIG9wdGlvbnMpIHtcclxuICAgIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XHJcbiAgICAgICAgbGV0IGN1c3RvbUxvZ0xldmVsID0gbnVsbDtcclxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmxldmVsKSB7XHJcbiAgICAgICAgICAgIGN1c3RvbUxvZ0xldmVsID0gbGV2ZWxTdHJpbmdUb0VudW1bb3B0aW9ucy5sZXZlbF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsb2dDYWxsYmFjayA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS51c2VyTG9nSGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS51c2VyTG9nSGFuZGxlciA9IChpbnN0YW5jZSwgbGV2ZWwsIC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhcmdzXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcChhcmcgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmcgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmcudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy5tZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChpZ25vcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihhcmcgPT4gYXJnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcgJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPj0gKGN1c3RvbUxvZ0xldmVsICE9PSBudWxsICYmIGN1c3RvbUxvZ0xldmVsICE9PSB2b2lkIDAgPyBjdXN0b21Mb2dMZXZlbCA6IGluc3RhbmNlLmxvZ0xldmVsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ0NhbGxiYWNrKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWw6IExvZ0xldmVsW2xldmVsXS50b0xvd2VyQ2FzZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBpbnN0YW5jZS5uYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IExvZ0xldmVsLCBMb2dnZXIsIHNldExvZ0xldmVsLCBzZXRVc2VyTG9nSGFuZGxlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiIsImNvbnN0IGluc3RhbmNlT2ZBbnkgPSAob2JqZWN0LCBjb25zdHJ1Y3RvcnMpID0+IGNvbnN0cnVjdG9ycy5zb21lKChjKSA9PiBvYmplY3QgaW5zdGFuY2VvZiBjKTtcblxubGV0IGlkYlByb3h5YWJsZVR5cGVzO1xubGV0IGN1cnNvckFkdmFuY2VNZXRob2RzO1xuLy8gVGhpcyBpcyBhIGZ1bmN0aW9uIHRvIHByZXZlbnQgaXQgdGhyb3dpbmcgdXAgaW4gbm9kZSBlbnZpcm9ubWVudHMuXG5mdW5jdGlvbiBnZXRJZGJQcm94eWFibGVUeXBlcygpIHtcbiAgICByZXR1cm4gKGlkYlByb3h5YWJsZVR5cGVzIHx8XG4gICAgICAgIChpZGJQcm94eWFibGVUeXBlcyA9IFtcbiAgICAgICAgICAgIElEQkRhdGFiYXNlLFxuICAgICAgICAgICAgSURCT2JqZWN0U3RvcmUsXG4gICAgICAgICAgICBJREJJbmRleCxcbiAgICAgICAgICAgIElEQkN1cnNvcixcbiAgICAgICAgICAgIElEQlRyYW5zYWN0aW9uLFxuICAgICAgICBdKSk7XG59XG4vLyBUaGlzIGlzIGEgZnVuY3Rpb24gdG8gcHJldmVudCBpdCB0aHJvd2luZyB1cCBpbiBub2RlIGVudmlyb25tZW50cy5cbmZ1bmN0aW9uIGdldEN1cnNvckFkdmFuY2VNZXRob2RzKCkge1xuICAgIHJldHVybiAoY3Vyc29yQWR2YW5jZU1ldGhvZHMgfHxcbiAgICAgICAgKGN1cnNvckFkdmFuY2VNZXRob2RzID0gW1xuICAgICAgICAgICAgSURCQ3Vyc29yLnByb3RvdHlwZS5hZHZhbmNlLFxuICAgICAgICAgICAgSURCQ3Vyc29yLnByb3RvdHlwZS5jb250aW51ZSxcbiAgICAgICAgICAgIElEQkN1cnNvci5wcm90b3R5cGUuY29udGludWVQcmltYXJ5S2V5LFxuICAgICAgICBdKSk7XG59XG5jb25zdCBjdXJzb3JSZXF1ZXN0TWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHRyYW5zYWN0aW9uRG9uZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCB0cmFuc2FjdGlvblN0b3JlTmFtZXNNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgdHJhbnNmb3JtQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHByb21pc2lmeVJlcXVlc3QocmVxdWVzdCkge1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHVubGlzdGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKCdzdWNjZXNzJywgc3VjY2Vzcyk7XG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSh3cmFwKHJlcXVlc3QucmVzdWx0KSk7XG4gICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignc3VjY2VzcycsIHN1Y2Nlc3MpO1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IpO1xuICAgIH0pO1xuICAgIHByb21pc2VcbiAgICAgICAgLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgIC8vIFNpbmNlIGN1cnNvcmluZyByZXVzZXMgdGhlIElEQlJlcXVlc3QgKCpzaWdoKiksIHdlIGNhY2hlIGl0IGZvciBsYXRlciByZXRyaWV2YWxcbiAgICAgICAgLy8gKHNlZSB3cmFwRnVuY3Rpb24pLlxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJREJDdXJzb3IpIHtcbiAgICAgICAgICAgIGN1cnNvclJlcXVlc3RNYXAuc2V0KHZhbHVlLCByZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYXRjaGluZyB0byBhdm9pZCBcIlVuY2F1Z2h0IFByb21pc2UgZXhjZXB0aW9uc1wiXG4gICAgfSlcbiAgICAgICAgLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgLy8gVGhpcyBtYXBwaW5nIGV4aXN0cyBpbiByZXZlcnNlVHJhbnNmb3JtQ2FjaGUgYnV0IGRvZXNuJ3QgZG9lc24ndCBleGlzdCBpbiB0cmFuc2Zvcm1DYWNoZS4gVGhpc1xuICAgIC8vIGlzIGJlY2F1c2Ugd2UgY3JlYXRlIG1hbnkgcHJvbWlzZXMgZnJvbSBhIHNpbmdsZSBJREJSZXF1ZXN0LlxuICAgIHJldmVyc2VUcmFuc2Zvcm1DYWNoZS5zZXQocHJvbWlzZSwgcmVxdWVzdCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5mdW5jdGlvbiBjYWNoZURvbmVQcm9taXNlRm9yVHJhbnNhY3Rpb24odHgpIHtcbiAgICAvLyBFYXJseSBiYWlsIGlmIHdlJ3ZlIGFscmVhZHkgY3JlYXRlZCBhIGRvbmUgcHJvbWlzZSBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICBpZiAodHJhbnNhY3Rpb25Eb25lTWFwLmhhcyh0eCkpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBkb25lID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxpc3RlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHR4LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgY29tcGxldGUpO1xuICAgICAgICAgICAgdHgucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB0eC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdCh0eC5lcnJvciB8fCBuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydEVycm9yJywgJ0Fib3J0RXJyb3InKSk7XG4gICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICB9O1xuICAgICAgICB0eC5hZGRFdmVudExpc3RlbmVyKCdjb21wbGV0ZScsIGNvbXBsZXRlKTtcbiAgICAgICAgdHguYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgICAgIHR4LmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZXJyb3IpO1xuICAgIH0pO1xuICAgIC8vIENhY2hlIGl0IGZvciBsYXRlciByZXRyaWV2YWwuXG4gICAgdHJhbnNhY3Rpb25Eb25lTWFwLnNldCh0eCwgZG9uZSk7XG59XG5sZXQgaWRiUHJveHlUcmFwcyA9IHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSURCVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIHRyYW5zYWN0aW9uLmRvbmUuXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ2RvbmUnKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbkRvbmVNYXAuZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICAvLyBQb2x5ZmlsbCBmb3Igb2JqZWN0U3RvcmVOYW1lcyBiZWNhdXNlIG9mIEVkZ2UuXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ29iamVjdFN0b3JlTmFtZXMnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5vYmplY3RTdG9yZU5hbWVzIHx8IHRyYW5zYWN0aW9uU3RvcmVOYW1lc01hcC5nZXQodGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1ha2UgdHguc3RvcmUgcmV0dXJuIHRoZSBvbmx5IHN0b3JlIGluIHRoZSB0cmFuc2FjdGlvbiwgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGFyZSBtYW55LlxuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdzdG9yZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWl2ZXIub2JqZWN0U3RvcmVOYW1lc1sxXVxuICAgICAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA6IHJlY2VpdmVyLm9iamVjdFN0b3JlKHJlY2VpdmVyLm9iamVjdFN0b3JlTmFtZXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEVsc2UgdHJhbnNmb3JtIHdoYXRldmVyIHdlIGdldCBiYWNrLlxuICAgICAgICByZXR1cm4gd3JhcCh0YXJnZXRbcHJvcF0pO1xuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSURCVHJhbnNhY3Rpb24gJiZcbiAgICAgICAgICAgIChwcm9wID09PSAnZG9uZScgfHwgcHJvcCA9PT0gJ3N0b3JlJykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wIGluIHRhcmdldDtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHJlcGxhY2VUcmFwcyhjYWxsYmFjaykge1xuICAgIGlkYlByb3h5VHJhcHMgPSBjYWxsYmFjayhpZGJQcm94eVRyYXBzKTtcbn1cbmZ1bmN0aW9uIHdyYXBGdW5jdGlvbihmdW5jKSB7XG4gICAgLy8gRHVlIHRvIGV4cGVjdGVkIG9iamVjdCBlcXVhbGl0eSAod2hpY2ggaXMgZW5mb3JjZWQgYnkgdGhlIGNhY2hpbmcgaW4gYHdyYXBgKSwgd2VcbiAgICAvLyBvbmx5IGNyZWF0ZSBvbmUgbmV3IGZ1bmMgcGVyIGZ1bmMuXG4gICAgLy8gRWRnZSBkb2Vzbid0IHN1cHBvcnQgb2JqZWN0U3RvcmVOYW1lcyAoYm9vbyksIHNvIHdlIHBvbHlmaWxsIGl0IGhlcmUuXG4gICAgaWYgKGZ1bmMgPT09IElEQkRhdGFiYXNlLnByb3RvdHlwZS50cmFuc2FjdGlvbiAmJlxuICAgICAgICAhKCdvYmplY3RTdG9yZU5hbWVzJyBpbiBJREJUcmFuc2FjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RvcmVOYW1lcywgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgdHggPSBmdW5jLmNhbGwodW53cmFwKHRoaXMpLCBzdG9yZU5hbWVzLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uU3RvcmVOYW1lc01hcC5zZXQodHgsIHN0b3JlTmFtZXMuc29ydCA/IHN0b3JlTmFtZXMuc29ydCgpIDogW3N0b3JlTmFtZXNdKTtcbiAgICAgICAgICAgIHJldHVybiB3cmFwKHR4KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ3Vyc29yIG1ldGhvZHMgYXJlIHNwZWNpYWwsIGFzIHRoZSBiZWhhdmlvdXIgaXMgYSBsaXR0bGUgbW9yZSBkaWZmZXJlbnQgdG8gc3RhbmRhcmQgSURCLiBJblxuICAgIC8vIElEQiwgeW91IGFkdmFuY2UgdGhlIGN1cnNvciBhbmQgd2FpdCBmb3IgYSBuZXcgJ3N1Y2Nlc3MnIG9uIHRoZSBJREJSZXF1ZXN0IHRoYXQgZ2F2ZSB5b3UgdGhlXG4gICAgLy8gY3Vyc29yLiBJdCdzIGtpbmRhIGxpa2UgYSBwcm9taXNlIHRoYXQgY2FuIHJlc29sdmUgd2l0aCBtYW55IHZhbHVlcy4gVGhhdCBkb2Vzbid0IG1ha2Ugc2Vuc2VcbiAgICAvLyB3aXRoIHJlYWwgcHJvbWlzZXMsIHNvIGVhY2ggYWR2YW5jZSBtZXRob2RzIHJldHVybnMgYSBuZXcgcHJvbWlzZSBmb3IgdGhlIGN1cnNvciBvYmplY3QsIG9yXG4gICAgLy8gdW5kZWZpbmVkIGlmIHRoZSBlbmQgb2YgdGhlIGN1cnNvciBoYXMgYmVlbiByZWFjaGVkLlxuICAgIGlmIChnZXRDdXJzb3JBZHZhbmNlTWV0aG9kcygpLmluY2x1ZGVzKGZ1bmMpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgLy8gQ2FsbGluZyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJveHkgYXMgJ3RoaXMnIGNhdXNlcyBJTExFR0FMIElOVk9DQVRJT04sIHNvIHdlIHVzZVxuICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAgICAgICAgICAgIGZ1bmMuYXBwbHkodW53cmFwKHRoaXMpLCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB3cmFwKGN1cnNvclJlcXVlc3RNYXAuZ2V0KHRoaXMpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIC8vIENhbGxpbmcgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3h5IGFzICd0aGlzJyBjYXVzZXMgSUxMRUdBTCBJTlZPQ0FUSU9OLCBzbyB3ZSB1c2VcbiAgICAgICAgLy8gdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHdyYXAoZnVuYy5hcHBseSh1bndyYXAodGhpcyksIGFyZ3MpKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtQ2FjaGFibGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB3cmFwRnVuY3Rpb24odmFsdWUpO1xuICAgIC8vIFRoaXMgZG9lc24ndCByZXR1cm4sIGl0IGp1c3QgY3JlYXRlcyBhICdkb25lJyBwcm9taXNlIGZvciB0aGUgdHJhbnNhY3Rpb24sXG4gICAgLy8gd2hpY2ggaXMgbGF0ZXIgcmV0dXJuZWQgZm9yIHRyYW5zYWN0aW9uLmRvbmUgKHNlZSBpZGJPYmplY3RIYW5kbGVyKS5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJREJUcmFuc2FjdGlvbilcbiAgICAgICAgY2FjaGVEb25lUHJvbWlzZUZvclRyYW5zYWN0aW9uKHZhbHVlKTtcbiAgICBpZiAoaW5zdGFuY2VPZkFueSh2YWx1ZSwgZ2V0SWRiUHJveHlhYmxlVHlwZXMoKSkpXG4gICAgICAgIHJldHVybiBuZXcgUHJveHkodmFsdWUsIGlkYlByb3h5VHJhcHMpO1xuICAgIC8vIFJldHVybiB0aGUgc2FtZSB2YWx1ZSBiYWNrIGlmIHdlJ3JlIG5vdCBnb2luZyB0byB0cmFuc2Zvcm0gaXQuXG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gd3JhcCh2YWx1ZSkge1xuICAgIC8vIFdlIHNvbWV0aW1lcyBnZW5lcmF0ZSBtdWx0aXBsZSBwcm9taXNlcyBmcm9tIGEgc2luZ2xlIElEQlJlcXVlc3QgKGVnIHdoZW4gY3Vyc29yaW5nKSwgYmVjYXVzZVxuICAgIC8vIElEQiBpcyB3ZWlyZCBhbmQgYSBzaW5nbGUgSURCUmVxdWVzdCBjYW4geWllbGQgbWFueSByZXNwb25zZXMsIHNvIHRoZXNlIGNhbid0IGJlIGNhY2hlZC5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJREJSZXF1ZXN0KVxuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5UmVxdWVzdCh2YWx1ZSk7XG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSB0cmFuc2Zvcm1lZCB0aGlzIHZhbHVlIGJlZm9yZSwgcmV1c2UgdGhlIHRyYW5zZm9ybWVkIHZhbHVlLlxuICAgIC8vIFRoaXMgaXMgZmFzdGVyLCBidXQgaXQgYWxzbyBwcm92aWRlcyBvYmplY3QgZXF1YWxpdHkuXG4gICAgaWYgKHRyYW5zZm9ybUNhY2hlLmhhcyh2YWx1ZSkpXG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1DYWNoZS5nZXQodmFsdWUpO1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gdHJhbnNmb3JtQ2FjaGFibGVWYWx1ZSh2YWx1ZSk7XG4gICAgLy8gTm90IGFsbCB0eXBlcyBhcmUgdHJhbnNmb3JtZWQuXG4gICAgLy8gVGhlc2UgbWF5IGJlIHByaW1pdGl2ZSB0eXBlcywgc28gdGhleSBjYW4ndCBiZSBXZWFrTWFwIGtleXMuXG4gICAgaWYgKG5ld1ZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICB0cmFuc2Zvcm1DYWNoZS5zZXQodmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLnNldChuZXdWYWx1ZSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3VmFsdWU7XG59XG5jb25zdCB1bndyYXAgPSAodmFsdWUpID0+IHJldmVyc2VUcmFuc2Zvcm1DYWNoZS5nZXQodmFsdWUpO1xuXG5leHBvcnQgeyByZXZlcnNlVHJhbnNmb3JtQ2FjaGUgYXMgYSwgaW5zdGFuY2VPZkFueSBhcyBpLCByZXBsYWNlVHJhcHMgYXMgciwgdW53cmFwIGFzIHUsIHdyYXAgYXMgdyB9O1xuIiwiaW1wb3J0IHsgdyBhcyB3cmFwLCByIGFzIHJlcGxhY2VUcmFwcyB9IGZyb20gJy4vd3JhcC1pZGItdmFsdWUuanMnO1xuZXhwb3J0IHsgdSBhcyB1bndyYXAsIHcgYXMgd3JhcCB9IGZyb20gJy4vd3JhcC1pZGItdmFsdWUuanMnO1xuXG4vKipcbiAqIE9wZW4gYSBkYXRhYmFzZS5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBkYXRhYmFzZS5cbiAqIEBwYXJhbSB2ZXJzaW9uIFNjaGVtYSB2ZXJzaW9uLlxuICogQHBhcmFtIGNhbGxiYWNrcyBBZGRpdGlvbmFsIGNhbGxiYWNrcy5cbiAqL1xuZnVuY3Rpb24gb3BlbkRCKG5hbWUsIHZlcnNpb24sIHsgYmxvY2tlZCwgdXBncmFkZSwgYmxvY2tpbmcsIHRlcm1pbmF0ZWQgfSA9IHt9KSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKG5hbWUsIHZlcnNpb24pO1xuICAgIGNvbnN0IG9wZW5Qcm9taXNlID0gd3JhcChyZXF1ZXN0KTtcbiAgICBpZiAodXBncmFkZSkge1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3VwZ3JhZGVuZWVkZWQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHVwZ3JhZGUod3JhcChyZXF1ZXN0LnJlc3VsdCksIGV2ZW50Lm9sZFZlcnNpb24sIGV2ZW50Lm5ld1ZlcnNpb24sIHdyYXAocmVxdWVzdC50cmFuc2FjdGlvbiksIGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChibG9ja2VkKSB7XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignYmxvY2tlZCcsIChldmVudCkgPT4gYmxvY2tlZChcbiAgICAgICAgLy8gQ2FzdGluZyBkdWUgdG8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0LURPTS1saWItZ2VuZXJhdG9yL3B1bGwvMTQwNVxuICAgICAgICBldmVudC5vbGRWZXJzaW9uLCBldmVudC5uZXdWZXJzaW9uLCBldmVudCkpO1xuICAgIH1cbiAgICBvcGVuUHJvbWlzZVxuICAgICAgICAudGhlbigoZGIpID0+IHtcbiAgICAgICAgaWYgKHRlcm1pbmF0ZWQpXG4gICAgICAgICAgICBkYi5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsICgpID0+IHRlcm1pbmF0ZWQoKSk7XG4gICAgICAgIGlmIChibG9ja2luZykge1xuICAgICAgICAgICAgZGIuYWRkRXZlbnRMaXN0ZW5lcigndmVyc2lvbmNoYW5nZScsIChldmVudCkgPT4gYmxvY2tpbmcoZXZlbnQub2xkVmVyc2lvbiwgZXZlbnQubmV3VmVyc2lvbiwgZXZlbnQpKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgICAgIC5jYXRjaCgoKSA9PiB7IH0pO1xuICAgIHJldHVybiBvcGVuUHJvbWlzZTtcbn1cbi8qKlxuICogRGVsZXRlIGEgZGF0YWJhc2UuXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgZGF0YWJhc2UuXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZURCKG5hbWUsIHsgYmxvY2tlZCB9ID0ge30pIHtcbiAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKG5hbWUpO1xuICAgIGlmIChibG9ja2VkKSB7XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignYmxvY2tlZCcsIChldmVudCkgPT4gYmxvY2tlZChcbiAgICAgICAgLy8gQ2FzdGluZyBkdWUgdG8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0LURPTS1saWItZ2VuZXJhdG9yL3B1bGwvMTQwNVxuICAgICAgICBldmVudC5vbGRWZXJzaW9uLCBldmVudCkpO1xuICAgIH1cbiAgICByZXR1cm4gd3JhcChyZXF1ZXN0KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG59XG5cbmNvbnN0IHJlYWRNZXRob2RzID0gWydnZXQnLCAnZ2V0S2V5JywgJ2dldEFsbCcsICdnZXRBbGxLZXlzJywgJ2NvdW50J107XG5jb25zdCB3cml0ZU1ldGhvZHMgPSBbJ3B1dCcsICdhZGQnLCAnZGVsZXRlJywgJ2NsZWFyJ107XG5jb25zdCBjYWNoZWRNZXRob2RzID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0TWV0aG9kKHRhcmdldCwgcHJvcCkge1xuICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIElEQkRhdGFiYXNlICYmXG4gICAgICAgICEocHJvcCBpbiB0YXJnZXQpICYmXG4gICAgICAgIHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2FjaGVkTWV0aG9kcy5nZXQocHJvcCkpXG4gICAgICAgIHJldHVybiBjYWNoZWRNZXRob2RzLmdldChwcm9wKTtcbiAgICBjb25zdCB0YXJnZXRGdW5jTmFtZSA9IHByb3AucmVwbGFjZSgvRnJvbUluZGV4JC8sICcnKTtcbiAgICBjb25zdCB1c2VJbmRleCA9IHByb3AgIT09IHRhcmdldEZ1bmNOYW1lO1xuICAgIGNvbnN0IGlzV3JpdGUgPSB3cml0ZU1ldGhvZHMuaW5jbHVkZXModGFyZ2V0RnVuY05hbWUpO1xuICAgIGlmIChcbiAgICAvLyBCYWlsIGlmIHRoZSB0YXJnZXQgZG9lc24ndCBleGlzdCBvbiB0aGUgdGFyZ2V0LiBFZywgZ2V0QWxsIGlzbid0IGluIEVkZ2UuXG4gICAgISh0YXJnZXRGdW5jTmFtZSBpbiAodXNlSW5kZXggPyBJREJJbmRleCA6IElEQk9iamVjdFN0b3JlKS5wcm90b3R5cGUpIHx8XG4gICAgICAgICEoaXNXcml0ZSB8fCByZWFkTWV0aG9kcy5pbmNsdWRlcyh0YXJnZXRGdW5jTmFtZSkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gYXN5bmMgZnVuY3Rpb24gKHN0b3JlTmFtZSwgLi4uYXJncykge1xuICAgICAgICAvLyBpc1dyaXRlID8gJ3JlYWR3cml0ZScgOiB1bmRlZmluZWQgZ3ppcHBzIGJldHRlciwgYnV0IGZhaWxzIGluIEVkZ2UgOihcbiAgICAgICAgY29uc3QgdHggPSB0aGlzLnRyYW5zYWN0aW9uKHN0b3JlTmFtZSwgaXNXcml0ZSA/ICdyZWFkd3JpdGUnIDogJ3JlYWRvbmx5Jyk7XG4gICAgICAgIGxldCB0YXJnZXQgPSB0eC5zdG9yZTtcbiAgICAgICAgaWYgKHVzZUluZGV4KVxuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LmluZGV4KGFyZ3Muc2hpZnQoKSk7XG4gICAgICAgIC8vIE11c3QgcmVqZWN0IGlmIG9wIHJlamVjdHMuXG4gICAgICAgIC8vIElmIGl0J3MgYSB3cml0ZSBvcGVyYXRpb24sIG11c3QgcmVqZWN0IGlmIHR4LmRvbmUgcmVqZWN0cy5cbiAgICAgICAgLy8gTXVzdCByZWplY3Qgd2l0aCBvcCByZWplY3Rpb24gZmlyc3QuXG4gICAgICAgIC8vIE11c3QgcmVzb2x2ZSB3aXRoIG9wIHZhbHVlLlxuICAgICAgICAvLyBNdXN0IGhhbmRsZSBib3RoIHByb21pc2VzIChubyB1bmhhbmRsZWQgcmVqZWN0aW9ucylcbiAgICAgICAgcmV0dXJuIChhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0YXJnZXRbdGFyZ2V0RnVuY05hbWVdKC4uLmFyZ3MpLFxuICAgICAgICAgICAgaXNXcml0ZSAmJiB0eC5kb25lLFxuICAgICAgICBdKSlbMF07XG4gICAgfTtcbiAgICBjYWNoZWRNZXRob2RzLnNldChwcm9wLCBtZXRob2QpO1xuICAgIHJldHVybiBtZXRob2Q7XG59XG5yZXBsYWNlVHJhcHMoKG9sZFRyYXBzKSA9PiAoe1xuICAgIC4uLm9sZFRyYXBzLFxuICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IGdldE1ldGhvZCh0YXJnZXQsIHByb3ApIHx8IG9sZFRyYXBzLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSxcbiAgICBoYXM6ICh0YXJnZXQsIHByb3ApID0+ICEhZ2V0TWV0aG9kKHRhcmdldCwgcHJvcCkgfHwgb2xkVHJhcHMuaGFzKHRhcmdldCwgcHJvcCksXG59KSk7XG5cbmV4cG9ydCB7IGRlbGV0ZURCLCBvcGVuREIgfTtcbiIsImltcG9ydCB7IENvbXBvbmVudCwgQ29tcG9uZW50Q29udGFpbmVyIH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBMb2dnZXIsIHNldFVzZXJMb2dIYW5kbGVyLCBzZXRMb2dMZXZlbCBhcyBzZXRMb2dMZXZlbCQxIH0gZnJvbSAnQGZpcmViYXNlL2xvZ2dlcic7XG5pbXBvcnQgeyBFcnJvckZhY3RvcnksIGdldERlZmF1bHRBcHBDb25maWcsIGRlZXBFcXVhbCwgaXNCcm93c2VyLCBpc1dlYldvcmtlciwgRmlyZWJhc2VFcnJvciwgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcsIGlzSW5kZXhlZERCQXZhaWxhYmxlLCB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuZXhwb3J0IHsgRmlyZWJhc2VFcnJvciB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IG9wZW5EQiB9IGZyb20gJ2lkYic7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIFBsYXRmb3JtTG9nZ2VyU2VydmljZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICB9XHJcbiAgICAvLyBJbiBpbml0aWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdpbGwgYmUgY2FsbGVkIGJ5IGluc3RhbGxhdGlvbnMgb25cclxuICAgIC8vIGF1dGggdG9rZW4gcmVmcmVzaCwgYW5kIGluc3RhbGxhdGlvbnMgd2lsbCBzZW5kIHRoaXMgc3RyaW5nLlxyXG4gICAgZ2V0UGxhdGZvcm1JbmZvU3RyaW5nKCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVycyA9IHRoaXMuY29udGFpbmVyLmdldFByb3ZpZGVycygpO1xyXG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBwcm92aWRlcnMgYW5kIGdldCBsaWJyYXJ5L3ZlcnNpb24gcGFpcnMgZnJvbSBhbnkgdGhhdCBhcmVcclxuICAgICAgICAvLyB2ZXJzaW9uIGNvbXBvbmVudHMuXHJcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyc1xyXG4gICAgICAgICAgICAubWFwKHByb3ZpZGVyID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzVmVyc2lvblNlcnZpY2VQcm92aWRlcihwcm92aWRlcikpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZpY2UgPSBwcm92aWRlci5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtzZXJ2aWNlLmxpYnJhcnl9LyR7c2VydmljZS52ZXJzaW9ufWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5maWx0ZXIobG9nU3RyaW5nID0+IGxvZ1N0cmluZylcclxuICAgICAgICAgICAgLmpvaW4oJyAnKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHByb3ZpZGVyIGNoZWNrIGlmIHRoaXMgcHJvdmlkZXIgcHJvdmlkZXMgYSBWZXJzaW9uU2VydmljZVxyXG4gKlxyXG4gKiBOT1RFOiBVc2luZyBQcm92aWRlcjwnYXBwLXZlcnNpb24nPiBpcyBhIGhhY2sgdG8gaW5kaWNhdGUgdGhhdCB0aGUgcHJvdmlkZXJcclxuICogcHJvdmlkZXMgVmVyc2lvblNlcnZpY2UuIFRoZSBwcm92aWRlciBpcyBub3QgbmVjZXNzYXJpbHkgYSAnYXBwLXZlcnNpb24nXHJcbiAqIHByb3ZpZGVyLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNWZXJzaW9uU2VydmljZVByb3ZpZGVyKHByb3ZpZGVyKSB7XHJcbiAgICBjb25zdCBjb21wb25lbnQgPSBwcm92aWRlci5nZXRDb21wb25lbnQoKTtcclxuICAgIHJldHVybiAoY29tcG9uZW50ID09PSBudWxsIHx8IGNvbXBvbmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcG9uZW50LnR5cGUpID09PSBcIlZFUlNJT05cIiAvKiBDb21wb25lbnRUeXBlLlZFUlNJT04gKi87XHJcbn1cblxuY29uc3QgbmFtZSRwID0gXCJAZmlyZWJhc2UvYXBwXCI7XG5jb25zdCB2ZXJzaW9uJDEgPSBcIjAuMTAuOVwiO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCdAZmlyZWJhc2UvYXBwJyk7XG5cbmNvbnN0IG5hbWUkbyA9IFwiQGZpcmViYXNlL2FwcC1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRuID0gXCJAZmlyZWJhc2UvYW5hbHl0aWNzLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJG0gPSBcIkBmaXJlYmFzZS9hbmFseXRpY3NcIjtcblxuY29uc3QgbmFtZSRsID0gXCJAZmlyZWJhc2UvYXBwLWNoZWNrLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGsgPSBcIkBmaXJlYmFzZS9hcHAtY2hlY2tcIjtcblxuY29uc3QgbmFtZSRqID0gXCJAZmlyZWJhc2UvYXV0aFwiO1xuXG5jb25zdCBuYW1lJGkgPSBcIkBmaXJlYmFzZS9hdXRoLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGggPSBcIkBmaXJlYmFzZS9kYXRhYmFzZVwiO1xuXG5jb25zdCBuYW1lJGcgPSBcIkBmaXJlYmFzZS9kYXRhYmFzZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRmID0gXCJAZmlyZWJhc2UvZnVuY3Rpb25zXCI7XG5cbmNvbnN0IG5hbWUkZSA9IFwiQGZpcmViYXNlL2Z1bmN0aW9ucy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRkID0gXCJAZmlyZWJhc2UvaW5zdGFsbGF0aW9uc1wiO1xuXG5jb25zdCBuYW1lJGMgPSBcIkBmaXJlYmFzZS9pbnN0YWxsYXRpb25zLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGIgPSBcIkBmaXJlYmFzZS9tZXNzYWdpbmdcIjtcblxuY29uc3QgbmFtZSRhID0gXCJAZmlyZWJhc2UvbWVzc2FnaW5nLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDkgPSBcIkBmaXJlYmFzZS9wZXJmb3JtYW5jZVwiO1xuXG5jb25zdCBuYW1lJDggPSBcIkBmaXJlYmFzZS9wZXJmb3JtYW5jZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSQ3ID0gXCJAZmlyZWJhc2UvcmVtb3RlLWNvbmZpZ1wiO1xuXG5jb25zdCBuYW1lJDYgPSBcIkBmaXJlYmFzZS9yZW1vdGUtY29uZmlnLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDUgPSBcIkBmaXJlYmFzZS9zdG9yYWdlXCI7XG5cbmNvbnN0IG5hbWUkNCA9IFwiQGZpcmViYXNlL3N0b3JhZ2UtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkMyA9IFwiQGZpcmViYXNlL2ZpcmVzdG9yZVwiO1xuXG5jb25zdCBuYW1lJDIgPSBcIkBmaXJlYmFzZS92ZXJ0ZXhhaS1wcmV2aWV3XCI7XG5cbmNvbnN0IG5hbWUkMSA9IFwiQGZpcmViYXNlL2ZpcmVzdG9yZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSA9IFwiZmlyZWJhc2VcIjtcbmNvbnN0IHZlcnNpb24gPSBcIjEwLjEzLjBcIjtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBkZWZhdWx0IGFwcCBuYW1lXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9FTlRSWV9OQU1FID0gJ1tERUZBVUxUXSc7XHJcbmNvbnN0IFBMQVRGT1JNX0xPR19TVFJJTkcgPSB7XHJcbiAgICBbbmFtZSRwXTogJ2ZpcmUtY29yZScsXHJcbiAgICBbbmFtZSRvXTogJ2ZpcmUtY29yZS1jb21wYXQnLFxyXG4gICAgW25hbWUkbV06ICdmaXJlLWFuYWx5dGljcycsXHJcbiAgICBbbmFtZSRuXTogJ2ZpcmUtYW5hbHl0aWNzLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRrXTogJ2ZpcmUtYXBwLWNoZWNrJyxcclxuICAgIFtuYW1lJGxdOiAnZmlyZS1hcHAtY2hlY2stY29tcGF0JyxcclxuICAgIFtuYW1lJGpdOiAnZmlyZS1hdXRoJyxcclxuICAgIFtuYW1lJGldOiAnZmlyZS1hdXRoLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRoXTogJ2ZpcmUtcnRkYicsXHJcbiAgICBbbmFtZSRnXTogJ2ZpcmUtcnRkYi1jb21wYXQnLFxyXG4gICAgW25hbWUkZl06ICdmaXJlLWZuJyxcclxuICAgIFtuYW1lJGVdOiAnZmlyZS1mbi1jb21wYXQnLFxyXG4gICAgW25hbWUkZF06ICdmaXJlLWlpZCcsXHJcbiAgICBbbmFtZSRjXTogJ2ZpcmUtaWlkLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRiXTogJ2ZpcmUtZmNtJyxcclxuICAgIFtuYW1lJGFdOiAnZmlyZS1mY20tY29tcGF0JyxcclxuICAgIFtuYW1lJDldOiAnZmlyZS1wZXJmJyxcclxuICAgIFtuYW1lJDhdOiAnZmlyZS1wZXJmLWNvbXBhdCcsXHJcbiAgICBbbmFtZSQ3XTogJ2ZpcmUtcmMnLFxyXG4gICAgW25hbWUkNl06ICdmaXJlLXJjLWNvbXBhdCcsXHJcbiAgICBbbmFtZSQ1XTogJ2ZpcmUtZ2NzJyxcclxuICAgIFtuYW1lJDRdOiAnZmlyZS1nY3MtY29tcGF0JyxcclxuICAgIFtuYW1lJDNdOiAnZmlyZS1mc3QnLFxyXG4gICAgW25hbWUkMV06ICdmaXJlLWZzdC1jb21wYXQnLFxyXG4gICAgW25hbWUkMl06ICdmaXJlLXZlcnRleCcsXHJcbiAgICAnZmlyZS1qcyc6ICdmaXJlLWpzJyxcclxuICAgIFtuYW1lXTogJ2ZpcmUtanMtYWxsJ1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBfYXBwcyA9IG5ldyBNYXAoKTtcclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3QgX3NlcnZlckFwcHMgPSBuZXcgTWFwKCk7XHJcbi8qKlxyXG4gKiBSZWdpc3RlcmVkIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuY29uc3QgX2NvbXBvbmVudHMgPSBuZXcgTWFwKCk7XHJcbi8qKlxyXG4gKiBAcGFyYW0gY29tcG9uZW50IC0gdGhlIGNvbXBvbmVudCBiZWluZyBhZGRlZCB0byB0aGlzIGFwcCdzIGNvbnRhaW5lclxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9hZGRDb21wb25lbnQoYXBwLCBjb21wb25lbnQpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgYXBwLmNvbnRhaW5lci5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gZmFpbGVkIHRvIHJlZ2lzdGVyIHdpdGggRmlyZWJhc2VBcHAgJHthcHAubmFtZX1gLCBlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoYXBwLCBjb21wb25lbnQpIHtcclxuICAgIGFwcC5jb250YWluZXIuYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoY29tcG9uZW50KTtcclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIGNvbXBvbmVudCAtIHRoZSBjb21wb25lbnQgdG8gcmVnaXN0ZXJcclxuICogQHJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGNvbXBvbmVudCBpcyByZWdpc3RlcmVkIHN1Y2Nlc3NmdWxseVxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9yZWdpc3RlckNvbXBvbmVudChjb21wb25lbnQpIHtcclxuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQubmFtZTtcclxuICAgIGlmIChfY29tcG9uZW50cy5oYXMoY29tcG9uZW50TmFtZSkpIHtcclxuICAgICAgICBsb2dnZXIuZGVidWcoYFRoZXJlIHdlcmUgbXVsdGlwbGUgYXR0ZW1wdHMgdG8gcmVnaXN0ZXIgY29tcG9uZW50ICR7Y29tcG9uZW50TmFtZX0uYCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgX2NvbXBvbmVudHMuc2V0KGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudCk7XHJcbiAgICAvLyBhZGQgdGhlIGNvbXBvbmVudCB0byBleGlzdGluZyBhcHAgaW5zdGFuY2VzXHJcbiAgICBmb3IgKGNvbnN0IGFwcCBvZiBfYXBwcy52YWx1ZXMoKSkge1xyXG4gICAgICAgIF9hZGRDb21wb25lbnQoYXBwLCBjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBzZXJ2ZXJBcHAgb2YgX3NlcnZlckFwcHMudmFsdWVzKCkpIHtcclxuICAgICAgICBfYWRkQ29tcG9uZW50KHNlcnZlckFwcCwgY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gYXBwIC0gRmlyZWJhc2VBcHAgaW5zdGFuY2VcclxuICogQHBhcmFtIG5hbWUgLSBzZXJ2aWNlIG5hbWVcclxuICpcclxuICogQHJldHVybnMgdGhlIHByb3ZpZGVyIGZvciB0aGUgc2VydmljZSB3aXRoIHRoZSBtYXRjaGluZyBuYW1lXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX2dldFByb3ZpZGVyKGFwcCwgbmFtZSkge1xyXG4gICAgY29uc3QgaGVhcnRiZWF0Q29udHJvbGxlciA9IGFwcC5jb250YWluZXJcclxuICAgICAgICAuZ2V0UHJvdmlkZXIoJ2hlYXJ0YmVhdCcpXHJcbiAgICAgICAgLmdldEltbWVkaWF0ZSh7IG9wdGlvbmFsOiB0cnVlIH0pO1xyXG4gICAgaWYgKGhlYXJ0YmVhdENvbnRyb2xsZXIpIHtcclxuICAgICAgICB2b2lkIGhlYXJ0YmVhdENvbnRyb2xsZXIudHJpZ2dlckhlYXJ0YmVhdCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFwcC5jb250YWluZXIuZ2V0UHJvdmlkZXIobmFtZSk7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBhcHAgLSBGaXJlYmFzZUFwcCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0gbmFtZSAtIHNlcnZpY2UgbmFtZVxyXG4gKiBAcGFyYW0gaW5zdGFuY2VJZGVudGlmaWVyIC0gc2VydmljZSBpbnN0YW5jZSBpZGVudGlmaWVyIGluIGNhc2UgdGhlIHNlcnZpY2Ugc3VwcG9ydHMgbXVsdGlwbGUgaW5zdGFuY2VzXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX3JlbW92ZVNlcnZpY2VJbnN0YW5jZShhcHAsIG5hbWUsIGluc3RhbmNlSWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgX2dldFByb3ZpZGVyKGFwcCwgbmFtZSkuY2xlYXJJbnN0YW5jZShpbnN0YW5jZUlkZW50aWZpZXIpO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gb2JqIC0gYW4gb2JqZWN0IG9mIHR5cGUgRmlyZWJhc2VBcHAgb3IgRmlyZWJhc2VPcHRpb25zLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlIG9iamVjdCBpcyBvZiB0eXBlIEZpcmViYXNlQXBwLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9pc0ZpcmViYXNlQXBwKG9iaikge1xyXG4gICAgcmV0dXJuIG9iai5vcHRpb25zICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBvYmogLSBhbiBvYmplY3Qgb2YgdHlwZSBGaXJlYmFzZUFwcC5cclxuICpcclxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgb2JqZWN0IGlzIG9mIHR5cGUgRmlyZWJhc2VTZXJ2ZXJBcHBJbXBsLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9pc0ZpcmViYXNlU2VydmVyQXBwKG9iaikge1xyXG4gICAgcmV0dXJuIG9iai5zZXR0aW5ncyAhPT0gdW5kZWZpbmVkO1xyXG59XHJcbi8qKlxyXG4gKiBUZXN0IG9ubHlcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBfY2xlYXJDb21wb25lbnRzKCkge1xyXG4gICAgX2NvbXBvbmVudHMuY2xlYXIoKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBFUlJPUlMgPSB7XHJcbiAgICBbXCJuby1hcHBcIiAvKiBBcHBFcnJvci5OT19BUFAgKi9dOiBcIk5vIEZpcmViYXNlIEFwcCAneyRhcHBOYW1lfScgaGFzIGJlZW4gY3JlYXRlZCAtIFwiICtcclxuICAgICAgICAnY2FsbCBpbml0aWFsaXplQXBwKCkgZmlyc3QnLFxyXG4gICAgW1wiYmFkLWFwcC1uYW1lXCIgLyogQXBwRXJyb3IuQkFEX0FQUF9OQU1FICovXTogXCJJbGxlZ2FsIEFwcCBuYW1lOiAneyRhcHBOYW1lfSdcIixcclxuICAgIFtcImR1cGxpY2F0ZS1hcHBcIiAvKiBBcHBFcnJvci5EVVBMSUNBVEVfQVBQICovXTogXCJGaXJlYmFzZSBBcHAgbmFtZWQgJ3skYXBwTmFtZX0nIGFscmVhZHkgZXhpc3RzIHdpdGggZGlmZmVyZW50IG9wdGlvbnMgb3IgY29uZmlnXCIsXHJcbiAgICBbXCJhcHAtZGVsZXRlZFwiIC8qIEFwcEVycm9yLkFQUF9ERUxFVEVEICovXTogXCJGaXJlYmFzZSBBcHAgbmFtZWQgJ3skYXBwTmFtZX0nIGFscmVhZHkgZGVsZXRlZFwiLFxyXG4gICAgW1wic2VydmVyLWFwcC1kZWxldGVkXCIgLyogQXBwRXJyb3IuU0VSVkVSX0FQUF9ERUxFVEVEICovXTogJ0ZpcmViYXNlIFNlcnZlciBBcHAgaGFzIGJlZW4gZGVsZXRlZCcsXHJcbiAgICBbXCJuby1vcHRpb25zXCIgLyogQXBwRXJyb3IuTk9fT1BUSU9OUyAqL106ICdOZWVkIHRvIHByb3ZpZGUgb3B0aW9ucywgd2hlbiBub3QgYmVpbmcgZGVwbG95ZWQgdG8gaG9zdGluZyB2aWEgc291cmNlLicsXHJcbiAgICBbXCJpbnZhbGlkLWFwcC1hcmd1bWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfQVBQX0FSR1VNRU5UICovXTogJ2ZpcmViYXNlLnskYXBwTmFtZX0oKSB0YWtlcyBlaXRoZXIgbm8gYXJndW1lbnQgb3IgYSAnICtcclxuICAgICAgICAnRmlyZWJhc2UgQXBwIGluc3RhbmNlLicsXHJcbiAgICBbXCJpbnZhbGlkLWxvZy1hcmd1bWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfTE9HX0FSR1VNRU5UICovXTogJ0ZpcnN0IGFyZ3VtZW50IHRvIGBvbkxvZ2AgbXVzdCBiZSBudWxsIG9yIGEgZnVuY3Rpb24uJyxcclxuICAgIFtcImlkYi1vcGVuXCIgLyogQXBwRXJyb3IuSURCX09QRU4gKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gb3BlbmluZyBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxyXG4gICAgW1wiaWRiLWdldFwiIC8qIEFwcEVycm9yLklEQl9HRVQgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gcmVhZGluZyBmcm9tIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXHJcbiAgICBbXCJpZGItc2V0XCIgLyogQXBwRXJyb3IuSURCX1dSSVRFICovXTogJ0Vycm9yIHRocm93biB3aGVuIHdyaXRpbmcgdG8gSW5kZXhlZERCLiBPcmlnaW5hbCBlcnJvcjogeyRvcmlnaW5hbEVycm9yTWVzc2FnZX0uJyxcclxuICAgIFtcImlkYi1kZWxldGVcIiAvKiBBcHBFcnJvci5JREJfREVMRVRFICovXTogJ0Vycm9yIHRocm93biB3aGVuIGRlbGV0aW5nIGZyb20gSW5kZXhlZERCLiBPcmlnaW5hbCBlcnJvcjogeyRvcmlnaW5hbEVycm9yTWVzc2FnZX0uJyxcclxuICAgIFtcImZpbmFsaXphdGlvbi1yZWdpc3RyeS1ub3Qtc3VwcG9ydGVkXCIgLyogQXBwRXJyb3IuRklOQUxJWkFUSU9OX1JFR0lTVFJZX05PVF9TVVBQT1JURUQgKi9dOiAnRmlyZWJhc2VTZXJ2ZXJBcHAgZGVsZXRlT25EZXJlZiBmaWVsZCBkZWZpbmVkIGJ1dCB0aGUgSlMgcnVudGltZSBkb2VzIG5vdCBzdXBwb3J0IEZpbmFsaXphdGlvblJlZ2lzdHJ5LicsXHJcbiAgICBbXCJpbnZhbGlkLXNlcnZlci1hcHAtZW52aXJvbm1lbnRcIiAvKiBBcHBFcnJvci5JTlZBTElEX1NFUlZFUl9BUFBfRU5WSVJPTk1FTlQgKi9dOiAnRmlyZWJhc2VTZXJ2ZXJBcHAgaXMgbm90IGZvciB1c2UgaW4gYnJvd3NlciBlbnZpcm9ubWVudHMuJ1xyXG59O1xyXG5jb25zdCBFUlJPUl9GQUNUT1JZID0gbmV3IEVycm9yRmFjdG9yeSgnYXBwJywgJ0ZpcmViYXNlJywgRVJST1JTKTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgRmlyZWJhc2VBcHBJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5faXNEZWxldGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9IGNvbmZpZy5uYW1lO1xyXG4gICAgICAgIHRoaXMuX2F1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCA9XHJcbiAgICAgICAgICAgIGNvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ7XHJcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENvbXBvbmVudChuZXcgQ29tcG9uZW50KCdhcHAnLCAoKSA9PiB0aGlzLCBcIlBVQkxJQ1wiIC8qIENvbXBvbmVudFR5cGUuUFVCTElDICovKSk7XHJcbiAgICB9XHJcbiAgICBnZXQgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkKCkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkO1xyXG4gICAgfVxyXG4gICAgc2V0IGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCh2YWwpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID0gdmFsO1xyXG4gICAgfVxyXG4gICAgZ2V0IG5hbWUoKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xyXG4gICAgfVxyXG4gICAgZ2V0IG9wdGlvbnMoKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNvbmZpZygpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcclxuICAgIH1cclxuICAgIGdldCBjb250YWluZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuICAgIH1cclxuICAgIGdldCBpc0RlbGV0ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRGVsZXRlZDtcclxuICAgIH1cclxuICAgIHNldCBpc0RlbGV0ZWQodmFsKSB7XHJcbiAgICAgICAgdGhpcy5faXNEZWxldGVkID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gRXJyb3IgaWYgdGhlIEFwcCBoYXMgYWxyZWFkeSBiZWVuIGRlbGV0ZWQgLVxyXG4gICAgICogdXNlIGJlZm9yZSBwZXJmb3JtaW5nIEFQSSBhY3Rpb25zIG9uIHRoZSBBcHAuXHJcbiAgICAgKi9cclxuICAgIGNoZWNrRGVzdHJveWVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGVsZXRlZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImFwcC1kZWxldGVkXCIgLyogQXBwRXJyb3IuQVBQX0RFTEVURUQgKi8sIHsgYXBwTmFtZTogdGhpcy5fbmFtZSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgRmlyZWJhc2VTZXJ2ZXJBcHBJbXBsIGV4dGVuZHMgRmlyZWJhc2VBcHBJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHNlcnZlckNvbmZpZywgbmFtZSwgY29udGFpbmVyKSB7XHJcbiAgICAgICAgLy8gQnVpbGQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIGZvciB0aGUgRmlyZWJhc2VBcHBJbXBsIGJhc2UgY2xhc3MuXHJcbiAgICAgICAgY29uc3QgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID0gc2VydmVyQ29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgID8gc2VydmVyQ29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZFxyXG4gICAgICAgICAgICA6IGZhbHNlO1xyXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgRmlyZWJhc2VBcHBTZXR0aW5ncyBvYmplY3QgZm9yIHRoZSBGaXJlYmFzZUFwcEltcCBjb25zdHJ1Y3Rvci5cclxuICAgICAgICBjb25zdCBjb25maWcgPSB7XHJcbiAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgIGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuYXBpS2V5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBwYXJlbnQgRmlyZWJhc2VBcHBJbXAgb2JqZWN0LlxyXG4gICAgICAgICAgICBzdXBlcihvcHRpb25zLCBjb25maWcsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBhcHBJbXBsID0gb3B0aW9ucztcclxuICAgICAgICAgICAgc3VwZXIoYXBwSW1wbC5vcHRpb25zLCBjb25maWcsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vdyBjb25zdHJ1Y3QgdGhlIGRhdGEgZm9yIHRoZSBGaXJlYmFzZVNlcnZlckFwcEltcGwuXHJcbiAgICAgICAgdGhpcy5fc2VydmVyQ29uZmlnID0gT2JqZWN0LmFzc2lnbih7IGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCB9LCBzZXJ2ZXJDb25maWcpO1xyXG4gICAgICAgIHRoaXMuX2ZpbmFsaXphdGlvblJlZ2lzdHJ5ID0gbnVsbDtcclxuICAgICAgICBpZiAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLl9maW5hbGl6YXRpb25SZWdpc3RyeSA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9tYXRpY0NsZWFudXAoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3JlZkNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLmluY1JlZkNvdW50KHRoaXMuX3NlcnZlckNvbmZpZy5yZWxlYXNlT25EZXJlZik7XHJcbiAgICAgICAgLy8gRG8gbm90IHJldGFpbiBhIGhhcmQgcmVmZXJlbmNlIHRvIHRoZSBkcmVmIG9iamVjdCwgb3RoZXJ3aXNlIHRoZSBGaW5hbGl6YXRpb25SZWdpc3RyeVxyXG4gICAgICAgIC8vIHdpbGwgbmV2ZXIgdHJpZ2dlci5cclxuICAgICAgICB0aGlzLl9zZXJ2ZXJDb25maWcucmVsZWFzZU9uRGVyZWYgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgc2VydmVyQ29uZmlnLnJlbGVhc2VPbkRlcmVmID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lJHAsIHZlcnNpb24kMSwgJ3NlcnZlcmFwcCcpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBnZXQgcmVmQ291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZkNvdW50O1xyXG4gICAgfVxyXG4gICAgLy8gSW5jcmVtZW50IHRoZSByZWZlcmVuY2UgY291bnQgb2YgdGhpcyBzZXJ2ZXIgYXBwLiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQsIHJlZ2lzdGVyIGl0XHJcbiAgICAvLyB3aXRoIHRoZSBmaW5hbGl6YXRpb24gcmVnaXN0cnkuXHJcbiAgICBpbmNSZWZDb3VudChvYmopIHtcclxuICAgICAgICBpZiAodGhpcy5pc0RlbGV0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yZWZDb3VudCsrO1xyXG4gICAgICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9maW5hbGl6YXRpb25SZWdpc3RyeSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9maW5hbGl6YXRpb25SZWdpc3RyeS5yZWdpc3RlcihvYmosIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIERlY3JlbWVudCB0aGUgcmVmZXJlbmNlIGNvdW50LlxyXG4gICAgZGVjUmVmQ291bnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gLS10aGlzLl9yZWZDb3VudDtcclxuICAgIH1cclxuICAgIC8vIEludm9rZWQgYnkgdGhlIEZpbmFsaXphdGlvblJlZ2lzdHJ5IGNhbGxiYWNrIHRvIG5vdGUgdGhhdCB0aGlzIGFwcCBzaG91bGQgZ28gdGhyb3VnaCBpdHNcclxuICAgIC8vIHJlZmVyZW5jZSBjb3VudHMgYW5kIGRlbGV0ZSBpdHNlbGYgaWYgbm8gcmVmZXJlbmNlIGNvdW50IHJlbWFpbi4gVGhlIGNvb3JkaW5hdGluZyBsb2dpYyB0aGF0XHJcbiAgICAvLyBoYW5kbGVzIHRoaXMgaXMgaW4gZGVsZXRlQXBwKC4uLikuXHJcbiAgICBhdXRvbWF0aWNDbGVhbnVwKCkge1xyXG4gICAgICAgIHZvaWQgZGVsZXRlQXBwKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNldHRpbmdzKCkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2VydmVyQ29uZmlnO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gRXJyb3IgaWYgdGhlIEFwcCBoYXMgYWxyZWFkeSBiZWVuIGRlbGV0ZWQgLVxyXG4gICAgICogdXNlIGJlZm9yZSBwZXJmb3JtaW5nIEFQSSBhY3Rpb25zIG9uIHRoZSBBcHAuXHJcbiAgICAgKi9cclxuICAgIGNoZWNrRGVzdHJveWVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGVsZXRlZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcInNlcnZlci1hcHAtZGVsZXRlZFwiIC8qIEFwcEVycm9yLlNFUlZFUl9BUFBfREVMRVRFRCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaGUgY3VycmVudCBTREsgdmVyc2lvbi5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgU0RLX1ZFUlNJT04gPSB2ZXJzaW9uO1xyXG5mdW5jdGlvbiBpbml0aWFsaXplQXBwKF9vcHRpb25zLCByYXdDb25maWcgPSB7fSkge1xyXG4gICAgbGV0IG9wdGlvbnMgPSBfb3B0aW9ucztcclxuICAgIGlmICh0eXBlb2YgcmF3Q29uZmlnICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSByYXdDb25maWc7XHJcbiAgICAgICAgcmF3Q29uZmlnID0geyBuYW1lIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb25maWcgPSBPYmplY3QuYXNzaWduKHsgbmFtZTogREVGQVVMVF9FTlRSWV9OQU1FLCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ6IGZhbHNlIH0sIHJhd0NvbmZpZyk7XHJcbiAgICBjb25zdCBuYW1lID0gY29uZmlnLm5hbWU7XHJcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8ICFuYW1lKSB7XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJiYWQtYXBwLW5hbWVcIiAvKiBBcHBFcnJvci5CQURfQVBQX05BTUUgKi8sIHtcclxuICAgICAgICAgICAgYXBwTmFtZTogU3RyaW5nKG5hbWUpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0gZ2V0RGVmYXVsdEFwcENvbmZpZygpKTtcclxuICAgIGlmICghb3B0aW9ucykge1xyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwibm8tb3B0aW9uc1wiIC8qIEFwcEVycm9yLk5PX09QVElPTlMgKi8pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZXhpc3RpbmdBcHAgPSBfYXBwcy5nZXQobmFtZSk7XHJcbiAgICBpZiAoZXhpc3RpbmdBcHApIHtcclxuICAgICAgICAvLyByZXR1cm4gdGhlIGV4aXN0aW5nIGFwcCBpZiBvcHRpb25zIGFuZCBjb25maWcgZGVlcCBlcXVhbCB0aGUgb25lcyBpbiB0aGUgZXhpc3RpbmcgYXBwLlxyXG4gICAgICAgIGlmIChkZWVwRXF1YWwob3B0aW9ucywgZXhpc3RpbmdBcHAub3B0aW9ucykgJiZcclxuICAgICAgICAgICAgZGVlcEVxdWFsKGNvbmZpZywgZXhpc3RpbmdBcHAuY29uZmlnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdBcHA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImR1cGxpY2F0ZS1hcHBcIiAvKiBBcHBFcnJvci5EVVBMSUNBVEVfQVBQICovLCB7IGFwcE5hbWU6IG5hbWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgY29udGFpbmVyID0gbmV3IENvbXBvbmVudENvbnRhaW5lcihuYW1lKTtcclxuICAgIGZvciAoY29uc3QgY29tcG9uZW50IG9mIF9jb21wb25lbnRzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgY29udGFpbmVyLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmV3QXBwID0gbmV3IEZpcmViYXNlQXBwSW1wbChvcHRpb25zLCBjb25maWcsIGNvbnRhaW5lcik7XHJcbiAgICBfYXBwcy5zZXQobmFtZSwgbmV3QXBwKTtcclxuICAgIHJldHVybiBuZXdBcHA7XHJcbn1cclxuZnVuY3Rpb24gaW5pdGlhbGl6ZVNlcnZlckFwcChfb3B0aW9ucywgX3NlcnZlckFwcENvbmZpZykge1xyXG4gICAgaWYgKGlzQnJvd3NlcigpICYmICFpc1dlYldvcmtlcigpKSB7XHJcbiAgICAgICAgLy8gRmlyZWJhc2VTZXJ2ZXJBcHAgaXNuJ3QgZGVzaWduZWQgdG8gYmUgcnVuIGluIGJyb3dzZXJzLlxyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaW52YWxpZC1zZXJ2ZXItYXBwLWVudmlyb25tZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9TRVJWRVJfQVBQX0VOVklST05NRU5UICovKTtcclxuICAgIH1cclxuICAgIGlmIChfc2VydmVyQXBwQ29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgX3NlcnZlckFwcENvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGxldCBhcHBPcHRpb25zO1xyXG4gICAgaWYgKF9pc0ZpcmViYXNlQXBwKF9vcHRpb25zKSkge1xyXG4gICAgICAgIGFwcE9wdGlvbnMgPSBfb3B0aW9ucy5vcHRpb25zO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYXBwT3B0aW9ucyA9IF9vcHRpb25zO1xyXG4gICAgfVxyXG4gICAgLy8gQnVpbGQgYW4gYXBwIG5hbWUgYmFzZWQgb24gYSBoYXNoIG9mIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXHJcbiAgICBjb25zdCBuYW1lT2JqID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfc2VydmVyQXBwQ29uZmlnKSwgYXBwT3B0aW9ucyk7XHJcbiAgICAvLyBIb3dldmVyLCBEbyBub3QgbWFuZ2xlIHRoZSBuYW1lIGJhc2VkIG9uIHJlbGVhc2VPbkRlcmVmLCBzaW5jZSBpdCB3aWxsIHZhcnkgYmV0d2VlbiB0aGVcclxuICAgIC8vIGNvbnN0cnVjdGlvbiBvZiBGaXJlYmFzZVNlcnZlckFwcCBpbnN0YW5jZXMuIEZvciBleGFtcGxlLCBpZiB0aGUgb2JqZWN0IGlzIHRoZSByZXF1ZXN0IGhlYWRlcnMuXHJcbiAgICBpZiAobmFtZU9iai5yZWxlYXNlT25EZXJlZiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZGVsZXRlIG5hbWVPYmoucmVsZWFzZU9uRGVyZWY7XHJcbiAgICB9XHJcbiAgICBjb25zdCBoYXNoQ29kZSA9IChzKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIFsuLi5zXS5yZWR1Y2UoKGhhc2gsIGMpID0+IChNYXRoLmltdWwoMzEsIGhhc2gpICsgYy5jaGFyQ29kZUF0KDApKSB8IDAsIDApO1xyXG4gICAgfTtcclxuICAgIGlmIChfc2VydmVyQXBwQ29uZmlnLnJlbGVhc2VPbkRlcmVmICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImZpbmFsaXphdGlvbi1yZWdpc3RyeS1ub3Qtc3VwcG9ydGVkXCIgLyogQXBwRXJyb3IuRklOQUxJWkFUSU9OX1JFR0lTVFJZX05PVF9TVVBQT1JURUQgKi8sIHt9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBuYW1lU3RyaW5nID0gJycgKyBoYXNoQ29kZShKU09OLnN0cmluZ2lmeShuYW1lT2JqKSk7XHJcbiAgICBjb25zdCBleGlzdGluZ0FwcCA9IF9zZXJ2ZXJBcHBzLmdldChuYW1lU3RyaW5nKTtcclxuICAgIGlmIChleGlzdGluZ0FwcCkge1xyXG4gICAgICAgIGV4aXN0aW5nQXBwLmluY1JlZkNvdW50KF9zZXJ2ZXJBcHBDb25maWcucmVsZWFzZU9uRGVyZWYpO1xyXG4gICAgICAgIHJldHVybiBleGlzdGluZ0FwcDtcclxuICAgIH1cclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb21wb25lbnRDb250YWluZXIobmFtZVN0cmluZyk7XHJcbiAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBfY29tcG9uZW50cy52YWx1ZXMoKSkge1xyXG4gICAgICAgIGNvbnRhaW5lci5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5ld0FwcCA9IG5ldyBGaXJlYmFzZVNlcnZlckFwcEltcGwoYXBwT3B0aW9ucywgX3NlcnZlckFwcENvbmZpZywgbmFtZVN0cmluZywgY29udGFpbmVyKTtcclxuICAgIF9zZXJ2ZXJBcHBzLnNldChuYW1lU3RyaW5nLCBuZXdBcHApO1xyXG4gICAgcmV0dXJuIG5ld0FwcDtcclxufVxyXG4vKipcclxuICogUmV0cmlldmVzIGEge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9IGluc3RhbmNlLlxyXG4gKlxyXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cywgdGhlIGRlZmF1bHQgYXBwIGlzIHJldHVybmVkLiBXaGVuIGFuIGFwcCBuYW1lXHJcbiAqIGlzIHByb3ZpZGVkLCB0aGUgYXBwIGNvcnJlc3BvbmRpbmcgdG8gdGhhdCBuYW1lIGlzIHJldHVybmVkLlxyXG4gKlxyXG4gKiBBbiBleGNlcHRpb24gaXMgdGhyb3duIGlmIHRoZSBhcHAgYmVpbmcgcmV0cmlldmVkIGhhcyBub3QgeWV0IGJlZW5cclxuICogaW5pdGlhbGl6ZWQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gUmV0dXJuIHRoZSBkZWZhdWx0IGFwcFxyXG4gKiBjb25zdCBhcHAgPSBnZXRBcHAoKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogLy8gUmV0dXJuIGEgbmFtZWQgYXBwXHJcbiAqIGNvbnN0IG90aGVyQXBwID0gZ2V0QXBwKFwib3RoZXJBcHBcIik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gbmFtZSAtIE9wdGlvbmFsIG5hbWUgb2YgdGhlIGFwcCB0byByZXR1cm4uIElmIG5vIG5hbWUgaXNcclxuICogICBwcm92aWRlZCwgdGhlIGRlZmF1bHQgaXMgYFwiW0RFRkFVTFRdXCJgLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgYXBwIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3ZpZGVkIGFwcCBuYW1lLlxyXG4gKiAgIElmIG5vIGFwcCBuYW1lIGlzIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBhcHAgaXMgcmV0dXJuZWQuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGdldEFwcChuYW1lID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICBjb25zdCBhcHAgPSBfYXBwcy5nZXQobmFtZSk7XHJcbiAgICBpZiAoIWFwcCAmJiBuYW1lID09PSBERUZBVUxUX0VOVFJZX05BTUUgJiYgZ2V0RGVmYXVsdEFwcENvbmZpZygpKSB7XHJcbiAgICAgICAgcmV0dXJuIGluaXRpYWxpemVBcHAoKTtcclxuICAgIH1cclxuICAgIGlmICghYXBwKSB7XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJuby1hcHBcIiAvKiBBcHBFcnJvci5OT19BUFAgKi8sIHsgYXBwTmFtZTogbmFtZSB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcHA7XHJcbn1cclxuLyoqXHJcbiAqIEEgKHJlYWQtb25seSkgYXJyYXkgb2YgYWxsIGluaXRpYWxpemVkIGFwcHMuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGdldEFwcHMoKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbShfYXBwcy52YWx1ZXMoKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlbmRlcnMgdGhpcyBhcHAgdW51c2FibGUgYW5kIGZyZWVzIHRoZSByZXNvdXJjZXMgb2YgYWxsIGFzc29jaWF0ZWRcclxuICogc2VydmljZXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGphdmFzY3JpcHRcclxuICogZGVsZXRlQXBwKGFwcClcclxuICogICAudGhlbihmdW5jdGlvbigpIHtcclxuICogICAgIGNvbnNvbGUubG9nKFwiQXBwIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xyXG4gKiAgIH0pXHJcbiAqICAgLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGRlbGV0aW5nIGFwcDpcIiwgZXJyb3IpO1xyXG4gKiAgIH0pO1xyXG4gKiBgYGBcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gZGVsZXRlQXBwKGFwcCkge1xyXG4gICAgbGV0IGNsZWFudXBQcm92aWRlcnMgPSBmYWxzZTtcclxuICAgIGNvbnN0IG5hbWUgPSBhcHAubmFtZTtcclxuICAgIGlmIChfYXBwcy5oYXMobmFtZSkpIHtcclxuICAgICAgICBjbGVhbnVwUHJvdmlkZXJzID0gdHJ1ZTtcclxuICAgICAgICBfYXBwcy5kZWxldGUobmFtZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChfc2VydmVyQXBwcy5oYXMobmFtZSkpIHtcclxuICAgICAgICBjb25zdCBmaXJlYmFzZVNlcnZlckFwcCA9IGFwcDtcclxuICAgICAgICBpZiAoZmlyZWJhc2VTZXJ2ZXJBcHAuZGVjUmVmQ291bnQoKSA8PSAwKSB7XHJcbiAgICAgICAgICAgIF9zZXJ2ZXJBcHBzLmRlbGV0ZShuYW1lKTtcclxuICAgICAgICAgICAgY2xlYW51cFByb3ZpZGVycyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGNsZWFudXBQcm92aWRlcnMpIHtcclxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChhcHAuY29udGFpbmVyXHJcbiAgICAgICAgICAgIC5nZXRQcm92aWRlcnMoKVxyXG4gICAgICAgICAgICAubWFwKHByb3ZpZGVyID0+IHByb3ZpZGVyLmRlbGV0ZSgpKSk7XHJcbiAgICAgICAgYXBwLmlzRGVsZXRlZCA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlZ2lzdGVycyBhIGxpYnJhcnkncyBuYW1lIGFuZCB2ZXJzaW9uIGZvciBwbGF0Zm9ybSBsb2dnaW5nIHB1cnBvc2VzLlxyXG4gKiBAcGFyYW0gbGlicmFyeSAtIE5hbWUgb2YgMXAgb3IgM3AgbGlicmFyeSAoZS5nLiBmaXJlc3RvcmUsIGFuZ3VsYXJmaXJlKVxyXG4gKiBAcGFyYW0gdmVyc2lvbiAtIEN1cnJlbnQgdmVyc2lvbiBvZiB0aGF0IGxpYnJhcnkuXHJcbiAqIEBwYXJhbSB2YXJpYW50IC0gQnVuZGxlIHZhcmlhbnQsIGUuZy4sIG5vZGUsIHJuLCBldGMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyVmVyc2lvbihsaWJyYXJ5S2V5T3JOYW1lLCB2ZXJzaW9uLCB2YXJpYW50KSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICAvLyBUT0RPOiBXZSBjYW4gdXNlIHRoaXMgY2hlY2sgdG8gd2hpdGVsaXN0IHN0cmluZ3Mgd2hlbi9pZiB3ZSBzZXQgdXBcclxuICAgIC8vIGEgZ29vZCB3aGl0ZWxpc3Qgc3lzdGVtLlxyXG4gICAgbGV0IGxpYnJhcnkgPSAoX2EgPSBQTEFURk9STV9MT0dfU1RSSU5HW2xpYnJhcnlLZXlPck5hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBsaWJyYXJ5S2V5T3JOYW1lO1xyXG4gICAgaWYgKHZhcmlhbnQpIHtcclxuICAgICAgICBsaWJyYXJ5ICs9IGAtJHt2YXJpYW50fWA7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsaWJyYXJ5TWlzbWF0Y2ggPSBsaWJyYXJ5Lm1hdGNoKC9cXHN8XFwvLyk7XHJcbiAgICBjb25zdCB2ZXJzaW9uTWlzbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKC9cXHN8XFwvLyk7XHJcbiAgICBpZiAobGlicmFyeU1pc21hdGNoIHx8IHZlcnNpb25NaXNtYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IHdhcm5pbmcgPSBbXHJcbiAgICAgICAgICAgIGBVbmFibGUgdG8gcmVnaXN0ZXIgbGlicmFyeSBcIiR7bGlicmFyeX1cIiB3aXRoIHZlcnNpb24gXCIke3ZlcnNpb259XCI6YFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgaWYgKGxpYnJhcnlNaXNtYXRjaCkge1xyXG4gICAgICAgICAgICB3YXJuaW5nLnB1c2goYGxpYnJhcnkgbmFtZSBcIiR7bGlicmFyeX1cIiBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMgKHdoaXRlc3BhY2Ugb3IgXCIvXCIpYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsaWJyYXJ5TWlzbWF0Y2ggJiYgdmVyc2lvbk1pc21hdGNoKSB7XHJcbiAgICAgICAgICAgIHdhcm5pbmcucHVzaCgnYW5kJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2ZXJzaW9uTWlzbWF0Y2gpIHtcclxuICAgICAgICAgICAgd2FybmluZy5wdXNoKGB2ZXJzaW9uIG5hbWUgXCIke3ZlcnNpb259XCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzICh3aGl0ZXNwYWNlIG9yIFwiL1wiKWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsb2dnZXIud2Fybih3YXJuaW5nLmpvaW4oJyAnKSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoYCR7bGlicmFyeX0tdmVyc2lvbmAsICgpID0+ICh7IGxpYnJhcnksIHZlcnNpb24gfSksIFwiVkVSU0lPTlwiIC8qIENvbXBvbmVudFR5cGUuVkVSU0lPTiAqLykpO1xyXG59XHJcbi8qKlxyXG4gKiBTZXRzIGxvZyBoYW5kbGVyIGZvciBhbGwgRmlyZWJhc2UgU0RLcy5cclxuICogQHBhcmFtIGxvZ0NhbGxiYWNrIC0gQW4gb3B0aW9uYWwgY3VzdG9tIGxvZyBoYW5kbGVyIHRoYXQgZXhlY3V0ZXMgdXNlciBjb2RlIHdoZW5ldmVyXHJcbiAqIHRoZSBGaXJlYmFzZSBTREsgbWFrZXMgYSBsb2dnaW5nIGNhbGwuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIG9uTG9nKGxvZ0NhbGxiYWNrLCBvcHRpb25zKSB7XHJcbiAgICBpZiAobG9nQ2FsbGJhY2sgIT09IG51bGwgJiYgdHlwZW9mIGxvZ0NhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpbnZhbGlkLWxvZy1hcmd1bWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfTE9HX0FSR1VNRU5UICovKTtcclxuICAgIH1cclxuICAgIHNldFVzZXJMb2dIYW5kbGVyKGxvZ0NhbGxiYWNrLCBvcHRpb25zKTtcclxufVxyXG4vKipcclxuICogU2V0cyBsb2cgbGV2ZWwgZm9yIGFsbCBGaXJlYmFzZSBTREtzLlxyXG4gKlxyXG4gKiBBbGwgb2YgdGhlIGxvZyB0eXBlcyBhYm92ZSB0aGUgY3VycmVudCBsb2cgbGV2ZWwgYXJlIGNhcHR1cmVkIChpLmUuIGlmXHJcbiAqIHlvdSBzZXQgdGhlIGxvZyBsZXZlbCB0byBgaW5mb2AsIGVycm9ycyBhcmUgbG9nZ2VkLCBidXQgYGRlYnVnYCBhbmRcclxuICogYHZlcmJvc2VgIGxvZ3MgYXJlIG5vdCkuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxvZ0xldmVsKSB7XHJcbiAgICBzZXRMb2dMZXZlbCQxKGxvZ0xldmVsKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBEQl9OQU1FID0gJ2ZpcmViYXNlLWhlYXJ0YmVhdC1kYXRhYmFzZSc7XHJcbmNvbnN0IERCX1ZFUlNJT04gPSAxO1xyXG5jb25zdCBTVE9SRV9OQU1FID0gJ2ZpcmViYXNlLWhlYXJ0YmVhdC1zdG9yZSc7XHJcbmxldCBkYlByb21pc2UgPSBudWxsO1xyXG5mdW5jdGlvbiBnZXREYlByb21pc2UoKSB7XHJcbiAgICBpZiAoIWRiUHJvbWlzZSkge1xyXG4gICAgICAgIGRiUHJvbWlzZSA9IG9wZW5EQihEQl9OQU1FLCBEQl9WRVJTSU9OLCB7XHJcbiAgICAgICAgICAgIHVwZ3JhZGU6IChkYiwgb2xkVmVyc2lvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdXNlICdicmVhaycgaW4gdGhpcyBzd2l0Y2ggc3RhdGVtZW50LCB0aGUgZmFsbC10aHJvdWdoXHJcbiAgICAgICAgICAgICAgICAvLyBiZWhhdmlvciBpcyB3aGF0IHdlIHdhbnQsIGJlY2F1c2UgaWYgdGhlcmUgYXJlIG11bHRpcGxlIHZlcnNpb25zIGJldHdlZW5cclxuICAgICAgICAgICAgICAgIC8vIHRoZSBvbGQgdmVyc2lvbiBhbmQgdGhlIGN1cnJlbnQgdmVyc2lvbiwgd2Ugd2FudCBBTEwgdGhlIG1pZ3JhdGlvbnNcclxuICAgICAgICAgICAgICAgIC8vIHRoYXQgY29ycmVzcG9uZCB0byB0aG9zZSB2ZXJzaW9ucyB0byBydW4sIG5vdCBvbmx5IHRoZSBsYXN0IG9uZS5cclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZWZhdWx0LWNhc2VcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob2xkVmVyc2lvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKFNUT1JFX05BTUUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkvaU9TIGJyb3dzZXJzIHRocm93IG9jY2FzaW9uYWwgZXhjZXB0aW9ucyBvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGIuY3JlYXRlT2JqZWN0U3RvcmUoKSB0aGF0IG1heSBiZSBhIGJ1Zy4gQXZvaWQgYmxvY2tpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSByZXN0IG9mIHRoZSBhcHAgZnVuY3Rpb25hbGl0eS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaWRiLW9wZW5cIiAvKiBBcHBFcnJvci5JREJfT1BFTiAqLywge1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFcnJvck1lc3NhZ2U6IGUubWVzc2FnZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBkYlByb21pc2U7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gcmVhZEhlYXJ0YmVhdHNGcm9tSW5kZXhlZERCKGFwcCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkYiA9IGF3YWl0IGdldERiUHJvbWlzZSgpO1xyXG4gICAgICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oU1RPUkVfTkFNRSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdHgub2JqZWN0U3RvcmUoU1RPUkVfTkFNRSkuZ2V0KGNvbXB1dGVLZXkoYXBwKSk7XHJcbiAgICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIHRoZSB2YWx1ZSBidXQgdHguZG9uZSBjYW4gdGhyb3csXHJcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byBhd2FpdCBpdCBoZXJlIHRvIGNhdGNoIGVycm9yc1xyXG4gICAgICAgIGF3YWl0IHR4LmRvbmU7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGUubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBpZGJHZXRFcnJvciA9IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaWRiLWdldFwiIC8qIEFwcEVycm9yLklEQl9HRVQgKi8sIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oaWRiR2V0RXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHdyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCKGFwcCwgaGVhcnRiZWF0T2JqZWN0KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XHJcbiAgICAgICAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbihTVE9SRV9OQU1FLCAncmVhZHdyaXRlJyk7XHJcbiAgICAgICAgY29uc3Qgb2JqZWN0U3RvcmUgPSB0eC5vYmplY3RTdG9yZShTVE9SRV9OQU1FKTtcclxuICAgICAgICBhd2FpdCBvYmplY3RTdG9yZS5wdXQoaGVhcnRiZWF0T2JqZWN0LCBjb21wdXRlS2V5KGFwcCkpO1xyXG4gICAgICAgIGF3YWl0IHR4LmRvbmU7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvcikge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybihlLm1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaWRiR2V0RXJyb3IgPSBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImlkYi1zZXRcIiAvKiBBcHBFcnJvci5JREJfV1JJVEUgKi8sIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oaWRiR2V0RXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbXB1dGVLZXkoYXBwKSB7XHJcbiAgICByZXR1cm4gYCR7YXBwLm5hbWV9ISR7YXBwLm9wdGlvbnMuYXBwSWR9YDtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBNQVhfSEVBREVSX0JZVEVTID0gMTAyNDtcclxuLy8gMzAgZGF5c1xyXG5jb25zdCBTVE9SRURfSEVBUlRCRUFUX1JFVEVOVElPTl9NQVhfTUlMTElTID0gMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xyXG5jbGFzcyBIZWFydGJlYXRTZXJ2aWNlSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbi1tZW1vcnkgY2FjaGUgZm9yIGhlYXJ0YmVhdHMsIHVzZWQgYnkgZ2V0SGVhcnRiZWF0c0hlYWRlcigpIHRvIGdlbmVyYXRlXHJcbiAgICAgICAgICogdGhlIGhlYWRlciBzdHJpbmcuXHJcbiAgICAgICAgICogU3RvcmVzIG9uZSByZWNvcmQgcGVyIGRhdGUuIFRoaXMgd2lsbCBiZSBjb25zb2xpZGF0ZWQgaW50byB0aGUgc3RhbmRhcmRcclxuICAgICAgICAgKiBmb3JtYXQgb2Ygb25lIHJlY29yZCBwZXIgdXNlciBhZ2VudCBzdHJpbmcgYmVmb3JlIGJlaW5nIHNlbnQgYXMgYSBoZWFkZXIuXHJcbiAgICAgICAgICogUG9wdWxhdGVkIGZyb20gaW5kZXhlZERCIHdoZW4gdGhlIGNvbnRyb2xsZXIgaXMgaW5zdGFudGlhdGVkIGFuZCBzaG91bGRcclxuICAgICAgICAgKiBiZSBrZXB0IGluIHN5bmMgd2l0aCBpbmRleGVkREIuXHJcbiAgICAgICAgICogTGVhdmUgcHVibGljIGZvciBlYXNpZXIgdGVzdGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IGFwcCA9IHRoaXMuY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICB0aGlzLl9zdG9yYWdlID0gbmV3IEhlYXJ0YmVhdFN0b3JhZ2VJbXBsKGFwcCk7XHJcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZSA9IHRoaXMuX3N0b3JhZ2UucmVhZCgpLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gcmVzdWx0O1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgdG8gcmVwb3J0IGEgaGVhcnRiZWF0LiBUaGUgZnVuY3Rpb24gd2lsbCBnZW5lcmF0ZVxyXG4gICAgICogYSBIZWFydGJlYXRzQnlVc2VyQWdlbnQgb2JqZWN0LCB1cGRhdGUgaGVhcnRiZWF0c0NhY2hlLCBhbmQgcGVyc2lzdCBpdFxyXG4gICAgICogdG8gSW5kZXhlZERCLlxyXG4gICAgICogTm90ZSB0aGF0IHdlIG9ubHkgc3RvcmUgb25lIGhlYXJ0YmVhdCBwZXIgZGF5LiBTbyBpZiBhIGhlYXJ0YmVhdCBmb3IgdG9kYXkgaXNcclxuICAgICAqIGFscmVhZHkgbG9nZ2VkLCBzdWJzZXF1ZW50IGNhbGxzIHRvIHRoaXMgZnVuY3Rpb24gaW4gdGhlIHNhbWUgZGF5IHdpbGwgYmUgaWdub3JlZC5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgdHJpZ2dlckhlYXJ0YmVhdCgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBwbGF0Zm9ybUxvZ2dlciA9IHRoaXMuY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAuZ2V0UHJvdmlkZXIoJ3BsYXRmb3JtLWxvZ2dlcicpXHJcbiAgICAgICAgICAgICAgICAuZ2V0SW1tZWRpYXRlKCk7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIFwiRmlyZWJhc2UgdXNlciBhZ2VudFwiIHN0cmluZyBmcm9tIHRoZSBwbGF0Zm9ybSBsb2dnZXJcclxuICAgICAgICAgICAgLy8gc2VydmljZSwgbm90IHRoZSBicm93c2VyIHVzZXIgYWdlbnQuXHJcbiAgICAgICAgICAgIGNvbnN0IGFnZW50ID0gcGxhdGZvcm1Mb2dnZXIuZ2V0UGxhdGZvcm1JbmZvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBnZXRVVENEYXRlU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdoZWFydGJlYXRzJywgKF9hID0gdGhpcy5faGVhcnRiZWF0c0NhY2hlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhcnRiZWF0cyk7XHJcbiAgICAgICAgICAgIGlmICgoKF9iID0gdGhpcy5faGVhcnRiZWF0c0NhY2hlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVhcnRiZWF0cykgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gYXdhaXQgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZTtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGZhaWxlZCB0byBjb25zdHJ1Y3QgYSBoZWFydGJlYXRzIGNhY2hlLCB0aGVuIHJldHVybiBpbW1lZGlhdGVseS5cclxuICAgICAgICAgICAgICAgIGlmICgoKF9jID0gdGhpcy5faGVhcnRiZWF0c0NhY2hlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaGVhcnRiZWF0cykgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBEbyBub3Qgc3RvcmUgYSBoZWFydGJlYXQgaWYgb25lIGlzIGFscmVhZHkgc3RvcmVkIGZvciB0aGlzIGRheVxyXG4gICAgICAgICAgICAvLyBvciBpZiBhIGhlYWRlciBoYXMgYWxyZWFkeSBiZWVuIHNlbnQgdG9kYXkuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9oZWFydGJlYXRzQ2FjaGUubGFzdFNlbnRIZWFydGJlYXREYXRlID09PSBkYXRlIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5zb21lKHNpbmdsZURhdGVIZWFydGJlYXQgPT4gc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlID09PSBkYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gZW50cnkgZm9yIHRoaXMgZGF0ZS4gQ3JlYXRlIG9uZS5cclxuICAgICAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzLnB1c2goeyBkYXRlLCBhZ2VudCB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgZW50cmllcyBvbGRlciB0aGFuIDMwIGRheXMuXHJcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzID1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzLmZpbHRlcihzaW5nbGVEYXRlSGVhcnRiZWF0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYlRpbWVzdGFtcCA9IG5ldyBEYXRlKHNpbmdsZURhdGVIZWFydGJlYXQuZGF0ZSkudmFsdWVPZigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vdyAtIGhiVGltZXN0YW1wIDw9IFNUT1JFRF9IRUFSVEJFQVRfUkVURU5USU9OX01BWF9NSUxMSVM7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2Uub3ZlcndyaXRlKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB3aGljaCBjYW4gYmUgYXR0YWNoZWQgdG8gdGhlIGhlYXJ0YmVhdC1zcGVjaWZpYyBoZWFkZXIgZGlyZWN0bHkuXHJcbiAgICAgKiBJdCBhbHNvIGNsZWFycyBhbGwgaGVhcnRiZWF0cyBmcm9tIG1lbW9yeSBhcyB3ZWxsIGFzIGluIEluZGV4ZWREQi5cclxuICAgICAqXHJcbiAgICAgKiBOT1RFOiBDb25zdW1pbmcgcHJvZHVjdCBTREtzIHNob3VsZCBub3Qgc2VuZCB0aGUgaGVhZGVyIGlmIHRoaXMgbWV0aG9kXHJcbiAgICAgKiByZXR1cm5zIGFuIGVtcHR5IHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2V0SGVhcnRiZWF0c0hlYWRlcigpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJZiBpdCdzIHN0aWxsIG51bGwgb3IgdGhlIGFycmF5IGlzIGVtcHR5LCB0aGVyZSBpcyBubyBkYXRhIHRvIHNlbmQuXHJcbiAgICAgICAgICAgIGlmICgoKF9hID0gdGhpcy5faGVhcnRiZWF0c0NhY2hlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhcnRiZWF0cykgPT0gbnVsbCB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IGdldFVUQ0RhdGVTdHJpbmcoKTtcclxuICAgICAgICAgICAgLy8gRXh0cmFjdCBhcyBtYW55IGhlYXJ0YmVhdHMgZnJvbSB0aGUgY2FjaGUgYXMgd2lsbCBmaXQgdW5kZXIgdGhlIHNpemUgbGltaXQuXHJcbiAgICAgICAgICAgIGNvbnN0IHsgaGVhcnRiZWF0c1RvU2VuZCwgdW5zZW50RW50cmllcyB9ID0gZXh0cmFjdEhlYXJ0YmVhdHNGb3JIZWFkZXIodGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMpO1xyXG4gICAgICAgICAgICBjb25zdCBoZWFkZXJTdHJpbmcgPSBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhKU09OLnN0cmluZ2lmeSh7IHZlcnNpb246IDIsIGhlYXJ0YmVhdHM6IGhlYXJ0YmVhdHNUb1NlbmQgfSkpO1xyXG4gICAgICAgICAgICAvLyBTdG9yZSBsYXN0IHNlbnQgZGF0ZSB0byBwcmV2ZW50IGFub3RoZXIgYmVpbmcgbG9nZ2VkL3NlbnQgZm9yIHRoZSBzYW1lIGRheS5cclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmxhc3RTZW50SGVhcnRiZWF0RGF0ZSA9IGRhdGU7XHJcbiAgICAgICAgICAgIGlmICh1bnNlbnRFbnRyaWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIGFueSB1bnNlbnQgZW50cmllcyBpZiB0aGV5IGV4aXN0LlxyXG4gICAgICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMgPSB1bnNlbnRFbnRyaWVzO1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzZWVtcyBtb3JlIGxpa2VseSB0aGFuIGVtcHR5aW5nIHRoZSBhcnJheSAoYmVsb3cpIHRvIGxlYWQgdG8gc29tZSBvZGQgc3RhdGVcclxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBjYWNoZSBpc24ndCBlbXB0eSBhbmQgdGhpcyB3aWxsIGJlIGNhbGxlZCBhZ2FpbiBvbiB0aGUgbmV4dCByZXF1ZXN0LFxyXG4gICAgICAgICAgICAgICAgLy8gYW5kIGlzIHByb2JhYmx5IHNhZmVzdCBpZiB3ZSBhd2FpdCBpdC5cclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3N0b3JhZ2Uub3ZlcndyaXRlKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IHdhaXQgZm9yIHRoaXMsIHRvIHJlZHVjZSBsYXRlbmN5LlxyXG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLl9zdG9yYWdlLm92ZXJ3cml0ZSh0aGlzLl9oZWFydGJlYXRzQ2FjaGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJTdHJpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFVUQ0RhdGVTdHJpbmcoKSB7XHJcbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XHJcbiAgICAvLyBSZXR1cm5zIGRhdGUgZm9ybWF0ICdZWVlZLU1NLUREJ1xyXG4gICAgcmV0dXJuIHRvZGF5LnRvSVNPU3RyaW5nKCkuc3Vic3RyaW5nKDAsIDEwKTtcclxufVxyXG5mdW5jdGlvbiBleHRyYWN0SGVhcnRiZWF0c0ZvckhlYWRlcihoZWFydGJlYXRzQ2FjaGUsIG1heFNpemUgPSBNQVhfSEVBREVSX0JZVEVTKSB7XHJcbiAgICAvLyBIZWFydGJlYXRzIGdyb3VwZWQgYnkgdXNlciBhZ2VudCBpbiB0aGUgc3RhbmRhcmQgZm9ybWF0IHRvIGJlIHNlbnQgaW5cclxuICAgIC8vIHRoZSBoZWFkZXIuXHJcbiAgICBjb25zdCBoZWFydGJlYXRzVG9TZW5kID0gW107XHJcbiAgICAvLyBTaW5nbGUgZGF0ZSBmb3JtYXQgaGVhcnRiZWF0cyB0aGF0IGFyZSBub3Qgc2VudC5cclxuICAgIGxldCB1bnNlbnRFbnRyaWVzID0gaGVhcnRiZWF0c0NhY2hlLnNsaWNlKCk7XHJcbiAgICBmb3IgKGNvbnN0IHNpbmdsZURhdGVIZWFydGJlYXQgb2YgaGVhcnRiZWF0c0NhY2hlKSB7XHJcbiAgICAgICAgLy8gTG9vayBmb3IgYW4gZXhpc3RpbmcgZW50cnkgd2l0aCB0aGUgc2FtZSB1c2VyIGFnZW50LlxyXG4gICAgICAgIGNvbnN0IGhlYXJ0YmVhdEVudHJ5ID0gaGVhcnRiZWF0c1RvU2VuZC5maW5kKGhiID0+IGhiLmFnZW50ID09PSBzaW5nbGVEYXRlSGVhcnRiZWF0LmFnZW50KTtcclxuICAgICAgICBpZiAoIWhlYXJ0YmVhdEVudHJ5KSB7XHJcbiAgICAgICAgICAgIC8vIElmIG5vIGVudHJ5IGZvciB0aGlzIHVzZXIgYWdlbnQgZXhpc3RzLCBjcmVhdGUgb25lLlxyXG4gICAgICAgICAgICBoZWFydGJlYXRzVG9TZW5kLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgYWdlbnQ6IHNpbmdsZURhdGVIZWFydGJlYXQuYWdlbnQsXHJcbiAgICAgICAgICAgICAgICBkYXRlczogW3NpbmdsZURhdGVIZWFydGJlYXQuZGF0ZV1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChjb3VudEJ5dGVzKGhlYXJ0YmVhdHNUb1NlbmQpID4gbWF4U2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGhlYWRlciB3b3VsZCBleGNlZWQgbWF4IHNpemUsIHJlbW92ZSB0aGUgYWRkZWQgaGVhcnRiZWF0XHJcbiAgICAgICAgICAgICAgICAvLyBlbnRyeSBhbmQgc3RvcCBhZGRpbmcgdG8gdGhlIGhlYWRlci5cclxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdHNUb1NlbmQucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGVhcnRiZWF0RW50cnkuZGF0ZXMucHVzaChzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGUpO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgaGVhZGVyIHdvdWxkIGV4Y2VlZCBtYXggc2l6ZSwgcmVtb3ZlIHRoZSBhZGRlZCBkYXRlXHJcbiAgICAgICAgICAgIC8vIGFuZCBzdG9wIGFkZGluZyB0byB0aGUgaGVhZGVyLlxyXG4gICAgICAgICAgICBpZiAoY291bnRCeXRlcyhoZWFydGJlYXRzVG9TZW5kKSA+IG1heFNpemUpIHtcclxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdEVudHJ5LmRhdGVzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUG9wIHVuc2VudCBlbnRyeSBmcm9tIHF1ZXVlLiAoU2tpcHBlZCBpZiBhZGRpbmcgdGhlIGVudHJ5IGV4Y2VlZGVkXHJcbiAgICAgICAgLy8gcXVvdGEgYW5kIHRoZSBsb29wIGJyZWFrcyBlYXJseS4pXHJcbiAgICAgICAgdW5zZW50RW50cmllcyA9IHVuc2VudEVudHJpZXMuc2xpY2UoMSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGhlYXJ0YmVhdHNUb1NlbmQsXHJcbiAgICAgICAgdW5zZW50RW50cmllc1xyXG4gICAgfTtcclxufVxyXG5jbGFzcyBIZWFydGJlYXRTdG9yYWdlSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHApIHtcclxuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcclxuICAgICAgICB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlID0gdGhpcy5ydW5JbmRleGVkREJFbnZpcm9ubWVudENoZWNrKCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBydW5JbmRleGVkREJFbnZpcm9ubWVudENoZWNrKCkge1xyXG4gICAgICAgIGlmICghaXNJbmRleGVkREJBdmFpbGFibGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSgpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0cnVlKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgYWxsIGhlYXJ0YmVhdHMuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHJlYWQoKSB7XHJcbiAgICAgICAgY29uc3QgY2FuVXNlSW5kZXhlZERCID0gYXdhaXQgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZTtcclxuICAgICAgICBpZiAoIWNhblVzZUluZGV4ZWREQikge1xyXG4gICAgICAgICAgICByZXR1cm4geyBoZWFydGJlYXRzOiBbXSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgaWRiSGVhcnRiZWF0T2JqZWN0ID0gYXdhaXQgcmVhZEhlYXJ0YmVhdHNGcm9tSW5kZXhlZERCKHRoaXMuYXBwKTtcclxuICAgICAgICAgICAgaWYgKGlkYkhlYXJ0YmVhdE9iamVjdCA9PT0gbnVsbCB8fCBpZGJIZWFydGJlYXRPYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlkYkhlYXJ0YmVhdE9iamVjdC5oZWFydGJlYXRzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaWRiSGVhcnRiZWF0T2JqZWN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaGVhcnRiZWF0czogW10gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG92ZXJ3cml0ZSB0aGUgc3RvcmFnZSB3aXRoIHRoZSBwcm92aWRlZCBoZWFydGJlYXRzXHJcbiAgICBhc3luYyBvdmVyd3JpdGUoaGVhcnRiZWF0c09iamVjdCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBjYW5Vc2VJbmRleGVkREIgPSBhd2FpdCB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlO1xyXG4gICAgICAgIGlmICghY2FuVXNlSW5kZXhlZERCKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdCA9IGF3YWl0IHRoaXMucmVhZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gd3JpdGVIZWFydGJlYXRzVG9JbmRleGVkREIodGhpcy5hcHAsIHtcclxuICAgICAgICAgICAgICAgIGxhc3RTZW50SGVhcnRiZWF0RGF0ZTogKF9hID0gaGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUsXHJcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRzOiBoZWFydGJlYXRzT2JqZWN0LmhlYXJ0YmVhdHNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gYWRkIGhlYXJ0YmVhdHNcclxuICAgIGFzeW5jIGFkZChoZWFydGJlYXRzT2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IGNhblVzZUluZGV4ZWREQiA9IGF3YWl0IHRoaXMuX2NhblVzZUluZGV4ZWREQlByb21pc2U7XHJcbiAgICAgICAgaWYgKCFjYW5Vc2VJbmRleGVkREIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0ID0gYXdhaXQgdGhpcy5yZWFkKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQih0aGlzLmFwcCwge1xyXG4gICAgICAgICAgICAgICAgbGFzdFNlbnRIZWFydGJlYXREYXRlOiAoX2EgPSBoZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSxcclxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdHM6IFtcclxuICAgICAgICAgICAgICAgICAgICAuLi5leGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QuaGVhcnRiZWF0cyxcclxuICAgICAgICAgICAgICAgICAgICAuLi5oZWFydGJlYXRzT2JqZWN0LmhlYXJ0YmVhdHNcclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgYnl0ZXMgb2YgYSBIZWFydGJlYXRzQnlVc2VyQWdlbnQgYXJyYXkgYWZ0ZXIgYmVpbmcgd3JhcHBlZFxyXG4gKiBpbiBhIHBsYXRmb3JtIGxvZ2dpbmcgaGVhZGVyIEpTT04gb2JqZWN0LCBzdHJpbmdpZmllZCwgYW5kIGNvbnZlcnRlZFxyXG4gKiB0byBiYXNlIDY0LlxyXG4gKi9cclxuZnVuY3Rpb24gY291bnRCeXRlcyhoZWFydGJlYXRzQ2FjaGUpIHtcclxuICAgIC8vIGJhc2U2NCBoYXMgYSByZXN0cmljdGVkIHNldCBvZiBjaGFyYWN0ZXJzLCBhbGwgb2Ygd2hpY2ggc2hvdWxkIGJlIDEgYnl0ZS5cclxuICAgIHJldHVybiBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhcclxuICAgIC8vIGhlYXJ0YmVhdHNDYWNoZSB3cmFwcGVyIHByb3BlcnRpZXNcclxuICAgIEpTT04uc3RyaW5naWZ5KHsgdmVyc2lvbjogMiwgaGVhcnRiZWF0czogaGVhcnRiZWF0c0NhY2hlIH0pKS5sZW5ndGg7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVnaXN0ZXJDb3JlQ29tcG9uZW50cyh2YXJpYW50KSB7XHJcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudCgncGxhdGZvcm0tbG9nZ2VyJywgY29udGFpbmVyID0+IG5ldyBQbGF0Zm9ybUxvZ2dlclNlcnZpY2VJbXBsKGNvbnRhaW5lciksIFwiUFJJVkFURVwiIC8qIENvbXBvbmVudFR5cGUuUFJJVkFURSAqLykpO1xyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2hlYXJ0YmVhdCcsIGNvbnRhaW5lciA9PiBuZXcgSGVhcnRiZWF0U2VydmljZUltcGwoY29udGFpbmVyKSwgXCJQUklWQVRFXCIgLyogQ29tcG9uZW50VHlwZS5QUklWQVRFICovKSk7XHJcbiAgICAvLyBSZWdpc3RlciBgYXBwYCBwYWNrYWdlLlxyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUkcCwgdmVyc2lvbiQxLCB2YXJpYW50KTtcclxuICAgIC8vIEJVSUxEX1RBUkdFVCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHZhbHVlcyBsaWtlIGVzbTUsIGVzbTIwMTcsIGNqczUsIGV0YyBkdXJpbmcgdGhlIGNvbXBpbGF0aW9uXHJcbiAgICByZWdpc3RlclZlcnNpb24obmFtZSRwLCB2ZXJzaW9uJDEsICdlc20yMDE3Jyk7XHJcbiAgICAvLyBSZWdpc3RlciBwbGF0Zm9ybSBTREsgaWRlbnRpZmllciAobm8gdmVyc2lvbikuXHJcbiAgICByZWdpc3RlclZlcnNpb24oJ2ZpcmUtanMnLCAnJyk7XHJcbn1cblxuLyoqXHJcbiAqIEZpcmViYXNlIEFwcFxyXG4gKlxyXG4gKiBAcmVtYXJrcyBUaGlzIHBhY2thZ2UgY29vcmRpbmF0ZXMgdGhlIGNvbW11bmljYXRpb24gYmV0d2VlbiB0aGUgZGlmZmVyZW50IEZpcmViYXNlIGNvbXBvbmVudHNcclxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXHJcbiAqL1xyXG5yZWdpc3RlckNvcmVDb21wb25lbnRzKCcnKTtcblxuZXhwb3J0IHsgU0RLX1ZFUlNJT04sIERFRkFVTFRfRU5UUllfTkFNRSBhcyBfREVGQVVMVF9FTlRSWV9OQU1FLCBfYWRkQ29tcG9uZW50LCBfYWRkT3JPdmVyd3JpdGVDb21wb25lbnQsIF9hcHBzLCBfY2xlYXJDb21wb25lbnRzLCBfY29tcG9uZW50cywgX2dldFByb3ZpZGVyLCBfaXNGaXJlYmFzZUFwcCwgX2lzRmlyZWJhc2VTZXJ2ZXJBcHAsIF9yZWdpc3RlckNvbXBvbmVudCwgX3JlbW92ZVNlcnZpY2VJbnN0YW5jZSwgX3NlcnZlckFwcHMsIGRlbGV0ZUFwcCwgZ2V0QXBwLCBnZXRBcHBzLCBpbml0aWFsaXplQXBwLCBpbml0aWFsaXplU2VydmVyQXBwLCBvbkxvZywgcmVnaXN0ZXJWZXJzaW9uLCBzZXRMb2dMZXZlbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiIsImltcG9ydCB7IHJlZ2lzdGVyVmVyc2lvbiB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuZXhwb3J0ICogZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5cbnZhciBuYW1lID0gXCJmaXJlYmFzZVwiO1xudmFyIHZlcnNpb24gPSBcIjEwLjEzLjBcIjtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxucmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sICdhcHAnKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiIsImltcG9ydCB7IF9yZWdpc3RlckNvbXBvbmVudCwgcmVnaXN0ZXJWZXJzaW9uLCBfZ2V0UHJvdmlkZXIsIGdldEFwcCB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgRmlyZWJhc2VFcnJvciwgZ2V0TW9kdWxhckluc3RhbmNlLCBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTE9OR19UWVBFID0gJ3R5cGUuZ29vZ2xlYXBpcy5jb20vZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWUnO1xyXG5jb25zdCBVTlNJR05FRF9MT05HX1RZUEUgPSAndHlwZS5nb29nbGVhcGlzLmNvbS9nb29nbGUucHJvdG9idWYuVUludDY0VmFsdWUnO1xyXG5mdW5jdGlvbiBtYXBWYWx1ZXMoXHJcbi8vIHsgW2s6IHN0cmluZ106IHVua25vd24gfSBpcyBubyBsb25nZXIgYSB3aWxkY2FyZCBhc3NpZ25tZW50IHRhcmdldCBhZnRlciB0eXBlc2NyaXB0IDMuNVxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG5vLCBmKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG8pIHtcclxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gZihvW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIFRha2VzIGRhdGEgYW5kIGVuY29kZXMgaXQgaW4gYSBKU09OLWZyaWVuZGx5IHdheSwgc3VjaCB0aGF0IHR5cGVzIHN1Y2ggYXNcclxuICogRGF0ZSBhcmUgcHJlc2VydmVkLlxyXG4gKiBAaW50ZXJuYWxcclxuICogQHBhcmFtIGRhdGEgLSBEYXRhIHRvIGVuY29kZS5cclxuICovXHJcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XHJcbiAgICBpZiAoZGF0YSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIE51bWJlcikge1xyXG4gICAgICAgIGRhdGEgPSBkYXRhLnZhbHVlT2YoKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoZGF0YSkpIHtcclxuICAgICAgICAvLyBBbnkgbnVtYmVyIGluIEpTIGlzIHNhZmUgdG8gcHV0IGRpcmVjdGx5IGluIEpTT04gYW5kIHBhcnNlIGFzIGEgZG91YmxlXHJcbiAgICAgICAgLy8gd2l0aG91dCBhbnkgbG9zcyBvZiBwcmVjaXNpb24uXHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbiAgICBpZiAoZGF0YSA9PT0gdHJ1ZSB8fCBkYXRhID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBkYXRhLnRvSVNPU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xyXG4gICAgICAgIHJldHVybiBkYXRhLm1hcCh4ID0+IGVuY29kZSh4KSk7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hcFZhbHVlcyhkYXRhLCB4ID0+IGVuY29kZSh4KSk7XHJcbiAgICB9XHJcbiAgICAvLyBJZiB3ZSBnb3QgdGhpcyBmYXIsIHRoZSBkYXRhIGlzIG5vdCBlbmNvZGFibGUuXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgY2Fubm90IGJlIGVuY29kZWQgaW4gSlNPTjogJyArIGRhdGEpO1xyXG59XHJcbi8qKlxyXG4gKiBUYWtlcyBkYXRhIHRoYXQncyBiZWVuIGVuY29kZWQgaW4gYSBKU09OLWZyaWVuZGx5IGZvcm0gYW5kIHJldHVybnMgYSBmb3JtXHJcbiAqIHdpdGggcmljaGVyIGRhdGF0eXBlcywgc3VjaCBhcyBEYXRlcywgZXRjLlxyXG4gKiBAaW50ZXJuYWxcclxuICogQHBhcmFtIGpzb24gLSBKU09OIHRvIGNvbnZlcnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWNvZGUoanNvbikge1xyXG4gICAgaWYgKGpzb24gPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBqc29uO1xyXG4gICAgfVxyXG4gICAgaWYgKGpzb25bJ0B0eXBlJ10pIHtcclxuICAgICAgICBzd2l0Y2ggKGpzb25bJ0B0eXBlJ10pIHtcclxuICAgICAgICAgICAgY2FzZSBMT05HX1RZUEU6XHJcbiAgICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaCBhbmQgaGFuZGxlIHRoaXMgdGhlIHNhbWUgYXMgdW5zaWduZWQuXHJcbiAgICAgICAgICAgIGNhc2UgVU5TSUdORURfTE9OR19UWVBFOiB7XHJcbiAgICAgICAgICAgICAgICAvLyBUZWNobmljYWxseSwgdGhpcyBjb3VsZCB3b3JrIHJldHVybiBhIHZhbGlkIG51bWJlciBmb3IgbWFsZm9ybWVkXHJcbiAgICAgICAgICAgICAgICAvLyBkYXRhIGlmIHRoZXJlIHdhcyBhIG51bWJlciBmb2xsb3dlZCBieSBnYXJiYWdlLiBCdXQgaXQncyBqdXN0IG5vdFxyXG4gICAgICAgICAgICAgICAgLy8gd29ydGggYWxsIHRoZSBleHRyYSBjb2RlIHRvIGRldGVjdCB0aGF0IGNhc2UuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IE51bWJlcihqc29uWyd2YWx1ZSddKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgY2Fubm90IGJlIGRlY29kZWQgZnJvbSBKU09OOiAnICsganNvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGNhbm5vdCBiZSBkZWNvZGVkIGZyb20gSlNPTjogJyArIGpzb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoanNvbikpIHtcclxuICAgICAgICByZXR1cm4ganNvbi5tYXAoeCA9PiBkZWNvZGUoeCkpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBqc29uID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBqc29uID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHJldHVybiBtYXBWYWx1ZXMoanNvbiwgeCA9PiBkZWNvZGUoeCkpO1xyXG4gICAgfVxyXG4gICAgLy8gQW55dGhpbmcgZWxzZSBpcyBzYWZlIHRvIHJldHVybi5cclxuICAgIHJldHVybiBqc29uO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUeXBlIGNvbnN0YW50IGZvciBGaXJlYmFzZSBGdW5jdGlvbnMuXHJcbiAqL1xyXG5jb25zdCBGVU5DVElPTlNfVFlQRSA9ICdmdW5jdGlvbnMnO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogU3RhbmRhcmQgZXJyb3IgY29kZXMgZm9yIGRpZmZlcmVudCB3YXlzIGEgcmVxdWVzdCBjYW4gZmFpbCwgYXMgZGVmaW5lZCBieTpcclxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZWFwaXMvZ29vZ2xlYXBpcy9ibG9iL21hc3Rlci9nb29nbGUvcnBjL2NvZGUucHJvdG9cclxuICpcclxuICogVGhpcyBtYXAgaXMgdXNlZCBwcmltYXJpbHkgdG8gY29udmVydCBmcm9tIGEgYmFja2VuZCBlcnJvciBjb2RlIHN0cmluZyB0b1xyXG4gKiBhIGNsaWVudCBTREsgZXJyb3IgY29kZSBzdHJpbmcsIGFuZCBtYWtlIHN1cmUgaXQncyBpbiB0aGUgc3VwcG9ydGVkIHNldC5cclxuICovXHJcbmNvbnN0IGVycm9yQ29kZU1hcCA9IHtcclxuICAgIE9LOiAnb2snLFxyXG4gICAgQ0FOQ0VMTEVEOiAnY2FuY2VsbGVkJyxcclxuICAgIFVOS05PV046ICd1bmtub3duJyxcclxuICAgIElOVkFMSURfQVJHVU1FTlQ6ICdpbnZhbGlkLWFyZ3VtZW50JyxcclxuICAgIERFQURMSU5FX0VYQ0VFREVEOiAnZGVhZGxpbmUtZXhjZWVkZWQnLFxyXG4gICAgTk9UX0ZPVU5EOiAnbm90LWZvdW5kJyxcclxuICAgIEFMUkVBRFlfRVhJU1RTOiAnYWxyZWFkeS1leGlzdHMnLFxyXG4gICAgUEVSTUlTU0lPTl9ERU5JRUQ6ICdwZXJtaXNzaW9uLWRlbmllZCcsXHJcbiAgICBVTkFVVEhFTlRJQ0FURUQ6ICd1bmF1dGhlbnRpY2F0ZWQnLFxyXG4gICAgUkVTT1VSQ0VfRVhIQVVTVEVEOiAncmVzb3VyY2UtZXhoYXVzdGVkJyxcclxuICAgIEZBSUxFRF9QUkVDT05ESVRJT046ICdmYWlsZWQtcHJlY29uZGl0aW9uJyxcclxuICAgIEFCT1JURUQ6ICdhYm9ydGVkJyxcclxuICAgIE9VVF9PRl9SQU5HRTogJ291dC1vZi1yYW5nZScsXHJcbiAgICBVTklNUExFTUVOVEVEOiAndW5pbXBsZW1lbnRlZCcsXHJcbiAgICBJTlRFUk5BTDogJ2ludGVybmFsJyxcclxuICAgIFVOQVZBSUxBQkxFOiAndW5hdmFpbGFibGUnLFxyXG4gICAgREFUQV9MT1NTOiAnZGF0YS1sb3NzJ1xyXG59O1xyXG4vKipcclxuICogQW4gZXhwbGljaXQgZXJyb3IgdGhhdCBjYW4gYmUgdGhyb3duIGZyb20gYSBoYW5kbGVyIHRvIHNlbmQgYW4gZXJyb3IgdG8gdGhlXHJcbiAqIGNsaWVudCB0aGF0IGNhbGxlZCB0aGUgZnVuY3Rpb24uXHJcbiAqL1xyXG5jbGFzcyBGdW5jdGlvbnNFcnJvciBleHRlbmRzIEZpcmViYXNlRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKipcclxuICAgICAqIEEgc3RhbmRhcmQgZXJyb3IgY29kZSB0aGF0IHdpbGwgYmUgcmV0dXJuZWQgdG8gdGhlIGNsaWVudC4gVGhpcyBhbHNvXHJcbiAgICAgKiBkZXRlcm1pbmVzIHRoZSBIVFRQIHN0YXR1cyBjb2RlIG9mIHRoZSByZXNwb25zZSwgYXMgZGVmaW5lZCBpbiBjb2RlLnByb3RvLlxyXG4gICAgICovXHJcbiAgICBjb2RlLCBtZXNzYWdlLCBcclxuICAgIC8qKlxyXG4gICAgICogRXh0cmEgZGF0YSB0byBiZSBjb252ZXJ0ZWQgdG8gSlNPTiBhbmQgaW5jbHVkZWQgaW4gdGhlIGVycm9yIHJlc3BvbnNlLlxyXG4gICAgICovXHJcbiAgICBkZXRhaWxzKSB7XHJcbiAgICAgICAgc3VwZXIoYCR7RlVOQ1RJT05TX1RZUEV9LyR7Y29kZX1gLCBtZXNzYWdlIHx8ICcnKTtcclxuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUYWtlcyBhbiBIVFRQIHN0YXR1cyBjb2RlIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIEVycm9yQ29kZS5cclxuICogVGhpcyBpcyB0aGUgc3RhbmRhcmQgSFRUUCBzdGF0dXMgY29kZSAtPiBlcnJvciBtYXBwaW5nIGRlZmluZWQgaW46XHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGVhcGlzL2dvb2dsZWFwaXMvYmxvYi9tYXN0ZXIvZ29vZ2xlL3JwYy9jb2RlLnByb3RvXHJcbiAqXHJcbiAqIEBwYXJhbSBzdGF0dXMgQW4gSFRUUCBzdGF0dXMgY29kZS5cclxuICogQHJldHVybiBUaGUgY29ycmVzcG9uZGluZyBFcnJvckNvZGUsIG9yIEVycm9yQ29kZS5VTktOT1dOIGlmIG5vbmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb2RlRm9ySFRUUFN0YXR1cyhzdGF0dXMpIHtcclxuICAgIC8vIE1ha2Ugc3VyZSBhbnkgc3VjY2Vzc2Z1bCBzdGF0dXMgaXMgT0suXHJcbiAgICBpZiAoc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDApIHtcclxuICAgICAgICByZXR1cm4gJ29rJztcclxuICAgIH1cclxuICAgIHN3aXRjaCAoc3RhdHVzKSB7XHJcbiAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlIHNlcnZlciByZXR1cm5zIDUwMC5cclxuICAgICAgICAgICAgcmV0dXJuICdpbnRlcm5hbCc7XHJcbiAgICAgICAgY2FzZSA0MDA6XHJcbiAgICAgICAgICAgIHJldHVybiAnaW52YWxpZC1hcmd1bWVudCc7XHJcbiAgICAgICAgY2FzZSA0MDE6XHJcbiAgICAgICAgICAgIHJldHVybiAndW5hdXRoZW50aWNhdGVkJztcclxuICAgICAgICBjYXNlIDQwMzpcclxuICAgICAgICAgICAgcmV0dXJuICdwZXJtaXNzaW9uLWRlbmllZCc7XHJcbiAgICAgICAgY2FzZSA0MDQ6XHJcbiAgICAgICAgICAgIHJldHVybiAnbm90LWZvdW5kJztcclxuICAgICAgICBjYXNlIDQwOTpcclxuICAgICAgICAgICAgcmV0dXJuICdhYm9ydGVkJztcclxuICAgICAgICBjYXNlIDQyOTpcclxuICAgICAgICAgICAgcmV0dXJuICdyZXNvdXJjZS1leGhhdXN0ZWQnO1xyXG4gICAgICAgIGNhc2UgNDk5OlxyXG4gICAgICAgICAgICByZXR1cm4gJ2NhbmNlbGxlZCc7XHJcbiAgICAgICAgY2FzZSA1MDA6XHJcbiAgICAgICAgICAgIHJldHVybiAnaW50ZXJuYWwnO1xyXG4gICAgICAgIGNhc2UgNTAxOlxyXG4gICAgICAgICAgICByZXR1cm4gJ3VuaW1wbGVtZW50ZWQnO1xyXG4gICAgICAgIGNhc2UgNTAzOlxyXG4gICAgICAgICAgICByZXR1cm4gJ3VuYXZhaWxhYmxlJztcclxuICAgICAgICBjYXNlIDUwNDpcclxuICAgICAgICAgICAgcmV0dXJuICdkZWFkbGluZS1leGNlZWRlZCc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJ3Vua25vd24nO1xyXG59XHJcbi8qKlxyXG4gKiBUYWtlcyBhbiBIVFRQIHJlc3BvbnNlIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIEVycm9yLCBpZiBhbnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBfZXJyb3JGb3JSZXNwb25zZShzdGF0dXMsIGJvZHlKU09OKSB7XHJcbiAgICBsZXQgY29kZSA9IGNvZGVGb3JIVFRQU3RhdHVzKHN0YXR1cyk7XHJcbiAgICAvLyBTdGFydCB3aXRoIHJlYXNvbmFibGUgZGVmYXVsdHMgZnJvbSB0aGUgc3RhdHVzIGNvZGUuXHJcbiAgICBsZXQgZGVzY3JpcHRpb24gPSBjb2RlO1xyXG4gICAgbGV0IGRldGFpbHMgPSB1bmRlZmluZWQ7XHJcbiAgICAvLyBUaGVuIGxvb2sgdGhyb3VnaCB0aGUgYm9keSBmb3IgZXhwbGljaXQgZGV0YWlscy5cclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3JKU09OID0gYm9keUpTT04gJiYgYm9keUpTT04uZXJyb3I7XHJcbiAgICAgICAgaWYgKGVycm9ySlNPTikge1xyXG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBlcnJvckpTT04uc3RhdHVzO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXR1cyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZXJyb3JDb2RlTWFwW3N0YXR1c10pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IG11c3QndmUgaW5jbHVkZWQgYW4gdW5rbm93biBlcnJvciBjb2RlIGluIHRoZSBib2R5LlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25zRXJyb3IoJ2ludGVybmFsJywgJ2ludGVybmFsJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb2RlID0gZXJyb3JDb2RlTWFwW3N0YXR1c107XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGtsaW10KTogQWRkIGJldHRlciBkZWZhdWx0IGRlc2NyaXB0aW9ucyBmb3IgZXJyb3IgZW51bXMuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBkZXNjcmlwdGlvbiBuZWVkcyB0byBiZSB1cGRhdGVkIGZvciB0aGUgbmV3IGNvZGUuXHJcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA9IHN0YXR1cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3JKU09OLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gbWVzc2FnZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZXRhaWxzID0gZXJyb3JKU09OLmRldGFpbHM7XHJcbiAgICAgICAgICAgIGlmIChkZXRhaWxzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGRldGFpbHMgPSBkZWNvZGUoZGV0YWlscyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIElmIHdlIGNvdWxkbid0IHBhcnNlIGV4cGxpY2l0IGVycm9yIGRhdGEsIHRoYXQncyBmaW5lLlxyXG4gICAgfVxyXG4gICAgaWYgKGNvZGUgPT09ICdvaycpIHtcclxuICAgICAgICAvLyBUZWNobmljYWxseSwgdGhlcmUncyBhbiBlZGdlIGNhc2Ugd2hlcmUgYSBkZXZlbG9wZXIgY291bGQgZXhwbGljaXRseVxyXG4gICAgICAgIC8vIHJldHVybiBhbiBlcnJvciBjb2RlIG9mIE9LLCBhbmQgd2Ugd2lsbCB0cmVhdCBpdCBhcyBzdWNjZXNzLCBidXQgdGhhdFxyXG4gICAgICAgIC8vIHNlZW1zIHJlYXNvbmFibGUuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uc0Vycm9yKGNvZGUsIGRlc2NyaXB0aW9uLCBkZXRhaWxzKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogSGVscGVyIGNsYXNzIHRvIGdldCBtZXRhZGF0YSB0aGF0IHNob3VsZCBiZSBpbmNsdWRlZCB3aXRoIGEgZnVuY3Rpb24gY2FsbC5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBDb250ZXh0UHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoYXV0aFByb3ZpZGVyLCBtZXNzYWdpbmdQcm92aWRlciwgYXBwQ2hlY2tQcm92aWRlcikge1xyXG4gICAgICAgIHRoaXMuYXV0aCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tZXNzYWdpbmcgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2sgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGhQcm92aWRlci5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2luZyA9IG1lc3NhZ2luZ1Byb3ZpZGVyLmdldEltbWVkaWF0ZSh7XHJcbiAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmF1dGgpIHtcclxuICAgICAgICAgICAgYXV0aFByb3ZpZGVyLmdldCgpLnRoZW4oYXV0aCA9PiAodGhpcy5hdXRoID0gYXV0aCksICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8qIGdldCgpIG5ldmVyIHJlamVjdHMgKi9cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5tZXNzYWdpbmcpIHtcclxuICAgICAgICAgICAgbWVzc2FnaW5nUHJvdmlkZXIuZ2V0KCkudGhlbihtZXNzYWdpbmcgPT4gKHRoaXMubWVzc2FnaW5nID0gbWVzc2FnaW5nKSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLyogZ2V0KCkgbmV2ZXIgcmVqZWN0cyAqL1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmFwcENoZWNrKSB7XHJcbiAgICAgICAgICAgIGFwcENoZWNrUHJvdmlkZXIuZ2V0KCkudGhlbihhcHBDaGVjayA9PiAodGhpcy5hcHBDaGVjayA9IGFwcENoZWNrKSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLyogZ2V0KCkgbmV2ZXIgcmVqZWN0cyAqL1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3luYyBnZXRBdXRoVG9rZW4oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmF1dGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLmF1dGguZ2V0VG9rZW4oKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRva2VuID09PSBudWxsIHx8IHRva2VuID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0b2tlbi5hY2Nlc3NUb2tlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhbnkgZXJyb3Igd2hlbiB0cnlpbmcgdG8gZ2V0IHRoZSBhdXRoIHRva2VuLCBsZWF2ZSBpdCBvZmYuXHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0TWVzc2FnaW5nVG9rZW4oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm1lc3NhZ2luZyB8fFxyXG4gICAgICAgICAgICAhKCdOb3RpZmljYXRpb24nIGluIHNlbGYpIHx8XHJcbiAgICAgICAgICAgIE5vdGlmaWNhdGlvbi5wZXJtaXNzaW9uICE9PSAnZ3JhbnRlZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubWVzc2FnaW5nLmdldFRva2VuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhcm4gb24gdGhpcywgYmVjYXVzZSBpdCB1c3VhbGx5IG1lYW5zIG1lc3NhZ2luZyBpc24ndCBzZXQgdXAuXHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHJldHJpZXZlIGluc3RhbmNlIGlkIHRva2VuLicsIGUpO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGFueSBlcnJvciB3aGVuIHRyeWluZyB0byBnZXQgdGhlIHRva2VuLCBsZWF2ZSBpdCBvZmYuXHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgZ2V0QXBwQ2hlY2tUb2tlbihsaW1pdGVkVXNlQXBwQ2hlY2tUb2tlbnMpIHtcclxuICAgICAgICBpZiAodGhpcy5hcHBDaGVjaykge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBsaW1pdGVkVXNlQXBwQ2hlY2tUb2tlbnNcclxuICAgICAgICAgICAgICAgID8gYXdhaXQgdGhpcy5hcHBDaGVjay5nZXRMaW1pdGVkVXNlVG9rZW4oKVxyXG4gICAgICAgICAgICAgICAgOiBhd2FpdCB0aGlzLmFwcENoZWNrLmdldFRva2VuKCk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBzZW5kIHRoZSBBcHAgQ2hlY2sgaGVhZGVyIHRvIHRoZSBmdW5jdGlvbnMgZW5kcG9pbnQgaWZcclxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIHdhcyBhbiBlcnJvciBmcm9tIHRoZSBBcHAgQ2hlY2sgZXhjaGFuZ2UgZW5kcG9pbnQuIFRoZSBBcHBcclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIFNESyB3aWxsIGFscmVhZHkgaGF2ZSBsb2dnZWQgdGhlIGVycm9yIHRvIGNvbnNvbGUuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRva2VuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGFzeW5jIGdldENvbnRleHQobGltaXRlZFVzZUFwcENoZWNrVG9rZW5zKSB7XHJcbiAgICAgICAgY29uc3QgYXV0aFRva2VuID0gYXdhaXQgdGhpcy5nZXRBdXRoVG9rZW4oKTtcclxuICAgICAgICBjb25zdCBtZXNzYWdpbmdUb2tlbiA9IGF3YWl0IHRoaXMuZ2V0TWVzc2FnaW5nVG9rZW4oKTtcclxuICAgICAgICBjb25zdCBhcHBDaGVja1Rva2VuID0gYXdhaXQgdGhpcy5nZXRBcHBDaGVja1Rva2VuKGxpbWl0ZWRVc2VBcHBDaGVja1Rva2Vucyk7XHJcbiAgICAgICAgcmV0dXJuIHsgYXV0aFRva2VuLCBtZXNzYWdpbmdUb2tlbiwgYXBwQ2hlY2tUb2tlbiB9O1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfUkVHSU9OID0gJ3VzLWNlbnRyYWwxJztcclxuLyoqXHJcbiAqIFJldHVybnMgYSBQcm9taXNlIHRoYXQgd2lsbCBiZSByZWplY3RlZCBhZnRlciB0aGUgZ2l2ZW4gZHVyYXRpb24uXHJcbiAqIFRoZSBlcnJvciB3aWxsIGJlIG9mIHR5cGUgRnVuY3Rpb25zRXJyb3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBtaWxsaXMgTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSByZWplY3RpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBmYWlsQWZ0ZXIobWlsbGlzKSB7XHJcbiAgICAvLyBOb2RlIHRpbWVycyBhbmQgYnJvd3NlciB0aW1lcnMgYXJlIGZ1bmRhbWVudGFsbHkgaW5jb21wYXRpYmxlLCBidXQgd2VcclxuICAgIC8vIGRvbid0IGNhcmUgYWJvdXQgdGhlIHZhbHVlIGhlcmVcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICBsZXQgdGltZXIgPSBudWxsO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwcm9taXNlOiBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEZ1bmN0aW9uc0Vycm9yKCdkZWFkbGluZS1leGNlZWRlZCcsICdkZWFkbGluZS1leGNlZWRlZCcpKTtcclxuICAgICAgICAgICAgfSwgbWlsbGlzKTtcclxuICAgICAgICB9KSxcclxuICAgICAgICBjYW5jZWw6ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRpbWVyKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogVGhlIG1haW4gY2xhc3MgZm9yIHRoZSBGaXJlYmFzZSBGdW5jdGlvbnMgU0RLLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIEZ1bmN0aW9uc1NlcnZpY2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEZ1bmN0aW9ucyBzZXJ2aWNlIGZvciB0aGUgZ2l2ZW4gYXBwLlxyXG4gICAgICogQHBhcmFtIGFwcCAtIFRoZSBGaXJlYmFzZUFwcCB0byB1c2UuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGFwcCwgYXV0aFByb3ZpZGVyLCBtZXNzYWdpbmdQcm92aWRlciwgYXBwQ2hlY2tQcm92aWRlciwgcmVnaW9uT3JDdXN0b21Eb21haW4gPSBERUZBVUxUX1JFR0lPTiwgZmV0Y2hJbXBsKSB7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICAgICAgdGhpcy5mZXRjaEltcGwgPSBmZXRjaEltcGw7XHJcbiAgICAgICAgdGhpcy5lbXVsYXRvck9yaWdpbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0UHJvdmlkZXIgPSBuZXcgQ29udGV4dFByb3ZpZGVyKGF1dGhQcm92aWRlciwgbWVzc2FnaW5nUHJvdmlkZXIsIGFwcENoZWNrUHJvdmlkZXIpO1xyXG4gICAgICAgIC8vIENhbmNlbHMgYWxsIG9uZ29pbmcgcmVxdWVzdHMgd2hlbiByZXNvbHZlZC5cclxuICAgICAgICB0aGlzLmNhbmNlbEFsbFJlcXVlc3RzID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlU2VydmljZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzb2x2ZSgpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBSZXNvbHZlIHRoZSByZWdpb24gb3IgY3VzdG9tIGRvbWFpbiBvdmVybG9hZCBieSBhdHRlbXB0aW5nIHRvIHBhcnNlIGl0LlxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVnaW9uT3JDdXN0b21Eb21haW4pO1xyXG4gICAgICAgICAgICB0aGlzLmN1c3RvbURvbWFpbiA9IHVybC5vcmlnaW47XHJcbiAgICAgICAgICAgIHRoaXMucmVnaW9uID0gREVGQVVMVF9SRUdJT047XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tRG9tYWluID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5yZWdpb24gPSByZWdpb25PckN1c3RvbURvbWFpbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZGVsZXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZVNlcnZpY2UoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgVVJMIGZvciBhIGNhbGxhYmxlIHdpdGggdGhlIGdpdmVuIG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjYWxsYWJsZS5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfdXJsKG5hbWUpIHtcclxuICAgICAgICBjb25zdCBwcm9qZWN0SWQgPSB0aGlzLmFwcC5vcHRpb25zLnByb2plY3RJZDtcclxuICAgICAgICBpZiAodGhpcy5lbXVsYXRvck9yaWdpbiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW4gPSB0aGlzLmVtdWxhdG9yT3JpZ2luO1xyXG4gICAgICAgICAgICByZXR1cm4gYCR7b3JpZ2lufS8ke3Byb2plY3RJZH0vJHt0aGlzLnJlZ2lvbn0vJHtuYW1lfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmN1c3RvbURvbWFpbiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5jdXN0b21Eb21haW59LyR7bmFtZX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYGh0dHBzOi8vJHt0aGlzLnJlZ2lvbn0tJHtwcm9qZWN0SWR9LmNsb3VkZnVuY3Rpb25zLm5ldC8ke25hbWV9YDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTW9kaWZ5IHRoaXMgaW5zdGFuY2UgdG8gY29tbXVuaWNhdGUgd2l0aCB0aGUgQ2xvdWQgRnVuY3Rpb25zIGVtdWxhdG9yLlxyXG4gKlxyXG4gKiBOb3RlOiB0aGlzIG11c3QgYmUgY2FsbGVkIGJlZm9yZSB0aGlzIGluc3RhbmNlIGhhcyBiZWVuIHVzZWQgdG8gZG8gYW55IG9wZXJhdGlvbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBob3N0IFRoZSBlbXVsYXRvciBob3N0IChleDogbG9jYWxob3N0KVxyXG4gKiBAcGFyYW0gcG9ydCBUaGUgZW11bGF0b3IgcG9ydCAoZXg6IDUwMDEpXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGNvbm5lY3RGdW5jdGlvbnNFbXVsYXRvciQxKGZ1bmN0aW9uc0luc3RhbmNlLCBob3N0LCBwb3J0KSB7XHJcbiAgICBmdW5jdGlvbnNJbnN0YW5jZS5lbXVsYXRvck9yaWdpbiA9IGBodHRwOi8vJHtob3N0fToke3BvcnR9YDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgY2FsbGFibGUgaHR0cHMgdHJpZ2dlciB3aXRoIHRoZSBnaXZlbiBuYW1lLlxyXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB0cmlnZ2VyLlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBodHRwc0NhbGxhYmxlJDEoZnVuY3Rpb25zSW5zdGFuY2UsIG5hbWUsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiAoZGF0YSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGNhbGwoZnVuY3Rpb25zSW5zdGFuY2UsIG5hbWUsIGRhdGEsIG9wdGlvbnMgfHwge30pO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGNhbGxhYmxlIGh0dHBzIHRyaWdnZXIgd2l0aCB0aGUgZ2l2ZW4gdXJsLlxyXG4gKiBAcGFyYW0gdXJsIC0gVGhlIHVybCBvZiB0aGUgdHJpZ2dlci5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gaHR0cHNDYWxsYWJsZUZyb21VUkwkMShmdW5jdGlvbnNJbnN0YW5jZSwgdXJsLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gKGRhdGEgPT4ge1xyXG4gICAgICAgIHJldHVybiBjYWxsQXRVUkwoZnVuY3Rpb25zSW5zdGFuY2UsIHVybCwgZGF0YSwgb3B0aW9ucyB8fCB7fSk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogRG9lcyBhbiBIVFRQIFBPU1QgYW5kIHJldHVybnMgdGhlIGNvbXBsZXRlZCByZXNwb25zZS5cclxuICogQHBhcmFtIHVybCBUaGUgdXJsIHRvIHBvc3QgdG8uXHJcbiAqIEBwYXJhbSBib2R5IFRoZSBKU09OIGJvZHkgb2YgdGhlIHBvc3QuXHJcbiAqIEBwYXJhbSBoZWFkZXJzIFRoZSBIVFRQIGhlYWRlcnMgdG8gaW5jbHVkZSBpbiB0aGUgcmVxdWVzdC5cclxuICogQHJldHVybiBBIFByb21pc2UgdGhhdCB3aWxsIHN1Y2NlZWQgd2hlbiB0aGUgcmVxdWVzdCBmaW5pc2hlcy5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIHBvc3RKU09OKHVybCwgYm9keSwgaGVhZGVycywgZmV0Y2hJbXBsKSB7XHJcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcclxuICAgIGxldCByZXNwb25zZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaEltcGwodXJsLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcclxuICAgICAgICAgICAgaGVhZGVyc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIGFuIHVuaGFuZGxlZCBlcnJvciBvbiB0aGUgYmFja2VuZCwgb3IgaXQgY291bGQgYmUgYVxyXG4gICAgICAgIC8vIG5ldHdvcmsgZXJyb3IuIFRoZXJlJ3Mgbm8gd2F5IHRvIGtub3csIHNpbmNlIGFuIHVuaGFuZGxlZCBlcnJvciBvbiB0aGVcclxuICAgICAgICAvLyBiYWNrZW5kIHdpbGwgZmFpbCB0byBzZXQgdGhlIHByb3BlciBDT1JTIGhlYWRlciwgYW5kIHRodXMgd2lsbCBiZVxyXG4gICAgICAgIC8vIHRyZWF0ZWQgYXMgYSBuZXR3b3JrIGVycm9yIGJ5IGZldGNoLlxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN0YXR1czogMCxcclxuICAgICAgICAgICAganNvbjogbnVsbFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBsZXQganNvbiA9IG51bGw7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIElmIHdlIGZhaWwgdG8gcGFyc2UgSlNPTiwgaXQgd2lsbCBmYWlsIHRoZSBzYW1lIGFzIGFuIGVtcHR5IGJvZHkuXHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxyXG4gICAgICAgIGpzb25cclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIENhbGxzIGEgY2FsbGFibGUgZnVuY3Rpb24gYXN5bmNocm9ub3VzbHkgYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cclxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNhbGxhYmxlIHRyaWdnZXIuXHJcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIHBhc3MgYXMgcGFyYW1zIHRvIHRoZSBmdW5jdGlvbi5zXHJcbiAqL1xyXG5mdW5jdGlvbiBjYWxsKGZ1bmN0aW9uc0luc3RhbmNlLCBuYW1lLCBkYXRhLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCB1cmwgPSBmdW5jdGlvbnNJbnN0YW5jZS5fdXJsKG5hbWUpO1xyXG4gICAgcmV0dXJuIGNhbGxBdFVSTChmdW5jdGlvbnNJbnN0YW5jZSwgdXJsLCBkYXRhLCBvcHRpb25zKTtcclxufVxyXG4vKipcclxuICogQ2FsbHMgYSBjYWxsYWJsZSBmdW5jdGlvbiBhc3luY2hyb25vdXNseSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxyXG4gKiBAcGFyYW0gdXJsIFRoZSB1cmwgb2YgdGhlIGNhbGxhYmxlIHRyaWdnZXIuXHJcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIHBhc3MgYXMgcGFyYW1zIHRvIHRoZSBmdW5jdGlvbi5zXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBjYWxsQXRVUkwoZnVuY3Rpb25zSW5zdGFuY2UsIHVybCwgZGF0YSwgb3B0aW9ucykge1xyXG4gICAgLy8gRW5jb2RlIGFueSBzcGVjaWFsIHR5cGVzLCBzdWNoIGFzIGRhdGVzLCBpbiB0aGUgaW5wdXQgZGF0YS5cclxuICAgIGRhdGEgPSBlbmNvZGUoZGF0YSk7XHJcbiAgICBjb25zdCBib2R5ID0geyBkYXRhIH07XHJcbiAgICAvLyBBZGQgYSBoZWFkZXIgZm9yIHRoZSBhdXRoVG9rZW4uXHJcbiAgICBjb25zdCBoZWFkZXJzID0ge307XHJcbiAgICBjb25zdCBjb250ZXh0ID0gYXdhaXQgZnVuY3Rpb25zSW5zdGFuY2UuY29udGV4dFByb3ZpZGVyLmdldENvbnRleHQob3B0aW9ucy5saW1pdGVkVXNlQXBwQ2hlY2tUb2tlbnMpO1xyXG4gICAgaWYgKGNvbnRleHQuYXV0aFRva2VuKSB7XHJcbiAgICAgICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gJ0JlYXJlciAnICsgY29udGV4dC5hdXRoVG9rZW47XHJcbiAgICB9XHJcbiAgICBpZiAoY29udGV4dC5tZXNzYWdpbmdUb2tlbikge1xyXG4gICAgICAgIGhlYWRlcnNbJ0ZpcmViYXNlLUluc3RhbmNlLUlELVRva2VuJ10gPSBjb250ZXh0Lm1lc3NhZ2luZ1Rva2VuO1xyXG4gICAgfVxyXG4gICAgaWYgKGNvbnRleHQuYXBwQ2hlY2tUb2tlbiAhPT0gbnVsbCkge1xyXG4gICAgICAgIGhlYWRlcnNbJ1gtRmlyZWJhc2UtQXBwQ2hlY2snXSA9IGNvbnRleHQuYXBwQ2hlY2tUb2tlbjtcclxuICAgIH1cclxuICAgIC8vIERlZmF1bHQgdGltZW91dCB0byA3MHMsIGJ1dCBsZXQgdGhlIG9wdGlvbnMgb3ZlcnJpZGUgaXQuXHJcbiAgICBjb25zdCB0aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0IHx8IDcwMDAwO1xyXG4gICAgY29uc3QgZmFpbEFmdGVySGFuZGxlID0gZmFpbEFmdGVyKHRpbWVvdXQpO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQcm9taXNlLnJhY2UoW1xyXG4gICAgICAgIHBvc3RKU09OKHVybCwgYm9keSwgaGVhZGVycywgZnVuY3Rpb25zSW5zdGFuY2UuZmV0Y2hJbXBsKSxcclxuICAgICAgICBmYWlsQWZ0ZXJIYW5kbGUucHJvbWlzZSxcclxuICAgICAgICBmdW5jdGlvbnNJbnN0YW5jZS5jYW5jZWxBbGxSZXF1ZXN0c1xyXG4gICAgXSk7XHJcbiAgICAvLyBBbHdheXMgY2xlYXIgdGhlIGZhaWxBZnRlciB0aW1lb3V0XHJcbiAgICBmYWlsQWZ0ZXJIYW5kbGUuY2FuY2VsKCk7XHJcbiAgICAvLyBJZiBzZXJ2aWNlIHdhcyBkZWxldGVkLCBpbnRlcnJ1cHRlZCByZXNwb25zZSB0aHJvd3MgYW4gZXJyb3IuXHJcbiAgICBpZiAoIXJlc3BvbnNlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZ1bmN0aW9uc0Vycm9yKCdjYW5jZWxsZWQnLCAnRmlyZWJhc2UgRnVuY3Rpb25zIGluc3RhbmNlIHdhcyBkZWxldGVkLicpO1xyXG4gICAgfVxyXG4gICAgLy8gQ2hlY2sgZm9yIGFuIGVycm9yIHN0YXR1cywgcmVnYXJkbGVzcyBvZiBodHRwIHN0YXR1cy5cclxuICAgIGNvbnN0IGVycm9yID0gX2Vycm9yRm9yUmVzcG9uc2UocmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS5qc29uKTtcclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gICAgaWYgKCFyZXNwb25zZS5qc29uKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEZ1bmN0aW9uc0Vycm9yKCdpbnRlcm5hbCcsICdSZXNwb25zZSBpcyBub3QgdmFsaWQgSlNPTiBvYmplY3QuJyk7XHJcbiAgICB9XHJcbiAgICBsZXQgcmVzcG9uc2VEYXRhID0gcmVzcG9uc2UuanNvbi5kYXRhO1xyXG4gICAgLy8gVE9ETyhrbGltdCk6IEZvciByaWdodCBub3csIGFsbG93IFwicmVzdWx0XCIgaW5zdGVhZCBvZiBcImRhdGFcIiwgZm9yXHJcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cclxuICAgIGlmICh0eXBlb2YgcmVzcG9uc2VEYXRhID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJlc3BvbnNlRGF0YSA9IHJlc3BvbnNlLmpzb24ucmVzdWx0O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiByZXNwb25zZURhdGEgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgLy8gQ29uc2lkZXIgdGhlIHJlc3BvbnNlIG1hbGZvcm1lZC5cclxuICAgICAgICB0aHJvdyBuZXcgRnVuY3Rpb25zRXJyb3IoJ2ludGVybmFsJywgJ1Jlc3BvbnNlIGlzIG1pc3NpbmcgZGF0YSBmaWVsZC4nKTtcclxuICAgIH1cclxuICAgIC8vIERlY29kZSBhbnkgc3BlY2lhbCB0eXBlcywgc3VjaCBhcyBkYXRlcywgaW4gdGhlIHJldHVybmVkIGRhdGEuXHJcbiAgICBjb25zdCBkZWNvZGVkRGF0YSA9IGRlY29kZShyZXNwb25zZURhdGEpO1xyXG4gICAgcmV0dXJuIHsgZGF0YTogZGVjb2RlZERhdGEgfTtcclxufVxuXG5jb25zdCBuYW1lID0gXCJAZmlyZWJhc2UvZnVuY3Rpb25zXCI7XG5jb25zdCB2ZXJzaW9uID0gXCIwLjExLjZcIjtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgQVVUSF9JTlRFUk5BTF9OQU1FID0gJ2F1dGgtaW50ZXJuYWwnO1xyXG5jb25zdCBBUFBfQ0hFQ0tfSU5URVJOQUxfTkFNRSA9ICdhcHAtY2hlY2staW50ZXJuYWwnO1xyXG5jb25zdCBNRVNTQUdJTkdfSU5URVJOQUxfTkFNRSA9ICdtZXNzYWdpbmctaW50ZXJuYWwnO1xyXG5mdW5jdGlvbiByZWdpc3RlckZ1bmN0aW9ucyhmZXRjaEltcGwsIHZhcmlhbnQpIHtcclxuICAgIGNvbnN0IGZhY3RvcnkgPSAoY29udGFpbmVyLCB7IGluc3RhbmNlSWRlbnRpZmllcjogcmVnaW9uT3JDdXN0b21Eb21haW4gfSkgPT4ge1xyXG4gICAgICAgIC8vIERlcGVuZGVuY2llc1xyXG4gICAgICAgIGNvbnN0IGFwcCA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XHJcbiAgICAgICAgY29uc3QgYXV0aFByb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKEFVVEhfSU5URVJOQUxfTkFNRSk7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnaW5nUHJvdmlkZXIgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoTUVTU0FHSU5HX0lOVEVSTkFMX05BTUUpO1xyXG4gICAgICAgIGNvbnN0IGFwcENoZWNrUHJvdmlkZXIgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoQVBQX0NIRUNLX0lOVEVSTkFMX05BTUUpO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbnNTZXJ2aWNlKGFwcCwgYXV0aFByb3ZpZGVyLCBtZXNzYWdpbmdQcm92aWRlciwgYXBwQ2hlY2tQcm92aWRlciwgcmVnaW9uT3JDdXN0b21Eb21haW4sIGZldGNoSW1wbCk7XHJcbiAgICB9O1xyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoRlVOQ1RJT05TX1RZUEUsIGZhY3RvcnksIFwiUFVCTElDXCIgLyogQ29tcG9uZW50VHlwZS5QVUJMSUMgKi8pLnNldE11bHRpcGxlSW5zdGFuY2VzKHRydWUpKTtcclxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uLCB2YXJpYW50KTtcclxuICAgIC8vIEJVSUxEX1RBUkdFVCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHZhbHVlcyBsaWtlIGVzbTUsIGVzbTIwMTcsIGNqczUsIGV0YyBkdXJpbmcgdGhlIGNvbXBpbGF0aW9uXHJcbiAgICByZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbiwgJ2VzbTIwMTcnKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmV0dXJucyBhIHtAbGluayBGdW5jdGlvbnN9IGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gYXBwLlxyXG4gKiBAcGFyYW0gYXBwIC0gVGhlIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfSB0byB1c2UuXHJcbiAqIEBwYXJhbSByZWdpb25PckN1c3RvbURvbWFpbiAtIG9uZSBvZjpcclxuICogICBhKSBUaGUgcmVnaW9uIHRoZSBjYWxsYWJsZSBmdW5jdGlvbnMgYXJlIGxvY2F0ZWQgaW4gKGV4OiB1cy1jZW50cmFsMSlcclxuICogICBiKSBBIGN1c3RvbSBkb21haW4gaG9zdGluZyB0aGUgY2FsbGFibGUgZnVuY3Rpb25zIChleDogaHR0cHM6Ly9teWRvbWFpbi5jb20pXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGdldEZ1bmN0aW9ucyhhcHAgPSBnZXRBcHAoKSwgcmVnaW9uT3JDdXN0b21Eb21haW4gPSBERUZBVUxUX1JFR0lPTikge1xyXG4gICAgLy8gRGVwZW5kZW5jaWVzXHJcbiAgICBjb25zdCBmdW5jdGlvbnNQcm92aWRlciA9IF9nZXRQcm92aWRlcihnZXRNb2R1bGFySW5zdGFuY2UoYXBwKSwgRlVOQ1RJT05TX1RZUEUpO1xyXG4gICAgY29uc3QgZnVuY3Rpb25zSW5zdGFuY2UgPSBmdW5jdGlvbnNQcm92aWRlci5nZXRJbW1lZGlhdGUoe1xyXG4gICAgICAgIGlkZW50aWZpZXI6IHJlZ2lvbk9yQ3VzdG9tRG9tYWluXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGVtdWxhdG9yID0gZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0KCdmdW5jdGlvbnMnKTtcclxuICAgIGlmIChlbXVsYXRvcikge1xyXG4gICAgICAgIGNvbm5lY3RGdW5jdGlvbnNFbXVsYXRvcihmdW5jdGlvbnNJbnN0YW5jZSwgLi4uZW11bGF0b3IpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uc0luc3RhbmNlO1xyXG59XHJcbi8qKlxyXG4gKiBNb2RpZnkgdGhpcyBpbnN0YW5jZSB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBDbG91ZCBGdW5jdGlvbnMgZW11bGF0b3IuXHJcbiAqXHJcbiAqIE5vdGU6IHRoaXMgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHRoaXMgaW5zdGFuY2UgaGFzIGJlZW4gdXNlZCB0byBkbyBhbnkgb3BlcmF0aW9ucy5cclxuICpcclxuICogQHBhcmFtIGhvc3QgLSBUaGUgZW11bGF0b3IgaG9zdCAoZXg6IGxvY2FsaG9zdClcclxuICogQHBhcmFtIHBvcnQgLSBUaGUgZW11bGF0b3IgcG9ydCAoZXg6IDUwMDEpXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGNvbm5lY3RGdW5jdGlvbnNFbXVsYXRvcihmdW5jdGlvbnNJbnN0YW5jZSwgaG9zdCwgcG9ydCkge1xyXG4gICAgY29ubmVjdEZ1bmN0aW9uc0VtdWxhdG9yJDEoZ2V0TW9kdWxhckluc3RhbmNlKGZ1bmN0aW9uc0luc3RhbmNlKSwgaG9zdCwgcG9ydCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGNhbGxhYmxlIEhUVFBTIHRyaWdnZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cclxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdHJpZ2dlci5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gaHR0cHNDYWxsYWJsZShmdW5jdGlvbnNJbnN0YW5jZSwgbmFtZSwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGh0dHBzQ2FsbGFibGUkMShnZXRNb2R1bGFySW5zdGFuY2UoZnVuY3Rpb25zSW5zdGFuY2UpLCBuYW1lLCBvcHRpb25zKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgY2FsbGFibGUgSFRUUFMgdHJpZ2dlciB3aXRoIHRoZSBzcGVjaWZpZWQgdXJsLlxyXG4gKiBAcGFyYW0gdXJsIC0gVGhlIHVybCBvZiB0aGUgdHJpZ2dlci5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gaHR0cHNDYWxsYWJsZUZyb21VUkwoZnVuY3Rpb25zSW5zdGFuY2UsIHVybCwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGh0dHBzQ2FsbGFibGVGcm9tVVJMJDEoZ2V0TW9kdWxhckluc3RhbmNlKGZ1bmN0aW9uc0luc3RhbmNlKSwgdXJsLCBvcHRpb25zKTtcclxufVxuXG4vKipcclxuICogQ2xvdWQgRnVuY3Rpb25zIGZvciBGaXJlYmFzZVxyXG4gKlxyXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cclxuICovXHJcbnJlZ2lzdGVyRnVuY3Rpb25zKGZldGNoLmJpbmQoc2VsZikpO1xuXG5leHBvcnQgeyBjb25uZWN0RnVuY3Rpb25zRW11bGF0b3IsIGdldEZ1bmN0aW9ucywgaHR0cHNDYWxsYWJsZSwgaHR0cHNDYWxsYWJsZUZyb21VUkwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbTIwMTcuanMubWFwXG4iLCJleHBvcnQgKiBmcm9tICdAZmlyZWJhc2UvZnVuY3Rpb25zJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiIsImltcG9ydCB7IF9nZXRQcm92aWRlciwgZ2V0QXBwLCBTREtfVkVSU0lPTiBhcyBTREtfVkVSU0lPTiQxLCBfcmVnaXN0ZXJDb21wb25lbnQsIHJlZ2lzdGVyVmVyc2lvbiB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBDb21wb25lbnRDb250YWluZXIsIFByb3ZpZGVyIH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBzdHJpbmdpZnksIGpzb25FdmFsLCBjb250YWlucywgYXNzZXJ0LCBpc05vZGVTZGssIHN0cmluZ1RvQnl0ZUFycmF5LCBTaGExLCBiYXNlNjQsIGRlZXBDb3B5LCBiYXNlNjRFbmNvZGUsIGlzTW9iaWxlQ29yZG92YSwgc3RyaW5nTGVuZ3RoLCBEZWZlcnJlZCwgc2FmZUdldCwgaXNBZG1pbiwgaXNWYWxpZEZvcm1hdCwgaXNFbXB0eSwgaXNSZWFjdE5hdGl2ZSwgYXNzZXJ0aW9uRXJyb3IsIG1hcCwgcXVlcnlzdHJpbmcsIGVycm9yUHJlZml4LCBnZXRNb2R1bGFySW5zdGFuY2UsIGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCwgY3JlYXRlTW9ja1VzZXJUb2tlbiB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IExvZ2dlciwgTG9nTGV2ZWwgfSBmcm9tICdAZmlyZWJhc2UvbG9nZ2VyJztcblxuY29uc3QgbmFtZSA9IFwiQGZpcmViYXNlL2RhdGFiYXNlXCI7XG5jb25zdCB2ZXJzaW9uID0gXCIxLjAuN1wiO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKiogVGhlIHNlbXZlciAod3d3LnNlbXZlci5vcmcpIHZlcnNpb24gb2YgdGhlIFNESy4gKi9cclxubGV0IFNES19WRVJTSU9OID0gJyc7XHJcbi8qKlxyXG4gKiBTREtfVkVSU0lPTiBzaG91bGQgYmUgc2V0IGJlZm9yZSBhbnkgZGF0YWJhc2UgaW5zdGFuY2UgaXMgY3JlYXRlZFxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIHNldFNES1ZlcnNpb24odmVyc2lvbikge1xyXG4gICAgU0RLX1ZFUlNJT04gPSB2ZXJzaW9uO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBXcmFwcyBhIERPTSBTdG9yYWdlIG9iamVjdCBhbmQ6XHJcbiAqIC0gYXV0b21hdGljYWxseSBlbmNvZGUgb2JqZWN0cyBhcyBKU09OIHN0cmluZ3MgYmVmb3JlIHN0b3JpbmcgdGhlbSB0byBhbGxvdyB1cyB0byBzdG9yZSBhcmJpdHJhcnkgdHlwZXMuXHJcbiAqIC0gcHJlZml4ZXMgbmFtZXMgd2l0aCBcImZpcmViYXNlOlwiIHRvIGF2b2lkIGNvbGxpc2lvbnMgd2l0aCBhcHAgZGF0YS5cclxuICpcclxuICogV2UgYXV0b21hdGljYWxseSAoc2VlIHN0b3JhZ2UuanMpIGNyZWF0ZSB0d28gc3VjaCB3cmFwcGVycywgb25lIGZvciBzZXNzaW9uU3RvcmFnZSxcclxuICogYW5kIG9uZSBmb3IgbG9jYWxTdG9yYWdlLlxyXG4gKlxyXG4gKi9cclxuY2xhc3MgRE9NU3RvcmFnZVdyYXBwZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZG9tU3RvcmFnZV8gLSBUaGUgdW5kZXJseWluZyBzdG9yYWdlIG9iamVjdCAoZS5nLiBsb2NhbFN0b3JhZ2Ugb3Igc2Vzc2lvblN0b3JhZ2UpXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGRvbVN0b3JhZ2VfKSB7XHJcbiAgICAgICAgdGhpcy5kb21TdG9yYWdlXyA9IGRvbVN0b3JhZ2VfO1xyXG4gICAgICAgIC8vIFVzZSBhIHByZWZpeCB0byBhdm9pZCBjb2xsaXNpb25zIHdpdGggb3RoZXIgc3R1ZmYgc2F2ZWQgYnkgdGhlIGFwcC5cclxuICAgICAgICB0aGlzLnByZWZpeF8gPSAnZmlyZWJhc2U6JztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdG8gc2F2ZSB0aGUgdmFsdWUgdW5kZXJcclxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBiZWluZyBzdG9yZWQsIG9yIG51bGwgdG8gcmVtb3ZlIHRoZSBrZXkuXHJcbiAgICAgKi9cclxuICAgIHNldChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5kb21TdG9yYWdlXy5yZW1vdmVJdGVtKHRoaXMucHJlZml4ZWROYW1lXyhrZXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tU3RvcmFnZV8uc2V0SXRlbSh0aGlzLnByZWZpeGVkTmFtZV8oa2V5KSwgc3RyaW5naWZ5KHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgdGhhdCB3YXMgc3RvcmVkIHVuZGVyIHRoaXMga2V5LCBvciBudWxsXHJcbiAgICAgKi9cclxuICAgIGdldChrZXkpIHtcclxuICAgICAgICBjb25zdCBzdG9yZWRWYWwgPSB0aGlzLmRvbVN0b3JhZ2VfLmdldEl0ZW0odGhpcy5wcmVmaXhlZE5hbWVfKGtleSkpO1xyXG4gICAgICAgIGlmIChzdG9yZWRWYWwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBqc29uRXZhbChzdG9yZWRWYWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbW92ZShrZXkpIHtcclxuICAgICAgICB0aGlzLmRvbVN0b3JhZ2VfLnJlbW92ZUl0ZW0odGhpcy5wcmVmaXhlZE5hbWVfKGtleSkpO1xyXG4gICAgfVxyXG4gICAgcHJlZml4ZWROYW1lXyhuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlZml4XyArIG5hbWU7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb21TdG9yYWdlXy50b1N0cmluZygpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBbiBpbi1tZW1vcnkgc3RvcmFnZSBpbXBsZW1lbnRhdGlvbiB0aGF0IG1hdGNoZXMgdGhlIEFQSSBvZiBET01TdG9yYWdlV3JhcHBlclxyXG4gKiAoVE9ETzogY3JlYXRlIGludGVyZmFjZSBmb3IgYm90aCB0byBpbXBsZW1lbnQpLlxyXG4gKi9cclxuY2xhc3MgTWVtb3J5U3RvcmFnZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmNhY2hlXyA9IHt9O1xyXG4gICAgICAgIHRoaXMuaXNJbk1lbW9yeVN0b3JhZ2UgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jYWNoZV9ba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGVfW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5zKHRoaXMuY2FjaGVfLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlX1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJlbW92ZShrZXkpIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5jYWNoZV9ba2V5XTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogSGVscGVyIHRvIGNyZWF0ZSBhIERPTVN0b3JhZ2VXcmFwcGVyIG9yIGVsc2UgZmFsbCBiYWNrIHRvIE1lbW9yeVN0b3JhZ2UuXHJcbiAqIFRPRE86IE9uY2UgTWVtb3J5U3RvcmFnZSBhbmQgRE9NU3RvcmFnZVdyYXBwZXIgaGF2ZSBhIHNoYXJlZCBpbnRlcmZhY2UgdGhpcyBtZXRob2QgYW5ub3RhdGlvbiBzaG91bGQgY2hhbmdlXHJcbiAqIHRvIHJlZmxlY3QgdGhpcyB0eXBlXHJcbiAqXHJcbiAqIEBwYXJhbSBkb21TdG9yYWdlTmFtZSAtIE5hbWUgb2YgdGhlIHVuZGVybHlpbmcgc3RvcmFnZSBvYmplY3RcclxuICogICAoZS5nLiAnbG9jYWxTdG9yYWdlJyBvciAnc2Vzc2lvblN0b3JhZ2UnKS5cclxuICogQHJldHVybnMgVHVybmluZyBvZmYgdHlwZSBpbmZvcm1hdGlvbiB1bnRpbCBhIGNvbW1vbiBpbnRlcmZhY2UgaXMgZGVmaW5lZC5cclxuICovXHJcbmNvbnN0IGNyZWF0ZVN0b3JhZ2Vmb3IgPSBmdW5jdGlvbiAoZG9tU3RvcmFnZU5hbWUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy8gTk9URToganVzdCBhY2Nlc3NpbmcgXCJsb2NhbFN0b3JhZ2VcIiBvciBcIndpbmRvd1snbG9jYWxTdG9yYWdlJ11cIiBtYXkgdGhyb3cgYSBzZWN1cml0eSBleGNlcHRpb24sXHJcbiAgICAgICAgLy8gc28gaXQgbXVzdCBiZSBpbnNpZGUgdGhlIHRyeS9jYXRjaC5cclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgdHlwZW9mIHdpbmRvd1tkb21TdG9yYWdlTmFtZV0gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gdGVzdCBjYWNoZS4gSnVzdCBiZWNhdXNlIGl0J3MgaGVyZSBkb2Vzbid0IG1lYW4gaXQgd29ya3NcclxuICAgICAgICAgICAgY29uc3QgZG9tU3RvcmFnZSA9IHdpbmRvd1tkb21TdG9yYWdlTmFtZV07XHJcbiAgICAgICAgICAgIGRvbVN0b3JhZ2Uuc2V0SXRlbSgnZmlyZWJhc2U6c2VudGluZWwnLCAnY2FjaGUnKTtcclxuICAgICAgICAgICAgZG9tU3RvcmFnZS5yZW1vdmVJdGVtKCdmaXJlYmFzZTpzZW50aW5lbCcpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERPTVN0b3JhZ2VXcmFwcGVyKGRvbVN0b3JhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7IH1cclxuICAgIC8vIEZhaWxlZCB0byBjcmVhdGUgd3JhcHBlci4gIEp1c3QgcmV0dXJuIGluLW1lbW9yeSBzdG9yYWdlLlxyXG4gICAgLy8gVE9ETzogbG9nP1xyXG4gICAgcmV0dXJuIG5ldyBNZW1vcnlTdG9yYWdlKCk7XHJcbn07XHJcbi8qKiBBIHN0b3JhZ2Ugb2JqZWN0IHRoYXQgbGFzdHMgYWNyb3NzIHNlc3Npb25zICovXHJcbmNvbnN0IFBlcnNpc3RlbnRTdG9yYWdlID0gY3JlYXRlU3RvcmFnZWZvcignbG9jYWxTdG9yYWdlJyk7XHJcbi8qKiBBIHN0b3JhZ2Ugb2JqZWN0IHRoYXQgb25seSBsYXN0cyBvbmUgc2Vzc2lvbiAqL1xyXG5jb25zdCBTZXNzaW9uU3RvcmFnZSA9IGNyZWF0ZVN0b3JhZ2Vmb3IoJ3Nlc3Npb25TdG9yYWdlJyk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IGxvZ0NsaWVudCA9IG5ldyBMb2dnZXIoJ0BmaXJlYmFzZS9kYXRhYmFzZScpO1xyXG4vKipcclxuICogUmV0dXJucyBhIGxvY2FsbHktdW5pcXVlIElEIChnZW5lcmF0ZWQgYnkganVzdCBpbmNyZW1lbnRpbmcgdXAgZnJvbSAwIGVhY2ggdGltZSBpdHMgY2FsbGVkKS5cclxuICovXHJcbmNvbnN0IExVSURHZW5lcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgbGV0IGlkID0gMTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGlkKys7XHJcbiAgICB9O1xyXG59KSgpO1xyXG4vKipcclxuICogU2hhMSBoYXNoIG9mIHRoZSBpbnB1dCBzdHJpbmdcclxuICogQHBhcmFtIHN0ciAtIFRoZSBzdHJpbmcgdG8gaGFzaFxyXG4gKiBAcmV0dXJucyB7IXN0cmluZ30gVGhlIHJlc3VsdGluZyBoYXNoXHJcbiAqL1xyXG5jb25zdCBzaGExID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgY29uc3QgdXRmOEJ5dGVzID0gc3RyaW5nVG9CeXRlQXJyYXkoc3RyKTtcclxuICAgIGNvbnN0IHNoYTEgPSBuZXcgU2hhMSgpO1xyXG4gICAgc2hhMS51cGRhdGUodXRmOEJ5dGVzKTtcclxuICAgIGNvbnN0IHNoYTFCeXRlcyA9IHNoYTEuZGlnZXN0KCk7XHJcbiAgICByZXR1cm4gYmFzZTY0LmVuY29kZUJ5dGVBcnJheShzaGExQnl0ZXMpO1xyXG59O1xyXG5jb25zdCBidWlsZExvZ01lc3NhZ2VfID0gZnVuY3Rpb24gKC4uLnZhckFyZ3MpIHtcclxuICAgIGxldCBtZXNzYWdlID0gJyc7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhckFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBhcmcgPSB2YXJBcmdzW2ldO1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykgfHxcclxuICAgICAgICAgICAgKGFyZyAmJlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgYXJnLmxlbmd0aCA9PT0gJ251bWJlcicpKSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gYnVpbGRMb2dNZXNzYWdlXy5hcHBseShudWxsLCBhcmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBtZXNzYWdlICs9IHN0cmluZ2lmeShhcmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbWVzc2FnZSArPSBhcmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1lc3NhZ2UgKz0gJyAnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1lc3NhZ2U7XHJcbn07XHJcbi8qKlxyXG4gKiBVc2UgdGhpcyBmb3IgYWxsIGRlYnVnIG1lc3NhZ2VzIGluIEZpcmViYXNlLlxyXG4gKi9cclxubGV0IGxvZ2dlciA9IG51bGw7XHJcbi8qKlxyXG4gKiBGbGFnIHRvIGNoZWNrIGZvciBsb2cgYXZhaWxhYmlsaXR5IG9uIGZpcnN0IGxvZyBtZXNzYWdlXHJcbiAqL1xyXG5sZXQgZmlyc3RMb2dfID0gdHJ1ZTtcclxuLyoqXHJcbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiBGaXJlYmFzZS5lbmFibGVMb2dnaW5nIChkZWZpbmVkIGhlcmUgdG8gYnJlYWsgZGVwZW5kZW5jaWVzKVxyXG4gKiBAcGFyYW0gbG9nZ2VyXyAtIEEgZmxhZyB0byB0dXJuIG9uIGxvZ2dpbmcsIG9yIGEgY3VzdG9tIGxvZ2dlclxyXG4gKiBAcGFyYW0gcGVyc2lzdGVudCAtIFdoZXRoZXIgb3Igbm90IHRvIHBlcnNpc3QgbG9nZ2luZyBzZXR0aW5ncyBhY3Jvc3MgcmVmcmVzaGVzXHJcbiAqL1xyXG5jb25zdCBlbmFibGVMb2dnaW5nJDEgPSBmdW5jdGlvbiAobG9nZ2VyXywgcGVyc2lzdGVudCkge1xyXG4gICAgYXNzZXJ0KCFwZXJzaXN0ZW50IHx8IGxvZ2dlcl8gPT09IHRydWUgfHwgbG9nZ2VyXyA9PT0gZmFsc2UsIFwiQ2FuJ3QgdHVybiBvbiBjdXN0b20gbG9nZ2VycyBwZXJzaXN0ZW50bHkuXCIpO1xyXG4gICAgaWYgKGxvZ2dlcl8gPT09IHRydWUpIHtcclxuICAgICAgICBsb2dDbGllbnQubG9nTGV2ZWwgPSBMb2dMZXZlbC5WRVJCT1NFO1xyXG4gICAgICAgIGxvZ2dlciA9IGxvZ0NsaWVudC5sb2cuYmluZChsb2dDbGllbnQpO1xyXG4gICAgICAgIGlmIChwZXJzaXN0ZW50KSB7XHJcbiAgICAgICAgICAgIFNlc3Npb25TdG9yYWdlLnNldCgnbG9nZ2luZ19lbmFibGVkJywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGxvZ2dlcl8gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBsb2dnZXIgPSBsb2dnZXJfO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbG9nZ2VyID0gbnVsbDtcclxuICAgICAgICBTZXNzaW9uU3RvcmFnZS5yZW1vdmUoJ2xvZ2dpbmdfZW5hYmxlZCcpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBsb2cgPSBmdW5jdGlvbiAoLi4udmFyQXJncykge1xyXG4gICAgaWYgKGZpcnN0TG9nXyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIGZpcnN0TG9nXyA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChsb2dnZXIgPT09IG51bGwgJiYgU2Vzc2lvblN0b3JhZ2UuZ2V0KCdsb2dnaW5nX2VuYWJsZWQnKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBlbmFibGVMb2dnaW5nJDEodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGxvZ2dlcikge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBidWlsZExvZ01lc3NhZ2VfLmFwcGx5KG51bGwsIHZhckFyZ3MpO1xyXG4gICAgICAgIGxvZ2dlcihtZXNzYWdlKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgbG9nV3JhcHBlciA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4udmFyQXJncykge1xyXG4gICAgICAgIGxvZyhwcmVmaXgsIC4uLnZhckFyZ3MpO1xyXG4gICAgfTtcclxufTtcclxuY29uc3QgZXJyb3IgPSBmdW5jdGlvbiAoLi4udmFyQXJncykge1xyXG4gICAgY29uc3QgbWVzc2FnZSA9ICdGSVJFQkFTRSBJTlRFUk5BTCBFUlJPUjogJyArIGJ1aWxkTG9nTWVzc2FnZV8oLi4udmFyQXJncyk7XHJcbiAgICBsb2dDbGllbnQuZXJyb3IobWVzc2FnZSk7XHJcbn07XHJcbmNvbnN0IGZhdGFsID0gZnVuY3Rpb24gKC4uLnZhckFyZ3MpIHtcclxuICAgIGNvbnN0IG1lc3NhZ2UgPSBgRklSRUJBU0UgRkFUQUwgRVJST1I6ICR7YnVpbGRMb2dNZXNzYWdlXyguLi52YXJBcmdzKX1gO1xyXG4gICAgbG9nQ2xpZW50LmVycm9yKG1lc3NhZ2UpO1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG59O1xyXG5jb25zdCB3YXJuID0gZnVuY3Rpb24gKC4uLnZhckFyZ3MpIHtcclxuICAgIGNvbnN0IG1lc3NhZ2UgPSAnRklSRUJBU0UgV0FSTklORzogJyArIGJ1aWxkTG9nTWVzc2FnZV8oLi4udmFyQXJncyk7XHJcbiAgICBsb2dDbGllbnQud2FybihtZXNzYWdlKTtcclxufTtcclxuLyoqXHJcbiAqIExvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb250YWluaW5nIHBhZ2UgdXNlcyBodHRwcy4gQ2FsbGVkIHdoZW4gYSBjYWxsIHRvIG5ldyBGaXJlYmFzZVxyXG4gKiBkb2VzIG5vdCB1c2UgaHR0cHMuXHJcbiAqL1xyXG5jb25zdCB3YXJuSWZQYWdlSXNTZWN1cmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBCZSB2ZXJ5IGNhcmVmdWwgYWNjZXNzaW5nIGJyb3dzZXIgZ2xvYmFscy4gV2hvIGtub3dzIHdoYXQgbWF5IG9yIG1heSBub3QgZXhpc3QuXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICB3aW5kb3cubG9jYXRpb24gJiZcclxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgJiZcclxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wuaW5kZXhPZignaHR0cHM6JykgIT09IC0xKSB7XHJcbiAgICAgICAgd2FybignSW5zZWN1cmUgRmlyZWJhc2UgYWNjZXNzIGZyb20gYSBzZWN1cmUgcGFnZS4gJyArXHJcbiAgICAgICAgICAgICdQbGVhc2UgdXNlIGh0dHBzIGluIGNhbGxzIHRvIG5ldyBGaXJlYmFzZSgpLicpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIGRhdGEgaXMgTmFOLCBvciArLy0gSW5maW5pdHkuXHJcbiAqL1xyXG5jb25zdCBpc0ludmFsaWRKU09OTnVtYmVyID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIHJldHVybiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgKGRhdGEgIT09IGRhdGEgfHwgLy8gTmFOXHJcbiAgICAgICAgICAgIGRhdGEgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB8fFxyXG4gICAgICAgICAgICBkYXRhID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpKTtcclxufTtcclxuY29uc3QgZXhlY3V0ZVdoZW5ET01SZWFkeSA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgaWYgKGlzTm9kZVNkaygpIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcclxuICAgICAgICBmbigpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gTW9kZWxlZCBhZnRlciBqUXVlcnkuIFRyeSBET01Db250ZW50TG9hZGVkIGFuZCBvbnJlYWR5c3RhdGVjaGFuZ2UgKHdoaWNoXHJcbiAgICAgICAgLy8gZmlyZSBiZWZvcmUgb25sb2FkKSwgYnV0IGZhbGwgYmFjayB0byBvbmxvYWQuXHJcbiAgICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IHdyYXBwZWRGbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5KSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHdyYXBwZWRGbiwgTWF0aC5mbG9vcigxMCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghY2FsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZm4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHdyYXBwZWRGbiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0byBvbmxvYWQuXHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgd3JhcHBlZEZuLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRvY3VtZW50LmF0dGFjaEV2ZW50KSB7XHJcbiAgICAgICAgICAgIC8vIElFLlxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICBkb2N1bWVudC5hdHRhY2hFdmVudCgnb25yZWFkeXN0YXRlY2hhbmdlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVkRm4oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRvIG9ubG9hZC5cclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgd2luZG93LmF0dGFjaEV2ZW50KCdvbmxvYWQnLCB3cmFwcGVkRm4pO1xyXG4gICAgICAgICAgICAvLyBqUXVlcnkgaGFzIGFuIGV4dHJhIGhhY2sgZm9yIElFIHRoYXQgd2UgY291bGQgZW1wbG95IChiYXNlZCBvblxyXG4gICAgICAgICAgICAvLyBodHRwOi8vamF2YXNjcmlwdC5ud2JveC5jb20vSUVDb250ZW50TG9hZGVkLykgQnV0IGl0IGxvb2tzIHJlYWxseSBvbGQuXHJcbiAgICAgICAgICAgIC8vIEknbSBob3Bpbmcgd2UgZG9uJ3QgbmVlZCBpdC5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBNaW5pbXVtIGtleSBuYW1lLiBJbnZhbGlkIGZvciBhY3R1YWwgZGF0YSwgdXNlZCBhcyBhIG1hcmtlciB0byBzb3J0IGJlZm9yZSBhbnkgdmFsaWQgbmFtZXNcclxuICovXHJcbmNvbnN0IE1JTl9OQU1FID0gJ1tNSU5fTkFNRV0nO1xyXG4vKipcclxuICogTWF4aW11bSBrZXkgbmFtZS4gSW52YWxpZCBmb3IgYWN0dWFsIGRhdGEsIHVzZWQgYXMgYSBtYXJrZXIgdG8gc29ydCBhYm92ZSBhbnkgdmFsaWQgbmFtZXNcclxuICovXHJcbmNvbnN0IE1BWF9OQU1FID0gJ1tNQVhfTkFNRV0nO1xyXG4vKipcclxuICogQ29tcGFyZXMgdmFsaWQgRmlyZWJhc2Uga2V5IG5hbWVzLCBwbHVzIG1pbiBhbmQgbWF4IG5hbWVcclxuICovXHJcbmNvbnN0IG5hbWVDb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgIGlmIChhID09PSBiKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChhID09PSBNSU5fTkFNRSB8fCBiID09PSBNQVhfTkFNRSkge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGIgPT09IE1JTl9OQU1FIHx8IGEgPT09IE1BWF9OQU1FKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBhQXNJbnQgPSB0cnlQYXJzZUludChhKSwgYkFzSW50ID0gdHJ5UGFyc2VJbnQoYik7XHJcbiAgICAgICAgaWYgKGFBc0ludCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoYkFzSW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYUFzSW50IC0gYkFzSW50ID09PSAwID8gYS5sZW5ndGggLSBiLmxlbmd0aCA6IGFBc0ludCAtIGJBc0ludDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChiQXNJbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogQHJldHVybnMgeyFudW1iZXJ9IGNvbXBhcmlzb24gcmVzdWx0LlxyXG4gKi9cclxuY29uc3Qgc3RyaW5nQ29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICBpZiAoYSA9PT0gYikge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYSA8IGIpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxufTtcclxuY29uc3QgcmVxdWlyZUtleSA9IGZ1bmN0aW9uIChrZXksIG9iaikge1xyXG4gICAgaWYgKG9iaiAmJiBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG9ialtrZXldO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGtleSAoJyArIGtleSArICcpIGluIG9iamVjdDogJyArIHN0cmluZ2lmeShvYmopKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgT2JqZWN0VG9VbmlxdWVLZXkgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShvYmopO1xyXG4gICAgfVxyXG4gICAgY29uc3Qga2V5cyA9IFtdO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxyXG4gICAgZm9yIChjb25zdCBrIGluIG9iaikge1xyXG4gICAgICAgIGtleXMucHVzaChrKTtcclxuICAgIH1cclxuICAgIC8vIEV4cG9ydCBhcyBqc29uLCBidXQgd2l0aCB0aGUga2V5cyBzb3J0ZWQuXHJcbiAgICBrZXlzLnNvcnQoKTtcclxuICAgIGxldCBrZXkgPSAneyc7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoaSAhPT0gMCkge1xyXG4gICAgICAgICAgICBrZXkgKz0gJywnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBrZXkgKz0gc3RyaW5naWZ5KGtleXNbaV0pO1xyXG4gICAgICAgIGtleSArPSAnOic7XHJcbiAgICAgICAga2V5ICs9IE9iamVjdFRvVW5pcXVlS2V5KG9ialtrZXlzW2ldXSk7XHJcbiAgICB9XHJcbiAgICBrZXkgKz0gJ30nO1xyXG4gICAgcmV0dXJuIGtleTtcclxufTtcclxuLyoqXHJcbiAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIGEgbnVtYmVyIG9mIHNtYWxsZXIgc2VnbWVudHMgb2YgbWF4aW11bSBzaXplXHJcbiAqIEBwYXJhbSBzdHIgLSBUaGUgc3RyaW5nXHJcbiAqIEBwYXJhbSBzZWdzaXplIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGNoYXJzIGluIHRoZSBzdHJpbmcuXHJcbiAqIEByZXR1cm5zIFRoZSBzdHJpbmcsIHNwbGl0IGludG8gYXBwcm9wcmlhdGVseS1zaXplZCBjaHVua3NcclxuICovXHJcbmNvbnN0IHNwbGl0U3RyaW5nQnlTaXplID0gZnVuY3Rpb24gKHN0ciwgc2Vnc2l6ZSkge1xyXG4gICAgY29uc3QgbGVuID0gc3RyLmxlbmd0aDtcclxuICAgIGlmIChsZW4gPD0gc2Vnc2l6ZSkge1xyXG4gICAgICAgIHJldHVybiBbc3RyXTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRhdGFTZWdzID0gW107XHJcbiAgICBmb3IgKGxldCBjID0gMDsgYyA8IGxlbjsgYyArPSBzZWdzaXplKSB7XHJcbiAgICAgICAgaWYgKGMgKyBzZWdzaXplID4gbGVuKSB7XHJcbiAgICAgICAgICAgIGRhdGFTZWdzLnB1c2goc3RyLnN1YnN0cmluZyhjLCBsZW4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRhdGFTZWdzLnB1c2goc3RyLnN1YnN0cmluZyhjLCBjICsgc2Vnc2l6ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkYXRhU2VncztcclxufTtcclxuLyoqXHJcbiAqIEFwcGx5IGEgZnVuY3Rpb24gdG8gZWFjaCAoa2V5LCB2YWx1ZSkgcGFpciBpbiBhbiBvYmplY3Qgb3JcclxuICogYXBwbHkgYSBmdW5jdGlvbiB0byBlYWNoIChpbmRleCwgdmFsdWUpIHBhaXIgaW4gYW4gYXJyYXlcclxuICogQHBhcmFtIG9iaiAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyXHJcbiAqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiB0byBhcHBseVxyXG4gKi9cclxuZnVuY3Rpb24gZWFjaChvYmosIGZuKSB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgZm4oa2V5LCBvYmpba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBCb3Jyb3dlZCBmcm9tIGh0dHA6Ly9oZy5zZWNvbmRsaWZlLmNvbS9sbHNkL3NyYy90aXAvanMvdHlwZWRhcnJheS5qcyAoTUlUIExpY2Vuc2UpXHJcbiAqIEkgbWFkZSBvbmUgbW9kaWZpY2F0aW9uIGF0IHRoZSBlbmQgYW5kIHJlbW92ZWQgdGhlIE5hTiAvIEluZmluaXR5XHJcbiAqIGhhbmRsaW5nIChzaW5jZSBpdCBzZWVtZWQgYnJva2VuIFtjYXVzZWQgYW4gb3ZlcmZsb3ddIGFuZCB3ZSBkb24ndCBuZWVkIGl0KS4gIFNlZSBNSkwgY29tbWVudHMuXHJcbiAqIEBwYXJhbSB2IC0gQSBkb3VibGVcclxuICpcclxuICovXHJcbmNvbnN0IGRvdWJsZVRvSUVFRTc1NFN0cmluZyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICBhc3NlcnQoIWlzSW52YWxpZEpTT05OdW1iZXIodiksICdJbnZhbGlkIEpTT04gbnVtYmVyJyk7IC8vIE1KTFxyXG4gICAgY29uc3QgZWJpdHMgPSAxMSwgZmJpdHMgPSA1MjtcclxuICAgIGNvbnN0IGJpYXMgPSAoMSA8PCAoZWJpdHMgLSAxKSkgLSAxO1xyXG4gICAgbGV0IHMsIGUsIGYsIGxuLCBpO1xyXG4gICAgLy8gQ29tcHV0ZSBzaWduLCBleHBvbmVudCwgZnJhY3Rpb25cclxuICAgIC8vIFNraXAgTmFOIC8gSW5maW5pdHkgaGFuZGxpbmcgLS1NSkwuXHJcbiAgICBpZiAodiA9PT0gMCkge1xyXG4gICAgICAgIGUgPSAwO1xyXG4gICAgICAgIGYgPSAwO1xyXG4gICAgICAgIHMgPSAxIC8gdiA9PT0gLUluZmluaXR5ID8gMSA6IDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBzID0gdiA8IDA7XHJcbiAgICAgICAgdiA9IE1hdGguYWJzKHYpO1xyXG4gICAgICAgIGlmICh2ID49IE1hdGgucG93KDIsIDEgLSBiaWFzKSkge1xyXG4gICAgICAgICAgICAvLyBOb3JtYWxpemVkXHJcbiAgICAgICAgICAgIGxuID0gTWF0aC5taW4oTWF0aC5mbG9vcihNYXRoLmxvZyh2KSAvIE1hdGguTE4yKSwgYmlhcyk7XHJcbiAgICAgICAgICAgIGUgPSBsbiArIGJpYXM7XHJcbiAgICAgICAgICAgIGYgPSBNYXRoLnJvdW5kKHYgKiBNYXRoLnBvdygyLCBmYml0cyAtIGxuKSAtIE1hdGgucG93KDIsIGZiaXRzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBEZW5vcm1hbGl6ZWRcclxuICAgICAgICAgICAgZSA9IDA7XHJcbiAgICAgICAgICAgIGYgPSBNYXRoLnJvdW5kKHYgLyBNYXRoLnBvdygyLCAxIC0gYmlhcyAtIGZiaXRzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gUGFjayBzaWduLCBleHBvbmVudCwgZnJhY3Rpb25cclxuICAgIGNvbnN0IGJpdHMgPSBbXTtcclxuICAgIGZvciAoaSA9IGZiaXRzOyBpOyBpIC09IDEpIHtcclxuICAgICAgICBiaXRzLnB1c2goZiAlIDIgPyAxIDogMCk7XHJcbiAgICAgICAgZiA9IE1hdGguZmxvb3IoZiAvIDIpO1xyXG4gICAgfVxyXG4gICAgZm9yIChpID0gZWJpdHM7IGk7IGkgLT0gMSkge1xyXG4gICAgICAgIGJpdHMucHVzaChlICUgMiA/IDEgOiAwKTtcclxuICAgICAgICBlID0gTWF0aC5mbG9vcihlIC8gMik7XHJcbiAgICB9XHJcbiAgICBiaXRzLnB1c2gocyA/IDEgOiAwKTtcclxuICAgIGJpdHMucmV2ZXJzZSgpO1xyXG4gICAgY29uc3Qgc3RyID0gYml0cy5qb2luKCcnKTtcclxuICAgIC8vIFJldHVybiB0aGUgZGF0YSBhcyBhIGhleCBzdHJpbmcuIC0tTUpMXHJcbiAgICBsZXQgaGV4Qnl0ZVN0cmluZyA9ICcnO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyBpICs9IDgpIHtcclxuICAgICAgICBsZXQgaGV4Qnl0ZSA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSwgOCksIDIpLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICBpZiAoaGV4Qnl0ZS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgaGV4Qnl0ZSA9ICcwJyArIGhleEJ5dGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhleEJ5dGVTdHJpbmcgPSBoZXhCeXRlU3RyaW5nICsgaGV4Qnl0ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBoZXhCeXRlU3RyaW5nLnRvTG93ZXJDYXNlKCk7XHJcbn07XHJcbi8qKlxyXG4gKiBVc2VkIHRvIGRldGVjdCBpZiB3ZSdyZSBpbiBhIENocm9tZSBjb250ZW50IHNjcmlwdCAod2hpY2ggZXhlY3V0ZXMgaW4gYW5cclxuICogaXNvbGF0ZWQgZW52aXJvbm1lbnQgd2hlcmUgbG9uZy1wb2xsaW5nIGRvZXNuJ3Qgd29yaykuXHJcbiAqL1xyXG5jb25zdCBpc0Nocm9tZUV4dGVuc2lvbkNvbnRlbnRTY3JpcHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gISEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICB3aW5kb3dbJ2Nocm9tZSddICYmXHJcbiAgICAgICAgd2luZG93WydjaHJvbWUnXVsnZXh0ZW5zaW9uJ10gJiZcclxuICAgICAgICAhL15jaHJvbWUvLnRlc3Qod2luZG93LmxvY2F0aW9uLmhyZWYpKTtcclxufTtcclxuLyoqXHJcbiAqIFVzZWQgdG8gZGV0ZWN0IGlmIHdlJ3JlIGluIGEgV2luZG93cyA4IFN0b3JlIGFwcC5cclxuICovXHJcbmNvbnN0IGlzV2luZG93c1N0b3JlQXBwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gQ2hlY2sgZm9yIHRoZSBwcmVzZW5jZSBvZiBhIGNvdXBsZSBXaW5SVCBnbG9iYWxzXHJcbiAgICByZXR1cm4gdHlwZW9mIFdpbmRvd3MgPT09ICdvYmplY3QnICYmIHR5cGVvZiBXaW5kb3dzLlVJID09PSAnb2JqZWN0JztcclxufTtcclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgc2VydmVyIGVycm9yIGNvZGUgdG8gYSBKYXZhU2NyaXB0IEVycm9yXHJcbiAqL1xyXG5mdW5jdGlvbiBlcnJvckZvclNlcnZlckNvZGUoY29kZSwgcXVlcnkpIHtcclxuICAgIGxldCByZWFzb24gPSAnVW5rbm93biBFcnJvcic7XHJcbiAgICBpZiAoY29kZSA9PT0gJ3Rvb19iaWcnKSB7XHJcbiAgICAgICAgcmVhc29uID1cclxuICAgICAgICAgICAgJ1RoZSBkYXRhIHJlcXVlc3RlZCBleGNlZWRzIHRoZSBtYXhpbXVtIHNpemUgJyArXHJcbiAgICAgICAgICAgICAgICAndGhhdCBjYW4gYmUgYWNjZXNzZWQgd2l0aCBhIHNpbmdsZSByZXF1ZXN0Lic7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjb2RlID09PSAncGVybWlzc2lvbl9kZW5pZWQnKSB7XHJcbiAgICAgICAgcmVhc29uID0gXCJDbGllbnQgZG9lc24ndCBoYXZlIHBlcm1pc3Npb24gdG8gYWNjZXNzIHRoZSBkZXNpcmVkIGRhdGEuXCI7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjb2RlID09PSAndW5hdmFpbGFibGUnKSB7XHJcbiAgICAgICAgcmVhc29uID0gJ1RoZSBzZXJ2aWNlIGlzIHVuYXZhaWxhYmxlJztcclxuICAgIH1cclxuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGNvZGUgKyAnIGF0ICcgKyBxdWVyeS5fcGF0aC50b1N0cmluZygpICsgJzogJyArIHJlYXNvbik7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgZXJyb3IuY29kZSA9IGNvZGUudG9VcHBlckNhc2UoKTtcclxuICAgIHJldHVybiBlcnJvcjtcclxufVxyXG4vKipcclxuICogVXNlZCB0byB0ZXN0IGZvciBpbnRlZ2VyLWxvb2tpbmcgc3RyaW5nc1xyXG4gKi9cclxuY29uc3QgSU5URUdFUl9SRUdFWFBfID0gbmV3IFJlZ0V4cCgnXi0/KDAqKVxcXFxkezEsMTB9JCcpO1xyXG4vKipcclxuICogRm9yIHVzZSBpbiBrZXlzLCB0aGUgbWluaW11bSBwb3NzaWJsZSAzMi1iaXQgaW50ZWdlci5cclxuICovXHJcbmNvbnN0IElOVEVHRVJfMzJfTUlOID0gLTIxNDc0ODM2NDg7XHJcbi8qKlxyXG4gKiBGb3IgdXNlIGluIGtleXMsIHRoZSBtYXhpbXVtIHBvc3NpYmxlIDMyLWJpdCBpbnRlZ2VyLlxyXG4gKi9cclxuY29uc3QgSU5URUdFUl8zMl9NQVggPSAyMTQ3NDgzNjQ3O1xyXG4vKipcclxuICogSWYgdGhlIHN0cmluZyBjb250YWlucyBhIDMyLWJpdCBpbnRlZ2VyLCByZXR1cm4gaXQuICBFbHNlIHJldHVybiBudWxsLlxyXG4gKi9cclxuY29uc3QgdHJ5UGFyc2VJbnQgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICBpZiAoSU5URUdFUl9SRUdFWFBfLnRlc3Qoc3RyKSkge1xyXG4gICAgICAgIGNvbnN0IGludFZhbCA9IE51bWJlcihzdHIpO1xyXG4gICAgICAgIGlmIChpbnRWYWwgPj0gSU5URUdFUl8zMl9NSU4gJiYgaW50VmFsIDw9IElOVEVHRVJfMzJfTUFYKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnRWYWw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gcnVuIHNvbWUgY29kZSBidXQgY2F0Y2ggYW55IGV4Y2VwdGlvbnMgYW5kIHJlLXRocm93IHRoZW0gbGF0ZXIuXHJcbiAqIFVzZWZ1bCBmb3IgcHJldmVudGluZyB1c2VyIGNhbGxiYWNrcyBmcm9tIGJyZWFraW5nIGludGVybmFsIGNvZGUuXHJcbiAqXHJcbiAqIFJlLXRocm93aW5nIHRoZSBleGNlcHRpb24gZnJvbSBhIHNldFRpbWVvdXQgaXMgYSBsaXR0bGUgZXZpbCwgYnV0IGl0J3MgdmVyeVxyXG4gKiBjb252ZW5pZW50ICh3ZSBkb24ndCBoYXZlIHRvIHRyeSB0byBmaWd1cmUgb3V0IHdoZW4gaXMgYSBzYWZlIHBvaW50IHRvXHJcbiAqIHJlLXRocm93IGl0KSwgYW5kIHRoZSBiZWhhdmlvciBzZWVtcyByZWFzb25hYmxlOlxyXG4gKlxyXG4gKiAqIElmIHlvdSBhcmVuJ3QgcGF1c2luZyBvbiBleGNlcHRpb25zLCB5b3UgZ2V0IGFuIGVycm9yIGluIHRoZSBjb25zb2xlIHdpdGhcclxuICogICB0aGUgY29ycmVjdCBzdGFjayB0cmFjZS5cclxuICogKiBJZiB5b3UncmUgcGF1c2luZyBvbiBhbGwgZXhjZXB0aW9ucywgdGhlIGRlYnVnZ2VyIHdpbGwgcGF1c2Ugb24geW91clxyXG4gKiAgIGV4Y2VwdGlvbiBhbmQgdGhlbiBhZ2FpbiB3aGVuIHdlIHJldGhyb3cgaXQuXHJcbiAqICogSWYgeW91J3JlIG9ubHkgcGF1c2luZyBvbiB1bmNhdWdodCBleGNlcHRpb25zLCB0aGUgZGVidWdnZXIgd2lsbCBvbmx5IHBhdXNlXHJcbiAqICAgb24gdXMgcmUtdGhyb3dpbmcgaXQuXHJcbiAqXHJcbiAqIEBwYXJhbSBmbiAtIFRoZSBjb2RlIHRvIGd1YXJkLlxyXG4gKi9cclxuY29uc3QgZXhjZXB0aW9uR3VhcmQgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZm4oKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gUmUtdGhyb3cgZXhjZXB0aW9uIHdoZW4gaXQncyBzYWZlLlxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBJdCB1c2VkIHRvIGJlIHRoYXQgXCJ0aHJvdyBlXCIgd291bGQgcmVzdWx0IGluIGEgZ29vZCBjb25zb2xlIGVycm9yIHdpdGhcclxuICAgICAgICAgICAgLy8gcmVsZXZhbnQgY29udGV4dCwgYnV0IGFzIG9mIENocm9tZSAzOSwgeW91IGp1c3QgZ2V0IHRoZSBmaXJlYmFzZS5qc1xyXG4gICAgICAgICAgICAvLyBmaWxlL2xpbmUgbnVtYmVyIHdoZXJlIHdlIHJlLXRocm93IGl0LCB3aGljaCBpcyB1c2VsZXNzLiBTbyB3ZSBsb2dcclxuICAgICAgICAgICAgLy8gZS5zdGFjayBleHBsaWNpdGx5LlxyXG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IGUuc3RhY2sgfHwgJyc7XHJcbiAgICAgICAgICAgIHdhcm4oJ0V4Y2VwdGlvbiB3YXMgdGhyb3duIGJ5IHVzZXIgY2FsbGJhY2suJywgc3RhY2spO1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH0sIE1hdGguZmxvb3IoMCkpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgd2UgdGhpbmsgd2UncmUgY3VycmVudGx5IGJlaW5nIGNyYXdsZWQuXHJcbiAqL1xyXG5jb25zdCBiZWluZ0NyYXdsZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBjb25zdCB1c2VyQWdlbnQgPSAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICB3aW5kb3dbJ25hdmlnYXRvciddICYmXHJcbiAgICAgICAgd2luZG93WyduYXZpZ2F0b3InXVsndXNlckFnZW50J10pIHx8XHJcbiAgICAgICAgJyc7XHJcbiAgICAvLyBGb3Igbm93IHdlIHdoaXRlbGlzdCB0aGUgbW9zdCBwb3B1bGFyIGNyYXdsZXJzLiAgV2Ugc2hvdWxkIHJlZmluZSB0aGlzIHRvIGJlIHRoZSBzZXQgb2YgY3Jhd2xlcnMgd2VcclxuICAgIC8vIGJlbGlldmUgdG8gc3VwcG9ydCBKYXZhU2NyaXB0L0FKQVggcmVuZGVyaW5nLlxyXG4gICAgLy8gTk9URTogR29vZ2xlIFdlYm1hc3RlciBUb29scyBkb2Vzbid0IHJlYWxseSBiZWxvbmcsIGJ1dCB0aGVpciBcIlRoaXMgaXMgaG93IGEgdmlzaXRvciB0byB5b3VyIHdlYnNpdGVcclxuICAgIC8vIHdvdWxkIGhhdmUgc2VlbiB0aGUgcGFnZVwiIGlzIGZsYWt5IGlmIHdlIGRvbid0IHRyZWF0IGl0IGFzIGEgY3Jhd2xlci5cclxuICAgIHJldHVybiAodXNlckFnZW50LnNlYXJjaCgvZ29vZ2xlYm90fGdvb2dsZSB3ZWJtYXN0ZXIgdG9vbHN8YmluZ2JvdHx5YWhvbyEgc2x1cnB8YmFpZHVzcGlkZXJ8eWFuZGV4Ym90fGR1Y2tkdWNrYm90L2kpID49IDApO1xyXG59O1xyXG4vKipcclxuICogU2FtZSBhcyBzZXRUaW1lb3V0KCkgZXhjZXB0IG9uIE5vZGUuSlMgaXQgd2lsbCAvbm90LyBwcmV2ZW50IHRoZSBwcm9jZXNzIGZyb20gZXhpdGluZy5cclxuICpcclxuICogSXQgaXMgcmVtb3ZlZCB3aXRoIGNsZWFyVGltZW91dCgpIGFzIG5vcm1hbC5cclxuICpcclxuICogQHBhcmFtIGZuIC0gRnVuY3Rpb24gdG8gcnVuLlxyXG4gKiBAcGFyYW0gdGltZSAtIE1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBydW5uaW5nLlxyXG4gKiBAcmV0dXJucyBUaGUgc2V0VGltZW91dCgpIHJldHVybiB2YWx1ZS5cclxuICovXHJcbmNvbnN0IHNldFRpbWVvdXROb25CbG9ja2luZyA9IGZ1bmN0aW9uIChmbiwgdGltZSkge1xyXG4gICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoZm4sIHRpbWUpO1xyXG4gICAgLy8gTm90ZTogYXQgdGhlIHRpbWUgb2YgdGhpcyBjb21tZW50LCB1bnJlZlRpbWVyIGlzIHVuZGVyIHRoZSB1bnN0YWJsZSBzZXQgb2YgQVBJcy4gUnVuIHdpdGggLS11bnN0YWJsZSB0byBlbmFibGUgdGhlIEFQSS5cclxuICAgIGlmICh0eXBlb2YgdGltZW91dCA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAvLyBAdHMtaWdub3JlIElzIG9ubHkgZGVmaW5lZCBpbiBEZW5vIGVudmlyb25tZW50cy5cclxuICAgICAgICB0eXBlb2YgRGVubyAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAvLyBAdHMtaWdub3JlIERlbm8gYW5kIHVucmVmVGltZXIgYXJlIG9ubHkgZGVmaW5lZCBpbiBEZW5vIGVudmlyb25tZW50cy5cclxuICAgICAgICBEZW5vWyd1bnJlZlRpbWVyJ10pIHtcclxuICAgICAgICAvLyBAdHMtaWdub3JlIERlbm8gYW5kIHVucmVmVGltZXIgYXJlIG9ubHkgZGVmaW5lZCBpbiBEZW5vIGVudmlyb25tZW50cy5cclxuICAgICAgICBEZW5vLnVucmVmVGltZXIodGltZW91dCk7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiB0aW1lb3V0ID09PSAnb2JqZWN0JyAmJiB0aW1lb3V0Wyd1bnJlZiddKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICB0aW1lb3V0Wyd1bnJlZiddKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGltZW91dDtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFic3RyYWN0aW9uIGFyb3VuZCBBcHBDaGVjaydzIHRva2VuIGZldGNoaW5nIGNhcGFiaWxpdGllcy5cclxuICovXHJcbmNsYXNzIEFwcENoZWNrVG9rZW5Qcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHBOYW1lXywgYXBwQ2hlY2tQcm92aWRlcikge1xyXG4gICAgICAgIHRoaXMuYXBwTmFtZV8gPSBhcHBOYW1lXztcclxuICAgICAgICB0aGlzLmFwcENoZWNrUHJvdmlkZXIgPSBhcHBDaGVja1Byb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2sgPSBhcHBDaGVja1Byb3ZpZGVyID09PSBudWxsIHx8IGFwcENoZWNrUHJvdmlkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwcENoZWNrUHJvdmlkZXIuZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFwcENoZWNrKSB7XHJcbiAgICAgICAgICAgIGFwcENoZWNrUHJvdmlkZXIgPT09IG51bGwgfHwgYXBwQ2hlY2tQcm92aWRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXBwQ2hlY2tQcm92aWRlci5nZXQoKS50aGVuKGFwcENoZWNrID0+ICh0aGlzLmFwcENoZWNrID0gYXBwQ2hlY2spKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRUb2tlbihmb3JjZVJlZnJlc2gpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYXBwQ2hlY2spIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQgZGVsYXllZCBpbml0aWFsaXphdGlvbiBvZiBGaXJlYmFzZUFwcENoZWNrLiBUaGlzIGFsbG93cyBvdXJcclxuICAgICAgICAgICAgICAgIC8vIGN1c3RvbWVycyB0byBpbml0aWFsaXplIHRoZSBSVERCIFNESyBiZWZvcmUgaW5pdGlhbGl6aW5nIEZpcmViYXNlXHJcbiAgICAgICAgICAgICAgICAvLyBBcHBDaGVjayBhbmQgZW5zdXJlcyB0aGF0IGFsbCByZXF1ZXN0cyBhcmUgYXV0aGVudGljYXRlZCBpZiBhIHRva2VuXHJcbiAgICAgICAgICAgICAgICAvLyBiZWNvbWVzIGF2YWlsYWJsZSBiZWZvcmUgdGhlIHRpbWVvdXQgYmVsb3cgZXhwaXJlcy5cclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFwcENoZWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwQ2hlY2suZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKTtcclxuICAgIH1cclxuICAgIGFkZFRva2VuQ2hhbmdlTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgKF9hID0gdGhpcy5hcHBDaGVja1Byb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KCkudGhlbihhcHBDaGVjayA9PiBhcHBDaGVjay5hZGRUb2tlbkxpc3RlbmVyKGxpc3RlbmVyKSk7XHJcbiAgICB9XHJcbiAgICBub3RpZnlGb3JJbnZhbGlkVG9rZW4oKSB7XHJcbiAgICAgICAgd2FybihgUHJvdmlkZWQgQXBwQ2hlY2sgY3JlZGVudGlhbHMgZm9yIHRoZSBhcHAgbmFtZWQgXCIke3RoaXMuYXBwTmFtZV99XCIgYCArXHJcbiAgICAgICAgICAgICdhcmUgaW52YWxpZC4gVGhpcyB1c3VhbGx5IGluZGljYXRlcyB5b3VyIGFwcCB3YXMgbm90IGluaXRpYWxpemVkIGNvcnJlY3RseS4nKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQWJzdHJhY3Rpb24gYXJvdW5kIEZpcmViYXNlQXBwJ3MgdG9rZW4gZmV0Y2hpbmcgY2FwYWJpbGl0aWVzLlxyXG4gKi9cclxuY2xhc3MgRmlyZWJhc2VBdXRoVG9rZW5Qcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHBOYW1lXywgZmlyZWJhc2VPcHRpb25zXywgYXV0aFByb3ZpZGVyXykge1xyXG4gICAgICAgIHRoaXMuYXBwTmFtZV8gPSBhcHBOYW1lXztcclxuICAgICAgICB0aGlzLmZpcmViYXNlT3B0aW9uc18gPSBmaXJlYmFzZU9wdGlvbnNfO1xyXG4gICAgICAgIHRoaXMuYXV0aFByb3ZpZGVyXyA9IGF1dGhQcm92aWRlcl87XHJcbiAgICAgICAgdGhpcy5hdXRoXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5hdXRoXyA9IGF1dGhQcm92aWRlcl8uZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmF1dGhfKSB7XHJcbiAgICAgICAgICAgIGF1dGhQcm92aWRlcl8ub25Jbml0KGF1dGggPT4gKHRoaXMuYXV0aF8gPSBhdXRoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmF1dGhfKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0IGRlbGF5ZWQgaW5pdGlhbGl6YXRpb24gb2YgRmlyZWJhc2VBdXRoLiBUaGlzIGFsbG93cyBvdXJcclxuICAgICAgICAgICAgICAgIC8vIGN1c3RvbWVycyB0byBpbml0aWFsaXplIHRoZSBSVERCIFNESyBiZWZvcmUgaW5pdGlhbGl6aW5nIEZpcmViYXNlXHJcbiAgICAgICAgICAgICAgICAvLyBBdXRoIGFuZCBlbnN1cmVzIHRoYXQgYWxsIHJlcXVlc3RzIGFyZSBhdXRoZW50aWNhdGVkIGlmIGEgdG9rZW5cclxuICAgICAgICAgICAgICAgIC8vIGJlY29tZXMgYXZhaWxhYmxlIGJlZm9yZSB0aGUgdGltZW91dCBiZWxvdyBleHBpcmVzLlxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0aF8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5hdXRoXy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgLy8gVE9ETzogTmVlZCB0byBmaWd1cmUgb3V0IGFsbCB0aGUgY2FzZXMgdGhpcyBpcyByYWlzZWQgYW5kIHdoZXRoZXJcclxuICAgICAgICAgICAgLy8gdGhpcyBtYWtlcyBzZW5zZS5cclxuICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLmNvZGUgPT09ICdhdXRoL3Rva2VuLW5vdC1pbml0aWFsaXplZCcpIHtcclxuICAgICAgICAgICAgICAgIGxvZygnR290IGF1dGgvdG9rZW4tbm90LWluaXRpYWxpemVkIGVycm9yLiAgVHJlYXRpbmcgYXMgbnVsbCB0b2tlbi4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYWRkVG9rZW5DaGFuZ2VMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIC8vIFRPRE86IFdlIG1pZ2h0IHdhbnQgdG8gd3JhcCB0aGUgbGlzdGVuZXIgYW5kIGNhbGwgaXQgd2l0aCBubyBhcmdzIHRvXHJcbiAgICAgICAgLy8gYXZvaWQgYSBsZWFreSBhYnN0cmFjdGlvbiwgYnV0IHRoYXQgbWFrZXMgcmVtb3ZpbmcgdGhlIGxpc3RlbmVyIGhhcmRlci5cclxuICAgICAgICBpZiAodGhpcy5hdXRoXykge1xyXG4gICAgICAgICAgICB0aGlzLmF1dGhfLmFkZEF1dGhUb2tlbkxpc3RlbmVyKGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXV0aFByb3ZpZGVyX1xyXG4gICAgICAgICAgICAgICAgLmdldCgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihhdXRoID0+IGF1dGguYWRkQXV0aFRva2VuTGlzdGVuZXIobGlzdGVuZXIpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmVUb2tlbkNoYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5hdXRoUHJvdmlkZXJfXHJcbiAgICAgICAgICAgIC5nZXQoKVxyXG4gICAgICAgICAgICAudGhlbihhdXRoID0+IGF1dGgucmVtb3ZlQXV0aFRva2VuTGlzdGVuZXIobGlzdGVuZXIpKTtcclxuICAgIH1cclxuICAgIG5vdGlmeUZvckludmFsaWRUb2tlbigpIHtcclxuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gJ1Byb3ZpZGVkIGF1dGhlbnRpY2F0aW9uIGNyZWRlbnRpYWxzIGZvciB0aGUgYXBwIG5hbWVkIFwiJyArXHJcbiAgICAgICAgICAgIHRoaXMuYXBwTmFtZV8gK1xyXG4gICAgICAgICAgICAnXCIgYXJlIGludmFsaWQuIFRoaXMgdXN1YWxseSBpbmRpY2F0ZXMgeW91ciBhcHAgd2FzIG5vdCAnICtcclxuICAgICAgICAgICAgJ2luaXRpYWxpemVkIGNvcnJlY3RseS4gJztcclxuICAgICAgICBpZiAoJ2NyZWRlbnRpYWwnIGluIHRoaXMuZmlyZWJhc2VPcHRpb25zXykge1xyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz1cclxuICAgICAgICAgICAgICAgICdNYWtlIHN1cmUgdGhlIFwiY3JlZGVudGlhbFwiIHByb3BlcnR5IHByb3ZpZGVkIHRvIGluaXRpYWxpemVBcHAoKSAnICtcclxuICAgICAgICAgICAgICAgICAgICAnaXMgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhlIHNwZWNpZmllZCBcImRhdGFiYXNlVVJMXCIgYW5kIGlzIGZyb20gdGhlIGNvcnJlY3QgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ3Byb2plY3QuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ3NlcnZpY2VBY2NvdW50JyBpbiB0aGlzLmZpcmViYXNlT3B0aW9uc18pIHtcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9XHJcbiAgICAgICAgICAgICAgICAnTWFrZSBzdXJlIHRoZSBcInNlcnZpY2VBY2NvdW50XCIgcHJvcGVydHkgcHJvdmlkZWQgdG8gaW5pdGlhbGl6ZUFwcCgpICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdpcyBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGUgc3BlY2lmaWVkIFwiZGF0YWJhc2VVUkxcIiBhbmQgaXMgZnJvbSB0aGUgY29ycmVjdCAnICtcclxuICAgICAgICAgICAgICAgICAgICAncHJvamVjdC4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9XHJcbiAgICAgICAgICAgICAgICAnTWFrZSBzdXJlIHRoZSBcImFwaUtleVwiIGFuZCBcImRhdGFiYXNlVVJMXCIgcHJvcGVydGllcyBwcm92aWRlZCB0byAnICtcclxuICAgICAgICAgICAgICAgICAgICAnaW5pdGlhbGl6ZUFwcCgpIG1hdGNoIHRoZSB2YWx1ZXMgcHJvdmlkZWQgZm9yIHlvdXIgYXBwIGF0ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2NvbnNvbGUuZmlyZWJhc2UuZ29vZ2xlLmNvbS8uJztcclxuICAgICAgICB9XHJcbiAgICAgICAgd2FybihlcnJvck1lc3NhZ2UpO1xyXG4gICAgfVxyXG59XHJcbi8qIEF1dGhUb2tlblByb3ZpZGVyIHRoYXQgc3VwcGxpZXMgYSBjb25zdGFudCB0b2tlbi4gVXNlZCBieSBBZG1pbiBTREsgb3IgbW9ja1VzZXJUb2tlbiB3aXRoIGVtdWxhdG9ycy4gKi9cclxuY2xhc3MgRW11bGF0b3JUb2tlblByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xyXG4gICAgfVxyXG4gICAgZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XHJcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiB0aGlzLmFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhZGRUb2tlbkNoYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgLy8gSW52b2tlIHRoZSBsaXN0ZW5lciBpbW1lZGlhdGVseSB0byBtYXRjaCB0aGUgYmVoYXZpb3IgaW4gRmlyZWJhc2UgQXV0aFxyXG4gICAgICAgIC8vIChzZWUgcGFja2FnZXMvYXV0aC9zcmMvYXV0aC5qcyNMMTgwNylcclxuICAgICAgICBsaXN0ZW5lcih0aGlzLmFjY2Vzc1Rva2VuKTtcclxuICAgIH1cclxuICAgIHJlbW92ZVRva2VuQ2hhbmdlTGlzdGVuZXIobGlzdGVuZXIpIHsgfVxyXG4gICAgbm90aWZ5Rm9ySW52YWxpZFRva2VuKCkgeyB9XHJcbn1cclxuLyoqIEEgc3RyaW5nIHRoYXQgaXMgdHJlYXRlZCBhcyBhbiBhZG1pbiBhY2Nlc3MgdG9rZW4gYnkgdGhlIFJUREIgZW11bGF0b3IuIFVzZWQgYnkgQWRtaW4gU0RLLiAqL1xyXG5FbXVsYXRvclRva2VuUHJvdmlkZXIuT1dORVIgPSAnb3duZXInO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBQUk9UT0NPTF9WRVJTSU9OID0gJzUnO1xyXG5jb25zdCBWRVJTSU9OX1BBUkFNID0gJ3YnO1xyXG5jb25zdCBUUkFOU1BPUlRfU0VTU0lPTl9QQVJBTSA9ICdzJztcclxuY29uc3QgUkVGRVJFUl9QQVJBTSA9ICdyJztcclxuY29uc3QgRk9SR0VfUkVGID0gJ2YnO1xyXG4vLyBNYXRjaGVzIGNvbnNvbGUuZmlyZWJhc2UuZ29vZ2xlLmNvbSwgZmlyZWJhc2UtY29uc29sZS0qLmNvcnAuZ29vZ2xlLmNvbSBhbmRcclxuLy8gZmlyZWJhc2UuY29ycC5nb29nbGUuY29tXHJcbmNvbnN0IEZPUkdFX0RPTUFJTl9SRSA9IC8oY29uc29sZVxcLmZpcmViYXNlfGZpcmViYXNlLWNvbnNvbGUtXFx3K1xcLmNvcnB8ZmlyZWJhc2VcXC5jb3JwKVxcLmdvb2dsZVxcLmNvbS87XHJcbmNvbnN0IExBU1RfU0VTU0lPTl9QQVJBTSA9ICdscyc7XHJcbmNvbnN0IEFQUExJQ0FUSU9OX0lEX1BBUkFNID0gJ3AnO1xyXG5jb25zdCBBUFBfQ0hFQ0tfVE9LRU5fUEFSQU0gPSAnYWMnO1xyXG5jb25zdCBXRUJTT0NLRVQgPSAnd2Vic29ja2V0JztcclxuY29uc3QgTE9OR19QT0xMSU5HID0gJ2xvbmdfcG9sbGluZyc7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGNsYXNzIHRoYXQgaG9sZHMgbWV0YWRhdGEgYWJvdXQgYSBSZXBvIG9iamVjdFxyXG4gKi9cclxuY2xhc3MgUmVwb0luZm8ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gaG9zdCAtIEhvc3RuYW1lIHBvcnRpb24gb2YgdGhlIHVybCBmb3IgdGhlIHJlcG9cclxuICAgICAqIEBwYXJhbSBzZWN1cmUgLSBXaGV0aGVyIG9yIG5vdCB0aGlzIHJlcG8gaXMgYWNjZXNzZWQgb3ZlciBzc2xcclxuICAgICAqIEBwYXJhbSBuYW1lc3BhY2UgLSBUaGUgbmFtZXNwYWNlIHJlcHJlc2VudGVkIGJ5IHRoZSByZXBvXHJcbiAgICAgKiBAcGFyYW0gd2ViU29ja2V0T25seSAtIFdoZXRoZXIgdG8gcHJlZmVyIHdlYnNvY2tldHMgb3ZlciBhbGwgb3RoZXIgdHJhbnNwb3J0cyAodXNlZCBieSBOZXN0KS5cclxuICAgICAqIEBwYXJhbSBub2RlQWRtaW4gLSBXaGV0aGVyIHRoaXMgaW5zdGFuY2UgdXNlcyBBZG1pbiBTREsgY3JlZGVudGlhbHNcclxuICAgICAqIEBwYXJhbSBwZXJzaXN0ZW5jZUtleSAtIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHNlc3Npb24gcGVyc2lzdGVuY2Ugc3RvcmFnZSBrZXlcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoaG9zdCwgc2VjdXJlLCBuYW1lc3BhY2UsIHdlYlNvY2tldE9ubHksIG5vZGVBZG1pbiA9IGZhbHNlLCBwZXJzaXN0ZW5jZUtleSA9ICcnLCBpbmNsdWRlTmFtZXNwYWNlSW5RdWVyeVBhcmFtcyA9IGZhbHNlLCBpc1VzaW5nRW11bGF0b3IgPSBmYWxzZSkge1xyXG4gICAgICAgIHRoaXMuc2VjdXJlID0gc2VjdXJlO1xyXG4gICAgICAgIHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xyXG4gICAgICAgIHRoaXMud2ViU29ja2V0T25seSA9IHdlYlNvY2tldE9ubHk7XHJcbiAgICAgICAgdGhpcy5ub2RlQWRtaW4gPSBub2RlQWRtaW47XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZUtleSA9IHBlcnNpc3RlbmNlS2V5O1xyXG4gICAgICAgIHRoaXMuaW5jbHVkZU5hbWVzcGFjZUluUXVlcnlQYXJhbXMgPSBpbmNsdWRlTmFtZXNwYWNlSW5RdWVyeVBhcmFtcztcclxuICAgICAgICB0aGlzLmlzVXNpbmdFbXVsYXRvciA9IGlzVXNpbmdFbXVsYXRvcjtcclxuICAgICAgICB0aGlzLl9ob3N0ID0gaG9zdC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIHRoaXMuX2RvbWFpbiA9IHRoaXMuX2hvc3Quc3Vic3RyKHRoaXMuX2hvc3QuaW5kZXhPZignLicpICsgMSk7XHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbEhvc3QgPVxyXG4gICAgICAgICAgICBQZXJzaXN0ZW50U3RvcmFnZS5nZXQoJ2hvc3Q6JyArIGhvc3QpIHx8IHRoaXMuX2hvc3Q7XHJcbiAgICB9XHJcbiAgICBpc0NhY2hlYWJsZUhvc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxIb3N0LnN1YnN0cigwLCAyKSA9PT0gJ3MtJztcclxuICAgIH1cclxuICAgIGlzQ3VzdG9tSG9zdCgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX2RvbWFpbiAhPT0gJ2ZpcmViYXNlaW8uY29tJyAmJlxyXG4gICAgICAgICAgICB0aGlzLl9kb21haW4gIT09ICdmaXJlYmFzZWlvLWRlbW8uY29tJyk7XHJcbiAgICB9XHJcbiAgICBnZXQgaG9zdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faG9zdDtcclxuICAgIH1cclxuICAgIHNldCBob3N0KG5ld0hvc3QpIHtcclxuICAgICAgICBpZiAobmV3SG9zdCAhPT0gdGhpcy5pbnRlcm5hbEhvc3QpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEhvc3QgPSBuZXdIb3N0O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0NhY2hlYWJsZUhvc3QoKSkge1xyXG4gICAgICAgICAgICAgICAgUGVyc2lzdGVudFN0b3JhZ2Uuc2V0KCdob3N0OicgKyB0aGlzLl9ob3N0LCB0aGlzLmludGVybmFsSG9zdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICBsZXQgc3RyID0gdGhpcy50b1VSTFN0cmluZygpO1xyXG4gICAgICAgIGlmICh0aGlzLnBlcnNpc3RlbmNlS2V5KSB7XHJcbiAgICAgICAgICAgIHN0ciArPSAnPCcgKyB0aGlzLnBlcnNpc3RlbmNlS2V5ICsgJz4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG4gICAgdG9VUkxTdHJpbmcoKSB7XHJcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSB0aGlzLnNlY3VyZSA/ICdodHRwczovLycgOiAnaHR0cDovLyc7XHJcbiAgICAgICAgY29uc3QgcXVlcnkgPSB0aGlzLmluY2x1ZGVOYW1lc3BhY2VJblF1ZXJ5UGFyYW1zXHJcbiAgICAgICAgICAgID8gYD9ucz0ke3RoaXMubmFtZXNwYWNlfWBcclxuICAgICAgICAgICAgOiAnJztcclxuICAgICAgICByZXR1cm4gYCR7cHJvdG9jb2x9JHt0aGlzLmhvc3R9LyR7cXVlcnl9YDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXBvSW5mb05lZWRzUXVlcnlQYXJhbShyZXBvSW5mbykge1xyXG4gICAgcmV0dXJuIChyZXBvSW5mby5ob3N0ICE9PSByZXBvSW5mby5pbnRlcm5hbEhvc3QgfHxcclxuICAgICAgICByZXBvSW5mby5pc0N1c3RvbUhvc3QoKSB8fFxyXG4gICAgICAgIHJlcG9JbmZvLmluY2x1ZGVOYW1lc3BhY2VJblF1ZXJ5UGFyYW1zKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgd2Vic29ja2V0IFVSTCBmb3IgdGhpcyByZXBvXHJcbiAqIEBwYXJhbSByZXBvSW5mbyAtIFJlcG9JbmZvIG9iamVjdFxyXG4gKiBAcGFyYW0gdHlwZSAtIG9mIGNvbm5lY3Rpb25cclxuICogQHBhcmFtIHBhcmFtcyAtIGxpc3RcclxuICogQHJldHVybnMgVGhlIFVSTCBmb3IgdGhpcyByZXBvXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvSW5mb0Nvbm5lY3Rpb25VUkwocmVwb0luZm8sIHR5cGUsIHBhcmFtcykge1xyXG4gICAgYXNzZXJ0KHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJywgJ3R5cGVvZiB0eXBlIG11c3QgPT0gc3RyaW5nJyk7XHJcbiAgICBhc3NlcnQodHlwZW9mIHBhcmFtcyA9PT0gJ29iamVjdCcsICd0eXBlb2YgcGFyYW1zIG11c3QgPT0gb2JqZWN0Jyk7XHJcbiAgICBsZXQgY29ublVSTDtcclxuICAgIGlmICh0eXBlID09PSBXRUJTT0NLRVQpIHtcclxuICAgICAgICBjb25uVVJMID1cclxuICAgICAgICAgICAgKHJlcG9JbmZvLnNlY3VyZSA/ICd3c3M6Ly8nIDogJ3dzOi8vJykgKyByZXBvSW5mby5pbnRlcm5hbEhvc3QgKyAnLy53cz8nO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSA9PT0gTE9OR19QT0xMSU5HKSB7XHJcbiAgICAgICAgY29ublVSTCA9XHJcbiAgICAgICAgICAgIChyZXBvSW5mby5zZWN1cmUgPyAnaHR0cHM6Ly8nIDogJ2h0dHA6Ly8nKSArXHJcbiAgICAgICAgICAgICAgICByZXBvSW5mby5pbnRlcm5hbEhvc3QgK1xyXG4gICAgICAgICAgICAgICAgJy8ubHA/JztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjb25uZWN0aW9uIHR5cGU6ICcgKyB0eXBlKTtcclxuICAgIH1cclxuICAgIGlmIChyZXBvSW5mb05lZWRzUXVlcnlQYXJhbShyZXBvSW5mbykpIHtcclxuICAgICAgICBwYXJhbXNbJ25zJ10gPSByZXBvSW5mby5uYW1lc3BhY2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYWlycyA9IFtdO1xyXG4gICAgZWFjaChwYXJhbXMsIChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgcGFpcnMucHVzaChrZXkgKyAnPScgKyB2YWx1ZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjb25uVVJMICsgcGFpcnMuam9pbignJicpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUcmFja3MgYSBjb2xsZWN0aW9uIG9mIHN0YXRzLlxyXG4gKi9cclxuY2xhc3MgU3RhdHNDb2xsZWN0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuY291bnRlcnNfID0ge307XHJcbiAgICB9XHJcbiAgICBpbmNyZW1lbnRDb3VudGVyKG5hbWUsIGFtb3VudCA9IDEpIHtcclxuICAgICAgICBpZiAoIWNvbnRhaW5zKHRoaXMuY291bnRlcnNfLCBuYW1lKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50ZXJzX1tuYW1lXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY291bnRlcnNfW25hbWVdICs9IGFtb3VudDtcclxuICAgIH1cclxuICAgIGdldCgpIHtcclxuICAgICAgICByZXR1cm4gZGVlcENvcHkodGhpcy5jb3VudGVyc18pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IGNvbGxlY3Rpb25zID0ge307XHJcbmNvbnN0IHJlcG9ydGVycyA9IHt9O1xyXG5mdW5jdGlvbiBzdGF0c01hbmFnZXJHZXRDb2xsZWN0aW9uKHJlcG9JbmZvKSB7XHJcbiAgICBjb25zdCBoYXNoU3RyaW5nID0gcmVwb0luZm8udG9TdHJpbmcoKTtcclxuICAgIGlmICghY29sbGVjdGlvbnNbaGFzaFN0cmluZ10pIHtcclxuICAgICAgICBjb2xsZWN0aW9uc1toYXNoU3RyaW5nXSA9IG5ldyBTdGF0c0NvbGxlY3Rpb24oKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb2xsZWN0aW9uc1toYXNoU3RyaW5nXTtcclxufVxyXG5mdW5jdGlvbiBzdGF0c01hbmFnZXJHZXRPckNyZWF0ZVJlcG9ydGVyKHJlcG9JbmZvLCBjcmVhdG9yRnVuY3Rpb24pIHtcclxuICAgIGNvbnN0IGhhc2hTdHJpbmcgPSByZXBvSW5mby50b1N0cmluZygpO1xyXG4gICAgaWYgKCFyZXBvcnRlcnNbaGFzaFN0cmluZ10pIHtcclxuICAgICAgICByZXBvcnRlcnNbaGFzaFN0cmluZ10gPSBjcmVhdG9yRnVuY3Rpb24oKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXBvcnRlcnNbaGFzaFN0cmluZ107XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgZW5zdXJlcyB0aGUgcGFja2V0cyBmcm9tIHRoZSBzZXJ2ZXIgYXJyaXZlIGluIG9yZGVyXHJcbiAqIFRoaXMgY2xhc3MgdGFrZXMgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgYW5kIGVuc3VyZXMgaXQgZ2V0cyBwYXNzZWQgaW50byB0aGUgY2FsbGJhY2tzIGluIG9yZGVyLlxyXG4gKi9cclxuY2xhc3MgUGFja2V0UmVjZWl2ZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gb25NZXNzYWdlX1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihvbk1lc3NhZ2VfKSB7XHJcbiAgICAgICAgdGhpcy5vbk1lc3NhZ2VfID0gb25NZXNzYWdlXztcclxuICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRSZXNwb25zZU51bSA9IDA7XHJcbiAgICAgICAgdGhpcy5jbG9zZUFmdGVyUmVzcG9uc2UgPSAtMTtcclxuICAgICAgICB0aGlzLm9uQ2xvc2UgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgY2xvc2VBZnRlcihyZXNwb25zZU51bSwgY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLmNsb3NlQWZ0ZXJSZXNwb25zZSA9IHJlc3BvbnNlTnVtO1xyXG4gICAgICAgIHRoaXMub25DbG9zZSA9IGNhbGxiYWNrO1xyXG4gICAgICAgIGlmICh0aGlzLmNsb3NlQWZ0ZXJSZXNwb25zZSA8IHRoaXMuY3VycmVudFJlc3BvbnNlTnVtKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25DbG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2UgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRWFjaCBtZXNzYWdlIGZyb20gdGhlIHNlcnZlciBjb21lcyB3aXRoIGEgcmVzcG9uc2UgbnVtYmVyLCBhbmQgYW4gYXJyYXkgb2YgZGF0YS4gVGhlIHJlc3BvbnNlTnVtYmVyXHJcbiAgICAgKiBhbGxvd3MgdXMgdG8gZW5zdXJlIHRoYXQgd2UgcHJvY2VzcyB0aGVtIGluIHRoZSByaWdodCBvcmRlciwgc2luY2Ugd2UgY2FuJ3QgYmUgZ3VhcmFudGVlZCB0aGF0IGFsbFxyXG4gICAgICogYnJvd3NlcnMgd2lsbCByZXNwb25kIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSByZXF1ZXN0cyB3ZSBzZW50XHJcbiAgICAgKi9cclxuICAgIGhhbmRsZVJlc3BvbnNlKHJlcXVlc3ROdW0sIGRhdGEpIHtcclxuICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXNbcmVxdWVzdE51bV0gPSBkYXRhO1xyXG4gICAgICAgIHdoaWxlICh0aGlzLnBlbmRpbmdSZXNwb25zZXNbdGhpcy5jdXJyZW50UmVzcG9uc2VOdW1dKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvUHJvY2VzcyA9IHRoaXMucGVuZGluZ1Jlc3BvbnNlc1t0aGlzLmN1cnJlbnRSZXNwb25zZU51bV07XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZXNwb25zZXNbdGhpcy5jdXJyZW50UmVzcG9uc2VOdW1dO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvUHJvY2Vzcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvUHJvY2Vzc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbkd1YXJkKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2VfKHRvUHJvY2Vzc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFJlc3BvbnNlTnVtID09PSB0aGlzLmNsb3NlQWZ0ZXJSZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25DbG9zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXNwb25zZU51bSsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBVUkwgcXVlcnkgcGFyYW1ldGVycyBhc3NvY2lhdGVkIHdpdGggbG9uZ3BvbGxpbmdcclxuY29uc3QgRklSRUJBU0VfTE9OR1BPTExfU1RBUlRfUEFSQU0gPSAnc3RhcnQnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9DTE9TRV9DT01NQU5EID0gJ2Nsb3NlJztcclxuY29uc3QgRklSRUJBU0VfTE9OR1BPTExfQ09NTUFORF9DQl9OQU1FID0gJ3BMUENvbW1hbmQnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9EQVRBX0NCX05BTUUgPSAncFJUTFBDQic7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX0lEX1BBUkFNID0gJ2lkJztcclxuY29uc3QgRklSRUJBU0VfTE9OR1BPTExfUFdfUEFSQU0gPSAncHcnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9TRVJJQUxfUEFSQU0gPSAnc2VyJztcclxuY29uc3QgRklSRUJBU0VfTE9OR1BPTExfQ0FMTEJBQ0tfSURfUEFSQU0gPSAnY2InO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9TRUdNRU5UX05VTV9QQVJBTSA9ICdzZWcnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9TRUdNRU5UU19JTl9QQUNLRVQgPSAndHMnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9EQVRBX1BBUkFNID0gJ2QnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9ESVNDT05OX0ZSQU1FX1JFUVVFU1RfUEFSQU0gPSAnZGZyYW1lJztcclxuLy9EYXRhIHNpemUgY29uc3RhbnRzLlxyXG4vL1RPRE86IFBlcmY6IHRoZSBtYXhpbXVtIGxlbmd0aCBhY3R1YWxseSBkaWZmZXJzIGZyb20gYnJvd3NlciB0byBicm93c2VyLlxyXG4vLyBXZSBzaG91bGQgY2hlY2sgd2hhdCBicm93c2VyIHdlJ3JlIG9uIGFuZCBzZXQgYWNjb3JkaW5nbHkuXHJcbmNvbnN0IE1BWF9VUkxfREFUQV9TSVpFID0gMTg3MDtcclxuY29uc3QgU0VHX0hFQURFUl9TSVpFID0gMzA7IC8vaWU6ICZzZWc9ODI5OTIzNCZ0cz05ODIzODkxMjMmZD1cclxuY29uc3QgTUFYX1BBWUxPQURfU0laRSA9IE1BWF9VUkxfREFUQV9TSVpFIC0gU0VHX0hFQURFUl9TSVpFO1xyXG4vKipcclxuICogS2VlcGFsaXZlIHBlcmlvZFxyXG4gKiBzZW5kIGEgZnJlc2ggcmVxdWVzdCBhdCBtaW5pbXVtIGV2ZXJ5IDI1IHNlY29uZHMuIE9wZXJhIGhhcyBhIG1heGltdW0gcmVxdWVzdFxyXG4gKiBsZW5ndGggb2YgMzAgc2Vjb25kcyB0aGF0IHdlIGNhbid0IGV4Y2VlZC5cclxuICovXHJcbmNvbnN0IEtFRVBBTElWRV9SRVFVRVNUX0lOVEVSVkFMID0gMjUwMDA7XHJcbi8qKlxyXG4gKiBIb3cgbG9uZyB0byB3YWl0IGJlZm9yZSBhYm9ydGluZyBhIGxvbmctcG9sbGluZyBjb25uZWN0aW9uIGF0dGVtcHQuXHJcbiAqL1xyXG5jb25zdCBMUF9DT05ORUNUX1RJTUVPVVQgPSAzMDAwMDtcclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgbWFuYWdlcyBhIHNpbmdsZSBsb25nLXBvbGxpbmcgY29ubmVjdGlvbi5cclxuICovXHJcbmNsYXNzIEJyb3dzZXJQb2xsQ29ubmVjdGlvbiB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBjb25uSWQgQW4gaWRlbnRpZmllciBmb3IgdGhpcyBjb25uZWN0aW9uLCB1c2VkIGZvciBsb2dnaW5nXHJcbiAgICAgKiBAcGFyYW0gcmVwb0luZm8gVGhlIGluZm8gZm9yIHRoZSBlbmRwb2ludCB0byBzZW5kIGRhdGEgdG8uXHJcbiAgICAgKiBAcGFyYW0gYXBwbGljYXRpb25JZCBUaGUgRmlyZWJhc2UgQXBwIElEIGZvciB0aGlzIHByb2plY3QuXHJcbiAgICAgKiBAcGFyYW0gYXBwQ2hlY2tUb2tlbiBUaGUgQXBwQ2hlY2sgdG9rZW4gZm9yIHRoaXMgY2xpZW50LlxyXG4gICAgICogQHBhcmFtIGF1dGhUb2tlbiBUaGUgQXV0aFRva2VuIHRvIHVzZSBmb3IgdGhpcyBjb25uZWN0aW9uLlxyXG4gICAgICogQHBhcmFtIHRyYW5zcG9ydFNlc3Npb25JZCBPcHRpb25hbCB0cmFuc3BvcnRTZXNzaW9uaWQgaWYgd2UgYXJlXHJcbiAgICAgKiByZWNvbm5lY3RpbmcgZm9yIGFuIGV4aXN0aW5nIHRyYW5zcG9ydCBzZXNzaW9uXHJcbiAgICAgKiBAcGFyYW0gbGFzdFNlc3Npb25JZCBPcHRpb25hbCBsYXN0U2Vzc2lvbklkIGlmIHRoZSBQZXJzaXN0ZW50Q29ubmVjdGlvbiBoYXNcclxuICAgICAqIGFscmVhZHkgY3JlYXRlZCBhIGNvbm5lY3Rpb24gcHJldmlvdXNseVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25uSWQsIHJlcG9JbmZvLCBhcHBsaWNhdGlvbklkLCBhcHBDaGVja1Rva2VuLCBhdXRoVG9rZW4sIHRyYW5zcG9ydFNlc3Npb25JZCwgbGFzdFNlc3Npb25JZCkge1xyXG4gICAgICAgIHRoaXMuY29ubklkID0gY29ubklkO1xyXG4gICAgICAgIHRoaXMucmVwb0luZm8gPSByZXBvSW5mbztcclxuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uSWQgPSBhcHBsaWNhdGlvbklkO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlbiA9IGFwcENoZWNrVG9rZW47XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW4gPSBhdXRoVG9rZW47XHJcbiAgICAgICAgdGhpcy50cmFuc3BvcnRTZXNzaW9uSWQgPSB0cmFuc3BvcnRTZXNzaW9uSWQ7XHJcbiAgICAgICAgdGhpcy5sYXN0U2Vzc2lvbklkID0gbGFzdFNlc3Npb25JZDtcclxuICAgICAgICB0aGlzLmJ5dGVzU2VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5ieXRlc1JlY2VpdmVkID0gMDtcclxuICAgICAgICB0aGlzLmV2ZXJDb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5sb2dfID0gbG9nV3JhcHBlcihjb25uSWQpO1xyXG4gICAgICAgIHRoaXMuc3RhdHNfID0gc3RhdHNNYW5hZ2VyR2V0Q29sbGVjdGlvbihyZXBvSW5mbyk7XHJcbiAgICAgICAgdGhpcy51cmxGbiA9IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgLy8gQWx3YXlzIGFkZCB0aGUgdG9rZW4gaWYgd2UgaGF2ZSBvbmUuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFwcENoZWNrVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtc1tBUFBfQ0hFQ0tfVE9LRU5fUEFSQU1dID0gdGhpcy5hcHBDaGVja1Rva2VuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXBvSW5mb0Nvbm5lY3Rpb25VUkwocmVwb0luZm8sIExPTkdfUE9MTElORywgcGFyYW1zKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gb25NZXNzYWdlIC0gQ2FsbGJhY2sgd2hlbiBtZXNzYWdlcyBhcnJpdmVcclxuICAgICAqIEBwYXJhbSBvbkRpc2Nvbm5lY3QgLSBDYWxsYmFjayB3aXRoIGNvbm5lY3Rpb24gbG9zdC5cclxuICAgICAqL1xyXG4gICAgb3Blbihvbk1lc3NhZ2UsIG9uRGlzY29ubmVjdCkge1xyXG4gICAgICAgIHRoaXMuY3VyU2VnbWVudE51bSA9IDA7XHJcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gb25EaXNjb25uZWN0O1xyXG4gICAgICAgIHRoaXMubXlQYWNrZXRPcmRlcmVyID0gbmV3IFBhY2tldFJlY2VpdmVyKG9uTWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5pc0Nsb3NlZF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnVGltZWQgb3V0IHRyeWluZyB0byBjb25uZWN0LicpO1xyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgY2xlYXIgdGhlIGhvc3QgY2FjaGVcclxuICAgICAgICAgICAgdGhpcy5vbkNsb3NlZF8oKTtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgfSwgTWF0aC5mbG9vcihMUF9DT05ORUNUX1RJTUVPVVQpKTtcclxuICAgICAgICAvLyBFbnN1cmUgd2UgZGVsYXkgdGhlIGNyZWF0aW9uIG9mIHRoZSBpZnJhbWUgdW50aWwgdGhlIERPTSBpcyBsb2FkZWQuXHJcbiAgICAgICAgZXhlY3V0ZVdoZW5ET01SZWFkeSgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkXykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vU2V0IHVwIGEgY2FsbGJhY2sgdGhhdCBnZXRzIHRyaWdnZXJlZCBvbmNlIGEgY29ubmVjdGlvbiBpcyBzZXQgdXAuXHJcbiAgICAgICAgICAgIHRoaXMuc2NyaXB0VGFnSG9sZGVyID0gbmV3IEZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyKCguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBbY29tbWFuZCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNF0gPSBhcmdzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnRJbmNvbWluZ0J5dGVzXyhhcmdzKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zY3JpcHRUYWdIb2xkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIHdlIGNsb3NlZCB0aGUgY29ubmVjdGlvbi5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyQ29ubmVjdGVkXyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tbWFuZCA9PT0gRklSRUJBU0VfTE9OR1BPTExfU1RBUlRfUEFSQU0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlkID0gYXJnMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhc3N3b3JkID0gYXJnMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbW1hbmQgPT09IEZJUkVCQVNFX0xPTkdQT0xMX0NMT1NFX0NPTU1BTkQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjbGVhciB0aGUgaG9zdCBjYWNoZS4gV2UgZ290IGEgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyLCBzbyB3ZSBrbm93IGl0J3MgcmVhY2hhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZzEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlbid0IGV4cGVjdGluZyBhbnkgbW9yZSBkYXRhIChvdGhlciB0aGFuIHdoYXQgdGhlIHNlcnZlcidzIGFscmVhZHkgaW4gdGhlIHByb2Nlc3Mgb2Ygc2VuZGluZyB1c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdWdoIG91ciBhbHJlYWR5IG9wZW4gcG9sbHMpLCBzbyBkb24ndCBzZW5kIGFueSBtb3JlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlci5zZW5kTmV3UG9sbHMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJnMSBpbiB0aGlzIGNhc2UgaXMgdGhlIGxhc3QgcmVzcG9uc2UgbnVtYmVyIHNlbnQgYnkgdGhlIHNlcnZlci4gV2Ugc2hvdWxkIHRyeSB0byByZWNlaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBvZiB0aGUgcmVzcG9uc2VzIHVwIHRvIHRoaXMgb25lIGJlZm9yZSBjbG9zaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXlQYWNrZXRPcmRlcmVyLmNsb3NlQWZ0ZXIoYXJnMSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlZF8oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pemVkIGNvbW1hbmQgcmVjZWl2ZWQ6ICcgKyBjb21tYW5kKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFtwTiwgZGF0YV0gPSBhcmdzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnRJbmNvbWluZ0J5dGVzXyhhcmdzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXlQYWNrZXRPcmRlcmVyLmhhbmRsZVJlc3BvbnNlKHBOLCBkYXRhKTtcclxuICAgICAgICAgICAgfSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlZF8oKTtcclxuICAgICAgICAgICAgfSwgdGhpcy51cmxGbik7XHJcbiAgICAgICAgICAgIC8vU2VuZCB0aGUgaW5pdGlhbCByZXF1ZXN0IHRvIGNvbm5lY3QuIFRoZSBzZXJpYWwgbnVtYmVyIGlzIHNpbXBseSB0byBrZWVwIHRoZSBicm93c2VyIGZyb20gcHVsbGluZyBwcmV2aW91cyByZXN1bHRzXHJcbiAgICAgICAgICAgIC8vZnJvbSBjYWNoZS5cclxuICAgICAgICAgICAgY29uc3QgdXJsUGFyYW1zID0ge307XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9TVEFSVF9QQVJBTV0gPSAndCc7XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9TRVJJQUxfUEFSQU1dID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDAwKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2NyaXB0VGFnSG9sZGVyLnVuaXF1ZUNhbGxiYWNrSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX0NBTExCQUNLX0lEX1BBUkFNXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tWRVJTSU9OX1BBUkFNXSA9IFBST1RPQ09MX1ZFUlNJT047XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zcG9ydFNlc3Npb25JZCkge1xyXG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW1RSQU5TUE9SVF9TRVNTSU9OX1BBUkFNXSA9IHRoaXMudHJhbnNwb3J0U2Vzc2lvbklkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxhc3RTZXNzaW9uSWQpIHtcclxuICAgICAgICAgICAgICAgIHVybFBhcmFtc1tMQVNUX1NFU1NJT05fUEFSQU1dID0gdGhpcy5sYXN0U2Vzc2lvbklkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFwcGxpY2F0aW9uSWQpIHtcclxuICAgICAgICAgICAgICAgIHVybFBhcmFtc1tBUFBMSUNBVElPTl9JRF9QQVJBTV0gPSB0aGlzLmFwcGxpY2F0aW9uSWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuYXBwQ2hlY2tUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW0FQUF9DSEVDS19UT0tFTl9QQVJBTV0gPSB0aGlzLmFwcENoZWNrVG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uLmhvc3RuYW1lICYmXHJcbiAgICAgICAgICAgICAgICBGT1JHRV9ET01BSU5fUkUudGVzdChsb2NhdGlvbi5ob3N0bmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHVybFBhcmFtc1tSRUZFUkVSX1BBUkFNXSA9IEZPUkdFX1JFRjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjb25uZWN0VVJMID0gdGhpcy51cmxGbih1cmxQYXJhbXMpO1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0Nvbm5lY3RpbmcgdmlhIGxvbmctcG9sbCB0byAnICsgY29ubmVjdFVSTCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2NyaXB0VGFnSG9sZGVyLmFkZFRhZyhjb25uZWN0VVJMLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvKiBkbyBub3RoaW5nICovXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsIHRoaXMgd2hlbiBhIGhhbmRzaGFrZSBoYXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSBhbmQgd2Ugd2FudCB0byBjb25zaWRlciB0aGUgY29ubmVjdGlvbiBlc3RhYmxpc2hlZFxyXG4gICAgICovXHJcbiAgICBzdGFydCgpIHtcclxuICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlci5zdGFydExvbmdQb2xsKHRoaXMuaWQsIHRoaXMucGFzc3dvcmQpO1xyXG4gICAgICAgIHRoaXMuYWRkRGlzY29ubmVjdFBpbmdGcmFtZSh0aGlzLmlkLCB0aGlzLnBhc3N3b3JkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRm9yY2VzIGxvbmcgcG9sbGluZyB0byBiZSBjb25zaWRlcmVkIGFzIGEgcG90ZW50aWFsIHRyYW5zcG9ydFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZm9yY2VBbGxvdygpIHtcclxuICAgICAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VBbGxvd18gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3JjZXMgbG9uZ3BvbGxpbmcgdG8gbm90IGJlIGNvbnNpZGVyZWQgYXMgYSBwb3RlbnRpYWwgdHJhbnNwb3J0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmb3JjZURpc2FsbG93KCkge1xyXG4gICAgICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZURpc2FsbG93XyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyBTdGF0aWMgbWV0aG9kLCB1c2Ugc3RyaW5nIGxpdGVyYWwgc28gaXQgY2FuIGJlIGFjY2Vzc2VkIGluIGEgZ2VuZXJpYyB3YXlcclxuICAgIHN0YXRpYyBpc0F2YWlsYWJsZSgpIHtcclxuICAgICAgICBpZiAoaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VBbGxvd18pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBOT1RFOiBJbiBSZWFjdC1OYXRpdmUgdGhlcmUncyBub3JtYWxseSBubyAnZG9jdW1lbnQnLCBidXQgaWYgeW91IGRlYnVnIGEgUmVhY3QtTmF0aXZlIGFwcCBpblxyXG4gICAgICAgICAgICAvLyB0aGUgQ2hyb21lIGRlYnVnZ2VyLCAnZG9jdW1lbnQnIGlzIGRlZmluZWQsIGJ1dCBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzIG51bGwgKDIwMTUvMDYvMDgpLlxyXG4gICAgICAgICAgICByZXR1cm4gKCFCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvd18gJiZcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgIWlzQ2hyb21lRXh0ZW5zaW9uQ29udGVudFNjcmlwdCgpICYmXHJcbiAgICAgICAgICAgICAgICAhaXNXaW5kb3dzU3RvcmVBcHAoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBOby1vcCBmb3IgcG9sbGluZ1xyXG4gICAgICovXHJcbiAgICBtYXJrQ29ubmVjdGlvbkhlYWx0aHkoKSB7IH1cclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgcG9sbGluZyBhbmQgY2xlYW5zIHVwIHRoZSBpZnJhbWVcclxuICAgICAqL1xyXG4gICAgc2h1dGRvd25fKCkge1xyXG4gICAgICAgIHRoaXMuaXNDbG9zZWRfID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5zY3JpcHRUYWdIb2xkZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIuY2xvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL3JlbW92ZSB0aGUgZGlzY29ubmVjdCBmcmFtZSwgd2hpY2ggd2lsbCB0cmlnZ2VyIGFuIFhIUiBjYWxsIHRvIHRoZSBzZXJ2ZXIgdG8gdGVsbCBpdCB3ZSdyZSBsZWF2aW5nLlxyXG4gICAgICAgIGlmICh0aGlzLm15RGlzY29ubkZyYW1lKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5teURpc2Nvbm5GcmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMubXlEaXNjb25uRnJhbWUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0VGltZW91dFRpbWVyXykge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdGhpcyB0cmFuc3BvcnQgaXMgY2xvc2VkXHJcbiAgICAgKi9cclxuICAgIG9uQ2xvc2VkXygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNDbG9zZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnTG9uZ3BvbGwgaXMgY2xvc2luZyBpdHNlbGYnKTtcclxuICAgICAgICAgICAgdGhpcy5zaHV0ZG93bl8oKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub25EaXNjb25uZWN0Xykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfKHRoaXMuZXZlckNvbm5lY3RlZF8pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXh0ZXJuYWwtZmFjaW5nIGNsb3NlIGhhbmRsZXIuIFJlYWxUaW1lIGhhcyByZXF1ZXN0ZWQgd2Ugc2h1dCBkb3duLiBLaWxsIG91ciBjb25uZWN0aW9uIGFuZCB0ZWxsIHRoZSBzZXJ2ZXJcclxuICAgICAqIHRoYXQgd2UndmUgbGVmdC5cclxuICAgICAqL1xyXG4gICAgY2xvc2UoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzQ2xvc2VkXykge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0xvbmdwb2xsIGlzIGJlaW5nIGNsb3NlZC4nKTtcclxuICAgICAgICAgICAgdGhpcy5zaHV0ZG93bl8oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNlbmQgdGhlIEpTT04gb2JqZWN0IGRvd24gdG8gdGhlIHNlcnZlci4gSXQgd2lsbCBuZWVkIHRvIGJlIHN0cmluZ2lmaWVkLCBiYXNlNjQgZW5jb2RlZCwgYW5kIHRoZW5cclxuICAgICAqIGJyb2tlbiBpbnRvIGNodW5rcyAoc2luY2UgVVJMcyBoYXZlIGEgc21hbGwgbWF4aW11bSBsZW5ndGgpLlxyXG4gICAgICogQHBhcmFtIGRhdGEgLSBUaGUgSlNPTiBkYXRhIHRvIHRyYW5zbWl0LlxyXG4gICAgICovXHJcbiAgICBzZW5kKGRhdGEpIHtcclxuICAgICAgICBjb25zdCBkYXRhU3RyID0gc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNTZW50ICs9IGRhdGFTdHIubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuc3RhdHNfLmluY3JlbWVudENvdW50ZXIoJ2J5dGVzX3NlbnQnLCBkYXRhU3RyLmxlbmd0aCk7XHJcbiAgICAgICAgLy9maXJzdCwgbGV0cyBnZXQgdGhlIGJhc2U2NC1lbmNvZGVkIGRhdGFcclxuICAgICAgICBjb25zdCBiYXNlNjRkYXRhID0gYmFzZTY0RW5jb2RlKGRhdGFTdHIpO1xyXG4gICAgICAgIC8vV2UgY2FuIG9ubHkgZml0IGEgY2VydGFpbiBhbW91bnQgaW4gZWFjaCBVUkwsIHNvIHdlIG5lZWQgdG8gc3BsaXQgdGhpcyByZXF1ZXN0XHJcbiAgICAgICAgLy91cCBpbnRvIG11bHRpcGxlIHBpZWNlcyBpZiBpdCBkb2Vzbid0IGZpdCBpbiBvbmUgcmVxdWVzdC5cclxuICAgICAgICBjb25zdCBkYXRhU2VncyA9IHNwbGl0U3RyaW5nQnlTaXplKGJhc2U2NGRhdGEsIE1BWF9QQVlMT0FEX1NJWkUpO1xyXG4gICAgICAgIC8vRW5xdWV1ZSBlYWNoIHNlZ21lbnQgZm9yIHRyYW5zbWlzc2lvbi4gV2UgYXNzaWduIGVhY2ggY2h1bmsgYSBzZXF1ZW50aWFsIElEIGFuZCBhIHRvdGFsIG51bWJlclxyXG4gICAgICAgIC8vb2Ygc2VnbWVudHMgc28gdGhhdCB3ZSBjYW4gcmVhc3NlbWJsZSB0aGUgcGFja2V0IG9uIHRoZSBzZXJ2ZXIuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhU2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlci5lbnF1ZXVlU2VnbWVudCh0aGlzLmN1clNlZ21lbnROdW0sIGRhdGFTZWdzLmxlbmd0aCwgZGF0YVNlZ3NbaV0pO1xyXG4gICAgICAgICAgICB0aGlzLmN1clNlZ21lbnROdW0rKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgaG93IHdlIG5vdGlmeSB0aGUgc2VydmVyIHRoYXQgd2UncmUgbGVhdmluZy5cclxuICAgICAqIFdlIGFyZW4ndCBhYmxlIHRvIHNlbmQgcmVxdWVzdHMgd2l0aCBESFRNTCBvbiBhIHdpbmRvdyBjbG9zZSBldmVudCwgYnV0IHdlIGNhblxyXG4gICAgICogdHJpZ2dlciBYSFIgcmVxdWVzdHMgaW4gc29tZSBicm93c2VycyAoZXZlcnl0aGluZyBidXQgT3BlcmEgYmFzaWNhbGx5KS5cclxuICAgICAqL1xyXG4gICAgYWRkRGlzY29ubmVjdFBpbmdGcmFtZShpZCwgcHcpIHtcclxuICAgICAgICBpZiAoaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm15RGlzY29ubkZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XHJcbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0ge307XHJcbiAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX0RJU0NPTk5fRlJBTUVfUkVRVUVTVF9QQVJBTV0gPSAndCc7XHJcbiAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX0lEX1BBUkFNXSA9IGlkO1xyXG4gICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9QV19QQVJBTV0gPSBwdztcclxuICAgICAgICB0aGlzLm15RGlzY29ubkZyYW1lLnNyYyA9IHRoaXMudXJsRm4odXJsUGFyYW1zKTtcclxuICAgICAgICB0aGlzLm15RGlzY29ubkZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLm15RGlzY29ubkZyYW1lKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byB0cmFjayB0aGUgYnl0ZXMgcmVjZWl2ZWQgYnkgdGhpcyBjbGllbnRcclxuICAgICAqL1xyXG4gICAgaW5jcmVtZW50SW5jb21pbmdCeXRlc18oYXJncykge1xyXG4gICAgICAgIC8vIFRPRE86IFRoaXMgaXMgYW4gYW5ub3lpbmcgcGVyZiBoaXQganVzdCB0byB0cmFjayB0aGUgbnVtYmVyIG9mIGluY29taW5nIGJ5dGVzLiAgTWF5YmUgaXQgc2hvdWxkIGJlIG9wdC1pbi5cclxuICAgICAgICBjb25zdCBieXRlc1JlY2VpdmVkID0gc3RyaW5naWZ5KGFyZ3MpLmxlbmd0aDtcclxuICAgICAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgKz0gYnl0ZXNSZWNlaXZlZDtcclxuICAgICAgICB0aGlzLnN0YXRzXy5pbmNyZW1lbnRDb3VudGVyKCdieXRlc19yZWNlaXZlZCcsIGJ5dGVzUmVjZWl2ZWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICogQSB3cmFwcGVyIGFyb3VuZCBhbiBpZnJhbWUgdGhhdCBpcyB1c2VkIGFzIGEgbG9uZy1wb2xsaW5nIHNjcmlwdCBob2xkZXIuXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbmNsYXNzIEZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNvbW1hbmRDQiAtIFRoZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiBjb250cm9sIGNvbW1hbmRzIGFyZSByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0gb25NZXNzYWdlQ0IgLSBUaGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gcmVzcG9uc2VzIGFycml2ZSBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0gb25EaXNjb25uZWN0IC0gVGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoaXMgdGFnIGhvbGRlciBpcyBjbG9zZWRcclxuICAgICAqIEBwYXJhbSB1cmxGbiAtIEEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyB0aGUgVVJMIG9mIHRoZSBlbmRwb2ludCB0byBzZW5kIGRhdGEgdG8uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbW1hbmRDQiwgb25NZXNzYWdlQ0IsIG9uRGlzY29ubmVjdCwgdXJsRm4pIHtcclxuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCA9IG9uRGlzY29ubmVjdDtcclxuICAgICAgICB0aGlzLnVybEZuID0gdXJsRm47XHJcbiAgICAgICAgLy9XZSBtYWludGFpbiBhIGNvdW50IG9mIGFsbCBvZiB0aGUgb3V0c3RhbmRpbmcgcmVxdWVzdHMsIGJlY2F1c2UgaWYgd2UgaGF2ZSB0b28gbWFueSBhY3RpdmUgYXQgb25jZSBpdCBjYW4gY2F1c2VcclxuICAgICAgICAvL3Byb2JsZW1zIGluIHNvbWUgYnJvd3NlcnMuXHJcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1JlcXVlc3RzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIC8vQSBxdWV1ZSBvZiB0aGUgcGVuZGluZyBzZWdtZW50cyB3YWl0aW5nIGZvciB0cmFuc21pc3Npb24gdG8gdGhlIHNlcnZlci5cclxuICAgICAgICB0aGlzLnBlbmRpbmdTZWdzID0gW107XHJcbiAgICAgICAgLy9BIHNlcmlhbCBudW1iZXIuIFdlIHVzZSB0aGlzIGZvciB0d28gdGhpbmdzOlxyXG4gICAgICAgIC8vIDEpIEEgd2F5IHRvIGVuc3VyZSB0aGUgYnJvd3NlciBkb2Vzbid0IGNhY2hlIHJlc3BvbnNlcyB0byBwb2xsc1xyXG4gICAgICAgIC8vIDIpIEEgd2F5IHRvIG1ha2UgdGhlIHNlcnZlciBhd2FyZSB3aGVuIGxvbmctcG9sbHMgYXJyaXZlIGluIGEgZGlmZmVyZW50IG9yZGVyIHRoYW4gd2Ugc3RhcnRlZCB0aGVtLiBUaGVcclxuICAgICAgICAvLyAgICBzZXJ2ZXIgbmVlZHMgdG8gcmVsZWFzZSBib3RoIHBvbGxzIGluIHRoaXMgY2FzZSBvciBpdCB3aWxsIGNhdXNlIHByb2JsZW1zIGluIE9wZXJhIHNpbmNlIE9wZXJhIGNhbiBvbmx5IGV4ZWN1dGVcclxuICAgICAgICAvLyAgICBKU09OUCBjb2RlIGluIHRoZSBvcmRlciBpdCB3YXMgYWRkZWQgdG8gdGhlIGlmcmFtZS5cclxuICAgICAgICB0aGlzLmN1cnJlbnRTZXJpYWwgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDApO1xyXG4gICAgICAgIC8vIFRoaXMgZ2V0cyBzZXQgdG8gZmFsc2Ugd2hlbiB3ZSdyZSBcImNsb3NpbmcgZG93blwiIHRoZSBjb25uZWN0aW9uIChlLmcuIHdlJ3JlIHN3aXRjaGluZyB0cmFuc3BvcnRzIGJ1dCB0aGVyZSdzIHN0aWxsXHJcbiAgICAgICAgLy8gaW5jb21pbmcgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgdGhhdCB3ZSdyZSB3YWl0aW5nIGZvcikuXHJcbiAgICAgICAgdGhpcy5zZW5kTmV3UG9sbHMgPSB0cnVlO1xyXG4gICAgICAgIGlmICghaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgLy9FYWNoIHNjcmlwdCBob2xkZXIgcmVnaXN0ZXJzIGEgY291cGxlIG9mIHVuaXF1ZWx5IG5hbWVkIGNhbGxiYWNrcyB3aXRoIHRoZSB3aW5kb3cuIFRoZXNlIGFyZSBjYWxsZWQgZnJvbSB0aGVcclxuICAgICAgICAgICAgLy9pZnJhbWVzIHdoZXJlIHdlIHB1dCB0aGUgbG9uZy1wb2xsaW5nIHNjcmlwdCB0YWdzLiBXZSBoYXZlIHR3byBjYWxsYmFja3M6XHJcbiAgICAgICAgICAgIC8vICAgMSkgQ29tbWFuZCBDYWxsYmFjayAtIFRyaWdnZXJlZCBmb3IgY29udHJvbCBpc3N1ZXMsIGxpa2Ugc3RhcnRpbmcgYSBjb25uZWN0aW9uLlxyXG4gICAgICAgICAgICAvLyAgIDIpIE1lc3NhZ2UgQ2FsbGJhY2sgLSBUcmlnZ2VyZWQgd2hlbiBuZXcgZGF0YSBhcnJpdmVzLlxyXG4gICAgICAgICAgICB0aGlzLnVuaXF1ZUNhbGxiYWNrSWRlbnRpZmllciA9IExVSURHZW5lcmF0b3IoKTtcclxuICAgICAgICAgICAgd2luZG93W0ZJUkVCQVNFX0xPTkdQT0xMX0NPTU1BTkRfQ0JfTkFNRSArIHRoaXMudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyXSA9IGNvbW1hbmRDQjtcclxuICAgICAgICAgICAgd2luZG93W0ZJUkVCQVNFX0xPTkdQT0xMX0RBVEFfQ0JfTkFNRSArIHRoaXMudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyXSA9XHJcbiAgICAgICAgICAgICAgICBvbk1lc3NhZ2VDQjtcclxuICAgICAgICAgICAgLy9DcmVhdGUgYW4gaWZyYW1lIGZvciB1cyB0byBhZGQgc2NyaXB0IHRhZ3MgdG8uXHJcbiAgICAgICAgICAgIHRoaXMubXlJRnJhbWUgPSBGaXJlYmFzZUlGcmFtZVNjcmlwdEhvbGRlci5jcmVhdGVJRnJhbWVfKCk7XHJcbiAgICAgICAgICAgIC8vIFNldCB0aGUgaWZyYW1lJ3MgY29udGVudHMuXHJcbiAgICAgICAgICAgIGxldCBzY3JpcHQgPSAnJztcclxuICAgICAgICAgICAgLy8gaWYgd2Ugc2V0IGEgamF2YXNjcmlwdCB1cmwsIGl0J3MgSUUgYW5kIHdlIG5lZWQgdG8gc2V0IHRoZSBkb2N1bWVudCBkb21haW4uIFRoZSBqYXZhc2NyaXB0IHVybCBpcyBzdWZmaWNpZW50XHJcbiAgICAgICAgICAgIC8vIGZvciBpZTksIGJ1dCBpZTggbmVlZHMgdG8gZG8gaXQgYWdhaW4gaW4gdGhlIGRvY3VtZW50IGl0c2VsZi5cclxuICAgICAgICAgICAgaWYgKHRoaXMubXlJRnJhbWUuc3JjICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLm15SUZyYW1lLnNyYy5zdWJzdHIoMCwgJ2phdmFzY3JpcHQ6Jy5sZW5ndGgpID09PSAnamF2YXNjcmlwdDonKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RG9tYWluID0gZG9jdW1lbnQuZG9tYWluO1xyXG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gJzxzY3JpcHQ+ZG9jdW1lbnQuZG9tYWluPVwiJyArIGN1cnJlbnREb21haW4gKyAnXCI7PC9zY3JpcHQ+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBpZnJhbWVDb250ZW50cyA9ICc8aHRtbD48Ym9keT4nICsgc2NyaXB0ICsgJzwvYm9keT48L2h0bWw+JztcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMubXlJRnJhbWUuZG9jLm9wZW4oKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXlJRnJhbWUuZG9jLndyaXRlKGlmcmFtZUNvbnRlbnRzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXlJRnJhbWUuZG9jLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGxvZygnZnJhbWUgd3JpdGluZyBleGNlcHRpb24nKTtcclxuICAgICAgICAgICAgICAgIGlmIChlLnN0YWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nKGUuc3RhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbG9nKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRDQiA9IGNvbW1hbmRDQjtcclxuICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2VDQiA9IG9uTWVzc2FnZUNCO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRWFjaCBicm93c2VyIGhhcyBpdHMgb3duIGZ1bm55IHdheSB0byBoYW5kbGUgaWZyYW1lcy4gSGVyZSB3ZSBtdXNoIHRoZW0gYWxsIHRvZ2V0aGVyIGludG8gb25lIG9iamVjdCB0aGF0IEkgY2FuXHJcbiAgICAgKiBhY3R1YWxseSB1c2UuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVJRnJhbWVfKCkge1xyXG4gICAgICAgIGNvbnN0IGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xyXG4gICAgICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGluIG9yZGVyIHRvIGluaXRpYWxpemUgdGhlIGRvY3VtZW50IGluc2lkZSB0aGUgaWZyYW1lXHJcbiAgICAgICAgaWYgKGRvY3VtZW50LmJvZHkpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgZG9jdW1lbnQuZG9tYWluIGhhcyBiZWVuIG1vZGlmaWVkIGluIElFLCB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IsIGFuZCB3ZSBuZWVkIHRvIHNldCB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGRvbWFpbiBvZiB0aGUgaWZyYW1lJ3MgZG9jdW1lbnQgbWFudWFsbHkuIFdlIGNhbiBkbyB0aGlzIHZpYSBhIGphdmFzY3JpcHQ6IHVybCBhcyB0aGUgc3JjIGF0dHJpYnV0ZVxyXG4gICAgICAgICAgICAgICAgLy8gQWxzbyBub3RlIHRoYXQgd2UgbXVzdCBkbyB0aGlzICphZnRlciogdGhlIGlmcmFtZSBoYXMgYmVlbiBhcHBlbmRlZCB0byB0aGUgcGFnZS4gT3RoZXJ3aXNlIGl0IGRvZXNuJ3Qgd29yay5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcclxuICAgICAgICAgICAgICAgIGlmICghYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwb2xvZ2llcyBmb3IgdGhlIGxvZy1zcGFtLCBJIG5lZWQgdG8gZG8gc29tZXRoaW5nIHRvIGtlZXAgY2xvc3VyZSBmcm9tIG9wdGltaXppbmcgb3V0IHRoZSBhc3NpZ25tZW50IGFib3ZlLlxyXG4gICAgICAgICAgICAgICAgICAgIGxvZygnTm8gSUUgZG9tYWluIHNldHRpbmcgcmVxdWlyZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZG9tYWluID0gZG9jdW1lbnQuZG9tYWluO1xyXG4gICAgICAgICAgICAgICAgaWZyYW1lLnNyYyA9XHJcbiAgICAgICAgICAgICAgICAgICAgXCJqYXZhc2NyaXB0OnZvaWQoKGZ1bmN0aW9uKCl7ZG9jdW1lbnQub3BlbigpO2RvY3VtZW50LmRvbWFpbj0nXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW4gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIic7ZG9jdW1lbnQuY2xvc2UoKTt9KSgpKVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBMb25nUG9sbENvbm5lY3Rpb24gYXR0ZW1wdHMgdG8gZGVsYXkgaW5pdGlhbGl6YXRpb24gdW50aWwgdGhlIGRvY3VtZW50IGlzIHJlYWR5LCBzbyBob3BlZnVsbHkgdGhpc1xyXG4gICAgICAgICAgICAvLyBuZXZlciBnZXRzIGhpdC5cclxuICAgICAgICAgICAgdGhyb3cgJ0RvY3VtZW50IGJvZHkgaGFzIG5vdCBpbml0aWFsaXplZC4gV2FpdCB0byBpbml0aWFsaXplIEZpcmViYXNlIHVudGlsIGFmdGVyIHRoZSBkb2N1bWVudCBpcyByZWFkeS4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBHZXQgdGhlIGRvY3VtZW50IG9mIHRoZSBpZnJhbWUgaW4gYSBicm93c2VyLXNwZWNpZmljIHdheS5cclxuICAgICAgICBpZiAoaWZyYW1lLmNvbnRlbnREb2N1bWVudCkge1xyXG4gICAgICAgICAgICBpZnJhbWUuZG9jID0gaWZyYW1lLmNvbnRlbnREb2N1bWVudDsgLy8gRmlyZWZveCwgT3BlcmEsIFNhZmFyaVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpZnJhbWUuY29udGVudFdpbmRvdykge1xyXG4gICAgICAgICAgICBpZnJhbWUuZG9jID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7IC8vIEludGVybmV0IEV4cGxvcmVyXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlmcmFtZS5kb2N1bWVudCkge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICBpZnJhbWUuZG9jID0gaWZyYW1lLmRvY3VtZW50OyAvL290aGVycz9cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlmcmFtZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FuY2VsIGFsbCBvdXRzdGFuZGluZyBxdWVyaWVzIGFuZCByZW1vdmUgdGhlIGZyYW1lLlxyXG4gICAgICovXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgICAvL01hcmsgdGhpcyBpZnJhbWUgYXMgZGVhZCwgc28gbm8gbmV3IHJlcXVlc3RzIGFyZSBzZW50LlxyXG4gICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5teUlGcmFtZSkge1xyXG4gICAgICAgICAgICAvL1dlIGhhdmUgdG8gYWN0dWFsbHkgcmVtb3ZlIGFsbCBvZiB0aGUgaHRtbCBpbnNpZGUgdGhpcyBpZnJhbWUgYmVmb3JlIHJlbW92aW5nIGl0IGZyb20gdGhlXHJcbiAgICAgICAgICAgIC8vd2luZG93LCBvciBJRSB3aWxsIGNvbnRpbnVlIGxvYWRpbmcgYW5kIGV4ZWN1dGluZyB0aGUgc2NyaXB0IHRhZ3Mgd2UndmUgYWxyZWFkeSBhZGRlZCwgd2hpY2hcclxuICAgICAgICAgICAgLy9jYW4gbGVhZCB0byBzb21lIGVycm9ycyBiZWluZyB0aHJvd24uIFNldHRpbmcgdGV4dENvbnRlbnQgc2VlbXMgdG8gYmUgdGhlIHNhZmVzdCB3YXkgdG8gZG8gdGhpcy5cclxuICAgICAgICAgICAgdGhpcy5teUlGcmFtZS5kb2MuYm9keS50ZXh0Q29udGVudCA9ICcnO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm15SUZyYW1lICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLm15SUZyYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm15SUZyYW1lID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgTWF0aC5mbG9vcigwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFByb3RlY3QgZnJvbSBiZWluZyBjYWxsZWQgcmVjdXJzaXZlbHkuXHJcbiAgICAgICAgY29uc3Qgb25EaXNjb25uZWN0ID0gdGhpcy5vbkRpc2Nvbm5lY3Q7XHJcbiAgICAgICAgaWYgKG9uRGlzY29ubmVjdCkge1xyXG4gICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCA9IG51bGw7XHJcbiAgICAgICAgICAgIG9uRGlzY29ubmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWN0dWFsbHkgc3RhcnQgdGhlIGxvbmctcG9sbGluZyBzZXNzaW9uIGJ5IGFkZGluZyB0aGUgZmlyc3Qgc2NyaXB0IHRhZyhzKSB0byB0aGUgaWZyYW1lLlxyXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIElEIG9mIHRoaXMgY29ubmVjdGlvblxyXG4gICAgICogQHBhcmFtIHB3IC0gVGhlIHBhc3N3b3JkIGZvciB0aGlzIGNvbm5lY3Rpb25cclxuICAgICAqL1xyXG4gICAgc3RhcnRMb25nUG9sbChpZCwgcHcpIHtcclxuICAgICAgICB0aGlzLm15SUQgPSBpZDtcclxuICAgICAgICB0aGlzLm15UFcgPSBwdztcclxuICAgICAgICB0aGlzLmFsaXZlID0gdHJ1ZTtcclxuICAgICAgICAvL3NlbmQgdGhlIGluaXRpYWwgcmVxdWVzdC4gSWYgdGhlcmUgYXJlIHJlcXVlc3RzIHF1ZXVlZCwgbWFrZSBzdXJlIHRoYXQgd2UgdHJhbnNtaXQgYXMgbWFueSBhcyB3ZSBhcmUgY3VycmVudGx5IGFibGUgdG8uXHJcbiAgICAgICAgd2hpbGUgKHRoaXMubmV3UmVxdWVzdF8oKSkgeyB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgY2FsbGVkIGFueSB0aW1lIHNvbWVvbmUgbWlnaHQgd2FudCBhIHNjcmlwdCB0YWcgdG8gYmUgYWRkZWQuIEl0IGFkZHMgYSBzY3JpcHQgdGFnIHdoZW4gdGhlcmUgYXJlbid0XHJcbiAgICAgKiB0b28gbWFueSBvdXRzdGFuZGluZyByZXF1ZXN0cyBhbmQgd2UgYXJlIHN0aWxsIGFsaXZlLlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZXJlIGFyZSBvdXRzdGFuZGluZyBwYWNrZXQgc2VnbWVudHMgdG8gc2VuZCwgaXQgc2VuZHMgb25lLiBJZiB0aGVyZSBhcmVuJ3QsIGl0IHNlbmRzIGEgbG9uZy1wb2xsIGFueXdheXMgaWZcclxuICAgICAqIG5lZWRlZC5cclxuICAgICAqL1xyXG4gICAgbmV3UmVxdWVzdF8oKSB7XHJcbiAgICAgICAgLy8gV2Uga2VlcCBvbmUgb3V0c3RhbmRpbmcgcmVxdWVzdCBvcGVuIGFsbCB0aGUgdGltZSB0byByZWNlaXZlIGRhdGEsIGJ1dCBpZiB3ZSBuZWVkIHRvIHNlbmQgZGF0YVxyXG4gICAgICAgIC8vIChwZW5kaW5nU2Vncy5sZW5ndGggPiAwKSB0aGVuIHdlIGNyZWF0ZSBhIG5ldyByZXF1ZXN0IHRvIHNlbmQgdGhlIGRhdGEuICBUaGUgc2VydmVyIHdpbGwgYXV0b21hdGljYWxseVxyXG4gICAgICAgIC8vIGNsb3NlIHRoZSBvbGQgcmVxdWVzdC5cclxuICAgICAgICBpZiAodGhpcy5hbGl2ZSAmJlxyXG4gICAgICAgICAgICB0aGlzLnNlbmROZXdQb2xscyAmJlxyXG4gICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUmVxdWVzdHMuc2l6ZSA8ICh0aGlzLnBlbmRpbmdTZWdzLmxlbmd0aCA+IDAgPyAyIDogMSkpIHtcclxuICAgICAgICAgICAgLy9jb25zdHJ1Y3Qgb3VyIHVybFxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZXJpYWwrKztcclxuICAgICAgICAgICAgY29uc3QgdXJsUGFyYW1zID0ge307XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9JRF9QQVJBTV0gPSB0aGlzLm15SUQ7XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9QV19QQVJBTV0gPSB0aGlzLm15UFc7XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9TRVJJQUxfUEFSQU1dID0gdGhpcy5jdXJyZW50U2VyaWFsO1xyXG4gICAgICAgICAgICBsZXQgdGhlVVJMID0gdGhpcy51cmxGbih1cmxQYXJhbXMpO1xyXG4gICAgICAgICAgICAvL05vdyBhZGQgYXMgbXVjaCBkYXRhIGFzIHdlIGNhbi5cclxuICAgICAgICAgICAgbGV0IGN1ckRhdGFTdHJpbmcgPSAnJztcclxuICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5wZW5kaW5nU2Vncy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAvL2ZpcnN0LCBsZXRzIHNlZSBpZiB0aGUgbmV4dCBzZWdtZW50IHdpbGwgZml0LlxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFNlZyA9IHRoaXMucGVuZGluZ1NlZ3NbMF07XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dFNlZy5kLmxlbmd0aCArXHJcbiAgICAgICAgICAgICAgICAgICAgU0VHX0hFQURFUl9TSVpFICtcclxuICAgICAgICAgICAgICAgICAgICBjdXJEYXRhU3RyaW5nLmxlbmd0aCA8PVxyXG4gICAgICAgICAgICAgICAgICAgIE1BWF9VUkxfREFUQV9TSVpFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9ncmVhdCwgdGhlIHNlZ21lbnQgd2lsbCBmaXQuIExldHMgYXBwZW5kIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRoZVNlZyA9IHRoaXMucGVuZGluZ1NlZ3Muc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJEYXRhU3RyaW5nID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyRGF0YVN0cmluZyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRklSRUJBU0VfTE9OR1BPTExfU0VHTUVOVF9OVU1fUEFSQU0gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPScgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlU2VnLnNlZyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRklSRUJBU0VfTE9OR1BPTExfU0VHTUVOVFNfSU5fUEFDS0VUICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJz0nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZVNlZy50cyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRklSRUJBU0VfTE9OR1BPTExfREFUQV9QQVJBTSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc9JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVTZWcuZDtcclxuICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGVVUkwgPSB0aGVVUkwgKyBjdXJEYXRhU3RyaW5nO1xyXG4gICAgICAgICAgICB0aGlzLmFkZExvbmdQb2xsVGFnXyh0aGVVUkwsIHRoaXMuY3VycmVudFNlcmlhbCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUXVldWUgYSBwYWNrZXQgZm9yIHRyYW5zbWlzc2lvbiB0byB0aGUgc2VydmVyLlxyXG4gICAgICogQHBhcmFtIHNlZ251bSAtIEEgc2VxdWVudGlhbCBpZCBmb3IgdGhpcyBwYWNrZXQgc2VnbWVudCB1c2VkIGZvciByZWFzc2VtYmx5XHJcbiAgICAgKiBAcGFyYW0gdG90YWxzZWdzIC0gVGhlIHRvdGFsIG51bWJlciBvZiBzZWdtZW50cyBpbiB0aGlzIHBhY2tldFxyXG4gICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSBmb3IgdGhpcyBzZWdtZW50LlxyXG4gICAgICovXHJcbiAgICBlbnF1ZXVlU2VnbWVudChzZWdudW0sIHRvdGFsc2VncywgZGF0YSkge1xyXG4gICAgICAgIC8vYWRkIHRoaXMgdG8gdGhlIHF1ZXVlIG9mIHNlZ21lbnRzIHRvIHNlbmQuXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nU2Vncy5wdXNoKHsgc2VnOiBzZWdudW0sIHRzOiB0b3RhbHNlZ3MsIGQ6IGRhdGEgfSk7XHJcbiAgICAgICAgLy9zZW5kIHRoZSBkYXRhIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGlzbid0IGFscmVhZHkgZGF0YSBiZWluZyB0cmFuc21pdHRlZCwgdW5sZXNzXHJcbiAgICAgICAgLy9zdGFydExvbmdQb2xsIGhhc24ndCBiZWVuIGNhbGxlZCB5ZXQuXHJcbiAgICAgICAgaWYgKHRoaXMuYWxpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5uZXdSZXF1ZXN0XygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgc2NyaXB0IHRhZyBmb3IgYSByZWd1bGFyIGxvbmctcG9sbCByZXF1ZXN0LlxyXG4gICAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgb2YgdGhlIHNjcmlwdCB0YWcuXHJcbiAgICAgKiBAcGFyYW0gc2VyaWFsIC0gVGhlIHNlcmlhbCBudW1iZXIgb2YgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIGFkZExvbmdQb2xsVGFnXyh1cmwsIHNlcmlhbCkge1xyXG4gICAgICAgIC8vcmVtZW1iZXIgdGhhdCB3ZSBzZW50IHRoaXMgcmVxdWVzdC5cclxuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUmVxdWVzdHMuYWRkKHNlcmlhbCk7XHJcbiAgICAgICAgY29uc3QgZG9OZXdSZXF1ZXN0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUmVxdWVzdHMuZGVsZXRlKHNlcmlhbCk7XHJcbiAgICAgICAgICAgIHRoaXMubmV3UmVxdWVzdF8oKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIElmIHRoaXMgcmVxdWVzdCBkb2Vzbid0IHJldHVybiBvbiBpdHMgb3duIGFjY29yZCAoYnkgdGhlIHNlcnZlciBzZW5kaW5nIHVzIHNvbWUgZGF0YSksIHdlJ2xsXHJcbiAgICAgICAgLy8gY3JlYXRlIGEgbmV3IG9uZSBhZnRlciB0aGUgS0VFUEFMSVZFIGludGVydmFsIHRvIG1ha2Ugc3VyZSB3ZSBhbHdheXMga2VlcCBhIGZyZXNoIHJlcXVlc3Qgb3Blbi5cclxuICAgICAgICBjb25zdCBrZWVwYWxpdmVUaW1lb3V0ID0gc2V0VGltZW91dChkb05ld1JlcXVlc3QsIE1hdGguZmxvb3IoS0VFUEFMSVZFX1JFUVVFU1RfSU5URVJWQUwpKTtcclxuICAgICAgICBjb25zdCByZWFkeVN0YXRlQ0IgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFJlcXVlc3QgY29tcGxldGVkLiAgQ2FuY2VsIHRoZSBrZWVwYWxpdmUuXHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChrZWVwYWxpdmVUaW1lb3V0KTtcclxuICAgICAgICAgICAgLy8gVHJpZ2dlciBhIG5ldyByZXF1ZXN0IHNvIHdlIGNhbiBjb250aW51ZSByZWNlaXZpbmcgZGF0YS5cclxuICAgICAgICAgICAgZG9OZXdSZXF1ZXN0KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmFkZFRhZyh1cmwsIHJlYWR5U3RhdGVDQik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhbiBhcmJpdHJhcnkgc2NyaXB0IHRhZyB0byB0aGUgaWZyYW1lLlxyXG4gICAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgZm9yIHRoZSBzY3JpcHQgdGFnIHNvdXJjZS5cclxuICAgICAqIEBwYXJhbSBsb2FkQ0IgLSBBIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCBvbmNlIHRoZSBzY3JpcHQgaGFzIGxvYWRlZC5cclxuICAgICAqL1xyXG4gICAgYWRkVGFnKHVybCwgbG9hZENCKSB7XHJcbiAgICAgICAgaWYgKGlzTm9kZVNkaygpKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIHRoaXMuZG9Ob2RlTG9uZ1BvbGwodXJsLCBsb2FkQ0IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGFscmVhZHkgY2xvc2VkLCBkb24ndCBhZGQgdGhpcyBwb2xsXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNlbmROZXdQb2xscykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1NjcmlwdCA9IHRoaXMubXlJRnJhbWUuZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1NjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U2NyaXB0LmFzeW5jID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHQuc3JjID0gdXJsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U2NyaXB0Lm9ubG9hZCA9IG5ld1NjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcnN0YXRlID0gbmV3U2NyaXB0LnJlYWR5U3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJzdGF0ZSB8fCByc3RhdGUgPT09ICdsb2FkZWQnIHx8IHJzdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2NyaXB0Lm9ubG9hZCA9IG5ld1NjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdTY3JpcHQucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuZXdTY3JpcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkQ0IoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHQub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKCdMb25nLXBvbGwgc2NyaXB0IGZhaWxlZCB0byBsb2FkOiAnICsgdXJsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kTmV3UG9sbHMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5teUlGcmFtZS5kb2MuYm9keS5hcHBlbmRDaGlsZChuZXdTY3JpcHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB3ZSBzaG91bGQgbWFrZSB0aGlzIGVycm9yIHZpc2libGUgc29tZWhvd1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBNYXRoLmZsb29yKDEpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgV0VCU09DS0VUX01BWF9GUkFNRV9TSVpFID0gMTYzODQ7XHJcbmNvbnN0IFdFQlNPQ0tFVF9LRUVQQUxJVkVfSU5URVJWQUwgPSA0NTAwMDtcclxubGV0IFdlYlNvY2tldEltcGwgPSBudWxsO1xyXG5pZiAodHlwZW9mIE1veldlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIFdlYlNvY2tldEltcGwgPSBNb3pXZWJTb2NrZXQ7XHJcbn1cclxuZWxzZSBpZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIFdlYlNvY2tldEltcGwgPSBXZWJTb2NrZXQ7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyB3ZWJzb2NrZXQgY29ubmVjdGlvbiB3aXRoIHRoZSBnaXZlbiBjYWxsYmFja3MuXHJcbiAqL1xyXG5jbGFzcyBXZWJTb2NrZXRDb25uZWN0aW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNvbm5JZCBpZGVudGlmaWVyIGZvciB0aGlzIHRyYW5zcG9ydFxyXG4gICAgICogQHBhcmFtIHJlcG9JbmZvIFRoZSBpbmZvIGZvciB0aGUgd2Vic29ja2V0IGVuZHBvaW50LlxyXG4gICAgICogQHBhcmFtIGFwcGxpY2F0aW9uSWQgVGhlIEZpcmViYXNlIEFwcCBJRCBmb3IgdGhpcyBwcm9qZWN0LlxyXG4gICAgICogQHBhcmFtIGFwcENoZWNrVG9rZW4gVGhlIEFwcCBDaGVjayBUb2tlbiBmb3IgdGhpcyBjbGllbnQuXHJcbiAgICAgKiBAcGFyYW0gYXV0aFRva2VuIFRoZSBBdXRoIFRva2VuIGZvciB0aGlzIGNsaWVudC5cclxuICAgICAqIEBwYXJhbSB0cmFuc3BvcnRTZXNzaW9uSWQgT3B0aW9uYWwgdHJhbnNwb3J0U2Vzc2lvbklkIGlmIHRoaXMgaXMgY29ubmVjdGluZ1xyXG4gICAgICogdG8gYW4gZXhpc3RpbmcgdHJhbnNwb3J0IHNlc3Npb25cclxuICAgICAqIEBwYXJhbSBsYXN0U2Vzc2lvbklkIE9wdGlvbmFsIGxhc3RTZXNzaW9uSWQgaWYgdGhlcmUgd2FzIGEgcHJldmlvdXNcclxuICAgICAqIGNvbm5lY3Rpb25cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY29ubklkLCByZXBvSW5mbywgYXBwbGljYXRpb25JZCwgYXBwQ2hlY2tUb2tlbiwgYXV0aFRva2VuLCB0cmFuc3BvcnRTZXNzaW9uSWQsIGxhc3RTZXNzaW9uSWQpIHtcclxuICAgICAgICB0aGlzLmNvbm5JZCA9IGNvbm5JZDtcclxuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uSWQgPSBhcHBsaWNhdGlvbklkO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlbiA9IGFwcENoZWNrVG9rZW47XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW4gPSBhdXRoVG9rZW47XHJcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5mcmFtZXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudG90YWxGcmFtZXMgPSAwO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNTZW50ID0gMDtcclxuICAgICAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9nXyA9IGxvZ1dyYXBwZXIodGhpcy5jb25uSWQpO1xyXG4gICAgICAgIHRoaXMuc3RhdHNfID0gc3RhdHNNYW5hZ2VyR2V0Q29sbGVjdGlvbihyZXBvSW5mbyk7XHJcbiAgICAgICAgdGhpcy5jb25uVVJMID0gV2ViU29ja2V0Q29ubmVjdGlvbi5jb25uZWN0aW9uVVJMXyhyZXBvSW5mbywgdHJhbnNwb3J0U2Vzc2lvbklkLCBsYXN0U2Vzc2lvbklkLCBhcHBDaGVja1Rva2VuLCBhcHBsaWNhdGlvbklkKTtcclxuICAgICAgICB0aGlzLm5vZGVBZG1pbiA9IHJlcG9JbmZvLm5vZGVBZG1pbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHJlcG9JbmZvIC0gVGhlIGluZm8gZm9yIHRoZSB3ZWJzb2NrZXQgZW5kcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNwb3J0U2Vzc2lvbklkIC0gT3B0aW9uYWwgdHJhbnNwb3J0U2Vzc2lvbklkIGlmIHRoaXMgaXMgY29ubmVjdGluZyB0byBhbiBleGlzdGluZyB0cmFuc3BvcnRcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uXHJcbiAgICAgKiBAcGFyYW0gbGFzdFNlc3Npb25JZCAtIE9wdGlvbmFsIGxhc3RTZXNzaW9uSWQgaWYgdGhlcmUgd2FzIGEgcHJldmlvdXMgY29ubmVjdGlvblxyXG4gICAgICogQHJldHVybnMgY29ubmVjdGlvbiB1cmxcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNvbm5lY3Rpb25VUkxfKHJlcG9JbmZvLCB0cmFuc3BvcnRTZXNzaW9uSWQsIGxhc3RTZXNzaW9uSWQsIGFwcENoZWNrVG9rZW4sIGFwcGxpY2F0aW9uSWQpIHtcclxuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSB7fTtcclxuICAgICAgICB1cmxQYXJhbXNbVkVSU0lPTl9QQVJBTV0gPSBQUk9UT0NPTF9WRVJTSU9OO1xyXG4gICAgICAgIGlmICghaXNOb2RlU2RrKCkgJiZcclxuICAgICAgICAgICAgdHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICBsb2NhdGlvbi5ob3N0bmFtZSAmJlxyXG4gICAgICAgICAgICBGT1JHRV9ET01BSU5fUkUudGVzdChsb2NhdGlvbi5ob3N0bmFtZSkpIHtcclxuICAgICAgICAgICAgdXJsUGFyYW1zW1JFRkVSRVJfUEFSQU1dID0gRk9SR0VfUkVGO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHJhbnNwb3J0U2Vzc2lvbklkKSB7XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tUUkFOU1BPUlRfU0VTU0lPTl9QQVJBTV0gPSB0cmFuc3BvcnRTZXNzaW9uSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYXN0U2Vzc2lvbklkKSB7XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tMQVNUX1NFU1NJT05fUEFSQU1dID0gbGFzdFNlc3Npb25JZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFwcENoZWNrVG9rZW4pIHtcclxuICAgICAgICAgICAgdXJsUGFyYW1zW0FQUF9DSEVDS19UT0tFTl9QQVJBTV0gPSBhcHBDaGVja1Rva2VuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXBwbGljYXRpb25JZCkge1xyXG4gICAgICAgICAgICB1cmxQYXJhbXNbQVBQTElDQVRJT05fSURfUEFSQU1dID0gYXBwbGljYXRpb25JZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcG9JbmZvQ29ubmVjdGlvblVSTChyZXBvSW5mbywgV0VCU09DS0VULCB1cmxQYXJhbXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gb25NZXNzYWdlIC0gQ2FsbGJhY2sgd2hlbiBtZXNzYWdlcyBhcnJpdmVcclxuICAgICAqIEBwYXJhbSBvbkRpc2Nvbm5lY3QgLSBDYWxsYmFjayB3aXRoIGNvbm5lY3Rpb24gbG9zdC5cclxuICAgICAqL1xyXG4gICAgb3Blbihvbk1lc3NhZ2UsIG9uRGlzY29ubmVjdCkge1xyXG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0ID0gb25EaXNjb25uZWN0O1xyXG4gICAgICAgIHRoaXMub25NZXNzYWdlID0gb25NZXNzYWdlO1xyXG4gICAgICAgIHRoaXMubG9nXygnV2Vic29ja2V0IGNvbm5lY3RpbmcgdG8gJyArIHRoaXMuY29ublVSTCk7XHJcbiAgICAgICAgdGhpcy5ldmVyQ29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIC8vIEFzc3VtZSBmYWlsdXJlIHVudGlsIHByb3ZlbiBvdGhlcndpc2UuXHJcbiAgICAgICAgUGVyc2lzdGVudFN0b3JhZ2Uuc2V0KCdwcmV2aW91c193ZWJzb2NrZXRfZmFpbHVyZScsIHRydWUpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCBvcHRpb25zO1xyXG4gICAgICAgICAgICBpZiAoaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZSA9IHRoaXMubm9kZUFkbWluID8gJ0FkbWluTm9kZScgOiAnTm9kZSc7XHJcbiAgICAgICAgICAgICAgICAvLyBVQSBGb3JtYXQ6IEZpcmViYXNlLzx3aXJlX3Byb3RvY29sPi88c2RrX3ZlcnNpb24+LzxwbGF0Zm9ybT4vPGRldmljZT5cclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnVXNlci1BZ2VudCc6IGBGaXJlYmFzZS8ke1BST1RPQ09MX1ZFUlNJT059LyR7U0RLX1ZFUlNJT059LyR7cHJvY2Vzcy5wbGF0Zm9ybX0vJHtkZXZpY2V9YCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1gtRmlyZWJhc2UtR01QSUQnOiB0aGlzLmFwcGxpY2F0aW9uSWQgfHwgJydcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdXNpbmcgTm9kZSB3aXRoIGFkbWluIGNyZWRzLCBBcHBDaGVjay1yZWxhdGVkIGNoZWNrcyBhcmUgdW5uZWNlc3NhcnkuXHJcbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgd2Ugc2VuZCB0aGUgY3JlZGVudGlhbHMgaGVyZSBldmVuIGlmIHRoZXkgYXJlbid0IGFkbWluIGNyZWRlbnRpYWxzLCB3aGljaCBpc1xyXG4gICAgICAgICAgICAgICAgLy8gbm90IGEgcHJvYmxlbS5cclxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGhlYWRlciBpcyBqdXN0IHVzZWQgdG8gYnlwYXNzIGFwcGNoZWNrLCBhbmQgdGhlIHRva2VuIHNob3VsZCBzdGlsbCBiZSBzZW50XHJcbiAgICAgICAgICAgICAgICAvLyB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQgY29ubmVjdGlvbiBvbmNlIGl0IGlzIGVzdGFibGlzaGVkLlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0aFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7dGhpcy5hdXRoVG9rZW59YDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFwcENoZWNrVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnNbJ1gtRmlyZWJhc2UtQXBwQ2hlY2snXSA9IHRoaXMuYXBwQ2hlY2tUb2tlbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFBsdW1iIGFwcHJvcHJpYXRlIGh0dHBfcHJveHkgZW52aXJvbm1lbnQgdmFyaWFibGUgaW50byBmYXllLXdlYnNvY2tldCBpZiBpdCBleGlzdHMuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbnYgPSBwcm9jZXNzWydlbnYnXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3h5ID0gdGhpcy5jb25uVVJMLmluZGV4T2YoJ3dzczovLycpID09PSAwXHJcbiAgICAgICAgICAgICAgICAgICAgPyBlbnZbJ0hUVFBTX1BST1hZJ10gfHwgZW52WydodHRwc19wcm94eSddXHJcbiAgICAgICAgICAgICAgICAgICAgOiBlbnZbJ0hUVFBfUFJPWFknXSB8fCBlbnZbJ2h0dHBfcHJveHknXTtcclxuICAgICAgICAgICAgICAgIGlmIChwcm94eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbJ3Byb3h5J10gPSB7IG9yaWdpbjogcHJveHkgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm15U29jayA9IG5ldyBXZWJTb2NrZXRJbXBsKHRoaXMuY29ublVSTCwgW10sIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0Vycm9yIGluc3RhbnRpYXRpbmcgV2ViU29ja2V0LicpO1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGUubWVzc2FnZSB8fCBlLmRhdGE7XHJcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubXlTb2NrLm9ub3BlbiA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdXZWJzb2NrZXQgY29ubmVjdGVkLicpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZXJDb25uZWN0ZWRfID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubXlTb2NrLm9uY2xvc2UgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnV2Vic29ja2V0IGNvbm5lY3Rpb24gd2FzIGRpc2Nvbm5lY3RlZC4nKTtcclxuICAgICAgICAgICAgdGhpcy5teVNvY2sgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5teVNvY2sub25tZXNzYWdlID0gbSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSW5jb21pbmdGcmFtZShtKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubXlTb2NrLm9uZXJyb3IgPSBlID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdXZWJTb2NrZXQgZXJyb3IuICBDbG9zaW5nIGNvbm5lY3Rpb24uJyk7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZS5tZXNzYWdlIHx8IGUuZGF0YTtcclxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub25DbG9zZWRfKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTm8tb3AgZm9yIHdlYnNvY2tldHMsIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcgb25jZSB0aGUgY29ubmVjdGlvbiBpcyBjb25maXJtZWQgYXMgb3BlblxyXG4gICAgICovXHJcbiAgICBzdGFydCgpIHsgfVxyXG4gICAgc3RhdGljIGZvcmNlRGlzYWxsb3coKSB7XHJcbiAgICAgICAgV2ViU29ja2V0Q29ubmVjdGlvbi5mb3JjZURpc2FsbG93XyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaXNBdmFpbGFibGUoKSB7XHJcbiAgICAgICAgbGV0IGlzT2xkQW5kcm9pZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZEFuZHJvaWRSZWdleCA9IC9BbmRyb2lkIChbMC05XXswLH1cXC5bMC05XXswLH0pLztcclxuICAgICAgICAgICAgY29uc3Qgb2xkQW5kcm9pZE1hdGNoID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaChvbGRBbmRyb2lkUmVnZXgpO1xyXG4gICAgICAgICAgICBpZiAob2xkQW5kcm9pZE1hdGNoICYmIG9sZEFuZHJvaWRNYXRjaC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VGbG9hdChvbGRBbmRyb2lkTWF0Y2hbMV0pIDwgNC40KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNPbGRBbmRyb2lkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKCFpc09sZEFuZHJvaWQgJiZcclxuICAgICAgICAgICAgV2ViU29ja2V0SW1wbCAhPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAhV2ViU29ja2V0Q29ubmVjdGlvbi5mb3JjZURpc2FsbG93Xyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB3ZSBwcmV2aW91c2x5IGZhaWxlZCB0byBjb25uZWN0IHdpdGggdGhpcyB0cmFuc3BvcnQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBwcmV2aW91c2x5RmFpbGVkKCkge1xyXG4gICAgICAgIC8vIElmIG91ciBwZXJzaXN0ZW50IHN0b3JhZ2UgaXMgYWN0dWFsbHkgb25seSBpbi1tZW1vcnkgc3RvcmFnZSxcclxuICAgICAgICAvLyB3ZSBkZWZhdWx0IHRvIGFzc3VtaW5nIHRoYXQgaXQgcHJldmlvdXNseSBmYWlsZWQgdG8gYmUgc2FmZS5cclxuICAgICAgICByZXR1cm4gKFBlcnNpc3RlbnRTdG9yYWdlLmlzSW5NZW1vcnlTdG9yYWdlIHx8XHJcbiAgICAgICAgICAgIFBlcnNpc3RlbnRTdG9yYWdlLmdldCgncHJldmlvdXNfd2Vic29ja2V0X2ZhaWx1cmUnKSA9PT0gdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBtYXJrQ29ubmVjdGlvbkhlYWx0aHkoKSB7XHJcbiAgICAgICAgUGVyc2lzdGVudFN0b3JhZ2UucmVtb3ZlKCdwcmV2aW91c193ZWJzb2NrZXRfZmFpbHVyZScpO1xyXG4gICAgfVxyXG4gICAgYXBwZW5kRnJhbWVfKGRhdGEpIHtcclxuICAgICAgICB0aGlzLmZyYW1lcy5wdXNoKGRhdGEpO1xyXG4gICAgICAgIGlmICh0aGlzLmZyYW1lcy5sZW5ndGggPT09IHRoaXMudG90YWxGcmFtZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgZnVsbE1lc3MgPSB0aGlzLmZyYW1lcy5qb2luKCcnKTtcclxuICAgICAgICAgICAgdGhpcy5mcmFtZXMgPSBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBqc29uTWVzcyA9IGpzb25FdmFsKGZ1bGxNZXNzKTtcclxuICAgICAgICAgICAgLy9oYW5kbGUgdGhlIG1lc3NhZ2VcclxuICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2UoanNvbk1lc3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGZyYW1lQ291bnQgLSBUaGUgbnVtYmVyIG9mIGZyYW1lcyB3ZSBhcmUgZXhwZWN0aW5nIGZyb20gdGhlIHNlcnZlclxyXG4gICAgICovXHJcbiAgICBoYW5kbGVOZXdGcmFtZUNvdW50XyhmcmFtZUNvdW50KSB7XHJcbiAgICAgICAgdGhpcy50b3RhbEZyYW1lcyA9IGZyYW1lQ291bnQ7XHJcbiAgICAgICAgdGhpcy5mcmFtZXMgPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXR0ZW1wdHMgdG8gcGFyc2UgYSBmcmFtZSBjb3VudCBvdXQgb2Ygc29tZSB0ZXh0LiBJZiBpdCBjYW4ndCwgYXNzdW1lcyBhIHZhbHVlIG9mIDFcclxuICAgICAqIEByZXR1cm5zIEFueSByZW1haW5pbmcgZGF0YSB0byBiZSBwcm9jZXNzLCBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmVcclxuICAgICAqL1xyXG4gICAgZXh0cmFjdEZyYW1lQ291bnRfKGRhdGEpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5mcmFtZXMgPT09IG51bGwsICdXZSBhbHJlYWR5IGhhdmUgYSBmcmFtZSBidWZmZXInKTtcclxuICAgICAgICAvLyBUT0RPOiBUaGUgc2VydmVyIGlzIG9ubHkgc3VwcG9zZWQgdG8gc2VuZCB1cCB0byA5OTk5IGZyYW1lcyAoaS5lLiBsZW5ndGggPD0gNCksIGJ1dCB0aGF0IGlzbid0IGJlaW5nIGVuZm9yY2VkXHJcbiAgICAgICAgLy8gY3VycmVudGx5LiAgU28gYWxsb3dpbmcgbGFyZ2VyIGZyYW1lIGNvdW50cyAobGVuZ3RoIDw9IDYpLiAgU2VlIGh0dHBzOi8vYXBwLmFzYW5hLmNvbS8wL3NlYXJjaC84Njg4NTk4OTk4MzgwLzgyMzc2MDgwNDI1MDhcclxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPD0gNikge1xyXG4gICAgICAgICAgICBjb25zdCBmcmFtZUNvdW50ID0gTnVtYmVyKGRhdGEpO1xyXG4gICAgICAgICAgICBpZiAoIWlzTmFOKGZyYW1lQ291bnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU5ld0ZyYW1lQ291bnRfKGZyYW1lQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oYW5kbGVOZXdGcmFtZUNvdW50XygxKTtcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJvY2VzcyBhIHdlYnNvY2tldCBmcmFtZSB0aGF0IGhhcyBhcnJpdmVkIGZyb20gdGhlIHNlcnZlci5cclxuICAgICAqIEBwYXJhbSBtZXNzIC0gVGhlIGZyYW1lIGRhdGFcclxuICAgICAqL1xyXG4gICAgaGFuZGxlSW5jb21pbmdGcmFtZShtZXNzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubXlTb2NrID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gQ2hyb21lIGFwcGFyZW50bHkgZGVsaXZlcnMgaW5jb21pbmcgcGFja2V0cyBldmVuIGFmdGVyIHdlIC5jbG9zZSgpIHRoZSBjb25uZWN0aW9uIHNvbWV0aW1lcy5cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IG1lc3NbJ2RhdGEnXTtcclxuICAgICAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgKz0gZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5zdGF0c18uaW5jcmVtZW50Q291bnRlcignYnl0ZXNfcmVjZWl2ZWQnLCBkYXRhLmxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5yZXNldEtlZXBBbGl2ZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmZyYW1lcyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyB3ZSdyZSBidWZmZXJpbmdcclxuICAgICAgICAgICAgdGhpcy5hcHBlbmRGcmFtZV8oZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0cnkgdG8gcGFyc2Ugb3V0IGEgZnJhbWUgY291bnQsIG90aGVyd2lzZSwgYXNzdW1lIDEgYW5kIHByb2Nlc3MgaXRcclxuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nRGF0YSA9IHRoaXMuZXh0cmFjdEZyYW1lQ291bnRfKGRhdGEpO1xyXG4gICAgICAgICAgICBpZiAocmVtYWluaW5nRGF0YSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRGcmFtZV8ocmVtYWluaW5nRGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBzZXJ2ZXJcclxuICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIEpTT04gb2JqZWN0IHRvIHRyYW5zbWl0XHJcbiAgICAgKi9cclxuICAgIHNlbmQoZGF0YSkge1xyXG4gICAgICAgIHRoaXMucmVzZXRLZWVwQWxpdmUoKTtcclxuICAgICAgICBjb25zdCBkYXRhU3RyID0gc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNTZW50ICs9IGRhdGFTdHIubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuc3RhdHNfLmluY3JlbWVudENvdW50ZXIoJ2J5dGVzX3NlbnQnLCBkYXRhU3RyLmxlbmd0aCk7XHJcbiAgICAgICAgLy9XZSBjYW4gb25seSBmaXQgYSBjZXJ0YWluIGFtb3VudCBpbiBlYWNoIHdlYnNvY2tldCBmcmFtZSwgc28gd2UgbmVlZCB0byBzcGxpdCB0aGlzIHJlcXVlc3RcclxuICAgICAgICAvL3VwIGludG8gbXVsdGlwbGUgcGllY2VzIGlmIGl0IGRvZXNuJ3QgZml0IGluIG9uZSByZXF1ZXN0LlxyXG4gICAgICAgIGNvbnN0IGRhdGFTZWdzID0gc3BsaXRTdHJpbmdCeVNpemUoZGF0YVN0ciwgV0VCU09DS0VUX01BWF9GUkFNRV9TSVpFKTtcclxuICAgICAgICAvL1NlbmQgdGhlIGxlbmd0aCBoZWFkZXJcclxuICAgICAgICBpZiAoZGF0YVNlZ3MubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRTdHJpbmdfKFN0cmluZyhkYXRhU2Vncy5sZW5ndGgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9TZW5kIHRoZSBhY3R1YWwgZGF0YSBpbiBzZWdtZW50cy5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFTZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFN0cmluZ18oZGF0YVNlZ3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNodXRkb3duXygpIHtcclxuICAgICAgICB0aGlzLmlzQ2xvc2VkXyA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMua2VlcGFsaXZlVGltZXIpIHtcclxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmtlZXBhbGl2ZVRpbWVyKTtcclxuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm15U29jaykge1xyXG4gICAgICAgICAgICB0aGlzLm15U29jay5jbG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm15U29jayA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25DbG9zZWRfKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0Nsb3NlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdXZWJTb2NrZXQgaXMgY2xvc2luZyBpdHNlbGYnKTtcclxuICAgICAgICAgICAgdGhpcy5zaHV0ZG93bl8oKTtcclxuICAgICAgICAgICAgLy8gc2luY2UgdGhpcyBpcyBhbiBpbnRlcm5hbCBjbG9zZSwgdHJpZ2dlciB0aGUgY2xvc2UgbGlzdGVuZXJcclxuICAgICAgICAgICAgaWYgKHRoaXMub25EaXNjb25uZWN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCh0aGlzLmV2ZXJDb25uZWN0ZWRfKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXh0ZXJuYWwtZmFjaW5nIGNsb3NlIGhhbmRsZXIuXHJcbiAgICAgKiBDbG9zZSB0aGUgd2Vic29ja2V0IGFuZCBraWxsIHRoZSBjb25uZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNDbG9zZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnV2ViU29ja2V0IGlzIGJlaW5nIGNsb3NlZCcpO1xyXG4gICAgICAgICAgICB0aGlzLnNodXRkb3duXygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogS2lsbCB0aGUgY3VycmVudCBrZWVwYWxpdmUgdGltZXIgYW5kIHN0YXJ0IGEgbmV3IG9uZSwgdG8gZW5zdXJlIHRoYXQgaXQgYWx3YXlzIGZpcmVzIE4gc2Vjb25kcyBhZnRlclxyXG4gICAgICogdGhlIGxhc3QgYWN0aXZpdHkuXHJcbiAgICAgKi9cclxuICAgIHJlc2V0S2VlcEFsaXZlKCkge1xyXG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5rZWVwYWxpdmVUaW1lcik7XHJcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgICAgICAgLy9JZiB0aGVyZSBoYXMgYmVlbiBubyB3ZWJzb2NrZXQgYWN0aXZpdHkgZm9yIGEgd2hpbGUsIHNlbmQgYSBuby1vcFxyXG4gICAgICAgICAgICBpZiAodGhpcy5teVNvY2spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFN0cmluZ18oJzAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJlc2V0S2VlcEFsaXZlKCk7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgfSwgTWF0aC5mbG9vcihXRUJTT0NLRVRfS0VFUEFMSVZFX0lOVEVSVkFMKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNlbmQgYSBzdHJpbmcgb3ZlciB0aGUgd2Vic29ja2V0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdHIgLSBTdHJpbmcgdG8gc2VuZC5cclxuICAgICAqL1xyXG4gICAgc2VuZFN0cmluZ18oc3RyKSB7XHJcbiAgICAgICAgLy8gRmlyZWZveCBzZWVtcyB0byBzb21ldGltZXMgdGhyb3cgZXhjZXB0aW9ucyAoTlNfRVJST1JfVU5FWFBFQ1RFRCkgZnJvbSB3ZWJzb2NrZXQgLnNlbmQoKVxyXG4gICAgICAgIC8vIGNhbGxzIGZvciBzb21lIHVua25vd24gcmVhc29uLiAgV2UgdHJlYXQgdGhlc2UgYXMgYW4gZXJyb3IgYW5kIGRpc2Nvbm5lY3QuXHJcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vYXBwLmFzYW5hLmNvbS8wLzU4OTI2MTExNDAyMjkyLzY4MDIxMzQwMjUwNDEwXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5teVNvY2suc2VuZChzdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0V4Y2VwdGlvbiB0aHJvd24gZnJvbSBXZWJTb2NrZXQuc2VuZCgpOicsIGUubWVzc2FnZSB8fCBlLmRhdGEsICdDbG9zaW5nIGNvbm5lY3Rpb24uJyk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5vbkNsb3NlZF8uYmluZCh0aGlzKSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBOdW1iZXIgb2YgcmVzcG9uc2UgYmVmb3JlIHdlIGNvbnNpZGVyIHRoZSBjb25uZWN0aW9uIFwiaGVhbHRoeS5cIlxyXG4gKi9cclxuV2ViU29ja2V0Q29ubmVjdGlvbi5yZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5ID0gMjtcclxuLyoqXHJcbiAqIFRpbWUgdG8gd2FpdCBmb3IgdGhlIGNvbm5lY3Rpb24gdGUgYmVjb21lIGhlYWx0aHkgYmVmb3JlIGdpdmluZyB1cC5cclxuICovXHJcbldlYlNvY2tldENvbm5lY3Rpb24uaGVhbHRoeVRpbWVvdXQgPSAzMDAwMDtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEN1cnJlbnRseSBzaW1wbGlzdGljLCB0aGlzIGNsYXNzIG1hbmFnZXMgd2hhdCB0cmFuc3BvcnQgYSBDb25uZWN0aW9uIHNob3VsZCB1c2UgYXQgdmFyaW91cyBzdGFnZXMgb2YgaXRzXHJcbiAqIGxpZmVjeWNsZS5cclxuICpcclxuICogSXQgc3RhcnRzIHdpdGggbG9uZ3BvbGxpbmcgaW4gYSBicm93c2VyLCBhbmQgaHR0cHBvbGxpbmcgb24gbm9kZS4gSXQgdGhlbiB1cGdyYWRlcyB0byB3ZWJzb2NrZXRzIGlmXHJcbiAqIHRoZXkgYXJlIGF2YWlsYWJsZS5cclxuICovXHJcbmNsYXNzIFRyYW5zcG9ydE1hbmFnZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcmVwb0luZm8gLSBNZXRhZGF0YSBhcm91bmQgdGhlIG5hbWVzcGFjZSB3ZSdyZSBjb25uZWN0aW5nIHRvXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHJlcG9JbmZvKSB7XHJcbiAgICAgICAgdGhpcy5pbml0VHJhbnNwb3J0c18ocmVwb0luZm8pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBBTExfVFJBTlNQT1JUUygpIHtcclxuICAgICAgICByZXR1cm4gW0Jyb3dzZXJQb2xsQ29ubmVjdGlvbiwgV2ViU29ja2V0Q29ubmVjdGlvbl07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciB0cmFuc3BvcnQgaGFzIGJlZW4gc2VsZWN0ZWQgdG8gZW5zdXJlIFdlYlNvY2tldENvbm5lY3Rpb24gb3IgQnJvd3NlclBvbGxDb25uZWN0aW9uIGFyZSBub3QgY2FsbGVkIGFmdGVyXHJcbiAgICAgKiBUcmFuc3BvcnRNYW5hZ2VyIGhhcyBhbHJlYWR5IHNldCB1cCB0cmFuc3BvcnRzX1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IElTX1RSQU5TUE9SVF9JTklUSUFMSVpFRCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxUcmFuc3BvcnRJbml0aWFsaXplZF87XHJcbiAgICB9XHJcbiAgICBpbml0VHJhbnNwb3J0c18ocmVwb0luZm8pIHtcclxuICAgICAgICBjb25zdCBpc1dlYlNvY2tldHNBdmFpbGFibGUgPSBXZWJTb2NrZXRDb25uZWN0aW9uICYmIFdlYlNvY2tldENvbm5lY3Rpb25bJ2lzQXZhaWxhYmxlJ10oKTtcclxuICAgICAgICBsZXQgaXNTa2lwUG9sbENvbm5lY3Rpb24gPSBpc1dlYlNvY2tldHNBdmFpbGFibGUgJiYgIVdlYlNvY2tldENvbm5lY3Rpb24ucHJldmlvdXNseUZhaWxlZCgpO1xyXG4gICAgICAgIGlmIChyZXBvSW5mby53ZWJTb2NrZXRPbmx5KSB7XHJcbiAgICAgICAgICAgIGlmICghaXNXZWJTb2NrZXRzQXZhaWxhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKFwid3NzOi8vIFVSTCB1c2VkLCBidXQgYnJvd3NlciBpc24ndCBrbm93biB0byBzdXBwb3J0IHdlYnNvY2tldHMuICBUcnlpbmcgYW55d2F5LlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpc1NraXBQb2xsQ29ubmVjdGlvbiA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1NraXBQb2xsQ29ubmVjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydHNfID0gW1dlYlNvY2tldENvbm5lY3Rpb25dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNwb3J0cyA9ICh0aGlzLnRyYW5zcG9ydHNfID0gW10pO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRyYW5zcG9ydCBvZiBUcmFuc3BvcnRNYW5hZ2VyLkFMTF9UUkFOU1BPUlRTKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNwb3J0ICYmIHRyYW5zcG9ydFsnaXNBdmFpbGFibGUnXSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0cy5wdXNoKHRyYW5zcG9ydCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgVHJhbnNwb3J0TWFuYWdlci5nbG9iYWxUcmFuc3BvcnRJbml0aWFsaXplZF8gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgaW5pdGlhbCB0cmFuc3BvcnQgdG8gdXNlXHJcbiAgICAgKi9cclxuICAgIGluaXRpYWxUcmFuc3BvcnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0c18ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRzX1swXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIG5leHQgdHJhbnNwb3J0LCBvciBudWxsXHJcbiAgICAgKi9cclxuICAgIHVwZ3JhZGVUcmFuc3BvcnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0c18ubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRzX1sxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vLyBLZWVwcyB0cmFjayBvZiB3aGV0aGVyIHRoZSBUcmFuc3BvcnRNYW5hZ2VyIGhhcyBhbHJlYWR5IGNob3NlbiBhIHRyYW5zcG9ydCB0byB1c2VcclxuVHJhbnNwb3J0TWFuYWdlci5nbG9iYWxUcmFuc3BvcnRJbml0aWFsaXplZF8gPSBmYWxzZTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gQWJvcnQgdXBncmFkZSBhdHRlbXB0IGlmIGl0IHRha2VzIGxvbmdlciB0aGFuIDYwcy5cclxuY29uc3QgVVBHUkFERV9USU1FT1VUID0gNjAwMDA7XHJcbi8vIEZvciBzb21lIHRyYW5zcG9ydHMgKFdlYlNvY2tldHMpLCB3ZSBuZWVkIHRvIFwidmFsaWRhdGVcIiB0aGUgdHJhbnNwb3J0IGJ5IGV4Y2hhbmdpbmcgYSBmZXcgcmVxdWVzdHMgYW5kIHJlc3BvbnNlcy5cclxuLy8gSWYgd2UgaGF2ZW4ndCBzZW50IGVub3VnaCByZXF1ZXN0cyB3aXRoaW4gNXMsIHdlJ2xsIHN0YXJ0IHNlbmRpbmcgbm9vcCBwaW5nIHJlcXVlc3RzLlxyXG5jb25zdCBERUxBWV9CRUZPUkVfU0VORElOR19FWFRSQV9SRVFVRVNUUyA9IDUwMDA7XHJcbi8vIElmIHRoZSBpbml0aWFsIGRhdGEgc2VudCB0cmlnZ2VycyBhIGxvdCBvZiBiYW5kd2lkdGggKGkuZS4gaXQncyBhIGxhcmdlIHB1dCBvciBhIGxpc3RlbiBmb3IgYSBsYXJnZSBhbW91bnQgb2YgZGF0YSlcclxuLy8gdGhlbiB3ZSBtYXkgbm90IGJlIGFibGUgdG8gZXhjaGFuZ2Ugb3VyIHBpbmcvcG9uZyByZXF1ZXN0cyB3aXRoaW4gdGhlIGhlYWx0aHkgdGltZW91dC4gIFNvIGlmIHdlIHJlYWNoIHRoZSB0aW1lb3V0XHJcbi8vIGJ1dCB3ZSd2ZSBzZW50L3JlY2VpdmVkIGVub3VnaCBieXRlcywgd2UgZG9uJ3QgY2FuY2VsIHRoZSBjb25uZWN0aW9uLlxyXG5jb25zdCBCWVRFU19TRU5UX0hFQUxUSFlfT1ZFUlJJREUgPSAxMCAqIDEwMjQ7XHJcbmNvbnN0IEJZVEVTX1JFQ0VJVkVEX0hFQUxUSFlfT1ZFUlJJREUgPSAxMDAgKiAxMDI0O1xyXG5jb25zdCBNRVNTQUdFX1RZUEUgPSAndCc7XHJcbmNvbnN0IE1FU1NBR0VfREFUQSA9ICdkJztcclxuY29uc3QgQ09OVFJPTF9TSFVURE9XTiA9ICdzJztcclxuY29uc3QgQ09OVFJPTF9SRVNFVCA9ICdyJztcclxuY29uc3QgQ09OVFJPTF9FUlJPUiA9ICdlJztcclxuY29uc3QgQ09OVFJPTF9QT05HID0gJ28nO1xyXG5jb25zdCBTV0lUQ0hfQUNLID0gJ2EnO1xyXG5jb25zdCBFTkRfVFJBTlNNSVNTSU9OID0gJ24nO1xyXG5jb25zdCBQSU5HID0gJ3AnO1xyXG5jb25zdCBTRVJWRVJfSEVMTE8gPSAnaCc7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHJlYWwtdGltZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgdXNpbmcgd2hpY2hldmVyIG1ldGhvZCB3b3Jrc1xyXG4gKiBiZXN0IGluIHRoZSBjdXJyZW50IGJyb3dzZXIuXHJcbiAqL1xyXG5jbGFzcyBDb25uZWN0aW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGlkIC0gYW4gaWQgZm9yIHRoaXMgY29ubmVjdGlvblxyXG4gICAgICogQHBhcmFtIHJlcG9JbmZvXyAtIHRoZSBpbmZvIGZvciB0aGUgZW5kcG9pbnQgdG8gY29ubmVjdCB0b1xyXG4gICAgICogQHBhcmFtIGFwcGxpY2F0aW9uSWRfIC0gdGhlIEZpcmViYXNlIEFwcCBJRCBmb3IgdGhpcyBwcm9qZWN0XHJcbiAgICAgKiBAcGFyYW0gYXBwQ2hlY2tUb2tlbl8gLSBUaGUgQXBwIENoZWNrIFRva2VuIGZvciB0aGlzIGRldmljZS5cclxuICAgICAqIEBwYXJhbSBhdXRoVG9rZW5fIC0gVGhlIGF1dGggdG9rZW4gZm9yIHRoaXMgc2Vzc2lvbi5cclxuICAgICAqIEBwYXJhbSBvbk1lc3NhZ2VfIC0gdGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIGEgc2VydmVyLXB1c2ggbWVzc2FnZSBhcnJpdmVzXHJcbiAgICAgKiBAcGFyYW0gb25SZWFkeV8gLSB0aGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhpcyBjb25uZWN0aW9uIGlzIHJlYWR5IHRvIHNlbmQgbWVzc2FnZXMuXHJcbiAgICAgKiBAcGFyYW0gb25EaXNjb25uZWN0XyAtIHRoZSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiBhIGNvbm5lY3Rpb24gd2FzIGxvc3RcclxuICAgICAqIEBwYXJhbSBvbktpbGxfIC0gdGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoaXMgY29ubmVjdGlvbiBoYXMgcGVybWFuZW50bHkgc2h1dCBkb3duLlxyXG4gICAgICogQHBhcmFtIGxhc3RTZXNzaW9uSWQgLSBsYXN0IHNlc3Npb24gaWQgaW4gcGVyc2lzdGVudCBjb25uZWN0aW9uLiBpcyB1c2VkIHRvIGNsZWFuIHVwIG9sZCBzZXNzaW9uIGluIHJlYWwtdGltZSBzZXJ2ZXJcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoaWQsIHJlcG9JbmZvXywgYXBwbGljYXRpb25JZF8sIGFwcENoZWNrVG9rZW5fLCBhdXRoVG9rZW5fLCBvbk1lc3NhZ2VfLCBvblJlYWR5Xywgb25EaXNjb25uZWN0Xywgb25LaWxsXywgbGFzdFNlc3Npb25JZCkge1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLnJlcG9JbmZvXyA9IHJlcG9JbmZvXztcclxuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uSWRfID0gYXBwbGljYXRpb25JZF87XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuXyA9IGFwcENoZWNrVG9rZW5fO1xyXG4gICAgICAgIHRoaXMuYXV0aFRva2VuXyA9IGF1dGhUb2tlbl87XHJcbiAgICAgICAgdGhpcy5vbk1lc3NhZ2VfID0gb25NZXNzYWdlXztcclxuICAgICAgICB0aGlzLm9uUmVhZHlfID0gb25SZWFkeV87XHJcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gb25EaXNjb25uZWN0XztcclxuICAgICAgICB0aGlzLm9uS2lsbF8gPSBvbktpbGxfO1xyXG4gICAgICAgIHRoaXMubGFzdFNlc3Npb25JZCA9IGxhc3RTZXNzaW9uSWQ7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0RhdGFNZXNzYWdlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuc3RhdGVfID0gMCAvKiBSZWFsdGltZVN0YXRlLkNPTk5FQ1RJTkcgKi87XHJcbiAgICAgICAgdGhpcy5sb2dfID0gbG9nV3JhcHBlcignYzonICsgdGhpcy5pZCArICc6Jyk7XHJcbiAgICAgICAgdGhpcy50cmFuc3BvcnRNYW5hZ2VyXyA9IG5ldyBUcmFuc3BvcnRNYW5hZ2VyKHJlcG9JbmZvXyk7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdDb25uZWN0aW9uIGNyZWF0ZWQnKTtcclxuICAgICAgICB0aGlzLnN0YXJ0XygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgYSBjb25uZWN0aW9uIGF0dGVtcHRcclxuICAgICAqL1xyXG4gICAgc3RhcnRfKCkge1xyXG4gICAgICAgIGNvbnN0IGNvbm4gPSB0aGlzLnRyYW5zcG9ydE1hbmFnZXJfLmluaXRpYWxUcmFuc3BvcnQoKTtcclxuICAgICAgICB0aGlzLmNvbm5fID0gbmV3IGNvbm4odGhpcy5uZXh0VHJhbnNwb3J0SWRfKCksIHRoaXMucmVwb0luZm9fLCB0aGlzLmFwcGxpY2F0aW9uSWRfLCB0aGlzLmFwcENoZWNrVG9rZW5fLCB0aGlzLmF1dGhUb2tlbl8sIG51bGwsIHRoaXMubGFzdFNlc3Npb25JZCk7XHJcbiAgICAgICAgLy8gRm9yIGNlcnRhaW4gdHJhbnNwb3J0cyAoV2ViU29ja2V0cyksIHdlIG5lZWQgdG8gc2VuZCBhbmQgcmVjZWl2ZSBzZXZlcmFsIG1lc3NhZ2VzIGJhY2sgYW5kIGZvcnRoIGJlZm9yZSB3ZVxyXG4gICAgICAgIC8vIGNhbiBjb25zaWRlciB0aGUgdHJhbnNwb3J0IGhlYWx0aHkuXHJcbiAgICAgICAgdGhpcy5wcmltYXJ5UmVzcG9uc2VzUmVxdWlyZWRfID0gY29ublsncmVzcG9uc2VzUmVxdWlyZWRUb0JlSGVhbHRoeSddIHx8IDA7XHJcbiAgICAgICAgY29uc3Qgb25NZXNzYWdlUmVjZWl2ZWQgPSB0aGlzLmNvbm5SZWNlaXZlcl8odGhpcy5jb25uXyk7XHJcbiAgICAgICAgY29uc3Qgb25Db25uZWN0aW9uTG9zdCA9IHRoaXMuZGlzY29ublJlY2VpdmVyXyh0aGlzLmNvbm5fKTtcclxuICAgICAgICB0aGlzLnR4XyA9IHRoaXMuY29ubl87XHJcbiAgICAgICAgdGhpcy5yeF8gPSB0aGlzLmNvbm5fO1xyXG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaXNIZWFsdGh5XyA9IGZhbHNlO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogRmlyZWZveCBkb2Vzbid0IGxpa2Ugd2hlbiBjb2RlIGZyb20gb25lIGlmcmFtZSB0cmllcyB0byBjcmVhdGUgYW5vdGhlciBpZnJhbWUgYnkgd2F5IG9mIHRoZSBwYXJlbnQgZnJhbWUuXHJcbiAgICAgICAgICogVGhpcyBjYW4gb2NjdXIgaW4gdGhlIGNhc2Ugb2YgYSByZWRpcmVjdCwgaS5lLiB3ZSBndWVzc2VkIHdyb25nIG9uIHdoYXQgc2VydmVyIHRvIGNvbm5lY3QgdG8gYW5kIHJlY2VpdmVkIGEgcmVzZXQuXHJcbiAgICAgICAgICogU29tZWhvdywgc2V0VGltZW91dCBzZWVtcyB0byBtYWtlIHRoaXMgb2suIFRoYXQgZG9lc24ndCBtYWtlIHNlbnNlIGZyb20gYSBzZWN1cml0eSBwZXJzcGVjdGl2ZSwgc2luY2UgeW91IHNob3VsZFxyXG4gICAgICAgICAqIHN0aWxsIGhhdmUgdGhlIGNvbnRleHQgb2YgeW91ciBvcmlnaW5hdGluZyBmcmFtZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgLy8gdGhpcy5jb25uXyBnZXRzIHNldCB0byBudWxsIGluIHNvbWUgb2YgdGhlIHRlc3RzLiBDaGVjayB0byBtYWtlIHN1cmUgaXQgc3RpbGwgZXhpc3RzIGJlZm9yZSB1c2luZyBpdFxyXG4gICAgICAgICAgICB0aGlzLmNvbm5fICYmIHRoaXMuY29ubl8ub3Blbihvbk1lc3NhZ2VSZWNlaXZlZCwgb25Db25uZWN0aW9uTG9zdCk7XHJcbiAgICAgICAgfSwgTWF0aC5mbG9vcigwKSk7XHJcbiAgICAgICAgY29uc3QgaGVhbHRoeVRpbWVvdXRNUyA9IGNvbm5bJ2hlYWx0aHlUaW1lb3V0J10gfHwgMDtcclxuICAgICAgICBpZiAoaGVhbHRoeVRpbWVvdXRNUyA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFsdGh5VGltZW91dF8gPSBzZXRUaW1lb3V0Tm9uQmxvY2tpbmcoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWFsdGh5VGltZW91dF8gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzSGVhbHRoeV8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25uXyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5fLmJ5dGVzUmVjZWl2ZWQgPiBCWVRFU19SRUNFSVZFRF9IRUFMVEhZX09WRVJSSURFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nXygnQ29ubmVjdGlvbiBleGNlZWRlZCBoZWFsdGh5IHRpbWVvdXQgYnV0IGhhcyByZWNlaXZlZCAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubl8uYnl0ZXNSZWNlaXZlZCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGJ5dGVzLiAgTWFya2luZyBjb25uZWN0aW9uIGhlYWx0aHkuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNIZWFsdGh5XyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubl8ubWFya0Nvbm5lY3Rpb25IZWFsdGh5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29ubl8gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uXy5ieXRlc1NlbnQgPiBCWVRFU19TRU5UX0hFQUxUSFlfT1ZFUlJJREUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdDb25uZWN0aW9uIGV4Y2VlZGVkIGhlYWx0aHkgdGltZW91dCBidXQgaGFzIHNlbnQgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5fLmJ5dGVzU2VudCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGJ5dGVzLiAgTGVhdmluZyBjb25uZWN0aW9uIGFsaXZlLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBXZSBkb24ndCB3YW50IHRvIG1hcmsgaXQgaGVhbHRoeSwgc2luY2Ugd2UgaGF2ZSBubyBndWFyYW50ZWUgdGhhdCB0aGUgYnl0ZXMgaGF2ZSBtYWRlIGl0IHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzZXJ2ZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ0Nsb3NpbmcgdW5oZWFsdGh5IGNvbm5lY3Rpb24gYWZ0ZXIgdGltZW91dC4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIH0sIE1hdGguZmxvb3IoaGVhbHRoeVRpbWVvdXRNUykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG5leHRUcmFuc3BvcnRJZF8oKSB7XHJcbiAgICAgICAgcmV0dXJuICdjOicgKyB0aGlzLmlkICsgJzonICsgdGhpcy5jb25uZWN0aW9uQ291bnQrKztcclxuICAgIH1cclxuICAgIGRpc2Nvbm5SZWNlaXZlcl8oY29ubikge1xyXG4gICAgICAgIHJldHVybiBldmVyQ29ubmVjdGVkID0+IHtcclxuICAgICAgICAgICAgaWYgKGNvbm4gPT09IHRoaXMuY29ubl8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uTG9zdF8oZXZlckNvbm5lY3RlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29ubiA9PT0gdGhpcy5zZWNvbmRhcnlDb25uXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdTZWNvbmRhcnkgY29ubmVjdGlvbiBsb3N0LicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vblNlY29uZGFyeUNvbm5lY3Rpb25Mb3N0XygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdjbG9zaW5nIGFuIG9sZCBjb25uZWN0aW9uJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29ublJlY2VpdmVyXyhjb25uKSB7XHJcbiAgICAgICAgcmV0dXJuIChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlXyAhPT0gMiAvKiBSZWFsdGltZVN0YXRlLkRJU0NPTk5FQ1RFRCAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbm4gPT09IHRoaXMucnhfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblByaW1hcnlNZXNzYWdlUmVjZWl2ZWRfKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29ubiA9PT0gdGhpcy5zZWNvbmRhcnlDb25uXykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25TZWNvbmRhcnlNZXNzYWdlUmVjZWl2ZWRfKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdtZXNzYWdlIG9uIG9sZCBjb25uZWN0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZGF0YU1zZyAtIEFuIGFyYml0cmFyeSBkYXRhIG1lc3NhZ2UgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyXHJcbiAgICAgKi9cclxuICAgIHNlbmRSZXF1ZXN0KGRhdGFNc2cpIHtcclxuICAgICAgICAvLyB3cmFwIGluIGEgZGF0YSBtZXNzYWdlIGVudmVsb3BlIGFuZCBzZW5kIGl0IG9uXHJcbiAgICAgICAgY29uc3QgbXNnID0geyB0OiAnZCcsIGQ6IGRhdGFNc2cgfTtcclxuICAgICAgICB0aGlzLnNlbmREYXRhXyhtc2cpO1xyXG4gICAgfVxyXG4gICAgdHJ5Q2xlYW51cENvbm5lY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHhfID09PSB0aGlzLnNlY29uZGFyeUNvbm5fICYmIHRoaXMucnhfID09PSB0aGlzLnNlY29uZGFyeUNvbm5fKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnY2xlYW5pbmcgdXAgYW5kIHByb21vdGluZyBhIGNvbm5lY3Rpb246ICcgKyB0aGlzLnNlY29uZGFyeUNvbm5fLmNvbm5JZCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubl8gPSB0aGlzLnNlY29uZGFyeUNvbm5fO1xyXG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gdGhlIHNlcnZlciB3aWxsIHNodXRkb3duIHRoZSBvbGQgY29ubmVjdGlvblxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uU2Vjb25kYXJ5Q29udHJvbF8oY29udHJvbERhdGEpIHtcclxuICAgICAgICBpZiAoTUVTU0FHRV9UWVBFIGluIGNvbnRyb2xEYXRhKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNtZCA9IGNvbnRyb2xEYXRhW01FU1NBR0VfVFlQRV07XHJcbiAgICAgICAgICAgIGlmIChjbWQgPT09IFNXSVRDSF9BQ0spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBncmFkZUlmU2Vjb25kYXJ5SGVhbHRoeV8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbWQgPT09IENPTlRST0xfUkVTRVQpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1vc3QgbGlrZWx5IHRoZSBzZXNzaW9uIHdhc24ndCB2YWxpZC4gQWJhbmRvbiB0aGUgc3dpdGNoIGF0dGVtcHRcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnR290IGEgcmVzZXQgb24gc2Vjb25kYXJ5LCBjbG9zaW5nIGl0Jyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIGFscmVhZHkgdXNpbmcgdGhpcyBjb25uZWN0aW9uIGZvciBzb21ldGhpbmcsIHRoYW4gd2UgbmVlZCB0byBmdWxseSBjbG9zZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHhfID09PSB0aGlzLnNlY29uZGFyeUNvbm5fIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yeF8gPT09IHRoaXMuc2Vjb25kYXJ5Q29ubl8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX1BPTkcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnZ290IHBvbmcgb24gc2Vjb25kYXJ5LicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlSZXNwb25zZXNSZXF1aXJlZF8tLTtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBncmFkZUlmU2Vjb25kYXJ5SGVhbHRoeV8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uU2Vjb25kYXJ5TWVzc2FnZVJlY2VpdmVkXyhwYXJzZWREYXRhKSB7XHJcbiAgICAgICAgY29uc3QgbGF5ZXIgPSByZXF1aXJlS2V5KCd0JywgcGFyc2VkRGF0YSk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHJlcXVpcmVLZXkoJ2QnLCBwYXJzZWREYXRhKTtcclxuICAgICAgICBpZiAobGF5ZXIgPT09ICdjJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uU2Vjb25kYXJ5Q29udHJvbF8oZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxheWVyID09PSAnZCcpIHtcclxuICAgICAgICAgICAgLy8gZ290IGEgZGF0YSBtZXNzYWdlLCBidXQgd2UncmUgc3RpbGwgc2Vjb25kIGNvbm5lY3Rpb24uIE5lZWQgdG8gYnVmZmVyIGl0IHVwXHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RhdGFNZXNzYWdlcy5wdXNoKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByb3RvY29sIGxheWVyOiAnICsgbGF5ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZ3JhZGVJZlNlY29uZGFyeUhlYWx0aHlfKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlY29uZGFyeVJlc3BvbnNlc1JlcXVpcmVkXyA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnU2Vjb25kYXJ5IGNvbm5lY3Rpb24gaXMgaGVhbHRoeS4nKTtcclxuICAgICAgICAgICAgdGhpcy5pc0hlYWx0aHlfID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5tYXJrQ29ubmVjdGlvbkhlYWx0aHkoKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZWVkV2l0aFVwZ3JhZGVfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBTZW5kIGEgcGluZyB0byBtYWtlIHN1cmUgdGhlIGNvbm5lY3Rpb24gaXMgaGVhbHRoeS5cclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdzZW5kaW5nIHBpbmcgb24gc2Vjb25kYXJ5LicpO1xyXG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLnNlbmQoeyB0OiAnYycsIGQ6IHsgdDogUElORywgZDoge30gfSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwcm9jZWVkV2l0aFVwZ3JhZGVfKCkge1xyXG4gICAgICAgIC8vIHRlbGwgdGhpcyBjb25uZWN0aW9uIHRvIGNvbnNpZGVyIGl0c2VsZiBvcGVuXHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5zdGFydCgpO1xyXG4gICAgICAgIC8vIHNlbmQgYWNrXHJcbiAgICAgICAgdGhpcy5sb2dfKCdzZW5kaW5nIGNsaWVudCBhY2sgb24gc2Vjb25kYXJ5Jyk7XHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5zZW5kKHsgdDogJ2MnLCBkOiB7IHQ6IFNXSVRDSF9BQ0ssIGQ6IHt9IH0gfSk7XHJcbiAgICAgICAgLy8gc2VuZCBlbmQgcGFja2V0IG9uIHByaW1hcnkgdHJhbnNwb3J0LCBzd2l0Y2ggdG8gc2VuZGluZyBvbiB0aGlzIG9uZVxyXG4gICAgICAgIC8vIGNhbiByZWNlaXZlIG9uIHRoaXMgb25lLCBidWZmZXIgcmVzcG9uc2VzIHVudGlsIGVuZCByZWNlaXZlZCBvbiBwcmltYXJ5IHRyYW5zcG9ydFxyXG4gICAgICAgIHRoaXMubG9nXygnRW5kaW5nIHRyYW5zbWlzc2lvbiBvbiBwcmltYXJ5Jyk7XHJcbiAgICAgICAgdGhpcy5jb25uXy5zZW5kKHsgdDogJ2MnLCBkOiB7IHQ6IEVORF9UUkFOU01JU1NJT04sIGQ6IHt9IH0gfSk7XHJcbiAgICAgICAgdGhpcy50eF8gPSB0aGlzLnNlY29uZGFyeUNvbm5fO1xyXG4gICAgICAgIHRoaXMudHJ5Q2xlYW51cENvbm5lY3Rpb24oKTtcclxuICAgIH1cclxuICAgIG9uUHJpbWFyeU1lc3NhZ2VSZWNlaXZlZF8ocGFyc2VkRGF0YSkge1xyXG4gICAgICAgIC8vIE11c3QgcmVmZXIgdG8gcGFyc2VkRGF0YSBwcm9wZXJ0aWVzIGluIHF1b3Rlcywgc28gY2xvc3VyZSBkb2Vzbid0IHRvdWNoIHRoZW0uXHJcbiAgICAgICAgY29uc3QgbGF5ZXIgPSByZXF1aXJlS2V5KCd0JywgcGFyc2VkRGF0YSk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHJlcXVpcmVLZXkoJ2QnLCBwYXJzZWREYXRhKTtcclxuICAgICAgICBpZiAobGF5ZXIgPT09ICdjJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uQ29udHJvbF8oZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxheWVyID09PSAnZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkRhdGFNZXNzYWdlXyhkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkRhdGFNZXNzYWdlXyhtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy5vblByaW1hcnlSZXNwb25zZV8oKTtcclxuICAgICAgICAvLyBXZSBkb24ndCBkbyBhbnl0aGluZyB3aXRoIGRhdGEgbWVzc2FnZXMsIGp1c3Qga2ljayB0aGVtIHVwIGEgbGV2ZWxcclxuICAgICAgICB0aGlzLm9uTWVzc2FnZV8obWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICBvblByaW1hcnlSZXNwb25zZV8oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSGVhbHRoeV8pIHtcclxuICAgICAgICAgICAgdGhpcy5wcmltYXJ5UmVzcG9uc2VzUmVxdWlyZWRfLS07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByaW1hcnlSZXNwb25zZXNSZXF1aXJlZF8gPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdQcmltYXJ5IGNvbm5lY3Rpb24gaXMgaGVhbHRoeS4nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNIZWFsdGh5XyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5fLm1hcmtDb25uZWN0aW9uSGVhbHRoeSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25Db250cm9sXyhjb250cm9sRGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNtZCA9IHJlcXVpcmVLZXkoTUVTU0FHRV9UWVBFLCBjb250cm9sRGF0YSk7XHJcbiAgICAgICAgaWYgKE1FU1NBR0VfREFUQSBpbiBjb250cm9sRGF0YSkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gY29udHJvbERhdGFbTUVTU0FHRV9EQVRBXTtcclxuICAgICAgICAgICAgaWYgKGNtZCA9PT0gU0VSVkVSX0hFTExPKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kc2hha2VQYXlsb2FkID0gT2JqZWN0LmFzc2lnbih7fSwgcGF5bG9hZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXBvSW5mb18uaXNVc2luZ0VtdWxhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBvbiBjb25uZWN0aW5nLCB0aGUgZW11bGF0b3Igd2lsbCBwYXNzIHRoZSBob3N0bmFtZSB0aGF0IGl0J3MgYXdhcmUgb2YsIGJ1dCB3ZSBwcmVmZXIgdGhlIHVzZXIncyBzZXQgaG9zdG5hbWUgdmlhIGBjb25uZWN0RGF0YWJhc2VFbXVsYXRvcmAgb3ZlciB3aGF0IHRoZSBlbXVsYXRvciBwYXNzZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZHNoYWtlUGF5bG9hZC5oID0gdGhpcy5yZXBvSW5mb18uaG9zdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMub25IYW5kc2hha2VfKGhhbmRzaGFrZVBheWxvYWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtZCA9PT0gRU5EX1RSQU5TTUlTU0lPTikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdyZWN2ZCBlbmQgdHJhbnNtaXNzaW9uIG9uIHByaW1hcnknKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucnhfID0gdGhpcy5zZWNvbmRhcnlDb25uXztcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wZW5kaW5nRGF0YU1lc3NhZ2VzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkRhdGFNZXNzYWdlXyh0aGlzLnBlbmRpbmdEYXRhTWVzc2FnZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nRGF0YU1lc3NhZ2VzID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyeUNsZWFudXBDb25uZWN0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX1NIVVRET1dOKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdhcyBwcmV2aW91c2x5IHRoZSAnb25LaWxsJyBjYWxsYmFjayBwYXNzZWQgdG8gdGhlIGxvd2VyLWxldmVsIGNvbm5lY3Rpb25cclxuICAgICAgICAgICAgICAgIC8vIHBheWxvYWQgaW4gdGhpcyBjYXNlIGlzIHRoZSByZWFzb24gZm9yIHRoZSBzaHV0ZG93bi4gR2VuZXJhbGx5IGEgaHVtYW4tcmVhZGFibGUgZXJyb3JcclxuICAgICAgICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uU2h1dGRvd25fKHBheWxvYWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtZCA9PT0gQ09OVFJPTF9SRVNFVCkge1xyXG4gICAgICAgICAgICAgICAgLy8gcGF5bG9hZCBpbiB0aGlzIGNhc2UgaXMgdGhlIGhvc3Qgd2Ugc2hvdWxkIGNvbnRhY3RcclxuICAgICAgICAgICAgICAgIHRoaXMub25SZXNldF8ocGF5bG9hZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX0VSUk9SKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcignU2VydmVyIEVycm9yOiAnICsgcGF5bG9hZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX1BPTkcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnZ290IHBvbmcgb24gcHJpbWFyeS4nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub25QcmltYXJ5UmVzcG9uc2VfKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRQaW5nT25QcmltYXJ5SWZOZWNlc3NhcnlfKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcignVW5rbm93biBjb250cm9sIHBhY2tldCBjb21tYW5kOiAnICsgY21kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGhhbmRzaGFrZSAtIFRoZSBoYW5kc2hha2UgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXJcclxuICAgICAqL1xyXG4gICAgb25IYW5kc2hha2VfKGhhbmRzaGFrZSkge1xyXG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IGhhbmRzaGFrZS50cztcclxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gaGFuZHNoYWtlLnY7XHJcbiAgICAgICAgY29uc3QgaG9zdCA9IGhhbmRzaGFrZS5oO1xyXG4gICAgICAgIHRoaXMuc2Vzc2lvbklkID0gaGFuZHNoYWtlLnM7XHJcbiAgICAgICAgdGhpcy5yZXBvSW5mb18uaG9zdCA9IGhvc3Q7XHJcbiAgICAgICAgLy8gaWYgd2UndmUgYWxyZWFkeSBjbG9zZWQgdGhlIGNvbm5lY3Rpb24sIHRoZW4gZG9uJ3QgYm90aGVyIHRyeWluZyB0byBwcm9ncmVzcyBmdXJ0aGVyXHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVfID09PSAwIC8qIFJlYWx0aW1lU3RhdGUuQ09OTkVDVElORyAqLykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5fLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uRXN0YWJsaXNoZWRfKHRoaXMuY29ubl8sIHRpbWVzdGFtcCk7XHJcbiAgICAgICAgICAgIGlmIChQUk9UT0NPTF9WRVJTSU9OICE9PSB2ZXJzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKCdQcm90b2NvbCB2ZXJzaW9uIG1pc21hdGNoIGRldGVjdGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVE9ETzogZG8gd2Ugd2FudCB0byB1cGdyYWRlPyB3aGVuPyBtYXliZSBhIGRlbGF5P1xyXG4gICAgICAgICAgICB0aGlzLnRyeVN0YXJ0VXBncmFkZV8oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0cnlTdGFydFVwZ3JhZGVfKCkge1xyXG4gICAgICAgIGNvbnN0IGNvbm4gPSB0aGlzLnRyYW5zcG9ydE1hbmFnZXJfLnVwZ3JhZGVUcmFuc3BvcnQoKTtcclxuICAgICAgICBpZiAoY29ubikge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0VXBncmFkZV8oY29ubik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhcnRVcGdyYWRlXyhjb25uKSB7XHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXyA9IG5ldyBjb25uKHRoaXMubmV4dFRyYW5zcG9ydElkXygpLCB0aGlzLnJlcG9JbmZvXywgdGhpcy5hcHBsaWNhdGlvbklkXywgdGhpcy5hcHBDaGVja1Rva2VuXywgdGhpcy5hdXRoVG9rZW5fLCB0aGlzLnNlc3Npb25JZCk7XHJcbiAgICAgICAgLy8gRm9yIGNlcnRhaW4gdHJhbnNwb3J0cyAoV2ViU29ja2V0cyksIHdlIG5lZWQgdG8gc2VuZCBhbmQgcmVjZWl2ZSBzZXZlcmFsIG1lc3NhZ2VzIGJhY2sgYW5kIGZvcnRoIGJlZm9yZSB3ZVxyXG4gICAgICAgIC8vIGNhbiBjb25zaWRlciB0aGUgdHJhbnNwb3J0IGhlYWx0aHkuXHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlSZXNwb25zZXNSZXF1aXJlZF8gPVxyXG4gICAgICAgICAgICBjb25uWydyZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5J10gfHwgMDtcclxuICAgICAgICBjb25zdCBvbk1lc3NhZ2UgPSB0aGlzLmNvbm5SZWNlaXZlcl8odGhpcy5zZWNvbmRhcnlDb25uXyk7XHJcbiAgICAgICAgY29uc3Qgb25EaXNjb25uZWN0ID0gdGhpcy5kaXNjb25uUmVjZWl2ZXJfKHRoaXMuc2Vjb25kYXJ5Q29ubl8pO1xyXG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8ub3Blbihvbk1lc3NhZ2UsIG9uRGlzY29ubmVjdCk7XHJcbiAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBzdWNjZXNzZnVsbHkgdXBncmFkZWQgYWZ0ZXIgVVBHUkFERV9USU1FT1VULCBnaXZlIHVwIGFuZCBraWxsIHRoZSBzZWNvbmRhcnkuXHJcbiAgICAgICAgc2V0VGltZW91dE5vbkJsb2NraW5nKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2Vjb25kYXJ5Q29ubl8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnVGltZWQgb3V0IHRyeWluZyB0byB1cGdyYWRlLicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgTWF0aC5mbG9vcihVUEdSQURFX1RJTUVPVVQpKTtcclxuICAgIH1cclxuICAgIG9uUmVzZXRfKGhvc3QpIHtcclxuICAgICAgICB0aGlzLmxvZ18oJ1Jlc2V0IHBhY2tldCByZWNlaXZlZC4gIE5ldyBob3N0OiAnICsgaG9zdCk7XHJcbiAgICAgICAgdGhpcy5yZXBvSW5mb18uaG9zdCA9IGhvc3Q7XHJcbiAgICAgICAgLy8gVE9ETzogaWYgd2UncmUgYWxyZWFkeSBcImNvbm5lY3RlZFwiLCB3ZSBuZWVkIHRvIHRyaWdnZXIgYSBkaXNjb25uZWN0IGF0IHRoZSBuZXh0IGxheWVyIHVwLlxyXG4gICAgICAgIC8vIFdlIGRvbid0IGN1cnJlbnRseSBzdXBwb3J0IHJlc2V0cyBhZnRlciB0aGUgY29ubmVjdGlvbiBoYXMgYWxyZWFkeSBiZWVuIGVzdGFibGlzaGVkXHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVfID09PSAxIC8qIFJlYWx0aW1lU3RhdGUuQ09OTkVDVEVEICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIENsb3NlIHdoYXRldmVyIGNvbm5lY3Rpb25zIHdlIGhhdmUgb3BlbiBhbmQgc3RhcnQgYWdhaW4uXHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VDb25uZWN0aW9uc18oKTtcclxuICAgICAgICAgICAgdGhpcy5zdGFydF8oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZF8oY29ubiwgdGltZXN0YW1wKSB7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdSZWFsdGltZSBjb25uZWN0aW9uIGVzdGFibGlzaGVkLicpO1xyXG4gICAgICAgIHRoaXMuY29ubl8gPSBjb25uO1xyXG4gICAgICAgIHRoaXMuc3RhdGVfID0gMSAvKiBSZWFsdGltZVN0YXRlLkNPTk5FQ1RFRCAqLztcclxuICAgICAgICBpZiAodGhpcy5vblJlYWR5Xykge1xyXG4gICAgICAgICAgICB0aGlzLm9uUmVhZHlfKHRpbWVzdGFtcCwgdGhpcy5zZXNzaW9uSWQpO1xyXG4gICAgICAgICAgICB0aGlzLm9uUmVhZHlfID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgYWZ0ZXIgNSBzZWNvbmRzIHdlIGhhdmVuJ3Qgc2VudCBlbm91Z2ggcmVxdWVzdHMgdG8gdGhlIHNlcnZlciB0byBnZXQgdGhlIGNvbm5lY3Rpb24gaGVhbHRoeSxcclxuICAgICAgICAvLyBzZW5kIHNvbWUgcGluZ3MuXHJcbiAgICAgICAgaWYgKHRoaXMucHJpbWFyeVJlc3BvbnNlc1JlcXVpcmVkXyA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1ByaW1hcnkgY29ubmVjdGlvbiBpcyBoZWFsdGh5LicpO1xyXG4gICAgICAgICAgICB0aGlzLmlzSGVhbHRoeV8gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dE5vbkJsb2NraW5nKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFBpbmdPblByaW1hcnlJZk5lY2Vzc2FyeV8oKTtcclxuICAgICAgICAgICAgfSwgTWF0aC5mbG9vcihERUxBWV9CRUZPUkVfU0VORElOR19FWFRSQV9SRVFVRVNUUykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNlbmRQaW5nT25QcmltYXJ5SWZOZWNlc3NhcnlfKCkge1xyXG4gICAgICAgIC8vIElmIHRoZSBjb25uZWN0aW9uIGlzbid0IGNvbnNpZGVyZWQgaGVhbHRoeSB5ZXQsIHdlJ2xsIHNlbmQgYSBub29wIHBpbmcgcGFja2V0IHJlcXVlc3QuXHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSGVhbHRoeV8gJiYgdGhpcy5zdGF0ZV8gPT09IDEgLyogUmVhbHRpbWVTdGF0ZS5DT05ORUNURUQgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdzZW5kaW5nIHBpbmcgb24gcHJpbWFyeS4nKTtcclxuICAgICAgICAgICAgdGhpcy5zZW5kRGF0YV8oeyB0OiAnYycsIGQ6IHsgdDogUElORywgZDoge30gfSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvblNlY29uZGFyeUNvbm5lY3Rpb25Mb3N0XygpIHtcclxuICAgICAgICBjb25zdCBjb25uID0gdGhpcy5zZWNvbmRhcnlDb25uXztcclxuICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy50eF8gPT09IGNvbm4gfHwgdGhpcy5yeF8gPT09IGNvbm4pIHtcclxuICAgICAgICAgICAgLy8gd2UgYXJlIHJlbHlpbmcgb24gdGhpcyBjb25uZWN0aW9uIGFscmVhZHkgaW4gc29tZSBjYXBhY2l0eS4gVGhlcmVmb3JlLCBhIGZhaWx1cmUgaXMgcmVhbFxyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZXZlckNvbm5lY3RlZCAtIFdoZXRoZXIgb3Igbm90IHRoZSBjb25uZWN0aW9uIGV2ZXIgcmVhY2hlZCBhIHNlcnZlci4gVXNlZCB0byBkZXRlcm1pbmUgaWZcclxuICAgICAqIHdlIHNob3VsZCBmbHVzaCB0aGUgaG9zdCBjYWNoZVxyXG4gICAgICovXHJcbiAgICBvbkNvbm5lY3Rpb25Mb3N0XyhldmVyQ29ubmVjdGVkKSB7XHJcbiAgICAgICAgdGhpcy5jb25uXyA9IG51bGw7XHJcbiAgICAgICAgLy8gTk9URTogSUYgeW91J3JlIHNlZWluZyBhIEZpcmVmb3ggZXJyb3IgZm9yIHRoaXMgbGluZSwgSSB0aGluayBpdCBtaWdodCBiZSBiZWNhdXNlIGl0J3MgZ2V0dGluZ1xyXG4gICAgICAgIC8vIGNhbGxlZCBvbiB3aW5kb3cgY2xvc2UgYW5kIFJlYWx0aW1lU3RhdGUuQ09OTkVDVElORyBpcyBubyBsb25nZXIgZGVmaW5lZC4gIEp1c3QgYSBndWVzcy5cclxuICAgICAgICBpZiAoIWV2ZXJDb25uZWN0ZWQgJiYgdGhpcy5zdGF0ZV8gPT09IDAgLyogUmVhbHRpbWVTdGF0ZS5DT05ORUNUSU5HICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnUmVhbHRpbWUgY29ubmVjdGlvbiBmYWlsZWQuJyk7XHJcbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIGZhaWxlZCB0byBjb25uZWN0IGF0IGFsbCwgY2xlYXIgYW55IGNhY2hlZCBlbnRyeSBmb3IgdGhpcyBuYW1lc3BhY2UgaW4gY2FzZSB0aGUgbWFjaGluZSB3ZW50IGF3YXlcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVwb0luZm9fLmlzQ2FjaGVhYmxlSG9zdCgpKSB7XHJcbiAgICAgICAgICAgICAgICBQZXJzaXN0ZW50U3RvcmFnZS5yZW1vdmUoJ2hvc3Q6JyArIHRoaXMucmVwb0luZm9fLmhvc3QpO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGludGVybmFsIGhvc3QgdG8gd2hhdCB3ZSB3b3VsZCBzaG93IHRoZSB1c2VyLCBpLmUuIDxucz4uZmlyZWJhc2Vpby5jb21cclxuICAgICAgICAgICAgICAgIHRoaXMucmVwb0luZm9fLmludGVybmFsSG9zdCA9IHRoaXMucmVwb0luZm9fLmhvc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZV8gPT09IDEgLyogUmVhbHRpbWVTdGF0ZS5DT05ORUNURUQgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdSZWFsdGltZSBjb25uZWN0aW9uIGxvc3QuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgIH1cclxuICAgIG9uQ29ubmVjdGlvblNodXRkb3duXyhyZWFzb24pIHtcclxuICAgICAgICB0aGlzLmxvZ18oJ0Nvbm5lY3Rpb24gc2h1dGRvd24gY29tbWFuZCByZWNlaXZlZC4gU2h1dHRpbmcgZG93bi4uLicpO1xyXG4gICAgICAgIGlmICh0aGlzLm9uS2lsbF8pIHtcclxuICAgICAgICAgICAgdGhpcy5vbktpbGxfKHJlYXNvbik7XHJcbiAgICAgICAgICAgIHRoaXMub25LaWxsXyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3Qgd2FudCB0byBmaXJlIG9uRGlzY29ubmVjdCAoa2lsbCBpcyBhIGRpZmZlcmVudCBjYXNlKSxcclxuICAgICAgICAvLyBzbyBjbGVhciB0aGUgY2FsbGJhY2suXHJcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICB9XHJcbiAgICBzZW5kRGF0YV8oZGF0YSkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlXyAhPT0gMSAvKiBSZWFsdGltZVN0YXRlLkNPTk5FQ1RFRCAqLykge1xyXG4gICAgICAgICAgICB0aHJvdyAnQ29ubmVjdGlvbiBpcyBub3QgY29ubmVjdGVkJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudHhfLnNlbmQoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhbnMgdXAgdGhpcyBjb25uZWN0aW9uLCBjYWxsaW5nIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3NcclxuICAgICAqL1xyXG4gICAgY2xvc2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVfICE9PSAyIC8qIFJlYWx0aW1lU3RhdGUuRElTQ09OTkVDVEVEICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnQ2xvc2luZyByZWFsdGltZSBjb25uZWN0aW9uLicpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlXyA9IDIgLyogUmVhbHRpbWVTdGF0ZS5ESVNDT05ORUNURUQgKi87XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VDb25uZWN0aW9uc18oKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub25EaXNjb25uZWN0Xykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xvc2VDb25uZWN0aW9uc18oKSB7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdTaHV0dGluZyBkb3duIGFsbCBjb25uZWN0aW9ucycpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5fKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubl8uY2xvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5jb25uXyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNlY29uZGFyeUNvbm5fKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8uY2xvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmhlYWx0aHlUaW1lb3V0Xykge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5oZWFsdGh5VGltZW91dF8pO1xyXG4gICAgICAgICAgICB0aGlzLmhlYWx0aHlUaW1lb3V0XyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBJbnRlcmZhY2UgZGVmaW5pbmcgdGhlIHNldCBvZiBhY3Rpb25zIHRoYXQgY2FuIGJlIHBlcmZvcm1lZCBhZ2FpbnN0IHRoZSBGaXJlYmFzZSBzZXJ2ZXJcclxuICogKGJhc2ljYWxseSBjb3JyZXNwb25kcyB0byBvdXIgd2lyZSBwcm90b2NvbCkuXHJcbiAqXHJcbiAqIEBpbnRlcmZhY2VcclxuICovXHJcbmNsYXNzIFNlcnZlckFjdGlvbnMge1xyXG4gICAgcHV0KHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpIHsgfVxyXG4gICAgbWVyZ2UocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCkgeyB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZnJlc2hlcyB0aGUgYXV0aCB0b2tlbiBmb3IgdGhlIGN1cnJlbnQgY29ubmVjdGlvbi5cclxuICAgICAqIEBwYXJhbSB0b2tlbiAtIFRoZSBhdXRoZW50aWNhdGlvbiB0b2tlblxyXG4gICAgICovXHJcbiAgICByZWZyZXNoQXV0aFRva2VuKHRva2VuKSB7IH1cclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaGVzIHRoZSBhcHAgY2hlY2sgdG9rZW4gZm9yIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gdG9rZW4gVGhlIGFwcCBjaGVjayB0b2tlblxyXG4gICAgICovXHJcbiAgICByZWZyZXNoQXBwQ2hlY2tUb2tlbih0b2tlbikgeyB9XHJcbiAgICBvbkRpc2Nvbm5lY3RQdXQocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSkgeyB9XHJcbiAgICBvbkRpc2Nvbm5lY3RNZXJnZShwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKSB7IH1cclxuICAgIG9uRGlzY29ubmVjdENhbmNlbChwYXRoU3RyaW5nLCBvbkNvbXBsZXRlKSB7IH1cclxuICAgIHJlcG9ydFN0YXRzKHN0YXRzKSB7IH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQmFzZSBjbGFzcyB0byBiZSB1c2VkIGlmIHlvdSB3YW50IHRvIGVtaXQgZXZlbnRzLiBDYWxsIHRoZSBjb25zdHJ1Y3RvciB3aXRoXHJcbiAqIHRoZSBzZXQgb2YgYWxsb3dlZCBldmVudCBuYW1lcy5cclxuICovXHJcbmNsYXNzIEV2ZW50RW1pdHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhbGxvd2VkRXZlbnRzXykge1xyXG4gICAgICAgIHRoaXMuYWxsb3dlZEV2ZW50c18gPSBhbGxvd2VkRXZlbnRzXztcclxuICAgICAgICB0aGlzLmxpc3RlbmVyc18gPSB7fTtcclxuICAgICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShhbGxvd2VkRXZlbnRzXykgJiYgYWxsb3dlZEV2ZW50c18ubGVuZ3RoID4gMCwgJ1JlcXVpcmVzIGEgbm9uLWVtcHR5IGFycmF5Jyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRvIGJlIGNhbGxlZCBieSBkZXJpdmVkIGNsYXNzZXMgdG8gdHJpZ2dlciBldmVudHMuXHJcbiAgICAgKi9cclxuICAgIHRyaWdnZXIoZXZlbnRUeXBlLCAuLi52YXJBcmdzKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5saXN0ZW5lcnNfW2V2ZW50VHlwZV0pKSB7XHJcbiAgICAgICAgICAgIC8vIENsb25lIHRoZSBsaXN0LCBzaW5jZSBjYWxsYmFja3MgY291bGQgYWRkL3JlbW92ZSBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IFsuLi50aGlzLmxpc3RlbmVyc19bZXZlbnRUeXBlXV07XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0uY2FsbGJhY2suYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIHZhckFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb24oZXZlbnRUeXBlLCBjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMudmFsaWRhdGVFdmVudFR5cGVfKGV2ZW50VHlwZSk7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNfW2V2ZW50VHlwZV0gPSB0aGlzLmxpc3RlbmVyc19bZXZlbnRUeXBlXSB8fCBbXTtcclxuICAgICAgICB0aGlzLmxpc3RlbmVyc19bZXZlbnRUeXBlXS5wdXNoKHsgY2FsbGJhY2ssIGNvbnRleHQgfSk7XHJcbiAgICAgICAgY29uc3QgZXZlbnREYXRhID0gdGhpcy5nZXRJbml0aWFsRXZlbnQoZXZlbnRUeXBlKTtcclxuICAgICAgICBpZiAoZXZlbnREYXRhKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KGNvbnRleHQsIGV2ZW50RGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb2ZmKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLnZhbGlkYXRlRXZlbnRUeXBlXyhldmVudFR5cGUpO1xyXG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzX1tldmVudFR5cGVdIHx8IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uY2FsbGJhY2sgPT09IGNhbGxiYWNrICYmXHJcbiAgICAgICAgICAgICAgICAoIWNvbnRleHQgfHwgY29udGV4dCA9PT0gbGlzdGVuZXJzW2ldLmNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFsaWRhdGVFdmVudFR5cGVfKGV2ZW50VHlwZSkge1xyXG4gICAgICAgIGFzc2VydCh0aGlzLmFsbG93ZWRFdmVudHNfLmZpbmQoZXQgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gZXQgPT09IGV2ZW50VHlwZTtcclxuICAgICAgICB9KSwgJ1Vua25vd24gZXZlbnQ6ICcgKyBldmVudFR5cGUpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBNb25pdG9ycyBvbmxpbmUgc3RhdGUgKGFzIHJlcG9ydGVkIGJ5IHdpbmRvdy5vbmxpbmUvb2ZmbGluZSBldmVudHMpLlxyXG4gKlxyXG4gKiBUaGUgZXhwZWN0YXRpb24gaXMgdGhhdCB0aGlzIGNvdWxkIGhhdmUgbWFueSBmYWxzZSBwb3NpdGl2ZXMgKHRoaW5rcyB3ZSBhcmUgb25saW5lXHJcbiAqIHdoZW4gd2UncmUgbm90KSwgYnV0IG5vIGZhbHNlIG5lZ2F0aXZlcy4gIFNvIHdlIGNhbiBzYWZlbHkgdXNlIGl0IHRvIGRldGVybWluZSB3aGVuXHJcbiAqIHdlIGRlZmluaXRlbHkgY2Fubm90IHJlYWNoIHRoZSBpbnRlcm5ldC5cclxuICovXHJcbmNsYXNzIE9ubGluZU1vbml0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoWydvbmxpbmUnXSk7XHJcbiAgICAgICAgdGhpcy5vbmxpbmVfID0gdHJ1ZTtcclxuICAgICAgICAvLyBXZSd2ZSBoYWQgcmVwZWF0ZWQgY29tcGxhaW50cyB0aGF0IENvcmRvdmEgYXBwcyBjYW4gZ2V0IHN0dWNrIFwib2ZmbGluZVwiLCBlLmcuXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9mb3J1bS5pb25pY2ZyYW1ld29yay5jb20vdC9maXJlYmFzZS1jb25uZWN0aW9uLWlzLWxvc3QtYW5kLW5ldmVyLWNvbWUtYmFjay80MzgxMFxyXG4gICAgICAgIC8vIEl0IHdvdWxkIHNlZW0gdGhhdCB0aGUgJ29ubGluZScgZXZlbnQgZG9lcyBub3QgYWx3YXlzIGZpcmUgY29uc2lzdGVudGx5LiBTbyB3ZSBkaXNhYmxlIGl0XHJcbiAgICAgICAgLy8gZm9yIENvcmRvdmEuXHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgIWlzTW9iaWxlQ29yZG92YSgpKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub25saW5lXykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25saW5lXyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdvbmxpbmUnLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9ubGluZV8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9ubGluZV8gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ29ubGluZScsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE9ubGluZU1vbml0b3IoKTtcclxuICAgIH1cclxuICAgIGdldEluaXRpYWxFdmVudChldmVudFR5cGUpIHtcclxuICAgICAgICBhc3NlcnQoZXZlbnRUeXBlID09PSAnb25saW5lJywgJ1Vua25vd24gZXZlbnQgdHlwZTogJyArIGV2ZW50VHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzLm9ubGluZV9dO1xyXG4gICAgfVxyXG4gICAgY3VycmVudGx5T25saW5lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9ubGluZV87XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIE1heGltdW0ga2V5IGRlcHRoLiAqL1xyXG5jb25zdCBNQVhfUEFUSF9ERVBUSCA9IDMyO1xyXG4vKiogTWF4aW11bSBudW1iZXIgb2YgKFVURjgpIGJ5dGVzIGluIGEgRmlyZWJhc2UgcGF0aC4gKi9cclxuY29uc3QgTUFYX1BBVEhfTEVOR1RIX0JZVEVTID0gNzY4O1xyXG4vKipcclxuICogQW4gaW1tdXRhYmxlIG9iamVjdCByZXByZXNlbnRpbmcgYSBwYXJzZWQgcGF0aC4gIEl0J3MgaW1tdXRhYmxlIHNvIHRoYXQgeW91XHJcbiAqIGNhbiBwYXNzIHRoZW0gYXJvdW5kIHRvIG90aGVyIGZ1bmN0aW9ucyB3aXRob3V0IHdvcnJ5aW5nIGFib3V0IHRoZW0gY2hhbmdpbmdcclxuICogaXQuXHJcbiAqL1xyXG5jbGFzcyBQYXRoIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHBhdGhPclN0cmluZyAtIFBhdGggc3RyaW5nIHRvIHBhcnNlLCBvciBhbm90aGVyIHBhdGgsIG9yIHRoZSByYXdcclxuICAgICAqIHRva2VucyBhcnJheVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXRoT3JTdHJpbmcsIHBpZWNlTnVtKSB7XHJcbiAgICAgICAgaWYgKHBpZWNlTnVtID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgdGhpcy5waWVjZXNfID0gcGF0aE9yU3RyaW5nLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBlbXB0eSBwaWVjZXMuXHJcbiAgICAgICAgICAgIGxldCBjb3B5VG8gPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGllY2VzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGllY2VzX1tpXS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5waWVjZXNfW2NvcHlUb10gPSB0aGlzLnBpZWNlc19baV07XHJcbiAgICAgICAgICAgICAgICAgICAgY29weVRvKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5waWVjZXNfLmxlbmd0aCA9IGNvcHlUbztcclxuICAgICAgICAgICAgdGhpcy5waWVjZU51bV8gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5waWVjZXNfID0gcGF0aE9yU3RyaW5nO1xyXG4gICAgICAgICAgICB0aGlzLnBpZWNlTnVtXyA9IHBpZWNlTnVtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIGxldCBwYXRoU3RyaW5nID0gJyc7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMucGllY2VOdW1fOyBpIDwgdGhpcy5waWVjZXNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBpZWNlc19baV0gIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoU3RyaW5nICs9ICcvJyArIHRoaXMucGllY2VzX1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGF0aFN0cmluZyB8fCAnLyc7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV3RW1wdHlQYXRoKCkge1xyXG4gICAgcmV0dXJuIG5ldyBQYXRoKCcnKTtcclxufVxyXG5mdW5jdGlvbiBwYXRoR2V0RnJvbnQocGF0aCkge1xyXG4gICAgaWYgKHBhdGgucGllY2VOdW1fID49IHBhdGgucGllY2VzXy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXRoLnBpZWNlc19bcGF0aC5waWVjZU51bV9dO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIGluIHRoaXMgcGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gcGF0aEdldExlbmd0aChwYXRoKSB7XHJcbiAgICByZXR1cm4gcGF0aC5waWVjZXNfLmxlbmd0aCAtIHBhdGgucGllY2VOdW1fO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhQb3BGcm9udChwYXRoKSB7XHJcbiAgICBsZXQgcGllY2VOdW0gPSBwYXRoLnBpZWNlTnVtXztcclxuICAgIGlmIChwaWVjZU51bSA8IHBhdGgucGllY2VzXy5sZW5ndGgpIHtcclxuICAgICAgICBwaWVjZU51bSsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBQYXRoKHBhdGgucGllY2VzXywgcGllY2VOdW0pO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhHZXRCYWNrKHBhdGgpIHtcclxuICAgIGlmIChwYXRoLnBpZWNlTnVtXyA8IHBhdGgucGllY2VzXy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gcGF0aC5waWVjZXNfW3BhdGgucGllY2VzXy5sZW5ndGggLSAxXTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhUb1VybEVuY29kZWRTdHJpbmcocGF0aCkge1xyXG4gICAgbGV0IHBhdGhTdHJpbmcgPSAnJztcclxuICAgIGZvciAobGV0IGkgPSBwYXRoLnBpZWNlTnVtXzsgaSA8IHBhdGgucGllY2VzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChwYXRoLnBpZWNlc19baV0gIT09ICcnKSB7XHJcbiAgICAgICAgICAgIHBhdGhTdHJpbmcgKz0gJy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhwYXRoLnBpZWNlc19baV0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF0aFN0cmluZyB8fCAnLyc7XHJcbn1cclxuLyoqXHJcbiAqIFNoYWxsb3cgY29weSBvZiB0aGUgcGFydHMgb2YgdGhlIHBhdGguXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXRoU2xpY2UocGF0aCwgYmVnaW4gPSAwKSB7XHJcbiAgICByZXR1cm4gcGF0aC5waWVjZXNfLnNsaWNlKHBhdGgucGllY2VOdW1fICsgYmVnaW4pO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhQYXJlbnQocGF0aCkge1xyXG4gICAgaWYgKHBhdGgucGllY2VOdW1fID49IHBhdGgucGllY2VzXy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IHBpZWNlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IHBhdGgucGllY2VOdW1fOyBpIDwgcGF0aC5waWVjZXNfLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgIHBpZWNlcy5wdXNoKHBhdGgucGllY2VzX1tpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFBhdGgocGllY2VzLCAwKTtcclxufVxyXG5mdW5jdGlvbiBwYXRoQ2hpbGQocGF0aCwgY2hpbGRQYXRoT2JqKSB7XHJcbiAgICBjb25zdCBwaWVjZXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSBwYXRoLnBpZWNlTnVtXzsgaSA8IHBhdGgucGllY2VzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHBpZWNlcy5wdXNoKHBhdGgucGllY2VzX1tpXSk7XHJcbiAgICB9XHJcbiAgICBpZiAoY2hpbGRQYXRoT2JqIGluc3RhbmNlb2YgUGF0aCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBjaGlsZFBhdGhPYmoucGllY2VOdW1fOyBpIDwgY2hpbGRQYXRoT2JqLnBpZWNlc18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcGllY2VzLnB1c2goY2hpbGRQYXRoT2JqLnBpZWNlc19baV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkUGllY2VzID0gY2hpbGRQYXRoT2JqLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZFBpZWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRQaWVjZXNbaV0ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcGllY2VzLnB1c2goY2hpbGRQaWVjZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBQYXRoKHBpZWNlcywgMCk7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlcmUgYXJlIG5vIHNlZ21lbnRzIGluIHRoaXMgcGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gcGF0aElzRW1wdHkocGF0aCkge1xyXG4gICAgcmV0dXJuIHBhdGgucGllY2VOdW1fID49IHBhdGgucGllY2VzXy5sZW5ndGg7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFRoZSBwYXRoIGZyb20gb3V0ZXJQYXRoIHRvIGlubmVyUGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gbmV3UmVsYXRpdmVQYXRoKG91dGVyUGF0aCwgaW5uZXJQYXRoKSB7XHJcbiAgICBjb25zdCBvdXRlciA9IHBhdGhHZXRGcm9udChvdXRlclBhdGgpLCBpbm5lciA9IHBhdGhHZXRGcm9udChpbm5lclBhdGgpO1xyXG4gICAgaWYgKG91dGVyID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGlubmVyUGF0aDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG91dGVyID09PSBpbm5lcikge1xyXG4gICAgICAgIHJldHVybiBuZXdSZWxhdGl2ZVBhdGgocGF0aFBvcEZyb250KG91dGVyUGF0aCksIHBhdGhQb3BGcm9udChpbm5lclBhdGgpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSU5URVJOQUwgRVJST1I6IGlubmVyUGF0aCAoJyArXHJcbiAgICAgICAgICAgIGlubmVyUGF0aCArXHJcbiAgICAgICAgICAgICcpIGlzIG5vdCB3aXRoaW4gJyArXHJcbiAgICAgICAgICAgICdvdXRlclBhdGggKCcgK1xyXG4gICAgICAgICAgICBvdXRlclBhdGggK1xyXG4gICAgICAgICAgICAnKScpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyAtMSwgMCwgMSBpZiBsZWZ0IGlzIGxlc3MsIGVxdWFsLCBvciBncmVhdGVyIHRoYW4gdGhlIHJpZ2h0LlxyXG4gKi9cclxuZnVuY3Rpb24gcGF0aENvbXBhcmUobGVmdCwgcmlnaHQpIHtcclxuICAgIGNvbnN0IGxlZnRLZXlzID0gcGF0aFNsaWNlKGxlZnQsIDApO1xyXG4gICAgY29uc3QgcmlnaHRLZXlzID0gcGF0aFNsaWNlKHJpZ2h0LCAwKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdEtleXMubGVuZ3RoICYmIGkgPCByaWdodEtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjbXAgPSBuYW1lQ29tcGFyZShsZWZ0S2V5c1tpXSwgcmlnaHRLZXlzW2ldKTtcclxuICAgICAgICBpZiAoY21wICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGxlZnRLZXlzLmxlbmd0aCA9PT0gcmlnaHRLZXlzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlZnRLZXlzLmxlbmd0aCA8IHJpZ2h0S2V5cy5sZW5ndGggPyAtMSA6IDE7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIHRydWUgaWYgcGF0aHMgYXJlIHRoZSBzYW1lLlxyXG4gKi9cclxuZnVuY3Rpb24gcGF0aEVxdWFscyhwYXRoLCBvdGhlcikge1xyXG4gICAgaWYgKHBhdGhHZXRMZW5ndGgocGF0aCkgIT09IHBhdGhHZXRMZW5ndGgob3RoZXIpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IHBhdGgucGllY2VOdW1fLCBqID0gb3RoZXIucGllY2VOdW1fOyBpIDw9IHBhdGgucGllY2VzXy5sZW5ndGg7IGkrKywgaisrKSB7XHJcbiAgICAgICAgaWYgKHBhdGgucGllY2VzX1tpXSAhPT0gb3RoZXIucGllY2VzX1tqXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhpcyBwYXRoIGlzIGEgcGFyZW50IG9mIChvciB0aGUgc2FtZSBhcykgb3RoZXJcclxuICovXHJcbmZ1bmN0aW9uIHBhdGhDb250YWlucyhwYXRoLCBvdGhlcikge1xyXG4gICAgbGV0IGkgPSBwYXRoLnBpZWNlTnVtXztcclxuICAgIGxldCBqID0gb3RoZXIucGllY2VOdW1fO1xyXG4gICAgaWYgKHBhdGhHZXRMZW5ndGgocGF0aCkgPiBwYXRoR2V0TGVuZ3RoKG90aGVyKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHdoaWxlIChpIDwgcGF0aC5waWVjZXNfLmxlbmd0aCkge1xyXG4gICAgICAgIGlmIChwYXRoLnBpZWNlc19baV0gIT09IG90aGVyLnBpZWNlc19bal0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICArK2k7XHJcbiAgICAgICAgKytqO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIER5bmFtaWMgKG11dGFibGUpIHBhdGggdXNlZCB0byBjb3VudCBwYXRoIGxlbmd0aHMuXHJcbiAqXHJcbiAqIFRoaXMgY2xhc3MgaXMgdXNlZCB0byBlZmZpY2llbnRseSBjaGVjayBwYXRocyBmb3IgdmFsaWRcclxuICogbGVuZ3RoIChpbiBVVEY4IGJ5dGVzKSBhbmQgZGVwdGggKHVzZWQgaW4gcGF0aCB2YWxpZGF0aW9uKS5cclxuICpcclxuICogVGhyb3dzIEVycm9yIGV4Y2VwdGlvbiBpZiBwYXRoIGlzIGV2ZXIgaW52YWxpZC5cclxuICpcclxuICogVGhlIGRlZmluaXRpb24gb2YgYSBwYXRoIGFsd2F5cyBiZWdpbnMgd2l0aCAnLycuXHJcbiAqL1xyXG5jbGFzcyBWYWxpZGF0aW9uUGF0aCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBwYXRoIC0gSW5pdGlhbCBQYXRoLlxyXG4gICAgICogQHBhcmFtIGVycm9yUHJlZml4XyAtIFByZWZpeCBmb3IgYW55IGVycm9yIG1lc3NhZ2VzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXRoLCBlcnJvclByZWZpeF8pIHtcclxuICAgICAgICB0aGlzLmVycm9yUHJlZml4XyA9IGVycm9yUHJlZml4XztcclxuICAgICAgICB0aGlzLnBhcnRzXyA9IHBhdGhTbGljZShwYXRoLCAwKTtcclxuICAgICAgICAvKiogSW5pdGlhbGl6ZSB0byBudW1iZXIgb2YgJy8nIGNoYXJzIG5lZWRlZCBpbiBwYXRoLiAqL1xyXG4gICAgICAgIHRoaXMuYnl0ZUxlbmd0aF8gPSBNYXRoLm1heCgxLCB0aGlzLnBhcnRzXy5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXJ0c18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoXyArPSBzdHJpbmdMZW5ndGgodGhpcy5wYXJ0c19baV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YWxpZGF0aW9uUGF0aENoZWNrVmFsaWQodGhpcyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGlvblBhdGhQdXNoKHZhbGlkYXRpb25QYXRoLCBjaGlsZCkge1xyXG4gICAgLy8gQ291bnQgdGhlIG5lZWRlZCAnLydcclxuICAgIGlmICh2YWxpZGF0aW9uUGF0aC5wYXJ0c18ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHZhbGlkYXRpb25QYXRoLmJ5dGVMZW5ndGhfICs9IDE7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0aW9uUGF0aC5wYXJ0c18ucHVzaChjaGlsZCk7XHJcbiAgICB2YWxpZGF0aW9uUGF0aC5ieXRlTGVuZ3RoXyArPSBzdHJpbmdMZW5ndGgoY2hpbGQpO1xyXG4gICAgdmFsaWRhdGlvblBhdGhDaGVja1ZhbGlkKHZhbGlkYXRpb25QYXRoKTtcclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0aW9uUGF0aFBvcCh2YWxpZGF0aW9uUGF0aCkge1xyXG4gICAgY29uc3QgbGFzdCA9IHZhbGlkYXRpb25QYXRoLnBhcnRzXy5wb3AoKTtcclxuICAgIHZhbGlkYXRpb25QYXRoLmJ5dGVMZW5ndGhfIC09IHN0cmluZ0xlbmd0aChsYXN0KTtcclxuICAgIC8vIFVuLWNvdW50IHRoZSBwcmV2aW91cyAnLydcclxuICAgIGlmICh2YWxpZGF0aW9uUGF0aC5wYXJ0c18ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHZhbGlkYXRpb25QYXRoLmJ5dGVMZW5ndGhfIC09IDE7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGlvblBhdGhDaGVja1ZhbGlkKHZhbGlkYXRpb25QYXRoKSB7XHJcbiAgICBpZiAodmFsaWRhdGlvblBhdGguYnl0ZUxlbmd0aF8gPiBNQVhfUEFUSF9MRU5HVEhfQllURVMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodmFsaWRhdGlvblBhdGguZXJyb3JQcmVmaXhfICtcclxuICAgICAgICAgICAgJ2hhcyBhIGtleSBwYXRoIGxvbmdlciB0aGFuICcgK1xyXG4gICAgICAgICAgICBNQVhfUEFUSF9MRU5HVEhfQllURVMgK1xyXG4gICAgICAgICAgICAnIGJ5dGVzICgnICtcclxuICAgICAgICAgICAgdmFsaWRhdGlvblBhdGguYnl0ZUxlbmd0aF8gK1xyXG4gICAgICAgICAgICAnKS4nKTtcclxuICAgIH1cclxuICAgIGlmICh2YWxpZGF0aW9uUGF0aC5wYXJ0c18ubGVuZ3RoID4gTUFYX1BBVEhfREVQVEgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodmFsaWRhdGlvblBhdGguZXJyb3JQcmVmaXhfICtcclxuICAgICAgICAgICAgJ3BhdGggc3BlY2lmaWVkIGV4Y2VlZHMgdGhlIG1heGltdW0gZGVwdGggdGhhdCBjYW4gYmUgd3JpdHRlbiAoJyArXHJcbiAgICAgICAgICAgIE1BWF9QQVRIX0RFUFRIICtcclxuICAgICAgICAgICAgJykgb3Igb2JqZWN0IGNvbnRhaW5zIGEgY3ljbGUgJyArXHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25QYXRoVG9FcnJvclN0cmluZyh2YWxpZGF0aW9uUGF0aCkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTdHJpbmcgZm9yIHVzZSBpbiBlcnJvciBtZXNzYWdlcyAtIHVzZXMgJy4nIG5vdGF0aW9uIGZvciBwYXRoLlxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGlvblBhdGhUb0Vycm9yU3RyaW5nKHZhbGlkYXRpb25QYXRoKSB7XHJcbiAgICBpZiAodmFsaWRhdGlvblBhdGgucGFydHNfLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuICAgIHJldHVybiBcImluIHByb3BlcnR5ICdcIiArIHZhbGlkYXRpb25QYXRoLnBhcnRzXy5qb2luKCcuJykgKyBcIidcIjtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBWaXNpYmlsaXR5TW9uaXRvciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihbJ3Zpc2libGUnXSk7XHJcbiAgICAgICAgbGV0IGhpZGRlbjtcclxuICAgICAgICBsZXQgdmlzaWJpbGl0eUNoYW5nZTtcclxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudFsnaGlkZGVuJ10gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPcGVyYSAxMi4xMCBhbmQgRmlyZWZveCAxOCBhbmQgbGF0ZXIgc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICd2aXNpYmlsaXR5Y2hhbmdlJztcclxuICAgICAgICAgICAgICAgIGhpZGRlbiA9ICdoaWRkZW4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudFsnbW96SGlkZGVuJ10gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ21venZpc2liaWxpdHljaGFuZ2UnO1xyXG4gICAgICAgICAgICAgICAgaGlkZGVuID0gJ21vekhpZGRlbic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50Wydtc0hpZGRlbiddICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICdtc3Zpc2liaWxpdHljaGFuZ2UnO1xyXG4gICAgICAgICAgICAgICAgaGlkZGVuID0gJ21zSGlkZGVuJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnRbJ3dlYmtpdEhpZGRlbiddICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICd3ZWJraXR2aXNpYmlsaXR5Y2hhbmdlJztcclxuICAgICAgICAgICAgICAgIGhpZGRlbiA9ICd3ZWJraXRIaWRkZW4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEluaXRpYWxseSwgd2UgYWx3YXlzIGFzc3VtZSB3ZSBhcmUgdmlzaWJsZS4gVGhpcyBlbnN1cmVzIHRoYXQgaW4gYnJvd3NlcnNcclxuICAgICAgICAvLyB3aXRob3V0IHBhZ2UgdmlzaWJpbGl0eSBzdXBwb3J0IG9yIGluIGNhc2VzIHdoZXJlIHdlIGFyZSBuZXZlciB2aXNpYmxlXHJcbiAgICAgICAgLy8gKGUuZy4gY2hyb21lIGV4dGVuc2lvbiksIHdlIGFjdCBhcyBpZiB3ZSBhcmUgdmlzaWJsZSwgaS5lLiBkb24ndCBkZWxheVxyXG4gICAgICAgIC8vIHJlY29ubmVjdHNcclxuICAgICAgICB0aGlzLnZpc2libGVfID0gdHJ1ZTtcclxuICAgICAgICBpZiAodmlzaWJpbGl0eUNoYW5nZSkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHZpc2liaWxpdHlDaGFuZ2UsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpc2libGUgPSAhZG9jdW1lbnRbaGlkZGVuXTtcclxuICAgICAgICAgICAgICAgIGlmICh2aXNpYmxlICE9PSB0aGlzLnZpc2libGVfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlXyA9IHZpc2libGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd2aXNpYmxlJywgdmlzaWJsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWaXNpYmlsaXR5TW9uaXRvcigpO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5pdGlhbEV2ZW50KGV2ZW50VHlwZSkge1xyXG4gICAgICAgIGFzc2VydChldmVudFR5cGUgPT09ICd2aXNpYmxlJywgJ1Vua25vd24gZXZlbnQgdHlwZTogJyArIGV2ZW50VHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzLnZpc2libGVfXTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBSRUNPTk5FQ1RfTUlOX0RFTEFZID0gMTAwMDtcclxuY29uc3QgUkVDT05ORUNUX01BWF9ERUxBWV9ERUZBVUxUID0gNjAgKiA1ICogMTAwMDsgLy8gNSBtaW51dGVzIGluIG1pbGxpc2Vjb25kcyAoQ2FzZTogMTg1OClcclxuY29uc3QgUkVDT05ORUNUX01BWF9ERUxBWV9GT1JfQURNSU5TID0gMzAgKiAxMDAwOyAvLyAzMCBzZWNvbmRzIGZvciBhZG1pbiBjbGllbnRzIChsaWtlbHkgdG8gYmUgYSBiYWNrZW5kIHNlcnZlcilcclxuY29uc3QgUkVDT05ORUNUX0RFTEFZX01VTFRJUExJRVIgPSAxLjM7XHJcbmNvbnN0IFJFQ09OTkVDVF9ERUxBWV9SRVNFVF9USU1FT1VUID0gMzAwMDA7IC8vIFJlc2V0IGRlbGF5IGJhY2sgdG8gTUlOX0RFTEFZIGFmdGVyIGJlaW5nIGNvbm5lY3RlZCBmb3IgMzBzZWMuXHJcbmNvbnN0IFNFUlZFUl9LSUxMX0lOVEVSUlVQVF9SRUFTT04gPSAnc2VydmVyX2tpbGwnO1xyXG4vLyBJZiBhdXRoIGZhaWxzIHJlcGVhdGVkbHksIHdlJ2xsIGFzc3VtZSBzb21ldGhpbmcgaXMgd3JvbmcgYW5kIGxvZyBhIHdhcm5pbmcgLyBiYWNrIG9mZi5cclxuY29uc3QgSU5WQUxJRF9UT0tFTl9USFJFU0hPTEQgPSAzO1xyXG4vKipcclxuICogRmlyZWJhc2UgY29ubmVjdGlvbi4gIEFic3RyYWN0cyB3aXJlIHByb3RvY29sIGFuZCBoYW5kbGVzIHJlY29ubmVjdGluZy5cclxuICpcclxuICogTk9URTogQWxsIEpTT04gb2JqZWN0cyBzZW50IHRvIHRoZSByZWFsdGltZSBjb25uZWN0aW9uIG11c3QgaGF2ZSBwcm9wZXJ0eSBuYW1lcyBlbmNsb3NlZFxyXG4gKiBpbiBxdW90ZXMgdG8gbWFrZSBzdXJlIHRoZSBjbG9zdXJlIGNvbXBpbGVyIGRvZXMgbm90IG1pbmlmeSB0aGVtLlxyXG4gKi9cclxuY2xhc3MgUGVyc2lzdGVudENvbm5lY3Rpb24gZXh0ZW5kcyBTZXJ2ZXJBY3Rpb25zIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHJlcG9JbmZvXyAtIERhdGEgYWJvdXQgdGhlIG5hbWVzcGFjZSB3ZSBhcmUgY29ubmVjdGluZyB0b1xyXG4gICAgICogQHBhcmFtIGFwcGxpY2F0aW9uSWRfIC0gVGhlIEZpcmViYXNlIEFwcCBJRCBmb3IgdGhpcyBwcm9qZWN0XHJcbiAgICAgKiBAcGFyYW0gb25EYXRhVXBkYXRlXyAtIEEgY2FsbGJhY2sgZm9yIG5ldyBkYXRhIGZyb20gdGhlIHNlcnZlclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihyZXBvSW5mb18sIGFwcGxpY2F0aW9uSWRfLCBvbkRhdGFVcGRhdGVfLCBvbkNvbm5lY3RTdGF0dXNfLCBvblNlcnZlckluZm9VcGRhdGVfLCBhdXRoVG9rZW5Qcm92aWRlcl8sIGFwcENoZWNrVG9rZW5Qcm92aWRlcl8sIGF1dGhPdmVycmlkZV8pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMucmVwb0luZm9fID0gcmVwb0luZm9fO1xyXG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25JZF8gPSBhcHBsaWNhdGlvbklkXztcclxuICAgICAgICB0aGlzLm9uRGF0YVVwZGF0ZV8gPSBvbkRhdGFVcGRhdGVfO1xyXG4gICAgICAgIHRoaXMub25Db25uZWN0U3RhdHVzXyA9IG9uQ29ubmVjdFN0YXR1c187XHJcbiAgICAgICAgdGhpcy5vblNlcnZlckluZm9VcGRhdGVfID0gb25TZXJ2ZXJJbmZvVXBkYXRlXztcclxuICAgICAgICB0aGlzLmF1dGhUb2tlblByb3ZpZGVyXyA9IGF1dGhUb2tlblByb3ZpZGVyXztcclxuICAgICAgICB0aGlzLmFwcENoZWNrVG9rZW5Qcm92aWRlcl8gPSBhcHBDaGVja1Rva2VuUHJvdmlkZXJfO1xyXG4gICAgICAgIHRoaXMuYXV0aE92ZXJyaWRlXyA9IGF1dGhPdmVycmlkZV87XHJcbiAgICAgICAgLy8gVXNlZCBmb3IgZGlhZ25vc3RpYyBsb2dnaW5nLlxyXG4gICAgICAgIHRoaXMuaWQgPSBQZXJzaXN0ZW50Q29ubmVjdGlvbi5uZXh0UGVyc2lzdGVudENvbm5lY3Rpb25JZF8rKztcclxuICAgICAgICB0aGlzLmxvZ18gPSBsb2dXcmFwcGVyKCdwOicgKyB0aGlzLmlkICsgJzonKTtcclxuICAgICAgICB0aGlzLmludGVycnVwdFJlYXNvbnNfID0ge307XHJcbiAgICAgICAgdGhpcy5saXN0ZW5zID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRzXyA9IFtdO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdHZXRzXyA9IFtdO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRDb3VudF8gPSAwO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdHZXRDb3VudF8gPSAwO1xyXG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01JTl9ERUxBWTtcclxuICAgICAgICB0aGlzLm1heFJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NQVhfREVMQVlfREVGQVVMVDtcclxuICAgICAgICB0aGlzLnNlY3VyaXR5RGVidWdDYWxsYmFja18gPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGFzdFNlc3Npb25JZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZpc2libGVfID0gZmFsc2U7XHJcbiAgICAgICAgLy8gQmVmb3JlIHdlIGdldCBjb25uZWN0ZWQsIHdlIGtlZXAgYSBxdWV1ZSBvZiBwZW5kaW5nIG1lc3NhZ2VzIHRvIHNlbmQuXHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0Q0JIYXNoXyA9IHt9O1xyXG4gICAgICAgIHRoaXMucmVxdWVzdE51bWJlcl8gPSAwO1xyXG4gICAgICAgIHRoaXMucmVhbHRpbWVfID0gbnVsbDtcclxuICAgICAgICB0aGlzLmF1dGhUb2tlbl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlbl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZm9yY2VUb2tlblJlZnJlc2hfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfID0gMDtcclxuICAgICAgICB0aGlzLmludmFsaWRBcHBDaGVja1Rva2VuQ291bnRfID0gMDtcclxuICAgICAgICB0aGlzLmZpcnN0Q29ubmVjdGlvbl8gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25BdHRlbXB0VGltZV8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25Fc3RhYmxpc2hlZFRpbWVfID0gbnVsbDtcclxuICAgICAgICBpZiAoYXV0aE92ZXJyaWRlXyAmJiAhaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRoIG92ZXJyaWRlIHNwZWNpZmllZCBpbiBvcHRpb25zLCBidXQgbm90IHN1cHBvcnRlZCBvbiBub24gTm9kZS5qcyBwbGF0Zm9ybXMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgVmlzaWJpbGl0eU1vbml0b3IuZ2V0SW5zdGFuY2UoKS5vbigndmlzaWJsZScsIHRoaXMub25WaXNpYmxlXywgdGhpcyk7XHJcbiAgICAgICAgaWYgKHJlcG9JbmZvXy5ob3N0LmluZGV4T2YoJ2ZibG9jYWwnKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgT25saW5lTW9uaXRvci5nZXRJbnN0YW5jZSgpLm9uKCdvbmxpbmUnLCB0aGlzLm9uT25saW5lXywgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VuZFJlcXVlc3QoYWN0aW9uLCBib2R5LCBvblJlc3BvbnNlKSB7XHJcbiAgICAgICAgY29uc3QgY3VyUmVxTnVtID0gKyt0aGlzLnJlcXVlc3ROdW1iZXJfO1xyXG4gICAgICAgIGNvbnN0IG1zZyA9IHsgcjogY3VyUmVxTnVtLCBhOiBhY3Rpb24sIGI6IGJvZHkgfTtcclxuICAgICAgICB0aGlzLmxvZ18oc3RyaW5naWZ5KG1zZykpO1xyXG4gICAgICAgIGFzc2VydCh0aGlzLmNvbm5lY3RlZF8sIFwic2VuZFJlcXVlc3QgY2FsbCB3aGVuIHdlJ3JlIG5vdCBjb25uZWN0ZWQgbm90IGFsbG93ZWQuXCIpO1xyXG4gICAgICAgIHRoaXMucmVhbHRpbWVfLnNlbmRSZXF1ZXN0KG1zZyk7XHJcbiAgICAgICAgaWYgKG9uUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0Q0JIYXNoX1tjdXJSZXFOdW1dID0gb25SZXNwb25zZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQocXVlcnkpIHtcclxuICAgICAgICB0aGlzLmluaXRDb25uZWN0aW9uXygpO1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgcDogcXVlcnkuX3BhdGgudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgcTogcXVlcnkuX3F1ZXJ5T2JqZWN0XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBvdXRzdGFuZGluZ0dldCA9IHtcclxuICAgICAgICAgICAgYWN0aW9uOiAnZycsXHJcbiAgICAgICAgICAgIHJlcXVlc3QsXHJcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gbWVzc2FnZVsnZCddO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VbJ3MnXSA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocGF5bG9hZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QocGF5bG9hZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdHZXRzXy5wdXNoKG91dHN0YW5kaW5nR2V0KTtcclxuICAgICAgICB0aGlzLm91dHN0YW5kaW5nR2V0Q291bnRfKys7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm91dHN0YW5kaW5nR2V0c18ubGVuZ3RoIC0gMTtcclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZEdldF8oaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxuICAgIH1cclxuICAgIGxpc3RlbihxdWVyeSwgY3VycmVudEhhc2hGbiwgdGFnLCBvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgdGhpcy5pbml0Q29ubmVjdGlvbl8oKTtcclxuICAgICAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgICAgICBjb25zdCBwYXRoU3RyaW5nID0gcXVlcnkuX3BhdGgudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmxvZ18oJ0xpc3RlbiBjYWxsZWQgZm9yICcgKyBwYXRoU3RyaW5nICsgJyAnICsgcXVlcnlJZCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmxpc3RlbnMuaGFzKHBhdGhTdHJpbmcpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdGVucy5zZXQocGF0aFN0cmluZywgbmV3IE1hcCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0KHF1ZXJ5Ll9xdWVyeVBhcmFtcy5pc0RlZmF1bHQoKSB8fCAhcXVlcnkuX3F1ZXJ5UGFyYW1zLmxvYWRzQWxsRGF0YSgpLCAnbGlzdGVuKCkgY2FsbGVkIGZvciBub24tZGVmYXVsdCBidXQgY29tcGxldGUgcXVlcnknKTtcclxuICAgICAgICBhc3NlcnQoIXRoaXMubGlzdGVucy5nZXQocGF0aFN0cmluZykuaGFzKHF1ZXJ5SWQpLCBgbGlzdGVuKCkgY2FsbGVkIHR3aWNlIGZvciBzYW1lIHBhdGgvcXVlcnlJZC5gKTtcclxuICAgICAgICBjb25zdCBsaXN0ZW5TcGVjID0ge1xyXG4gICAgICAgICAgICBvbkNvbXBsZXRlLFxyXG4gICAgICAgICAgICBoYXNoRm46IGN1cnJlbnRIYXNoRm4sXHJcbiAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICB0YWdcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubGlzdGVucy5nZXQocGF0aFN0cmluZykuc2V0KHF1ZXJ5SWQsIGxpc3RlblNwZWMpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kTGlzdGVuXyhsaXN0ZW5TcGVjKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZW5kR2V0XyhpbmRleCkge1xyXG4gICAgICAgIGNvbnN0IGdldCA9IHRoaXMub3V0c3RhbmRpbmdHZXRzX1tpbmRleF07XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdCgnZycsIGdldC5yZXF1ZXN0LCAobWVzc2FnZSkgPT4ge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5vdXRzdGFuZGluZ0dldHNfW2luZGV4XTtcclxuICAgICAgICAgICAgdGhpcy5vdXRzdGFuZGluZ0dldENvdW50Xy0tO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vdXRzdGFuZGluZ0dldENvdW50XyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vdXRzdGFuZGluZ0dldHNfID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGdldC5vbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICBnZXQub25Db21wbGV0ZShtZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2VuZExpc3Rlbl8obGlzdGVuU3BlYykge1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gbGlzdGVuU3BlYy5xdWVyeTtcclxuICAgICAgICBjb25zdCBwYXRoU3RyaW5nID0gcXVlcnkuX3BhdGgudG9TdHJpbmcoKTtcclxuICAgICAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgICAgICB0aGlzLmxvZ18oJ0xpc3RlbiBvbiAnICsgcGF0aFN0cmluZyArICcgZm9yICcgKyBxdWVyeUlkKTtcclxuICAgICAgICBjb25zdCByZXEgPSB7IC8qcGF0aCovIHA6IHBhdGhTdHJpbmcgfTtcclxuICAgICAgICBjb25zdCBhY3Rpb24gPSAncSc7XHJcbiAgICAgICAgLy8gT25seSBib3RoZXIgdG8gc2VuZCBxdWVyeSBpZiBpdCdzIG5vbi1kZWZhdWx0LlxyXG4gICAgICAgIGlmIChsaXN0ZW5TcGVjLnRhZykge1xyXG4gICAgICAgICAgICByZXFbJ3EnXSA9IHF1ZXJ5Ll9xdWVyeU9iamVjdDtcclxuICAgICAgICAgICAgcmVxWyd0J10gPSBsaXN0ZW5TcGVjLnRhZztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVxWyAvKmhhc2gqLydoJ10gPSBsaXN0ZW5TcGVjLmhhc2hGbigpO1xyXG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoYWN0aW9uLCByZXEsIChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBtZXNzYWdlWyAvKmRhdGEqLydkJ107XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IG1lc3NhZ2VbIC8qc3RhdHVzKi8ncyddO1xyXG4gICAgICAgICAgICAvLyBwcmludCB3YXJuaW5ncyBpbiBhbnkgY2FzZS4uLlxyXG4gICAgICAgICAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi53YXJuT25MaXN0ZW5XYXJuaW5nc18ocGF5bG9hZCwgcXVlcnkpO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TGlzdGVuU3BlYyA9IHRoaXMubGlzdGVucy5nZXQocGF0aFN0cmluZykgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVucy5nZXQocGF0aFN0cmluZykuZ2V0KHF1ZXJ5SWQpO1xyXG4gICAgICAgICAgICAvLyBvbmx5IHRyaWdnZXIgYWN0aW9ucyBpZiB0aGUgbGlzdGVuIGhhc24ndCBiZWVuIHJlbW92ZWQgYW5kIHJlYWRkZWRcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRMaXN0ZW5TcGVjID09PSBsaXN0ZW5TcGVjKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ2xpc3RlbiByZXNwb25zZScsIG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAhPT0gJ29rJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuXyhwYXRoU3RyaW5nLCBxdWVyeUlkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5TcGVjLm9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5TcGVjLm9uQ29tcGxldGUoc3RhdHVzLCBwYXlsb2FkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHdhcm5Pbkxpc3Rlbldhcm5pbmdzXyhwYXlsb2FkLCBxdWVyeSkge1xyXG4gICAgICAgIGlmIChwYXlsb2FkICYmIHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0JyAmJiBjb250YWlucyhwYXlsb2FkLCAndycpKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIGNvbnN0IHdhcm5pbmdzID0gc2FmZUdldChwYXlsb2FkLCAndycpO1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh3YXJuaW5ncykgJiYgfndhcm5pbmdzLmluZGV4T2YoJ25vX2luZGV4JykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4U3BlYyA9ICdcIi5pbmRleE9uXCI6IFwiJyArIHF1ZXJ5Ll9xdWVyeVBhcmFtcy5nZXRJbmRleCgpLnRvU3RyaW5nKCkgKyAnXCInO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhQYXRoID0gcXVlcnkuX3BhdGgudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIHdhcm4oYFVzaW5nIGFuIHVuc3BlY2lmaWVkIGluZGV4LiBZb3VyIGRhdGEgd2lsbCBiZSBkb3dubG9hZGVkIGFuZCBgICtcclxuICAgICAgICAgICAgICAgICAgICBgZmlsdGVyZWQgb24gdGhlIGNsaWVudC4gQ29uc2lkZXIgYWRkaW5nICR7aW5kZXhTcGVjfSBhdCBgICtcclxuICAgICAgICAgICAgICAgICAgICBgJHtpbmRleFBhdGh9IHRvIHlvdXIgc2VjdXJpdHkgcnVsZXMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlZnJlc2hBdXRoVG9rZW4odG9rZW4pIHtcclxuICAgICAgICB0aGlzLmF1dGhUb2tlbl8gPSB0b2tlbjtcclxuICAgICAgICB0aGlzLmxvZ18oJ0F1dGggdG9rZW4gcmVmcmVzaGVkJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuYXV0aFRva2VuXykge1xyXG4gICAgICAgICAgICB0aGlzLnRyeUF1dGgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vSWYgd2UncmUgY29ubmVjdGVkIHdlIHdhbnQgdG8gbGV0IHRoZSBzZXJ2ZXIga25vdyB0byB1bmF1dGhlbnRpY2F0ZSB1cy4gSWYgd2UncmUgbm90IGNvbm5lY3RlZCwgc2ltcGx5IGRlbGV0ZVxyXG4gICAgICAgICAgICAvL3RoZSBjcmVkZW50aWFsIHNvIHdlIGRvbnQgYmVjb21lIGF1dGhlbnRpY2F0ZWQgbmV4dCB0aW1lIHdlIGNvbm5lY3QuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoJ3VuYXV0aCcsIHt9LCAoKSA9PiB7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVkdWNlUmVjb25uZWN0RGVsYXlJZkFkbWluQ3JlZGVudGlhbF8odG9rZW4pO1xyXG4gICAgfVxyXG4gICAgcmVkdWNlUmVjb25uZWN0RGVsYXlJZkFkbWluQ3JlZGVudGlhbF8oY3JlZGVudGlhbCkge1xyXG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXNuJ3QgaW50ZW5kZWQgdG8gYmUgYnVsbGV0cHJvb2YgKGEgbWFsaWNpb3VzIGRldmVsb3BlciBjYW4gYWx3YXlzIGp1c3QgbW9kaWZ5IHRoZSBjbGllbnQpLlxyXG4gICAgICAgIC8vIEFkZGl0aW9uYWxseSwgd2UgZG9uJ3QgYm90aGVyIHJlc2V0dGluZyB0aGUgbWF4IGRlbGF5IGJhY2sgdG8gdGhlIGRlZmF1bHQgaWYgYXV0aCBmYWlscyAvIGV4cGlyZXMuXHJcbiAgICAgICAgY29uc3QgaXNGaXJlYmFzZVNlY3JldCA9IGNyZWRlbnRpYWwgJiYgY3JlZGVudGlhbC5sZW5ndGggPT09IDQwO1xyXG4gICAgICAgIGlmIChpc0ZpcmViYXNlU2VjcmV0IHx8IGlzQWRtaW4oY3JlZGVudGlhbCkpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdBZG1pbiBhdXRoIGNyZWRlbnRpYWwgZGV0ZWN0ZWQuICBSZWR1Y2luZyBtYXggcmVjb25uZWN0IHRpbWUuJyk7XHJcbiAgICAgICAgICAgIHRoaXMubWF4UmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01BWF9ERUxBWV9GT1JfQURNSU5TO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlZnJlc2hBcHBDaGVja1Rva2VuKHRva2VuKSB7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuXyA9IHRva2VuO1xyXG4gICAgICAgIHRoaXMubG9nXygnQXBwIGNoZWNrIHRva2VuIHJlZnJlc2hlZCcpO1xyXG4gICAgICAgIGlmICh0aGlzLmFwcENoZWNrVG9rZW5fKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJ5QXBwQ2hlY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vSWYgd2UncmUgY29ubmVjdGVkIHdlIHdhbnQgdG8gbGV0IHRoZSBzZXJ2ZXIga25vdyB0byB1bmF1dGhlbnRpY2F0ZSB1cy5cclxuICAgICAgICAgICAgLy9JZiB3ZSdyZSBub3QgY29ubmVjdGVkLCBzaW1wbHkgZGVsZXRlIHRoZSBjcmVkZW50aWFsIHNvIHdlIGRvbnQgYmVjb21lXHJcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0ZWQgbmV4dCB0aW1lIHdlIGNvbm5lY3QuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoJ3VuYXBwZWNrJywge30sICgpID0+IHsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEF0dGVtcHRzIHRvIGF1dGhlbnRpY2F0ZSB3aXRoIHRoZSBnaXZlbiBjcmVkZW50aWFscy4gSWYgdGhlIGF1dGhlbnRpY2F0aW9uIGF0dGVtcHQgZmFpbHMsIGl0J3MgdHJpZ2dlcmVkIGxpa2VcclxuICAgICAqIGEgYXV0aCByZXZva2VkICh0aGUgY29ubmVjdGlvbiBpcyBjbG9zZWQpLlxyXG4gICAgICovXHJcbiAgICB0cnlBdXRoKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8gJiYgdGhpcy5hdXRoVG9rZW5fKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5hdXRoVG9rZW5fO1xyXG4gICAgICAgICAgICBjb25zdCBhdXRoTWV0aG9kID0gaXNWYWxpZEZvcm1hdCh0b2tlbikgPyAnYXV0aCcgOiAnZ2F1dGgnO1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0RGF0YSA9IHsgY3JlZDogdG9rZW4gfTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYXV0aE92ZXJyaWRlXyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdERhdGFbJ25vYXV0aCddID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5hdXRoT3ZlcnJpZGVfID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdERhdGFbJ2F1dGh2YXInXSA9IHRoaXMuYXV0aE92ZXJyaWRlXztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KGF1dGhNZXRob2QsIHJlcXVlc3REYXRhLCAocmVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSByZXNbIC8qc3RhdHVzKi8ncyddO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHJlc1sgLypkYXRhKi8nZCddIHx8ICdlcnJvcic7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdXRoVG9rZW5fID09PSB0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyaWdnZXJzIHJlY29ubmVjdCBhbmQgZm9yY2UgcmVmcmVzaCBmb3IgYXV0aCB0b2tlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQXV0aFJldm9rZWRfKHN0YXR1cywgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEF0dGVtcHRzIHRvIGF1dGhlbnRpY2F0ZSB3aXRoIHRoZSBnaXZlbiB0b2tlbi4gSWYgdGhlIGF1dGhlbnRpY2F0aW9uXHJcbiAgICAgKiBhdHRlbXB0IGZhaWxzLCBpdCdzIHRyaWdnZXJlZCBsaWtlIHRoZSB0b2tlbiB3YXMgcmV2b2tlZCAodGhlIGNvbm5lY3Rpb24gaXNcclxuICAgICAqIGNsb3NlZCkuXHJcbiAgICAgKi9cclxuICAgIHRyeUFwcENoZWNrKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8gJiYgdGhpcy5hcHBDaGVja1Rva2VuXykge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KCdhcHBjaGVjaycsIHsgJ3Rva2VuJzogdGhpcy5hcHBDaGVja1Rva2VuXyB9LCAocmVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSByZXNbIC8qc3RhdHVzKi8ncyddO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHJlc1sgLypkYXRhKi8nZCddIHx8ICdlcnJvcic7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkQXBwQ2hlY2tUb2tlbkNvdW50XyA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQXBwQ2hlY2tSZXZva2VkXyhzdGF0dXMsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpbmhlcml0RG9jXHJcbiAgICAgKi9cclxuICAgIHVubGlzdGVuKHF1ZXJ5LCB0YWcpIHtcclxuICAgICAgICBjb25zdCBwYXRoU3RyaW5nID0gcXVlcnkuX3BhdGgudG9TdHJpbmcoKTtcclxuICAgICAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgICAgICB0aGlzLmxvZ18oJ1VubGlzdGVuIGNhbGxlZCBmb3IgJyArIHBhdGhTdHJpbmcgKyAnICcgKyBxdWVyeUlkKTtcclxuICAgICAgICBhc3NlcnQocXVlcnkuX3F1ZXJ5UGFyYW1zLmlzRGVmYXVsdCgpIHx8ICFxdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCksICd1bmxpc3RlbigpIGNhbGxlZCBmb3Igbm9uLWRlZmF1bHQgYnV0IGNvbXBsZXRlIHF1ZXJ5Jyk7XHJcbiAgICAgICAgY29uc3QgbGlzdGVuID0gdGhpcy5yZW1vdmVMaXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQpO1xyXG4gICAgICAgIGlmIChsaXN0ZW4gJiYgdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFVubGlzdGVuXyhwYXRoU3RyaW5nLCBxdWVyeUlkLCBxdWVyeS5fcXVlcnlPYmplY3QsIHRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VuZFVubGlzdGVuXyhwYXRoU3RyaW5nLCBxdWVyeUlkLCBxdWVyeU9iaiwgdGFnKSB7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdVbmxpc3RlbiBvbiAnICsgcGF0aFN0cmluZyArICcgZm9yICcgKyBxdWVyeUlkKTtcclxuICAgICAgICBjb25zdCByZXEgPSB7IC8qcGF0aCovIHA6IHBhdGhTdHJpbmcgfTtcclxuICAgICAgICBjb25zdCBhY3Rpb24gPSAnbic7XHJcbiAgICAgICAgLy8gT25seSBib3RoZXIgc2VuZGluZyBxdWVyeUlkIGlmIGl0J3Mgbm9uLWRlZmF1bHQuXHJcbiAgICAgICAgaWYgKHRhZykge1xyXG4gICAgICAgICAgICByZXFbJ3EnXSA9IHF1ZXJ5T2JqO1xyXG4gICAgICAgICAgICByZXFbJ3QnXSA9IHRhZztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChhY3Rpb24sIHJlcSk7XHJcbiAgICB9XHJcbiAgICBvbkRpc2Nvbm5lY3RQdXQocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSkge1xyXG4gICAgICAgIHRoaXMuaW5pdENvbm5lY3Rpb25fKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRPbkRpc2Nvbm5lY3RfKCdvJywgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdFJlcXVlc3RRdWV1ZV8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBwYXRoU3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnbycsXHJcbiAgICAgICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkRpc2Nvbm5lY3RNZXJnZShwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgdGhpcy5pbml0Q29ubmVjdGlvbl8oKTtcclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE9uRGlzY29ubmVjdF8oJ29tJywgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdFJlcXVlc3RRdWV1ZV8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBwYXRoU3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnb20nLFxyXG4gICAgICAgICAgICAgICAgZGF0YSxcclxuICAgICAgICAgICAgICAgIG9uQ29tcGxldGVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25EaXNjb25uZWN0Q2FuY2VsKHBhdGhTdHJpbmcsIG9uQ29tcGxldGUpIHtcclxuICAgICAgICB0aGlzLmluaXRDb25uZWN0aW9uXygpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kT25EaXNjb25uZWN0Xygnb2MnLCBwYXRoU3RyaW5nLCBudWxsLCBvbkNvbXBsZXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHBhdGhTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdvYycsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZW5kT25EaXNjb25uZWN0XyhhY3Rpb24sIHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0geyAvKnBhdGgqLyBwOiBwYXRoU3RyaW5nLCAvKmRhdGEqLyBkOiBkYXRhIH07XHJcbiAgICAgICAgdGhpcy5sb2dfKCdvbkRpc2Nvbm5lY3QgJyArIGFjdGlvbiwgcmVxdWVzdCk7XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChhY3Rpb24sIHJlcXVlc3QsIChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAob25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZShyZXNwb25zZVsgLypzdGF0dXMqLydzJ10sIHJlc3BvbnNlWyAvKiBkYXRhICovJ2QnXSk7XHJcbiAgICAgICAgICAgICAgICB9LCBNYXRoLmZsb29yKDApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcHV0KHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpIHtcclxuICAgICAgICB0aGlzLnB1dEludGVybmFsKCdwJywgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCk7XHJcbiAgICB9XHJcbiAgICBtZXJnZShwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKSB7XHJcbiAgICAgICAgdGhpcy5wdXRJbnRlcm5hbCgnbScsIHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpO1xyXG4gICAgfVxyXG4gICAgcHV0SW50ZXJuYWwoYWN0aW9uLCBwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKSB7XHJcbiAgICAgICAgdGhpcy5pbml0Q29ubmVjdGlvbl8oKTtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAvKnBhdGgqLyBwOiBwYXRoU3RyaW5nLFxyXG4gICAgICAgICAgICAvKmRhdGEqLyBkOiBkYXRhXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoaGFzaCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RbIC8qaGFzaCovJ2gnXSA9IGhhc2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IE9ubHkga2VlcCB0cmFjayBvZiB0aGUgbW9zdCByZWNlbnQgcHV0IGZvciBhIGdpdmVuIHBhdGg/XHJcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dHNfLnB1c2goe1xyXG4gICAgICAgICAgICBhY3Rpb24sXHJcbiAgICAgICAgICAgIHJlcXVlc3QsXHJcbiAgICAgICAgICAgIG9uQ29tcGxldGVcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0Q291bnRfKys7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm91dHN0YW5kaW5nUHV0c18ubGVuZ3RoIC0gMTtcclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFB1dF8oaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdCdWZmZXJpbmcgcHV0OiAnICsgcGF0aFN0cmluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VuZFB1dF8oaW5kZXgpIHtcclxuICAgICAgICBjb25zdCBhY3Rpb24gPSB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdLmFjdGlvbjtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5vdXRzdGFuZGluZ1B1dHNfW2luZGV4XS5yZXF1ZXN0O1xyXG4gICAgICAgIGNvbnN0IG9uQ29tcGxldGUgPSB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdLm9uQ29tcGxldGU7XHJcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dHNfW2luZGV4XS5xdWV1ZWQgPSB0aGlzLmNvbm5lY3RlZF87XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChhY3Rpb24sIHJlcXVlc3QsIChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXyhhY3Rpb24gKyAnIHJlc3BvbnNlJywgbWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdO1xyXG4gICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0Q291bnRfLS07XHJcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGFycmF5IG9jY2FzaW9uYWxseS5cclxuICAgICAgICAgICAgaWYgKHRoaXMub3V0c3RhbmRpbmdQdXRDb3VudF8gPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRzXyA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKG1lc3NhZ2VbIC8qc3RhdHVzKi8ncyddLCBtZXNzYWdlWyAvKiBkYXRhICovJ2QnXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlcG9ydFN0YXRzKHN0YXRzKSB7XHJcbiAgICAgICAgLy8gSWYgd2UncmUgbm90IGNvbm5lY3RlZCwgd2UganVzdCBkcm9wIHRoZSBzdGF0cy5cclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IC8qY291bnRlcnMqLyBjOiBzdGF0cyB9O1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ3JlcG9ydFN0YXRzJywgcmVxdWVzdCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoLypzdGF0cyovICdzJywgcmVxdWVzdCwgcmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc3VsdFsgLypzdGF0dXMqLydzJ107XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzICE9PSAnb2snKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JSZWFzb24gPSByZXN1bHRbIC8qIGRhdGEgKi8nZCddO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nXygncmVwb3J0U3RhdHMnLCAnRXJyb3Igc2VuZGluZyBzdGF0czogJyArIGVycm9yUmVhc29uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25EYXRhTWVzc2FnZV8obWVzc2FnZSkge1xyXG4gICAgICAgIGlmICgncicgaW4gbWVzc2FnZSkge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgcmVzcG9uc2VcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdmcm9tIHNlcnZlcjogJyArIHN0cmluZ2lmeShtZXNzYWdlKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcU51bSA9IG1lc3NhZ2VbJ3InXTtcclxuICAgICAgICAgICAgY29uc3Qgb25SZXNwb25zZSA9IHRoaXMucmVxdWVzdENCSGFzaF9bcmVxTnVtXTtcclxuICAgICAgICAgICAgaWYgKG9uUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlcXVlc3RDQkhhc2hfW3JlcU51bV07XHJcbiAgICAgICAgICAgICAgICBvblJlc3BvbnNlKG1lc3NhZ2VbIC8qYm9keSovJ2InXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ2Vycm9yJyBpbiBtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIHRocm93ICdBIHNlcnZlci1zaWRlIGVycm9yIGhhcyBvY2N1cnJlZDogJyArIG1lc3NhZ2VbJ2Vycm9yJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdhJyBpbiBtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIC8vIGEgYW5kIGIgYXJlIGFjdGlvbiBhbmQgYm9keSwgcmVzcGVjdGl2ZWx5XHJcbiAgICAgICAgICAgIHRoaXMub25EYXRhUHVzaF8obWVzc2FnZVsnYSddLCBtZXNzYWdlWydiJ10pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uRGF0YVB1c2hfKGFjdGlvbiwgYm9keSkge1xyXG4gICAgICAgIHRoaXMubG9nXygnaGFuZGxlU2VydmVyTWVzc2FnZScsIGFjdGlvbiwgYm9keSk7XHJcbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ2QnKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25EYXRhVXBkYXRlXyhib2R5WyAvKnBhdGgqLydwJ10sIGJvZHlbIC8qZGF0YSovJ2QnXSwgXHJcbiAgICAgICAgICAgIC8qaXNNZXJnZSovIGZhbHNlLCBib2R5Wyd0J10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdtJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uRGF0YVVwZGF0ZV8oYm9keVsgLypwYXRoKi8ncCddLCBib2R5WyAvKmRhdGEqLydkJ10sIFxyXG4gICAgICAgICAgICAvKmlzTWVyZ2U9Ki8gdHJ1ZSwgYm9keVsndCddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnYycpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkxpc3RlblJldm9rZWRfKGJvZHlbIC8qcGF0aCovJ3AnXSwgYm9keVsgLypxdWVyeSovJ3EnXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ2FjJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uQXV0aFJldm9rZWRfKGJvZHlbIC8qc3RhdHVzIGNvZGUqLydzJ10sIGJvZHlbIC8qIGV4cGxhbmF0aW9uICovJ2QnXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ2FwYycpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkFwcENoZWNrUmV2b2tlZF8oYm9keVsgLypzdGF0dXMgY29kZSovJ3MnXSwgYm9keVsgLyogZXhwbGFuYXRpb24gKi8nZCddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnc2QnKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25TZWN1cml0eURlYnVnUGFja2V0Xyhib2R5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVycm9yKCdVbnJlY29nbml6ZWQgYWN0aW9uIHJlY2VpdmVkIGZyb20gc2VydmVyOiAnICtcclxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShhY3Rpb24pICtcclxuICAgICAgICAgICAgICAgICdcXG5BcmUgeW91IHVzaW5nIHRoZSBsYXRlc3QgY2xpZW50PycpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uUmVhZHlfKHRpbWVzdGFtcCwgc2Vzc2lvbklkKSB7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdjb25uZWN0aW9uIHJlYWR5Jyk7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlVGltZXN0YW1wXyh0aW1lc3RhbXApO1xyXG4gICAgICAgIHRoaXMubGFzdFNlc3Npb25JZCA9IHNlc3Npb25JZDtcclxuICAgICAgICBpZiAodGhpcy5maXJzdENvbm5lY3Rpb25fKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZENvbm5lY3RTdGF0c18oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXN0b3JlU3RhdGVfKCk7XHJcbiAgICAgICAgdGhpcy5maXJzdENvbm5lY3Rpb25fID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5vbkNvbm5lY3RTdGF0dXNfKHRydWUpO1xyXG4gICAgfVxyXG4gICAgc2NoZWR1bGVDb25uZWN0Xyh0aW1lb3V0KSB7XHJcbiAgICAgICAgYXNzZXJ0KCF0aGlzLnJlYWx0aW1lXywgXCJTY2hlZHVsaW5nIGEgY29ubmVjdCB3aGVuIHdlJ3JlIGFscmVhZHkgY29ubmVjdGVkL2luZz9cIik7XHJcbiAgICAgICAgaWYgKHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXykge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTk9URTogRXZlbiB3aGVuIHRpbWVvdXQgaXMgMCwgaXQncyBpbXBvcnRhbnQgdG8gZG8gYSBzZXRUaW1lb3V0IHRvIHdvcmsgYXJvdW5kIGFuIGluZnVyaWF0aW5nIFwiU2VjdXJpdHkgRXJyb3JcIiBpblxyXG4gICAgICAgIC8vIEZpcmVmb3ggd2hlbiB0cnlpbmcgdG8gd3JpdGUgdG8gb3VyIGxvbmctcG9sbGluZyBpZnJhbWUgaW4gc29tZSBzY2VuYXJpb3MgKGUuZy4gRm9yZ2Ugb3Igb3VyIHVuaXQgdGVzdHMpLlxyXG4gICAgICAgIHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmVzdGFibGlzaENvbm5lY3Rpb25UaW1lcl8gPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmVzdGFibGlzaENvbm5lY3Rpb25fKCk7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgfSwgTWF0aC5mbG9vcih0aW1lb3V0KSk7XHJcbiAgICB9XHJcbiAgICBpbml0Q29ubmVjdGlvbl8oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJlYWx0aW1lXyAmJiB0aGlzLmZpcnN0Q29ubmVjdGlvbl8pIHtcclxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUNvbm5lY3RfKDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uVmlzaWJsZV8odmlzaWJsZSkge1xyXG4gICAgICAgIC8vIE5PVEU6IFRhYmJpbmcgYXdheSBhbmQgYmFjayB0byBhIHdpbmRvdyB3aWxsIGRlZmVhdCBvdXIgcmVjb25uZWN0IGJhY2tvZmYsIGJ1dCBJIHRoaW5rIHRoYXQncyBmaW5lLlxyXG4gICAgICAgIGlmICh2aXNpYmxlICYmXHJcbiAgICAgICAgICAgICF0aGlzLnZpc2libGVfICYmXHJcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID09PSB0aGlzLm1heFJlY29ubmVjdERlbGF5Xykge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1dpbmRvdyBiZWNhbWUgdmlzaWJsZS4gIFJlZHVjaW5nIGRlbGF5LicpO1xyXG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NSU5fREVMQVk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWFsdGltZV8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0XygwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZpc2libGVfID0gdmlzaWJsZTtcclxuICAgIH1cclxuICAgIG9uT25saW5lXyhvbmxpbmUpIHtcclxuICAgICAgICBpZiAob25saW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnQnJvd3NlciB3ZW50IG9ubGluZS4nKTtcclxuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUlOX0RFTEFZO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucmVhbHRpbWVfKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdF8oMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnQnJvd3NlciB3ZW50IG9mZmxpbmUuICBLaWxsaW5nIGNvbm5lY3Rpb24uJyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWx0aW1lXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZV8uY2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uUmVhbHRpbWVEaXNjb25uZWN0XygpIHtcclxuICAgICAgICB0aGlzLmxvZ18oJ2RhdGEgY2xpZW50IGRpc2Nvbm5lY3RlZCcpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucmVhbHRpbWVfID0gbnVsbDtcclxuICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCBrbm93IGlmIG91ciBzZW50IHRyYW5zYWN0aW9ucyBzdWNjZWVkZWQgb3Igbm90LCB3ZSBuZWVkIHRvIGNhbmNlbCB0aGVtLlxyXG4gICAgICAgIHRoaXMuY2FuY2VsU2VudFRyYW5zYWN0aW9uc18oKTtcclxuICAgICAgICAvLyBDbGVhciBvdXQgdGhlIHBlbmRpbmcgcmVxdWVzdHMuXHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0Q0JIYXNoXyA9IHt9O1xyXG4gICAgICAgIGlmICh0aGlzLnNob3VsZFJlY29ubmVjdF8oKSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudmlzaWJsZV8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXyhcIldpbmRvdyBpc24ndCB2aXNpYmxlLiAgRGVsYXlpbmcgcmVjb25uZWN0LlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gdGhpcy5tYXhSZWNvbm5lY3REZWxheV87XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0aW9uQXR0ZW1wdFRpbWVfID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sYXN0Q29ubmVjdGlvbkVzdGFibGlzaGVkVGltZV8pIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGJlZW4gY29ubmVjdGVkIGxvbmcgZW5vdWdoLCByZXNldCByZWNvbm5lY3QgZGVsYXkgdG8gbWluaW11bS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RDb25uZWN0U3VjY2VlZGVkID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXztcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lU2luY2VMYXN0Q29ubmVjdFN1Y2NlZWRlZCA+IFJFQ09OTkVDVF9ERUxBWV9SRVNFVF9USU1FT1VUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUlOX0RFTEFZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbkVzdGFibGlzaGVkVGltZV8gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RDb25uZWN0QXR0ZW1wdCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5sYXN0Q29ubmVjdGlvbkF0dGVtcHRUaW1lXztcclxuICAgICAgICAgICAgbGV0IHJlY29ubmVjdERlbGF5ID0gTWF0aC5tYXgoMCwgdGhpcy5yZWNvbm5lY3REZWxheV8gLSB0aW1lU2luY2VMYXN0Q29ubmVjdEF0dGVtcHQpO1xyXG4gICAgICAgICAgICByZWNvbm5lY3REZWxheSA9IE1hdGgucmFuZG9tKCkgKiByZWNvbm5lY3REZWxheTtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdUcnlpbmcgdG8gcmVjb25uZWN0IGluICcgKyByZWNvbm5lY3REZWxheSArICdtcycpO1xyXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdF8ocmVjb25uZWN0RGVsYXkpO1xyXG4gICAgICAgICAgICAvLyBBZGp1c3QgcmVjb25uZWN0IGRlbGF5IGZvciBuZXh0IHRpbWUuXHJcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gTWF0aC5taW4odGhpcy5tYXhSZWNvbm5lY3REZWxheV8sIHRoaXMucmVjb25uZWN0RGVsYXlfICogUkVDT05ORUNUX0RFTEFZX01VTFRJUExJRVIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9uQ29ubmVjdFN0YXR1c18oZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZXN0YWJsaXNoQ29ubmVjdGlvbl8oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkUmVjb25uZWN0XygpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnTWFraW5nIGEgY29ubmVjdGlvbiBhdHRlbXB0Jyk7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25BdHRlbXB0VGltZV8gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbkVzdGFibGlzaGVkVGltZV8gPSBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBvbkRhdGFNZXNzYWdlID0gdGhpcy5vbkRhdGFNZXNzYWdlXy5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICBjb25zdCBvblJlYWR5ID0gdGhpcy5vblJlYWR5Xy5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICBjb25zdCBvbkRpc2Nvbm5lY3QgPSB0aGlzLm9uUmVhbHRpbWVEaXNjb25uZWN0Xy5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICBjb25zdCBjb25uSWQgPSB0aGlzLmlkICsgJzonICsgUGVyc2lzdGVudENvbm5lY3Rpb24ubmV4dENvbm5lY3Rpb25JZF8rKztcclxuICAgICAgICAgICAgY29uc3QgbGFzdFNlc3Npb25JZCA9IHRoaXMubGFzdFNlc3Npb25JZDtcclxuICAgICAgICAgICAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBjb25uZWN0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgY29uc3QgY2xvc2VGbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIG9uRGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBzZW5kUmVxdWVzdEZuID0gZnVuY3Rpb24gKG1zZykge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGNvbm5lY3Rpb24sIFwic2VuZFJlcXVlc3QgY2FsbCB3aGVuIHdlJ3JlIG5vdCBjb25uZWN0ZWQgbm90IGFsbG93ZWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5zZW5kUmVxdWVzdChtc2cpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnJlYWx0aW1lXyA9IHtcclxuICAgICAgICAgICAgICAgIGNsb3NlOiBjbG9zZUZuLFxyXG4gICAgICAgICAgICAgICAgc2VuZFJlcXVlc3Q6IHNlbmRSZXF1ZXN0Rm5cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgZm9yY2VSZWZyZXNoID0gdGhpcy5mb3JjZVRva2VuUmVmcmVzaF87XHJcbiAgICAgICAgICAgIHRoaXMuZm9yY2VUb2tlblJlZnJlc2hfID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCBmZXRjaCBhdXRoIGFuZCBhcHAgY2hlY2sgdG9rZW4sIGFuZCBlc3RhYmxpc2ggY29ubmVjdGlvbiBhZnRlclxyXG4gICAgICAgICAgICAgICAgLy8gZmV0Y2hpbmcgdGhlIHRva2VuIHdhcyBzdWNjZXNzZnVsXHJcbiAgICAgICAgICAgICAgICBjb25zdCBbYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dGhUb2tlblByb3ZpZGVyXy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlblByb3ZpZGVyXy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2coJ2dldFRva2VuKCkgY29tcGxldGVkLiBDcmVhdGluZyBjb25uZWN0aW9uLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0aFRva2VuXyA9IGF1dGhUb2tlbiAmJiBhdXRoVG9rZW4uYWNjZXNzVG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuXyA9IGFwcENoZWNrVG9rZW4gJiYgYXBwQ2hlY2tUb2tlbi50b2tlbjtcclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uID0gbmV3IENvbm5lY3Rpb24oY29ubklkLCB0aGlzLnJlcG9JbmZvXywgdGhpcy5hcHBsaWNhdGlvbklkXywgdGhpcy5hcHBDaGVja1Rva2VuXywgdGhpcy5hdXRoVG9rZW5fLCBvbkRhdGFNZXNzYWdlLCBvblJlYWR5LCBvbkRpc2Nvbm5lY3QsIFxyXG4gICAgICAgICAgICAgICAgICAgIC8qIG9uS2lsbD0gKi8gcmVhc29uID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihyZWFzb24gKyAnICgnICsgdGhpcy5yZXBvSW5mb18udG9TdHJpbmcoKSArICcpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJydXB0KFNFUlZFUl9LSUxMX0lOVEVSUlVQVF9SRUFTT04pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGxhc3RTZXNzaW9uSWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nKCdnZXRUb2tlbigpIGNvbXBsZXRlZCBidXQgd2FzIGNhbmNlbGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ0ZhaWxlZCB0byBnZXQgdG9rZW46ICcgKyBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVwb0luZm9fLm5vZGVBZG1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG1heSBiZSBhIGNyaXRpY2FsIGVycm9yIGZvciB0aGUgQWRtaW4gTm9kZS5qcyBTREssIHNvIGxvZyBhIHdhcm5pbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBnZXRUb2tlbigpIG1heSBhbHNvIGp1c3QgaGF2ZSB0ZW1wb3JhcmlseSBmYWlsZWQsIHNvIHdlIHN0aWxsIHdhbnQgdG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWUgcmV0cnlpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjbG9zZUZuKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpbnRlcnJ1cHQocmVhc29uKSB7XHJcbiAgICAgICAgbG9nKCdJbnRlcnJ1cHRpbmcgY29ubmVjdGlvbiBmb3IgcmVhc29uOiAnICsgcmVhc29uKTtcclxuICAgICAgICB0aGlzLmludGVycnVwdFJlYXNvbnNfW3JlYXNvbl0gPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWx0aW1lXykge1xyXG4gICAgICAgICAgICB0aGlzLnJlYWx0aW1lXy5jbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXykge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVzdGFibGlzaENvbm5lY3Rpb25UaW1lcl8gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25SZWFsdGltZURpc2Nvbm5lY3RfKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXN1bWUocmVhc29uKSB7XHJcbiAgICAgICAgbG9nKCdSZXN1bWluZyBjb25uZWN0aW9uIGZvciByZWFzb246ICcgKyByZWFzb24pO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLmludGVycnVwdFJlYXNvbnNfW3JlYXNvbl07XHJcbiAgICAgICAgaWYgKGlzRW1wdHkodGhpcy5pbnRlcnJ1cHRSZWFzb25zXykpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUlOX0RFTEFZO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucmVhbHRpbWVfKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdF8oMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYW5kbGVUaW1lc3RhbXBfKHRpbWVzdGFtcCkge1xyXG4gICAgICAgIGNvbnN0IGRlbHRhID0gdGltZXN0YW1wIC0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgdGhpcy5vblNlcnZlckluZm9VcGRhdGVfKHsgc2VydmVyVGltZU9mZnNldDogZGVsdGEgfSk7XHJcbiAgICB9XHJcbiAgICBjYW5jZWxTZW50VHJhbnNhY3Rpb25zXygpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3V0c3RhbmRpbmdQdXRzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBwdXQgPSB0aGlzLm91dHN0YW5kaW5nUHV0c19baV07XHJcbiAgICAgICAgICAgIGlmIChwdXQgJiYgLypoYXNoKi8gJ2gnIGluIHB1dC5yZXF1ZXN0ICYmIHB1dC5xdWV1ZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwdXQub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHB1dC5vbkNvbXBsZXRlKCdkaXNjb25uZWN0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5vdXRzdGFuZGluZ1B1dHNfW2ldO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dENvdW50Xy0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENsZWFuIHVwIGFycmF5IG9jY2FzaW9uYWxseS5cclxuICAgICAgICBpZiAodGhpcy5vdXRzdGFuZGluZ1B1dENvdW50XyA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0c18gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkxpc3RlblJldm9rZWRfKHBhdGhTdHJpbmcsIHF1ZXJ5KSB7XHJcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBsaXN0ZW4gYW5kIG1hbnVmYWN0dXJlIGEgXCJwZXJtaXNzaW9uX2RlbmllZFwiIGVycm9yIGZvciB0aGUgZmFpbGVkIGxpc3Rlbi5cclxuICAgICAgICBsZXQgcXVlcnlJZDtcclxuICAgICAgICBpZiAoIXF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5SWQgPSAnZGVmYXVsdCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBxdWVyeUlkID0gcXVlcnkubWFwKHEgPT4gT2JqZWN0VG9VbmlxdWVLZXkocSkpLmpvaW4oJyQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGlzdGVuID0gdGhpcy5yZW1vdmVMaXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQpO1xyXG4gICAgICAgIGlmIChsaXN0ZW4gJiYgbGlzdGVuLm9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgbGlzdGVuLm9uQ29tcGxldGUoJ3Blcm1pc3Npb25fZGVuaWVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVtb3ZlTGlzdGVuXyhwYXRoU3RyaW5nLCBxdWVyeUlkKSB7XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFBhdGhTdHJpbmcgPSBuZXcgUGF0aChwYXRoU3RyaW5nKS50b1N0cmluZygpOyAvLyBub3JtYWxpemUgcGF0aC5cclxuICAgICAgICBsZXQgbGlzdGVuO1xyXG4gICAgICAgIGlmICh0aGlzLmxpc3RlbnMuaGFzKG5vcm1hbGl6ZWRQYXRoU3RyaW5nKSkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXAgPSB0aGlzLmxpc3RlbnMuZ2V0KG5vcm1hbGl6ZWRQYXRoU3RyaW5nKTtcclxuICAgICAgICAgICAgbGlzdGVuID0gbWFwLmdldChxdWVyeUlkKTtcclxuICAgICAgICAgICAgbWFwLmRlbGV0ZShxdWVyeUlkKTtcclxuICAgICAgICAgICAgaWYgKG1hcC5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbnMuZGVsZXRlKG5vcm1hbGl6ZWRQYXRoU3RyaW5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gYWxsIGxpc3RlbnMgZm9yIHRoaXMgcGF0aCBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWRcclxuICAgICAgICAgICAgbGlzdGVuID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGlzdGVuO1xyXG4gICAgfVxyXG4gICAgb25BdXRoUmV2b2tlZF8oc3RhdHVzQ29kZSwgZXhwbGFuYXRpb24pIHtcclxuICAgICAgICBsb2coJ0F1dGggdG9rZW4gcmV2b2tlZDogJyArIHN0YXR1c0NvZGUgKyAnLycgKyBleHBsYW5hdGlvbik7XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5fID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZvcmNlVG9rZW5SZWZyZXNoXyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5yZWFsdGltZV8uY2xvc2UoKTtcclxuICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gJ2ludmFsaWRfdG9rZW4nIHx8IHN0YXR1c0NvZGUgPT09ICdwZXJtaXNzaW9uX2RlbmllZCcpIHtcclxuICAgICAgICAgICAgLy8gV2UnbGwgd2FpdCBhIGNvdXBsZSB0aW1lcyBiZWZvcmUgbG9nZ2luZyB0aGUgd2FybmluZyAvIGluY3JlYXNpbmcgdGhlXHJcbiAgICAgICAgICAgIC8vIHJldHJ5IHBlcmlvZCBzaW5jZSBvYXV0aCB0b2tlbnMgd2lsbCByZXBvcnQgYXMgXCJpbnZhbGlkXCIgaWYgdGhleSdyZVxyXG4gICAgICAgICAgICAvLyBqdXN0IGV4cGlyZWQuIFBsdXMgdGhlcmUgbWF5IGJlIHRyYW5zaWVudCBpc3N1ZXMgdGhhdCByZXNvbHZlIHRoZW1zZWx2ZXMuXHJcbiAgICAgICAgICAgIHRoaXMuaW52YWxpZEF1dGhUb2tlbkNvdW50XysrO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfID49IElOVkFMSURfVE9LRU5fVEhSRVNIT0xEKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgYSBsb25nIHJlY29ubmVjdCBkZWxheSBiZWNhdXNlIHJlY292ZXJ5IGlzIHVubGlrZWx5XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NQVhfREVMQVlfRk9SX0FETUlOUztcclxuICAgICAgICAgICAgICAgIC8vIE5vdGlmeSB0aGUgYXV0aCB0b2tlbiBwcm92aWRlciB0aGF0IHRoZSB0b2tlbiBpcyBpbnZhbGlkLCB3aGljaCB3aWxsIGxvZ1xyXG4gICAgICAgICAgICAgICAgLy8gYSB3YXJuaW5nXHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1dGhUb2tlblByb3ZpZGVyXy5ub3RpZnlGb3JJbnZhbGlkVG9rZW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uQXBwQ2hlY2tSZXZva2VkXyhzdGF0dXNDb2RlLCBleHBsYW5hdGlvbikge1xyXG4gICAgICAgIGxvZygnQXBwIGNoZWNrIHRva2VuIHJldm9rZWQ6ICcgKyBzdGF0dXNDb2RlICsgJy8nICsgZXhwbGFuYXRpb24pO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlbl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZm9yY2VUb2tlblJlZnJlc2hfID0gdHJ1ZTtcclxuICAgICAgICAvLyBOb3RlOiBXZSBkb24ndCBjbG9zZSB0aGUgY29ubmVjdGlvbiBhcyB0aGUgZGV2ZWxvcGVyIG1heSBub3QgaGF2ZVxyXG4gICAgICAgIC8vIGVuZm9yY2VtZW50IGVuYWJsZWQuIFRoZSBiYWNrZW5kIGNsb3NlcyBjb25uZWN0aW9ucyB3aXRoIGVuZm9yY2VtZW50cy5cclxuICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gJ2ludmFsaWRfdG9rZW4nIHx8IHN0YXR1c0NvZGUgPT09ICdwZXJtaXNzaW9uX2RlbmllZCcpIHtcclxuICAgICAgICAgICAgLy8gV2UnbGwgd2FpdCBhIGNvdXBsZSB0aW1lcyBiZWZvcmUgbG9nZ2luZyB0aGUgd2FybmluZyAvIGluY3JlYXNpbmcgdGhlXHJcbiAgICAgICAgICAgIC8vIHJldHJ5IHBlcmlvZCBzaW5jZSBvYXV0aCB0b2tlbnMgd2lsbCByZXBvcnQgYXMgXCJpbnZhbGlkXCIgaWYgdGhleSdyZVxyXG4gICAgICAgICAgICAvLyBqdXN0IGV4cGlyZWQuIFBsdXMgdGhlcmUgbWF5IGJlIHRyYW5zaWVudCBpc3N1ZXMgdGhhdCByZXNvbHZlIHRoZW1zZWx2ZXMuXHJcbiAgICAgICAgICAgIHRoaXMuaW52YWxpZEFwcENoZWNrVG9rZW5Db3VudF8rKztcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW52YWxpZEFwcENoZWNrVG9rZW5Db3VudF8gPj0gSU5WQUxJRF9UT0tFTl9USFJFU0hPTEQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlblByb3ZpZGVyXy5ub3RpZnlGb3JJbnZhbGlkVG9rZW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uU2VjdXJpdHlEZWJ1Z1BhY2tldF8oYm9keSkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlY3VyaXR5RGVidWdDYWxsYmFja18pIHtcclxuICAgICAgICAgICAgdGhpcy5zZWN1cml0eURlYnVnQ2FsbGJhY2tfKGJvZHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCdtc2cnIGluIGJvZHkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGSVJFQkFTRTogJyArIGJvZHlbJ21zZyddLnJlcGxhY2UoJ1xcbicsICdcXG5GSVJFQkFTRTogJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVzdG9yZVN0YXRlXygpIHtcclxuICAgICAgICAvL1JlLWF1dGhlbnRpY2F0ZSBvdXJzZWx2ZXMgaWYgd2UgaGF2ZSBhIGNyZWRlbnRpYWwgc3RvcmVkLlxyXG4gICAgICAgIHRoaXMudHJ5QXV0aCgpO1xyXG4gICAgICAgIHRoaXMudHJ5QXBwQ2hlY2soKTtcclxuICAgICAgICAvLyBQdXRzIGRlcGVuZCBvbiBoYXZpbmcgcmVjZWl2ZWQgdGhlIGNvcnJlc3BvbmRpbmcgZGF0YSB1cGRhdGUgZnJvbSB0aGUgc2VydmVyIGJlZm9yZSB0aGV5IGNvbXBsZXRlLCBzbyB3ZSBtdXN0XHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHNlbmQgbGlzdGVucyBiZWZvcmUgcHV0cy5cclxuICAgICAgICBmb3IgKGNvbnN0IHF1ZXJpZXMgb2YgdGhpcy5saXN0ZW5zLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuU3BlYyBvZiBxdWVyaWVzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRMaXN0ZW5fKGxpc3RlblNwZWMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vdXRzdGFuZGluZ1B1dHNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHN0YW5kaW5nUHV0c19baV0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFB1dF8oaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXy5zaGlmdCgpO1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRPbkRpc2Nvbm5lY3RfKHJlcXVlc3QuYWN0aW9uLCByZXF1ZXN0LnBhdGhTdHJpbmcsIHJlcXVlc3QuZGF0YSwgcmVxdWVzdC5vbkNvbXBsZXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm91dHN0YW5kaW5nR2V0c18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3V0c3RhbmRpbmdHZXRzX1tpXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kR2V0XyhpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VuZHMgY2xpZW50IHN0YXRzIGZvciBmaXJzdCBjb25uZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHNlbmRDb25uZWN0U3RhdHNfKCkge1xyXG4gICAgICAgIGNvbnN0IHN0YXRzID0ge307XHJcbiAgICAgICAgbGV0IGNsaWVudE5hbWUgPSAnanMnO1xyXG4gICAgICAgIGlmIChpc05vZGVTZGsoKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yZXBvSW5mb18ubm9kZUFkbWluKSB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnROYW1lID0gJ2FkbWluX25vZGUnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2xpZW50TmFtZSA9ICdub2RlJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0c1snc2RrLicgKyBjbGllbnROYW1lICsgJy4nICsgU0RLX1ZFUlNJT04ucmVwbGFjZSgvXFwuL2csICctJyldID0gMTtcclxuICAgICAgICBpZiAoaXNNb2JpbGVDb3Jkb3ZhKCkpIHtcclxuICAgICAgICAgICAgc3RhdHNbJ2ZyYW1ld29yay5jb3Jkb3ZhJ10gPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcclxuICAgICAgICAgICAgc3RhdHNbJ2ZyYW1ld29yay5yZWFjdG5hdGl2ZSddID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXBvcnRTdGF0cyhzdGF0cyk7XHJcbiAgICB9XHJcbiAgICBzaG91bGRSZWNvbm5lY3RfKCkge1xyXG4gICAgICAgIGNvbnN0IG9ubGluZSA9IE9ubGluZU1vbml0b3IuZ2V0SW5zdGFuY2UoKS5jdXJyZW50bHlPbmxpbmUoKTtcclxuICAgICAgICByZXR1cm4gaXNFbXB0eSh0aGlzLmludGVycnVwdFJlYXNvbnNfKSAmJiBvbmxpbmU7XHJcbiAgICB9XHJcbn1cclxuUGVyc2lzdGVudENvbm5lY3Rpb24ubmV4dFBlcnNpc3RlbnRDb25uZWN0aW9uSWRfID0gMDtcclxuLyoqXHJcbiAqIENvdW50ZXIgZm9yIG51bWJlciBvZiBjb25uZWN0aW9ucyBjcmVhdGVkLiBNYWlubHkgdXNlZCBmb3IgdGFnZ2luZyBpbiB0aGUgbG9nc1xyXG4gKi9cclxuUGVyc2lzdGVudENvbm5lY3Rpb24ubmV4dENvbm5lY3Rpb25JZF8gPSAwO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBOYW1lZE5vZGUge1xyXG4gICAgY29uc3RydWN0b3IobmFtZSwgbm9kZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBXcmFwKG5hbWUsIG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShuYW1lLCBub2RlKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBJbmRleCB7XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIEEgc3RhbmRhbG9uZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvclxyXG4gICAgICogdGhpcyBpbmRleFxyXG4gICAgICovXHJcbiAgICBnZXRDb21wYXJlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUuYmluZCh0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSBiZWZvcmUgYW5kIGFmdGVyIHZhbHVlIGZvciBhIG5vZGUsIGRldGVybWluZSBpZiB0aGUgaW5kZXhlZCB2YWx1ZSBoYXMgY2hhbmdlZC4gRXZlbiBpZiB0aGV5IGFyZSBkaWZmZXJlbnQsXHJcbiAgICAgKiBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGNoYW5nZXMgYXJlIGlzb2xhdGVkIHRvIHBhcnRzIG9mIHRoZSBzbmFwc2hvdCB0aGF0IGFyZSBub3QgaW5kZXhlZC5cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgcG9ydGlvbiBvZiB0aGUgc25hcHNob3QgYmVpbmcgaW5kZXhlZCBjaGFuZ2VkIGJldHdlZW4gb2xkTm9kZSBhbmQgbmV3Tm9kZVxyXG4gICAgICovXHJcbiAgICBpbmRleGVkVmFsdWVDaGFuZ2VkKG9sZE5vZGUsIG5ld05vZGUpIHtcclxuICAgICAgICBjb25zdCBvbGRXcmFwcGVkID0gbmV3IE5hbWVkTm9kZShNSU5fTkFNRSwgb2xkTm9kZSk7XHJcbiAgICAgICAgY29uc3QgbmV3V3JhcHBlZCA9IG5ldyBOYW1lZE5vZGUoTUlOX05BTUUsIG5ld05vZGUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUob2xkV3JhcHBlZCwgbmV3V3JhcHBlZCkgIT09IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIGEgbm9kZSB3cmFwcGVyIHRoYXQgd2lsbCBzb3J0IGVxdWFsIHRvIG9yIGxlc3MgdGhhblxyXG4gICAgICogYW55IG90aGVyIG5vZGUgd3JhcHBlciwgdXNpbmcgdGhpcyBpbmRleFxyXG4gICAgICovXHJcbiAgICBtaW5Qb3N0KCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcmV0dXJuIE5hbWVkTm9kZS5NSU47XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IF9fRU1QVFlfTk9ERTtcclxuY2xhc3MgS2V5SW5kZXggZXh0ZW5kcyBJbmRleCB7XHJcbiAgICBzdGF0aWMgZ2V0IF9fRU1QVFlfTk9ERSgpIHtcclxuICAgICAgICByZXR1cm4gX19FTVBUWV9OT0RFO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHNldCBfX0VNUFRZX05PREUodmFsKSB7XHJcbiAgICAgICAgX19FTVBUWV9OT0RFID0gdmFsO1xyXG4gICAgfVxyXG4gICAgY29tcGFyZShhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIG5hbWVDb21wYXJlKGEubmFtZSwgYi5uYW1lKTtcclxuICAgIH1cclxuICAgIGlzRGVmaW5lZE9uKG5vZGUpIHtcclxuICAgICAgICAvLyBXZSBjb3VsZCBwcm9iYWJseSByZXR1cm4gdHJ1ZSBoZXJlIChzaW5jZSBldmVyeSBub2RlIGhhcyBhIGtleSksIGJ1dCBpdCdzIG5ldmVyIGNhbGxlZFxyXG4gICAgICAgIC8vIHNvIGp1c3QgbGVhdmluZyB1bmltcGxlbWVudGVkIGZvciBub3cuXHJcbiAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IoJ0tleUluZGV4LmlzRGVmaW5lZE9uIG5vdCBleHBlY3RlZCB0byBiZSBjYWxsZWQuJyk7XHJcbiAgICB9XHJcbiAgICBpbmRleGVkVmFsdWVDaGFuZ2VkKG9sZE5vZGUsIG5ld05vZGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFRoZSBrZXkgZm9yIGEgbm9kZSBuZXZlciBjaGFuZ2VzLlxyXG4gICAgfVxyXG4gICAgbWluUG9zdCgpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIHJldHVybiBOYW1lZE5vZGUuTUlOO1xyXG4gICAgfVxyXG4gICAgbWF4UG9zdCgpIHtcclxuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCByZWFsbHkgYmUgY3JlYXRlZCBvbmNlIGFuZCBjYWNoZWQgaW4gYSBzdGF0aWMgcHJvcGVydHksIGJ1dFxyXG4gICAgICAgIC8vIE5hbWVkTm9kZSBpc24ndCBkZWZpbmVkIHlldCwgc28gSSBjYW4ndCB1c2UgaXQgaW4gYSBzdGF0aWMuICBCbGVoLlxyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKE1BWF9OQU1FLCBfX0VNUFRZX05PREUpO1xyXG4gICAgfVxyXG4gICAgbWFrZVBvc3QoaW5kZXhWYWx1ZSwgbmFtZSkge1xyXG4gICAgICAgIGFzc2VydCh0eXBlb2YgaW5kZXhWYWx1ZSA9PT0gJ3N0cmluZycsICdLZXlJbmRleCBpbmRleFZhbHVlIG11c3QgYWx3YXlzIGJlIGEgc3RyaW5nLicpO1xyXG4gICAgICAgIC8vIFdlIGp1c3QgdXNlIGVtcHR5IG5vZGUsIGJ1dCBpdCdsbCBuZXZlciBiZSBjb21wYXJlZCwgc2luY2Ugb3VyIGNvbXBhcmF0b3Igb25seSBsb29rcyBhdCBuYW1lLlxyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKGluZGV4VmFsdWUsIF9fRU1QVFlfTk9ERSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFN0cmluZyByZXByZXNlbnRhdGlvbiBmb3IgaW5jbHVzaW9uIGluIGEgcXVlcnkgc3BlY1xyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gJy5rZXknO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IEtFWV9JTkRFWCA9IG5ldyBLZXlJbmRleCgpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaXRlcmF0b3Igb3ZlciBhbiBMTFJCTm9kZS5cclxuICovXHJcbmNsYXNzIFNvcnRlZE1hcEl0ZXJhdG9yIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIG5vZGUgLSBOb2RlIHRvIGl0ZXJhdGUuXHJcbiAgICAgKiBAcGFyYW0gaXNSZXZlcnNlXyAtIFdoZXRoZXIgb3Igbm90IHRvIGl0ZXJhdGUgaW4gcmV2ZXJzZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBzdGFydEtleSwgY29tcGFyYXRvciwgaXNSZXZlcnNlXywgcmVzdWx0R2VuZXJhdG9yXyA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLmlzUmV2ZXJzZV8gPSBpc1JldmVyc2VfO1xyXG4gICAgICAgIHRoaXMucmVzdWx0R2VuZXJhdG9yXyA9IHJlc3VsdEdlbmVyYXRvcl87XHJcbiAgICAgICAgdGhpcy5ub2RlU3RhY2tfID0gW107XHJcbiAgICAgICAgbGV0IGNtcCA9IDE7XHJcbiAgICAgICAgd2hpbGUgKCFub2RlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZTtcclxuICAgICAgICAgICAgY21wID0gc3RhcnRLZXkgPyBjb21wYXJhdG9yKG5vZGUua2V5LCBzdGFydEtleSkgOiAxO1xyXG4gICAgICAgICAgICAvLyBmbGlwIHRoZSBjb21wYXJpc29uIGlmIHdlJ3JlIGdvaW5nIGluIHJldmVyc2VcclxuICAgICAgICAgICAgaWYgKGlzUmV2ZXJzZV8pIHtcclxuICAgICAgICAgICAgICAgIGNtcCAqPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBub2RlIGlzIGxlc3MgdGhhbiBvdXIgc3RhcnQga2V5LiBpZ25vcmUgaXRcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUmV2ZXJzZV8pIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG5vZGUgaXMgZXhhY3RseSBlcXVhbCB0byBvdXIgc3RhcnQga2V5LiBQdXNoIGl0IG9uIHRoZSBzdGFjaywgYnV0IHN0b3AgaXRlcmF0aW5nO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2tfLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbm9kZSBpcyBncmVhdGVyIHRoYW4gb3VyIHN0YXJ0IGtleSwgYWRkIGl0IHRvIHRoZSBzdGFjayBhbmQgbW92ZSB0byB0aGUgbmV4dCBvbmVcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrXy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNSZXZlcnNlXykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldE5leHQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubm9kZVN0YWNrXy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5ub2RlU3RhY2tfLnBvcCgpO1xyXG4gICAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0R2VuZXJhdG9yXykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnJlc3VsdEdlbmVyYXRvcl8obm9kZS5rZXksIG5vZGUudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0geyBrZXk6IG5vZGUua2V5LCB2YWx1ZTogbm9kZS52YWx1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc1JldmVyc2VfKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrXy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdGFja18ucHVzaChub2RlKTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGhhc05leHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZVN0YWNrXy5sZW5ndGggPiAwO1xyXG4gICAgfVxyXG4gICAgcGVlaygpIHtcclxuICAgICAgICBpZiAodGhpcy5ub2RlU3RhY2tfLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZVN0YWNrX1t0aGlzLm5vZGVTdGFja18ubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0R2VuZXJhdG9yXykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRHZW5lcmF0b3JfKG5vZGUua2V5LCBub2RlLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGtleTogbm9kZS5rZXksIHZhbHVlOiBub2RlLnZhbHVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgbm9kZSBpbiBhIExlZnQtbGVhbmluZyBSZWQtQmxhY2sgdHJlZS5cclxuICovXHJcbmNsYXNzIExMUkJOb2RlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGtleSAtIEtleSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZS5cclxuICAgICAqIEBwYXJhbSBjb2xvciAtIFdoZXRoZXIgdGhpcyBub2RlIGlzIHJlZC5cclxuICAgICAqIEBwYXJhbSBsZWZ0IC0gTGVmdCBjaGlsZC5cclxuICAgICAqIEBwYXJhbSByaWdodCAtIFJpZ2h0IGNoaWxkLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlLCBjb2xvciwgbGVmdCwgcmlnaHQpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yICE9IG51bGwgPyBjb2xvciA6IExMUkJOb2RlLlJFRDtcclxuICAgICAgICB0aGlzLmxlZnQgPVxyXG4gICAgICAgICAgICBsZWZ0ICE9IG51bGwgPyBsZWZ0IDogU29ydGVkTWFwLkVNUFRZX05PREU7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9XHJcbiAgICAgICAgICAgIHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IFNvcnRlZE1hcC5FTVBUWV9OT0RFO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBub2RlLCBvcHRpb25hbGx5IHJlcGxhY2luZyBwaWVjZXMgb2YgaXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAtIE5ldyBrZXkgZm9yIHRoZSBub2RlLCBvciBudWxsLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gTmV3IHZhbHVlIGZvciB0aGUgbm9kZSwgb3IgbnVsbC5cclxuICAgICAqIEBwYXJhbSBjb2xvciAtIE5ldyBjb2xvciBmb3IgdGhlIG5vZGUsIG9yIG51bGwuXHJcbiAgICAgKiBAcGFyYW0gbGVmdCAtIE5ldyBsZWZ0IGNoaWxkIGZvciB0aGUgbm9kZSwgb3IgbnVsbC5cclxuICAgICAqIEBwYXJhbSByaWdodCAtIE5ldyByaWdodCBjaGlsZCBmb3IgdGhlIG5vZGUsIG9yIG51bGwuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbm9kZSBjb3B5LlxyXG4gICAgICovXHJcbiAgICBjb3B5KGtleSwgdmFsdWUsIGNvbG9yLCBsZWZ0LCByaWdodCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5ICE9IG51bGwgPyBrZXkgOiB0aGlzLmtleSwgdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogdGhpcy52YWx1ZSwgY29sb3IgIT0gbnVsbCA/IGNvbG9yIDogdGhpcy5jb2xvciwgbGVmdCAhPSBudWxsID8gbGVmdCA6IHRoaXMubGVmdCwgcmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogdGhpcy5yaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSB0b3RhbCBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlIHRyZWUuXHJcbiAgICAgKi9cclxuICAgIGNvdW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQuY291bnQoKSArIDEgKyB0aGlzLnJpZ2h0LmNvdW50KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHRyZWUgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIHRyZWUgaW4ga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxyXG4gICAgICogZm9yIGVhY2ggbm9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWN0aW9uIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBlYWNoXHJcbiAgICAgKiAgIG5vZGUuICBJZiBpdCByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgICogQHJldHVybnMgVGhlIGZpcnN0IHRydXRoeSB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24sIG9yIHRoZSBsYXN0IGZhbHNleVxyXG4gICAgICogICB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb25cclxuICAgICAqL1xyXG4gICAgaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMubGVmdC5pbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikgfHxcclxuICAgICAgICAgICAgISFhY3Rpb24odGhpcy5rZXksIHRoaXMudmFsdWUpIHx8XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHQuaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIHRoZSB0cmVlIGluIHJldmVyc2Uga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxyXG4gICAgICogZm9yIGVhY2ggbm9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWN0aW9uIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBlYWNoXHJcbiAgICAgKiBub2RlLiAgSWYgaXQgcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdHJhdmVyc2FsIHdhcyBhYm9ydGVkLlxyXG4gICAgICovXHJcbiAgICByZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5yaWdodC5yZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikgfHxcclxuICAgICAgICAgICAgYWN0aW9uKHRoaXMua2V5LCB0aGlzLnZhbHVlKSB8fFxyXG4gICAgICAgICAgICB0aGlzLmxlZnQucmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIG1pbmltdW0gbm9kZSBpbiB0aGUgdHJlZS5cclxuICAgICAqL1xyXG4gICAgbWluXygpIHtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQubWluXygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIG1heGltdW0ga2V5IGluIHRoZSB0cmVlLlxyXG4gICAgICovXHJcbiAgICBtaW5LZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWluXygpLmtleTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIG1heGltdW0ga2V5IGluIHRoZSB0cmVlLlxyXG4gICAgICovXHJcbiAgICBtYXhLZXkoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmtleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0Lm1heEtleSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGtleSAtIEtleSB0byBpbnNlcnQuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBpbnNlcnQuXHJcbiAgICAgKiBAcGFyYW0gY29tcGFyYXRvciAtIENvbXBhcmF0b3IuXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgd2l0aCB0aGUga2V5L3ZhbHVlIGFkZGVkLlxyXG4gICAgICovXHJcbiAgICBpbnNlcnQoa2V5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xyXG4gICAgICAgIGxldCBuID0gdGhpcztcclxuICAgICAgICBjb25zdCBjbXAgPSBjb21wYXJhdG9yKGtleSwgbi5rZXkpO1xyXG4gICAgICAgIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbi5sZWZ0Lmluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIHZhbHVlLCBudWxsLCBudWxsLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbi5yaWdodC5pbnNlcnQoa2V5LCB2YWx1ZSwgY29tcGFyYXRvcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbi5maXhVcF8oKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTmV3IHRyZWUsIHdpdGggdGhlIG1pbmltdW0ga2V5IHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZU1pbl8oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFNvcnRlZE1hcC5FTVBUWV9OT0RFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbiA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCFuLmxlZnQuaXNSZWRfKCkgJiYgIW4ubGVmdC5sZWZ0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLm1vdmVSZWRMZWZ0XygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG4ubGVmdC5yZW1vdmVNaW5fKCksIG51bGwpO1xyXG4gICAgICAgIHJldHVybiBuLmZpeFVwXygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiB0aGUgaXRlbSB0byByZW1vdmUuXHJcbiAgICAgKiBAcGFyYW0gY29tcGFyYXRvciAtIENvbXBhcmF0b3IuXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGl0ZW0gcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKGtleSwgY29tcGFyYXRvcikge1xyXG4gICAgICAgIGxldCBuLCBzbWFsbGVzdDtcclxuICAgICAgICBuID0gdGhpcztcclxuICAgICAgICBpZiAoY29tcGFyYXRvcihrZXksIG4ua2V5KSA8IDApIHtcclxuICAgICAgICAgICAgaWYgKCFuLmxlZnQuaXNFbXB0eSgpICYmICFuLmxlZnQuaXNSZWRfKCkgJiYgIW4ubGVmdC5sZWZ0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgICAgICBuID0gbi5tb3ZlUmVkTGVmdF8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG4ubGVmdC5yZW1vdmUoa2V5LCBjb21wYXJhdG9yKSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobi5sZWZ0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgICAgICBuID0gbi5yb3RhdGVSaWdodF8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW4ucmlnaHQuaXNFbXB0eSgpICYmICFuLnJpZ2h0LmlzUmVkXygpICYmICFuLnJpZ2h0LmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgICAgIG4gPSBuLm1vdmVSZWRSaWdodF8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29tcGFyYXRvcihrZXksIG4ua2V5KSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG4ucmlnaHQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNvcnRlZE1hcC5FTVBUWV9OT0RFO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc21hbGxlc3QgPSBuLnJpZ2h0Lm1pbl8oKTtcclxuICAgICAgICAgICAgICAgICAgICBuID0gbi5jb3B5KHNtYWxsZXN0LmtleSwgc21hbGxlc3QudmFsdWUsIG51bGwsIG51bGwsIG4ucmlnaHQucmVtb3ZlTWluXygpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG51bGwsIG4ucmlnaHQucmVtb3ZlKGtleSwgY29tcGFyYXRvcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbi5maXhVcF8oKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGlzIGlzIGEgUkVEIG5vZGUuXHJcbiAgICAgKi9cclxuICAgIGlzUmVkXygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTmV3IHRyZWUgYWZ0ZXIgcGVyZm9ybWluZyBhbnkgbmVlZGVkIHJvdGF0aW9ucy5cclxuICAgICAqL1xyXG4gICAgZml4VXBfKCkge1xyXG4gICAgICAgIGxldCBuID0gdGhpcztcclxuICAgICAgICBpZiAobi5yaWdodC5pc1JlZF8oKSAmJiAhbi5sZWZ0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZUxlZnRfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLmxlZnQuaXNSZWRfKCkgJiYgbi5sZWZ0LmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgbiA9IG4ucm90YXRlUmlnaHRfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLmxlZnQuaXNSZWRfKCkgJiYgbi5yaWdodC5pc1JlZF8oKSkge1xyXG4gICAgICAgICAgICBuID0gbi5jb2xvckZsaXBfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgYWZ0ZXIgbW92ZVJlZExlZnQuXHJcbiAgICAgKi9cclxuICAgIG1vdmVSZWRMZWZ0XygpIHtcclxuICAgICAgICBsZXQgbiA9IHRoaXMuY29sb3JGbGlwXygpO1xyXG4gICAgICAgIGlmIChuLnJpZ2h0LmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBudWxsLCBuLnJpZ2h0LnJvdGF0ZVJpZ2h0XygpKTtcclxuICAgICAgICAgICAgbiA9IG4ucm90YXRlTGVmdF8oKTtcclxuICAgICAgICAgICAgbiA9IG4uY29sb3JGbGlwXygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTmV3IHRyZWUsIGFmdGVyIG1vdmVSZWRSaWdodC5cclxuICAgICAqL1xyXG4gICAgbW92ZVJlZFJpZ2h0XygpIHtcclxuICAgICAgICBsZXQgbiA9IHRoaXMuY29sb3JGbGlwXygpO1xyXG4gICAgICAgIGlmIChuLmxlZnQubGVmdC5pc1JlZF8oKSkge1xyXG4gICAgICAgICAgICBuID0gbi5yb3RhdGVSaWdodF8oKTtcclxuICAgICAgICAgICAgbiA9IG4uY29sb3JGbGlwXygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTmV3IHRyZWUsIGFmdGVyIHJvdGF0ZUxlZnQuXHJcbiAgICAgKi9cclxuICAgIHJvdGF0ZUxlZnRfKCkge1xyXG4gICAgICAgIGNvbnN0IG5sID0gdGhpcy5jb3B5KG51bGwsIG51bGwsIExMUkJOb2RlLlJFRCwgbnVsbCwgdGhpcy5yaWdodC5sZWZ0KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5jb3B5KG51bGwsIG51bGwsIHRoaXMuY29sb3IsIG5sLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTmV3IHRyZWUsIGFmdGVyIHJvdGF0ZVJpZ2h0LlxyXG4gICAgICovXHJcbiAgICByb3RhdGVSaWdodF8oKSB7XHJcbiAgICAgICAgY29uc3QgbnIgPSB0aGlzLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuUkVELCB0aGlzLmxlZnQucmlnaHQsIG51bGwpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQuY29weShudWxsLCBudWxsLCB0aGlzLmNvbG9yLCBudWxsLCBucik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIE5ld3QgcmVlLCBhZnRlciBjb2xvckZsaXAuXHJcbiAgICAgKi9cclxuICAgIGNvbG9yRmxpcF8oKSB7XHJcbiAgICAgICAgY29uc3QgbGVmdCA9IHRoaXMubGVmdC5jb3B5KG51bGwsIG51bGwsICF0aGlzLmxlZnQuY29sb3IsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5yaWdodC5jb3B5KG51bGwsIG51bGwsICF0aGlzLnJpZ2h0LmNvbG9yLCBudWxsLCBudWxsKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb3B5KG51bGwsIG51bGwsICF0aGlzLmNvbG9yLCBsZWZ0LCByaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZvciB0ZXN0aW5nLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgYWxsIGlzIHdlbGwuXHJcbiAgICAgKi9cclxuICAgIGNoZWNrTWF4RGVwdGhfKCkge1xyXG4gICAgICAgIGNvbnN0IGJsYWNrRGVwdGggPSB0aGlzLmNoZWNrXygpO1xyXG4gICAgICAgIHJldHVybiBNYXRoLnBvdygyLjAsIGJsYWNrRGVwdGgpIDw9IHRoaXMuY291bnQoKSArIDE7XHJcbiAgICB9XHJcbiAgICBjaGVja18oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNSZWRfKCkgJiYgdGhpcy5sZWZ0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVkIG5vZGUgaGFzIHJlZCBjaGlsZCgnICsgdGhpcy5rZXkgKyAnLCcgKyB0aGlzLnZhbHVlICsgJyknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSaWdodCBjaGlsZCBvZiAoJyArIHRoaXMua2V5ICsgJywnICsgdGhpcy52YWx1ZSArICcpIGlzIHJlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBibGFja0RlcHRoID0gdGhpcy5sZWZ0LmNoZWNrXygpO1xyXG4gICAgICAgIGlmIChibGFja0RlcHRoICE9PSB0aGlzLnJpZ2h0LmNoZWNrXygpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmxhY2sgZGVwdGhzIGRpZmZlcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJsYWNrRGVwdGggKyAodGhpcy5pc1JlZF8oKSA/IDAgOiAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuTExSQk5vZGUuUkVEID0gdHJ1ZTtcclxuTExSQk5vZGUuQkxBQ0sgPSBmYWxzZTtcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gZW1wdHkgbm9kZSAoYSBsZWFmIG5vZGUgaW4gdGhlIFJlZC1CbGFjayBUcmVlKS5cclxuICovXHJcbmNsYXNzIExMUkJFbXB0eU5vZGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBub2RlIGNvcHkuXHJcbiAgICAgKi9cclxuICAgIGNvcHkoa2V5LCB2YWx1ZSwgY29sb3IsIGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSB0cmVlLCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5L3ZhbHVlIGFkZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBLZXkgdG8gYmUgYWRkZWQuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBiZSBhZGRlZC5cclxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yIC0gQ29tcGFyYXRvci5cclxuICAgICAqIEByZXR1cm5zIE5ldyB0cmVlLCB3aXRoIGl0ZW0gYWRkZWQuXHJcbiAgICAgKi9cclxuICAgIGluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMTFJCTm9kZShrZXksIHZhbHVlLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkgcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB0byByZW1vdmUuXHJcbiAgICAgKiBAcGFyYW0gY29tcGFyYXRvciAtIENvbXBhcmF0b3IuXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgd2l0aCBpdGVtIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZShrZXksIGNvbXBhcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIHRvdGFsIG51bWJlciBvZiBub2RlcyBpbiB0aGUgdHJlZS5cclxuICAgICAqL1xyXG4gICAgY291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHRyZWUgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyB0aGUgdHJlZSBpbiBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXHJcbiAgICAgKiBmb3IgZWFjaCBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2hcclxuICAgICAqIG5vZGUuICBJZiBpdCByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0cmF2ZXJzYWwgd2FzIGFib3J0ZWQuXHJcbiAgICAgKi9cclxuICAgIGlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIHRyZWUgaW4gcmV2ZXJzZSBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXHJcbiAgICAgKiBmb3IgZWFjaCBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2hcclxuICAgICAqIG5vZGUuICBJZiBpdCByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0cmF2ZXJzYWwgd2FzIGFib3J0ZWQuXHJcbiAgICAgKi9cclxuICAgIHJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbWluS2V5KCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgbWF4S2V5KCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY2hlY2tfKCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoaXMgbm9kZSBpcyByZWQuXHJcbiAgICAgKi9cclxuICAgIGlzUmVkXygpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFuIGltbXV0YWJsZSBzb3J0ZWQgbWFwIGltcGxlbWVudGF0aW9uLCBiYXNlZCBvbiBhIExlZnQtbGVhbmluZyBSZWQtQmxhY2tcclxuICogdHJlZS5cclxuICovXHJcbmNsYXNzIFNvcnRlZE1hcCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yXyAtIEtleSBjb21wYXJhdG9yLlxyXG4gICAgICogQHBhcmFtIHJvb3RfIC0gT3B0aW9uYWwgcm9vdCBub2RlIGZvciB0aGUgbWFwLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb21wYXJhdG9yXywgcm9vdF8gPSBTb3J0ZWRNYXAuRU1QVFlfTk9ERSkge1xyXG4gICAgICAgIHRoaXMuY29tcGFyYXRvcl8gPSBjb21wYXJhdG9yXztcclxuICAgICAgICB0aGlzLnJvb3RfID0gcm9vdF87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBtYXAsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkvdmFsdWUgYWRkZWQgb3IgcmVwbGFjZWQuXHJcbiAgICAgKiAoVE9ETzogV2Ugc2hvdWxkIHBlcmhhcHMgcmVuYW1lIHRoaXMgbWV0aG9kIHRvICdwdXQnKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBLZXkgdG8gYmUgYWRkZWQuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBiZSBhZGRlZC5cclxuICAgICAqIEByZXR1cm5zIE5ldyBtYXAsIHdpdGggaXRlbSBhZGRlZC5cclxuICAgICAqL1xyXG4gICAgaW5zZXJ0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3JfLCB0aGlzLnJvb3RfXHJcbiAgICAgICAgICAgIC5pbnNlcnQoa2V5LCB2YWx1ZSwgdGhpcy5jb21wYXJhdG9yXylcclxuICAgICAgICAgICAgLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuQkxBQ0ssIG51bGwsIG51bGwpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIG1hcCwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSByZW1vdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIHJlbW92ZS5cclxuICAgICAqIEByZXR1cm5zIE5ldyBtYXAsIHdpdGggaXRlbSByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICByZW1vdmUoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXAodGhpcy5jb21wYXJhdG9yXywgdGhpcy5yb290X1xyXG4gICAgICAgICAgICAucmVtb3ZlKGtleSwgdGhpcy5jb21wYXJhdG9yXylcclxuICAgICAgICAgICAgLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuQkxBQ0ssIG51bGwsIG51bGwpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5vZGUgd2l0aCB0aGUgZ2l2ZW4ga2V5LCBvciBudWxsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIGxvb2sgdXAuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIG5vZGUgd2l0aCB0aGUgZ2l2ZW4ga2V5LCBvciBudWxsIGlmIHRoZVxyXG4gICAgICoga2V5IGRvZXNuJ3QgZXhpc3QuXHJcbiAgICAgKi9cclxuICAgIGdldChrZXkpIHtcclxuICAgICAgICBsZXQgY21wO1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5yb290XztcclxuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGNtcCA9IHRoaXMuY29tcGFyYXRvcl8oa2V5LCBub2RlLmtleSk7XHJcbiAgICAgICAgICAgIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGtleSBvZiB0aGUgaXRlbSAqYmVmb3JlKiB0aGUgc3BlY2lmaWVkIGtleSwgb3IgbnVsbCBpZiBrZXkgaXMgdGhlIGZpcnN0IGl0ZW0uXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB0byBmaW5kIHRoZSBwcmVkZWNlc3NvciBvZlxyXG4gICAgICogQHJldHVybnMgVGhlIHByZWRlY2Vzc29yIGtleS5cclxuICAgICAqL1xyXG4gICAgZ2V0UHJlZGVjZXNzb3JLZXkoa2V5KSB7XHJcbiAgICAgICAgbGV0IGNtcCwgbm9kZSA9IHRoaXMucm9vdF8sIHJpZ2h0UGFyZW50ID0gbnVsbDtcclxuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGNtcCA9IHRoaXMuY29tcGFyYXRvcl8oa2V5LCBub2RlLmtleSk7XHJcbiAgICAgICAgICAgIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5sZWZ0LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFub2RlLnJpZ2h0LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUua2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmlnaHRQYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHRQYXJlbnQua2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIGZpcnN0IGl0ZW0uXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICByaWdodFBhcmVudCA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBmaW5kIHByZWRlY2Vzc29yIGtleSBmb3IgYSBub25leGlzdGVudCBrZXkuICBXaGF0IGdpdmVzPycpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBtYXAgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8uaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdG90YWwgbnVtYmVyIG9mIG5vZGVzIGluIHRoZSBtYXAuXHJcbiAgICAgKi9cclxuICAgIGNvdW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RfLmNvdW50KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBtaW5pbXVtIGtleSBpbiB0aGUgbWFwLlxyXG4gICAgICovXHJcbiAgICBtaW5LZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8ubWluS2V5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBtYXhpbXVtIGtleSBpbiB0aGUgbWFwLlxyXG4gICAgICovXHJcbiAgICBtYXhLZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8ubWF4S2V5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyB0aGUgbWFwIGluIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cclxuICAgICAqIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWRcclxuICAgICAqIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLiAgSWYgYWN0aW9uIHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XHJcbiAgICAgKiAgIHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvblxyXG4gICAgICovXHJcbiAgICBpbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RfLmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIHRoZSBtYXAgaW4gcmV2ZXJzZSBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXHJcbiAgICAgKiBmb3IgZWFjaCBrZXkvdmFsdWUgcGFpci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWN0aW9uIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXHJcbiAgICAgKiBmb3IgZWFjaCBrZXkvdmFsdWUgcGFpci4gIElmIGFjdGlvbiByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdHJhdmVyc2FsIHdhcyBhYm9ydGVkLlxyXG4gICAgICovXHJcbiAgICByZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RfLnJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHRoZSBTb3J0ZWRNYXAuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlcmF0b3IuXHJcbiAgICAgKi9cclxuICAgIGdldEl0ZXJhdG9yKHJlc3VsdEdlbmVyYXRvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwSXRlcmF0b3IodGhpcy5yb290XywgbnVsbCwgdGhpcy5jb21wYXJhdG9yXywgZmFsc2UsIHJlc3VsdEdlbmVyYXRvcik7XHJcbiAgICB9XHJcbiAgICBnZXRJdGVyYXRvckZyb20oa2V5LCByZXN1bHRHZW5lcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdF8sIGtleSwgdGhpcy5jb21wYXJhdG9yXywgZmFsc2UsIHJlc3VsdEdlbmVyYXRvcik7XHJcbiAgICB9XHJcbiAgICBnZXRSZXZlcnNlSXRlcmF0b3JGcm9tKGtleSwgcmVzdWx0R2VuZXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3RfLCBrZXksIHRoaXMuY29tcGFyYXRvcl8sIHRydWUsIHJlc3VsdEdlbmVyYXRvcik7XHJcbiAgICB9XHJcbiAgICBnZXRSZXZlcnNlSXRlcmF0b3IocmVzdWx0R2VuZXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3RfLCBudWxsLCB0aGlzLmNvbXBhcmF0b3JfLCB0cnVlLCByZXN1bHRHZW5lcmF0b3IpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBbHdheXMgdXNlIHRoZSBzYW1lIGVtcHR5IG5vZGUsIHRvIHJlZHVjZSBtZW1vcnkuXHJcbiAqL1xyXG5Tb3J0ZWRNYXAuRU1QVFlfTk9ERSA9IG5ldyBMTFJCRW1wdHlOb2RlKCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIE5BTUVfT05MWV9DT01QQVJBVE9SKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICByZXR1cm4gbmFtZUNvbXBhcmUobGVmdC5uYW1lLCByaWdodC5uYW1lKTtcclxufVxyXG5mdW5jdGlvbiBOQU1FX0NPTVBBUkFUT1IobGVmdCwgcmlnaHQpIHtcclxuICAgIHJldHVybiBuYW1lQ29tcGFyZShsZWZ0LCByaWdodCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IE1BWF9OT0RFJDI7XHJcbmZ1bmN0aW9uIHNldE1heE5vZGUkMSh2YWwpIHtcclxuICAgIE1BWF9OT0RFJDIgPSB2YWw7XHJcbn1cclxuY29uc3QgcHJpb3JpdHlIYXNoVGV4dCA9IGZ1bmN0aW9uIChwcmlvcml0eSkge1xyXG4gICAgaWYgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gJ251bWJlcjonICsgZG91YmxlVG9JRUVFNzU0U3RyaW5nKHByaW9yaXR5KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAnc3RyaW5nOicgKyBwcmlvcml0eTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFZhbGlkYXRlcyB0aGF0IGEgcHJpb3JpdHkgc25hcHNob3QgTm9kZSBpcyB2YWxpZC5cclxuICovXHJcbmNvbnN0IHZhbGlkYXRlUHJpb3JpdHlOb2RlID0gZnVuY3Rpb24gKHByaW9yaXR5Tm9kZSkge1xyXG4gICAgaWYgKHByaW9yaXR5Tm9kZS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICBjb25zdCB2YWwgPSBwcmlvcml0eU5vZGUudmFsKCk7XHJcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8XHJcbiAgICAgICAgICAgIHR5cGVvZiB2YWwgPT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgICAgICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiBjb250YWlucyh2YWwsICcuc3YnKSksICdQcmlvcml0eSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlci4nKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFzc2VydChwcmlvcml0eU5vZGUgPT09IE1BWF9OT0RFJDIgfHwgcHJpb3JpdHlOb2RlLmlzRW1wdHkoKSwgJ3ByaW9yaXR5IG9mIHVuZXhwZWN0ZWQgdHlwZS4nKTtcclxuICAgIH1cclxuICAgIC8vIERvbid0IGNhbGwgZ2V0UHJpb3JpdHkoKSBvbiBNQVhfTk9ERSB0byBhdm9pZCBoaXR0aW5nIGFzc2VydGlvbi5cclxuICAgIGFzc2VydChwcmlvcml0eU5vZGUgPT09IE1BWF9OT0RFJDIgfHwgcHJpb3JpdHlOb2RlLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpLCBcIlByaW9yaXR5IG5vZGVzIGNhbid0IGhhdmUgYSBwcmlvcml0eSBvZiB0aGVpciBvd24uXCIpO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5sZXQgX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3RvcjtcclxuLyoqXHJcbiAqIExlYWZOb2RlIGlzIGEgY2xhc3MgZm9yIHN0b3JpbmcgbGVhZiBub2RlcyBpbiBhIERhdGFTbmFwc2hvdC4gIEl0XHJcbiAqIGltcGxlbWVudHMgTm9kZSBhbmQgc3RvcmVzIHRoZSB2YWx1ZSBvZiB0aGUgbm9kZSAoYSBzdHJpbmcsXHJcbiAqIG51bWJlciwgb3IgYm9vbGVhbikgYWNjZXNzaWJsZSB2aWEgZ2V0VmFsdWUoKS5cclxuICovXHJcbmNsYXNzIExlYWZOb2RlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHZhbHVlXyAtIFRoZSB2YWx1ZSB0byBzdG9yZSBpbiB0aGlzIGxlYWYgbm9kZS4gVGhlIG9iamVjdCB0eXBlIGlzXHJcbiAgICAgKiBwb3NzaWJsZSBpbiB0aGUgZXZlbnQgb2YgYSBkZWZlcnJlZCB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHByaW9yaXR5Tm9kZV8gLSBUaGUgcHJpb3JpdHkgb2YgdGhpcyBub2RlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZV8sIHByaW9yaXR5Tm9kZV8gPSBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREUpIHtcclxuICAgICAgICB0aGlzLnZhbHVlXyA9IHZhbHVlXztcclxuICAgICAgICB0aGlzLnByaW9yaXR5Tm9kZV8gPSBwcmlvcml0eU5vZGVfO1xyXG4gICAgICAgIHRoaXMubGF6eUhhc2hfID0gbnVsbDtcclxuICAgICAgICBhc3NlcnQodGhpcy52YWx1ZV8gIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZhbHVlXyAhPT0gbnVsbCwgXCJMZWFmTm9kZSBzaG91bGRuJ3QgYmUgY3JlYXRlZCB3aXRoIG51bGwvdW5kZWZpbmVkIHZhbHVlLlwiKTtcclxuICAgICAgICB2YWxpZGF0ZVByaW9yaXR5Tm9kZSh0aGlzLnByaW9yaXR5Tm9kZV8pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHNldCBfX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yKHZhbCkge1xyXG4gICAgICAgIF9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IF9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3I7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGlzTGVhZk5vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGdldFByaW9yaXR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByaW9yaXR5Tm9kZV87XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIHVwZGF0ZVByaW9yaXR5KG5ld1ByaW9yaXR5Tm9kZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGVhZk5vZGUodGhpcy52YWx1ZV8sIG5ld1ByaW9yaXR5Tm9kZSk7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSkge1xyXG4gICAgICAgIC8vIEhhY2sgdG8gdHJlYXQgcHJpb3JpdHkgYXMgYSByZWd1bGFyIGNoaWxkXHJcbiAgICAgICAgaWYgKGNoaWxkTmFtZSA9PT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJpb3JpdHlOb2RlXztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBnZXRDaGlsZChwYXRoKSB7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXRoR2V0RnJvbnQocGF0aCkgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByaW9yaXR5Tm9kZV87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3Rvci5FTVBUWV9OT0RFO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhc0NoaWxkKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgZ2V0UHJlZGVjZXNzb3JDaGlsZE5hbWUoY2hpbGROYW1lLCBjaGlsZE5vZGUpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgdXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lLCBuZXdDaGlsZE5vZGUpIHtcclxuICAgICAgICBpZiAoY2hpbGROYW1lID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVQcmlvcml0eShuZXdDaGlsZE5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChuZXdDaGlsZE5vZGUuaXNFbXB0eSgpICYmIGNoaWxkTmFtZSAhPT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3Rvci5FTVBUWV9OT0RFLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKS51cGRhdGVQcmlvcml0eSh0aGlzLnByaW9yaXR5Tm9kZV8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgdXBkYXRlQ2hpbGQocGF0aCwgbmV3Q2hpbGROb2RlKSB7XHJcbiAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICAgICAgaWYgKGZyb250ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5ld0NoaWxkTm9kZS5pc0VtcHR5KCkgJiYgZnJvbnQgIT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXNzZXJ0KGZyb250ICE9PSAnLnByaW9yaXR5JyB8fCBwYXRoR2V0TGVuZ3RoKHBhdGgpID09PSAxLCAnLnByaW9yaXR5IG11c3QgYmUgdGhlIGxhc3QgdG9rZW4gaW4gYSBwYXRoJyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGZyb250LCBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREUudXBkYXRlQ2hpbGQocGF0aFBvcEZyb250KHBhdGgpLCBuZXdDaGlsZE5vZGUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBudW1DaGlsZHJlbigpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgZm9yRWFjaENoaWxkKGluZGV4LCBhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YWwoZXhwb3J0Rm9ybWF0KSB7XHJcbiAgICAgICAgaWYgKGV4cG9ydEZvcm1hdCAmJiAhdGhpcy5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgJy52YWx1ZSc6IHRoaXMuZ2V0VmFsdWUoKSxcclxuICAgICAgICAgICAgICAgICcucHJpb3JpdHknOiB0aGlzLmdldFByaW9yaXR5KCkudmFsKClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBoYXNoKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxhenlIYXNoXyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBsZXQgdG9IYXNoID0gJyc7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wcmlvcml0eU5vZGVfLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgdG9IYXNoICs9XHJcbiAgICAgICAgICAgICAgICAgICAgJ3ByaW9yaXR5OicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eUhhc2hUZXh0KHRoaXMucHJpb3JpdHlOb2RlXy52YWwoKSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnOic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiB0aGlzLnZhbHVlXztcclxuICAgICAgICAgICAgdG9IYXNoICs9IHR5cGUgKyAnOic7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgdG9IYXNoICs9IGRvdWJsZVRvSUVFRTc1NFN0cmluZyh0aGlzLnZhbHVlXyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0b0hhc2ggKz0gdGhpcy52YWx1ZV87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5sYXp5SGFzaF8gPSBzaGExKHRvSGFzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmxhenlIYXNoXztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGxlYWYgbm9kZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgbm9kZS5cclxuICAgICAqL1xyXG4gICAgZ2V0VmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVfO1xyXG4gICAgfVxyXG4gICAgY29tcGFyZVRvKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyID09PSBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG90aGVyIGluc3RhbmNlb2YgTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3NlcnQob3RoZXIuaXNMZWFmTm9kZSgpLCAnVW5rbm93biBub2RlIHR5cGUnKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvTGVhZk5vZGVfKG90aGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbXBhcmlzb24gc3BlY2lmaWNhbGx5IGZvciB0d28gbGVhZiBub2Rlc1xyXG4gICAgICovXHJcbiAgICBjb21wYXJlVG9MZWFmTm9kZV8ob3RoZXJMZWFmKSB7XHJcbiAgICAgICAgY29uc3Qgb3RoZXJMZWFmVHlwZSA9IHR5cGVvZiBvdGhlckxlYWYudmFsdWVfO1xyXG4gICAgICAgIGNvbnN0IHRoaXNMZWFmVHlwZSA9IHR5cGVvZiB0aGlzLnZhbHVlXztcclxuICAgICAgICBjb25zdCBvdGhlckluZGV4ID0gTGVhZk5vZGUuVkFMVUVfVFlQRV9PUkRFUi5pbmRleE9mKG90aGVyTGVhZlR5cGUpO1xyXG4gICAgICAgIGNvbnN0IHRoaXNJbmRleCA9IExlYWZOb2RlLlZBTFVFX1RZUEVfT1JERVIuaW5kZXhPZih0aGlzTGVhZlR5cGUpO1xyXG4gICAgICAgIGFzc2VydChvdGhlckluZGV4ID49IDAsICdVbmtub3duIGxlYWYgdHlwZTogJyArIG90aGVyTGVhZlR5cGUpO1xyXG4gICAgICAgIGFzc2VydCh0aGlzSW5kZXggPj0gMCwgJ1Vua25vd24gbGVhZiB0eXBlOiAnICsgdGhpc0xlYWZUeXBlKTtcclxuICAgICAgICBpZiAob3RoZXJJbmRleCA9PT0gdGhpc0luZGV4KSB7XHJcbiAgICAgICAgICAgIC8vIFNhbWUgdHlwZSwgY29tcGFyZSB2YWx1ZXNcclxuICAgICAgICAgICAgaWYgKHRoaXNMZWFmVHlwZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIERlZmVycmVkIHZhbHVlIG5vZGVzIGFyZSBhbGwgZXF1YWwsIGJ1dCB3ZSBzaG91bGQgYWxzbyBuZXZlciBnZXQgdG8gdGhpcyBwb2ludC4uLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyB3b3JrcyBiZWNhdXNlIHRydWUgPiBmYWxzZSwgYWxsIG90aGVycyBhcmUgbnVtYmVyIG9yIHN0cmluZyBjb21wYXJpc29uc1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVfIDwgb3RoZXJMZWFmLnZhbHVlXykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudmFsdWVfID09PSBvdGhlckxlYWYudmFsdWVfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNJbmRleCAtIG90aGVySW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgd2l0aEluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgaXNJbmRleGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvdGhlci5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3RoZXJMZWFmID0gb3RoZXI7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy52YWx1ZV8gPT09IG90aGVyTGVhZi52YWx1ZV8gJiZcclxuICAgICAgICAgICAgICAgIHRoaXMucHJpb3JpdHlOb2RlXy5lcXVhbHMob3RoZXJMZWFmLnByaW9yaXR5Tm9kZV8pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBzb3J0IG9yZGVyIGZvciBjb21wYXJpbmcgbGVhZiBub2RlcyBvZiBkaWZmZXJlbnQgdHlwZXMuIElmIHR3byBsZWFmIG5vZGVzIGhhdmVcclxuICogdGhlIHNhbWUgdHlwZSwgdGhlIGNvbXBhcmlzb24gZmFsbHMgYmFjayB0byB0aGVpciB2YWx1ZVxyXG4gKi9cclxuTGVhZk5vZGUuVkFMVUVfVFlQRV9PUkRFUiA9IFsnb2JqZWN0JywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ3N0cmluZyddO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5sZXQgbm9kZUZyb21KU09OJDE7XHJcbmxldCBNQVhfTk9ERSQxO1xyXG5mdW5jdGlvbiBzZXROb2RlRnJvbUpTT04odmFsKSB7XHJcbiAgICBub2RlRnJvbUpTT04kMSA9IHZhbDtcclxufVxyXG5mdW5jdGlvbiBzZXRNYXhOb2RlKHZhbCkge1xyXG4gICAgTUFYX05PREUkMSA9IHZhbDtcclxufVxyXG5jbGFzcyBQcmlvcml0eUluZGV4IGV4dGVuZHMgSW5kZXgge1xyXG4gICAgY29tcGFyZShhLCBiKSB7XHJcbiAgICAgICAgY29uc3QgYVByaW9yaXR5ID0gYS5ub2RlLmdldFByaW9yaXR5KCk7XHJcbiAgICAgICAgY29uc3QgYlByaW9yaXR5ID0gYi5ub2RlLmdldFByaW9yaXR5KCk7XHJcbiAgICAgICAgY29uc3QgaW5kZXhDbXAgPSBhUHJpb3JpdHkuY29tcGFyZVRvKGJQcmlvcml0eSk7XHJcbiAgICAgICAgaWYgKGluZGV4Q21wID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuYW1lQ29tcGFyZShhLm5hbWUsIGIubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXhDbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNEZWZpbmVkT24obm9kZSkge1xyXG4gICAgICAgIHJldHVybiAhbm9kZS5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKTtcclxuICAgIH1cclxuICAgIGluZGV4ZWRWYWx1ZUNoYW5nZWQob2xkTm9kZSwgbmV3Tm9kZSkge1xyXG4gICAgICAgIHJldHVybiAhb2xkTm9kZS5nZXRQcmlvcml0eSgpLmVxdWFscyhuZXdOb2RlLmdldFByaW9yaXR5KCkpO1xyXG4gICAgfVxyXG4gICAgbWluUG9zdCgpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIHJldHVybiBOYW1lZE5vZGUuTUlOO1xyXG4gICAgfVxyXG4gICAgbWF4UG9zdCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShNQVhfTkFNRSwgbmV3IExlYWZOb2RlKCdbUFJJT1JJVFktUE9TVF0nLCBNQVhfTk9ERSQxKSk7XHJcbiAgICB9XHJcbiAgICBtYWtlUG9zdChpbmRleFZhbHVlLCBuYW1lKSB7XHJcbiAgICAgICAgY29uc3QgcHJpb3JpdHlOb2RlID0gbm9kZUZyb21KU09OJDEoaW5kZXhWYWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUobmFtZSwgbmV3IExlYWZOb2RlKCdbUFJJT1JJVFktUE9TVF0nLCBwcmlvcml0eU5vZGUpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgU3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciBpbmNsdXNpb24gaW4gYSBxdWVyeSBzcGVjXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAnLnByaW9yaXR5JztcclxuICAgIH1cclxufVxyXG5jb25zdCBQUklPUklUWV9JTkRFWCA9IG5ldyBQcmlvcml0eUluZGV4KCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR18yID0gTWF0aC5sb2coMik7XHJcbmNsYXNzIEJhc2UxMk51bSB7XHJcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBsb2dCYXNlMiA9IChudW0pID0+IFxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcGFyc2VJbnQoKE1hdGgubG9nKG51bSkgLyBMT0dfMiksIDEwKTtcclxuICAgICAgICBjb25zdCBiaXRNYXNrID0gKGJpdHMpID0+IHBhcnNlSW50KEFycmF5KGJpdHMgKyAxKS5qb2luKCcxJyksIDIpO1xyXG4gICAgICAgIHRoaXMuY291bnQgPSBsb2dCYXNlMihsZW5ndGggKyAxKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRfID0gdGhpcy5jb3VudCAtIDE7XHJcbiAgICAgICAgY29uc3QgbWFzayA9IGJpdE1hc2sodGhpcy5jb3VudCk7XHJcbiAgICAgICAgdGhpcy5iaXRzXyA9IChsZW5ndGggKyAxKSAmIG1hc2s7XHJcbiAgICB9XHJcbiAgICBuZXh0Qml0SXNPbmUoKSB7XHJcbiAgICAgICAgLy9ub2luc3BlY3Rpb24gSlNCaXR3aXNlT3BlcmF0b3JVc2FnZVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICEodGhpcy5iaXRzXyAmICgweDEgPDwgdGhpcy5jdXJyZW50XykpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudF8tLTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUYWtlcyBhIGxpc3Qgb2YgY2hpbGQgbm9kZXMgYW5kIGNvbnN0cnVjdHMgYSBTb3J0ZWRTZXQgdXNpbmcgdGhlIGdpdmVuIGNvbXBhcmlzb25cclxuICogZnVuY3Rpb25cclxuICpcclxuICogVXNlcyB0aGUgYWxnb3JpdGhtIGRlc2NyaWJlZCBpbiB0aGUgcGFwZXIgbGlua2VkIGhlcmU6XHJcbiAqIGh0dHA6Ly9jaXRlc2VlcnguaXN0LnBzdS5lZHUvdmlld2RvYy9zdW1tYXJ5P2RvaT0xMC4xLjEuNDYuMTQ1OFxyXG4gKlxyXG4gKiBAcGFyYW0gY2hpbGRMaXN0IC0gVW5zb3J0ZWQgbGlzdCBvZiBjaGlsZHJlblxyXG4gKiBAcGFyYW0gY21wIC0gVGhlIGNvbXBhcmlzb24gbWV0aG9kIHRvIGJlIHVzZWRcclxuICogQHBhcmFtIGtleUZuIC0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZXh0cmFjdCBLIGZyb20gYSBub2RlIHdyYXBwZXIsIGlmIEsnc1xyXG4gKiB0eXBlIGlzIG5vdCBOYW1lZE5vZGVcclxuICogQHBhcmFtIG1hcFNvcnRGbiAtIEFuIG9wdGlvbmFsIG92ZXJyaWRlIGZvciBjb21wYXJhdG9yIHVzZWQgYnkgdGhlIGdlbmVyYXRlZCBzb3J0ZWQgbWFwXHJcbiAqL1xyXG5jb25zdCBidWlsZENoaWxkU2V0ID0gZnVuY3Rpb24gKGNoaWxkTGlzdCwgY21wLCBrZXlGbiwgbWFwU29ydEZuKSB7XHJcbiAgICBjaGlsZExpc3Quc29ydChjbXApO1xyXG4gICAgY29uc3QgYnVpbGRCYWxhbmNlZFRyZWUgPSBmdW5jdGlvbiAobG93LCBoaWdoKSB7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gaGlnaCAtIGxvdztcclxuICAgICAgICBsZXQgbmFtZWROb2RlO1xyXG4gICAgICAgIGxldCBrZXk7XHJcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIG5hbWVkTm9kZSA9IGNoaWxkTGlzdFtsb3ddO1xyXG4gICAgICAgICAgICBrZXkgPSBrZXlGbiA/IGtleUZuKG5hbWVkTm9kZSkgOiBuYW1lZE5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5LCBuYW1lZE5vZGUubm9kZSwgTExSQk5vZGUuQkxBQ0ssIG51bGwsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgY29uc3QgbWlkZGxlID0gcGFyc2VJbnQoKGxlbmd0aCAvIDIpLCAxMCkgKyBsb3c7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBidWlsZEJhbGFuY2VkVHJlZShsb3csIG1pZGRsZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gYnVpbGRCYWxhbmNlZFRyZWUobWlkZGxlICsgMSwgaGlnaCk7XHJcbiAgICAgICAgICAgIG5hbWVkTm9kZSA9IGNoaWxkTGlzdFttaWRkbGVdO1xyXG4gICAgICAgICAgICBrZXkgPSBrZXlGbiA/IGtleUZuKG5hbWVkTm9kZSkgOiBuYW1lZE5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5LCBuYW1lZE5vZGUubm9kZSwgTExSQk5vZGUuQkxBQ0ssIGxlZnQsIHJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgYnVpbGRGcm9tMTJBcnJheSA9IGZ1bmN0aW9uIChiYXNlMTIpIHtcclxuICAgICAgICBsZXQgbm9kZSA9IG51bGw7XHJcbiAgICAgICAgbGV0IHJvb3QgPSBudWxsO1xyXG4gICAgICAgIGxldCBpbmRleCA9IGNoaWxkTGlzdC5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgYnVpbGRQZW5uYW50ID0gZnVuY3Rpb24gKGNodW5rU2l6ZSwgY29sb3IpIHtcclxuICAgICAgICAgICAgY29uc3QgbG93ID0gaW5kZXggLSBjaHVua1NpemU7XHJcbiAgICAgICAgICAgIGNvbnN0IGhpZ2ggPSBpbmRleDtcclxuICAgICAgICAgICAgaW5kZXggLT0gY2h1bmtTaXplO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFRyZWUgPSBidWlsZEJhbGFuY2VkVHJlZShsb3cgKyAxLCBoaWdoKTtcclxuICAgICAgICAgICAgY29uc3QgbmFtZWROb2RlID0gY2hpbGRMaXN0W2xvd107XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleUZuID8ga2V5Rm4obmFtZWROb2RlKSA6IG5hbWVkTm9kZTtcclxuICAgICAgICAgICAgYXR0YWNoUGVubmFudChuZXcgTExSQk5vZGUoa2V5LCBuYW1lZE5vZGUubm9kZSwgY29sb3IsIG51bGwsIGNoaWxkVHJlZSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgYXR0YWNoUGVubmFudCA9IGZ1bmN0aW9uIChwZW5uYW50KSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmxlZnQgPSBwZW5uYW50O1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBlbm5hbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByb290ID0gcGVubmFudDtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBwZW5uYW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2UxMi5jb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzT25lID0gYmFzZTEyLm5leHRCaXRJc09uZSgpO1xyXG4gICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIG5vZGVzIHRha2VuIGluIGVhY2ggc2xpY2UgaXMgMl4oYXJyLmxlbmd0aCAtIChpICsgMSkpXHJcbiAgICAgICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGgucG93KDIsIGJhc2UxMi5jb3VudCAtIChpICsgMSkpO1xyXG4gICAgICAgICAgICBpZiAoaXNPbmUpIHtcclxuICAgICAgICAgICAgICAgIGJ1aWxkUGVubmFudChjaHVua1NpemUsIExMUkJOb2RlLkJMQUNLKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgPT0gMlxyXG4gICAgICAgICAgICAgICAgYnVpbGRQZW5uYW50KGNodW5rU2l6ZSwgTExSQk5vZGUuQkxBQ0spO1xyXG4gICAgICAgICAgICAgICAgYnVpbGRQZW5uYW50KGNodW5rU2l6ZSwgTExSQk5vZGUuUkVEKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcm9vdDtcclxuICAgIH07XHJcbiAgICBjb25zdCBiYXNlMTIgPSBuZXcgQmFzZTEyTnVtKGNoaWxkTGlzdC5sZW5ndGgpO1xyXG4gICAgY29uc3Qgcm9vdCA9IGJ1aWxkRnJvbTEyQXJyYXkoYmFzZTEyKTtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICByZXR1cm4gbmV3IFNvcnRlZE1hcChtYXBTb3J0Rm4gfHwgY21wLCByb290KTtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IF9kZWZhdWx0SW5kZXhNYXA7XHJcbmNvbnN0IGZhbGxiYWNrT2JqZWN0ID0ge307XHJcbmNsYXNzIEluZGV4TWFwIHtcclxuICAgIGNvbnN0cnVjdG9yKGluZGV4ZXNfLCBpbmRleFNldF8pIHtcclxuICAgICAgICB0aGlzLmluZGV4ZXNfID0gaW5kZXhlc187XHJcbiAgICAgICAgdGhpcy5pbmRleFNldF8gPSBpbmRleFNldF87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZWZhdWx0IEluZGV4TWFwIGZvciBub2RlcyB3aXRob3V0IGEgcHJpb3JpdHlcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xyXG4gICAgICAgIGFzc2VydChmYWxsYmFja09iamVjdCAmJiBQUklPUklUWV9JTkRFWCwgJ0NoaWxkcmVuTm9kZS50cyBoYXMgbm90IGJlZW4gbG9hZGVkJyk7XHJcbiAgICAgICAgX2RlZmF1bHRJbmRleE1hcCA9XHJcbiAgICAgICAgICAgIF9kZWZhdWx0SW5kZXhNYXAgfHxcclxuICAgICAgICAgICAgICAgIG5ldyBJbmRleE1hcCh7ICcucHJpb3JpdHknOiBmYWxsYmFja09iamVjdCB9LCB7ICcucHJpb3JpdHknOiBQUklPUklUWV9JTkRFWCB9KTtcclxuICAgICAgICByZXR1cm4gX2RlZmF1bHRJbmRleE1hcDtcclxuICAgIH1cclxuICAgIGdldChpbmRleEtleSkge1xyXG4gICAgICAgIGNvbnN0IHNvcnRlZE1hcCA9IHNhZmVHZXQodGhpcy5pbmRleGVzXywgaW5kZXhLZXkpO1xyXG4gICAgICAgIGlmICghc29ydGVkTWFwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5kZXggZGVmaW5lZCBmb3IgJyArIGluZGV4S2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNvcnRlZE1hcCBpbnN0YW5jZW9mIFNvcnRlZE1hcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc29ydGVkTWFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlIGluZGV4IGV4aXN0cywgYnV0IGl0IGZhbGxzIGJhY2sgdG8ganVzdCBuYW1lIGNvbXBhcmlzb24uIFJldHVybiBudWxsIHNvIHRoYXQgdGhlIGNhbGxpbmcgY29kZSB1c2VzIHRoZVxyXG4gICAgICAgICAgICAvLyByZWd1bGFyIGNoaWxkIG1hcFxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYXNJbmRleChpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gY29udGFpbnModGhpcy5pbmRleFNldF8sIGluZGV4RGVmaW5pdGlvbi50b1N0cmluZygpKTtcclxuICAgIH1cclxuICAgIGFkZEluZGV4KGluZGV4RGVmaW5pdGlvbiwgZXhpc3RpbmdDaGlsZHJlbikge1xyXG4gICAgICAgIGFzc2VydChpbmRleERlZmluaXRpb24gIT09IEtFWV9JTkRFWCwgXCJLZXlJbmRleCBhbHdheXMgZXhpc3RzIGFuZCBpc24ndCBtZWFudCB0byBiZSBhZGRlZCB0byB0aGUgSW5kZXhNYXAuXCIpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkTGlzdCA9IFtdO1xyXG4gICAgICAgIGxldCBzYXdJbmRleGVkVmFsdWUgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBpdGVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXRJdGVyYXRvcihOYW1lZE5vZGUuV3JhcCk7XHJcbiAgICAgICAgbGV0IG5leHQgPSBpdGVyLmdldE5leHQoKTtcclxuICAgICAgICB3aGlsZSAobmV4dCkge1xyXG4gICAgICAgICAgICBzYXdJbmRleGVkVmFsdWUgPVxyXG4gICAgICAgICAgICAgICAgc2F3SW5kZXhlZFZhbHVlIHx8IGluZGV4RGVmaW5pdGlvbi5pc0RlZmluZWRPbihuZXh0Lm5vZGUpO1xyXG4gICAgICAgICAgICBjaGlsZExpc3QucHVzaChuZXh0KTtcclxuICAgICAgICAgICAgbmV4dCA9IGl0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbmV3SW5kZXg7XHJcbiAgICAgICAgaWYgKHNhd0luZGV4ZWRWYWx1ZSkge1xyXG4gICAgICAgICAgICBuZXdJbmRleCA9IGJ1aWxkQ2hpbGRTZXQoY2hpbGRMaXN0LCBpbmRleERlZmluaXRpb24uZ2V0Q29tcGFyZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld0luZGV4ID0gZmFsbGJhY2tPYmplY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGluZGV4TmFtZSA9IGluZGV4RGVmaW5pdGlvbi50b1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IG5ld0luZGV4U2V0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5pbmRleFNldF8pO1xyXG4gICAgICAgIG5ld0luZGV4U2V0W2luZGV4TmFtZV0gPSBpbmRleERlZmluaXRpb247XHJcbiAgICAgICAgY29uc3QgbmV3SW5kZXhlcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaW5kZXhlc18pO1xyXG4gICAgICAgIG5ld0luZGV4ZXNbaW5kZXhOYW1lXSA9IG5ld0luZGV4O1xyXG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhNYXAobmV3SW5kZXhlcywgbmV3SW5kZXhTZXQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmUgdGhhdCB0aGlzIG5vZGUgaXMgcHJvcGVybHkgdHJhY2tlZCBpbiBhbnkgaW5kZXhlcyB0aGF0IHdlJ3JlIG1haW50YWluaW5nXHJcbiAgICAgKi9cclxuICAgIGFkZFRvSW5kZXhlcyhuYW1lZE5vZGUsIGV4aXN0aW5nQ2hpbGRyZW4pIHtcclxuICAgICAgICBjb25zdCBuZXdJbmRleGVzID0gbWFwKHRoaXMuaW5kZXhlc18sIChpbmRleGVkQ2hpbGRyZW4sIGluZGV4TmFtZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHNhZmVHZXQodGhpcy5pbmRleFNldF8sIGluZGV4TmFtZSk7XHJcbiAgICAgICAgICAgIGFzc2VydChpbmRleCwgJ01pc3NpbmcgaW5kZXggaW1wbGVtZW50YXRpb24gZm9yICcgKyBpbmRleE5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXhlZENoaWxkcmVuID09PSBmYWxsYmFja09iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIG5lZWQgdG8gaW5kZXggZXZlcnl0aGluZ1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4LmlzRGVmaW5lZE9uKG5hbWVkTm9kZS5ub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYnVpbGQgdGhpcyBpbmRleFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkTGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldEl0ZXJhdG9yKE5hbWVkTm9kZS5XcmFwKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGl0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Lm5hbWUgIT09IG5hbWVkTm9kZS5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZExpc3QucHVzaChuZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gaXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTGlzdC5wdXNoKG5hbWVkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkQ2hpbGRTZXQoY2hpbGRMaXN0LCBpbmRleC5nZXRDb21wYXJlKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gY2hhbmdlLCB0aGlzIHJlbWFpbnMgYSBmYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxsYmFja09iamVjdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nU25hcCA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5hbWVkTm9kZS5uYW1lKTtcclxuICAgICAgICAgICAgICAgIGxldCBuZXdDaGlsZHJlbiA9IGluZGV4ZWRDaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1NuYXApIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IG5ld0NoaWxkcmVuLnJlbW92ZShuZXcgTmFtZWROb2RlKG5hbWVkTm9kZS5uYW1lLCBleGlzdGluZ1NuYXApKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZHJlbi5pbnNlcnQobmFtZWROb2RlLCBuYW1lZE5vZGUubm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IEluZGV4TWFwKG5ld0luZGV4ZXMsIHRoaXMuaW5kZXhTZXRfKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IEluZGV4TWFwIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIHZhbHVlIHJlbW92ZWRcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlRnJvbUluZGV4ZXMobmFtZWROb2RlLCBleGlzdGluZ0NoaWxkcmVuKSB7XHJcbiAgICAgICAgY29uc3QgbmV3SW5kZXhlcyA9IG1hcCh0aGlzLmluZGV4ZXNfLCAoaW5kZXhlZENoaWxkcmVuKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleGVkQ2hpbGRyZW4gPT09IGZhbGxiYWNrT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmYWxsYmFjay4gSnVzdCByZXR1cm4gaXQsIG5vdGhpbmcgdG8gZG8gaW4gdGhpcyBjYXNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhlZENoaWxkcmVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdTbmFwID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmFtZWROb2RlLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nU25hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleGVkQ2hpbGRyZW4ucmVtb3ZlKG5ldyBOYW1lZE5vZGUobmFtZWROb2RlLm5hbWUsIGV4aXN0aW5nU25hcCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gcmVjb3JkIG9mIHRoaXMgY2hpbGRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhlZENoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleE1hcChuZXdJbmRleGVzLCB0aGlzLmluZGV4U2V0Xyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gVE9ETzogRm9yIG1lbW9yeSBzYXZpbmdzLCBkb24ndCBzdG9yZSBwcmlvcml0eU5vZGVfIGlmIGl0J3MgZW1wdHkuXHJcbmxldCBFTVBUWV9OT0RFO1xyXG4vKipcclxuICogQ2hpbGRyZW5Ob2RlIGlzIGEgY2xhc3MgZm9yIHN0b3JpbmcgaW50ZXJuYWwgbm9kZXMgaW4gYSBEYXRhU25hcHNob3RcclxuICogKGkuZS4gbm9kZXMgd2l0aCBjaGlsZHJlbikuICBJdCBpbXBsZW1lbnRzIE5vZGUgYW5kIHN0b3JlcyB0aGVcclxuICogbGlzdCBvZiBjaGlsZHJlbiBpbiB0aGUgY2hpbGRyZW4gcHJvcGVydHksIHNvcnRlZCBieSBjaGlsZCBuYW1lLlxyXG4gKi9cclxuY2xhc3MgQ2hpbGRyZW5Ob2RlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNoaWxkcmVuXyAtIExpc3Qgb2YgY2hpbGRyZW4gb2YgdGhpcyBub2RlLi5cclxuICAgICAqIEBwYXJhbSBwcmlvcml0eU5vZGVfIC0gVGhlIHByaW9yaXR5IG9mIHRoaXMgbm9kZSAoYXMgYSBzbmFwc2hvdCBub2RlKS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW5fLCBwcmlvcml0eU5vZGVfLCBpbmRleE1hcF8pIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuXyA9IGNoaWxkcmVuXztcclxuICAgICAgICB0aGlzLnByaW9yaXR5Tm9kZV8gPSBwcmlvcml0eU5vZGVfO1xyXG4gICAgICAgIHRoaXMuaW5kZXhNYXBfID0gaW5kZXhNYXBfO1xyXG4gICAgICAgIHRoaXMubGF6eUhhc2hfID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOb3RlOiBUaGUgb25seSByZWFzb24gd2UgYWxsb3cgbnVsbCBwcmlvcml0eSBpcyBmb3IgRU1QVFlfTk9ERSwgc2luY2Ugd2UgY2FuJ3QgdXNlXHJcbiAgICAgICAgICogRU1QVFlfTk9ERSBhcyB0aGUgcHJpb3JpdHkgb2YgRU1QVFlfTk9ERS4gIFdlIG1pZ2h0IHdhbnQgdG8gY29uc2lkZXIgbWFraW5nIEVNUFRZX05PREUgaXRzIG93blxyXG4gICAgICAgICAqIGNsYXNzIGluc3RlYWQgb2YgYW4gZW1wdHkgQ2hpbGRyZW5Ob2RlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmICh0aGlzLnByaW9yaXR5Tm9kZV8pIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVQcmlvcml0eU5vZGUodGhpcy5wcmlvcml0eU5vZGVfKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5fLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICBhc3NlcnQoIXRoaXMucHJpb3JpdHlOb2RlXyB8fCB0aGlzLnByaW9yaXR5Tm9kZV8uaXNFbXB0eSgpLCAnQW4gZW1wdHkgbm9kZSBjYW5ub3QgaGF2ZSBhIHByaW9yaXR5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBFTVBUWV9OT0RFKCkge1xyXG4gICAgICAgIHJldHVybiAoRU1QVFlfTk9ERSB8fFxyXG4gICAgICAgICAgICAoRU1QVFlfTk9ERSA9IG5ldyBDaGlsZHJlbk5vZGUobmV3IFNvcnRlZE1hcChOQU1FX0NPTVBBUkFUT1IpLCBudWxsLCBJbmRleE1hcC5EZWZhdWx0KSkpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBpc0xlYWZOb2RlKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgZ2V0UHJpb3JpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpb3JpdHlOb2RlXyB8fCBFTVBUWV9OT0RFO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICB1cGRhdGVQcmlvcml0eShuZXdQcmlvcml0eU5vZGUpIHtcclxuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbl8uaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIC8vIERvbid0IGFsbG93IHByaW9yaXRpZXMgb24gZW1wdHkgbm9kZXNcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZSh0aGlzLmNoaWxkcmVuXywgbmV3UHJpb3JpdHlOb2RlLCB0aGlzLmluZGV4TWFwXyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBnZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICAvLyBIYWNrIHRvIHRyZWF0IHByaW9yaXR5IGFzIGEgcmVndWxhciBjaGlsZFxyXG4gICAgICAgIGlmIChjaGlsZE5hbWUgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFByaW9yaXR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5fLmdldChjaGlsZE5hbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQgPT09IG51bGwgPyBFTVBUWV9OT0RFIDogY2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBnZXRDaGlsZChwYXRoKSB7XHJcbiAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICAgICAgaWYgKGZyb250ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRJbW1lZGlhdGVDaGlsZChmcm9udCkuZ2V0Q2hpbGQocGF0aFBvcEZyb250KHBhdGgpKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgaGFzQ2hpbGQoY2hpbGROYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmdldChjaGlsZE5hbWUpICE9PSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICB1cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUsIG5ld0NoaWxkTm9kZSkge1xyXG4gICAgICAgIGFzc2VydChuZXdDaGlsZE5vZGUsICdXZSBzaG91bGQgYWx3YXlzIGJlIHBhc3Npbmcgc25hcHNob3Qgbm9kZXMnKTtcclxuICAgICAgICBpZiAoY2hpbGROYW1lID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVQcmlvcml0eShuZXdDaGlsZE5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZWROb2RlID0gbmV3IE5hbWVkTm9kZShjaGlsZE5hbWUsIG5ld0NoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgIGxldCBuZXdDaGlsZHJlbiwgbmV3SW5kZXhNYXA7XHJcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZE5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW5fLnJlbW92ZShjaGlsZE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgbmV3SW5kZXhNYXAgPSB0aGlzLmluZGV4TWFwXy5yZW1vdmVGcm9tSW5kZXhlcyhuYW1lZE5vZGUsIHRoaXMuY2hpbGRyZW5fKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbl8uaW5zZXJ0KGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKTtcclxuICAgICAgICAgICAgICAgIG5ld0luZGV4TWFwID0gdGhpcy5pbmRleE1hcF8uYWRkVG9JbmRleGVzKG5hbWVkTm9kZSwgdGhpcy5jaGlsZHJlbl8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ByaW9yaXR5ID0gbmV3Q2hpbGRyZW4uaXNFbXB0eSgpXHJcbiAgICAgICAgICAgICAgICA/IEVNUFRZX05PREVcclxuICAgICAgICAgICAgICAgIDogdGhpcy5wcmlvcml0eU5vZGVfO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZShuZXdDaGlsZHJlbiwgbmV3UHJpb3JpdHksIG5ld0luZGV4TWFwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIHVwZGF0ZUNoaWxkKHBhdGgsIG5ld0NoaWxkTm9kZSkge1xyXG4gICAgICAgIGNvbnN0IGZyb250ID0gcGF0aEdldEZyb250KHBhdGgpO1xyXG4gICAgICAgIGlmIChmcm9udCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3Q2hpbGROb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXNzZXJ0KHBhdGhHZXRGcm9udChwYXRoKSAhPT0gJy5wcmlvcml0eScgfHwgcGF0aEdldExlbmd0aChwYXRoKSA9PT0gMSwgJy5wcmlvcml0eSBtdXN0IGJlIHRoZSBsYXN0IHRva2VuIGluIGEgcGF0aCcpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdJbW1lZGlhdGVDaGlsZCA9IHRoaXMuZ2V0SW1tZWRpYXRlQ2hpbGQoZnJvbnQpLnVwZGF0ZUNoaWxkKHBhdGhQb3BGcm9udChwYXRoKSwgbmV3Q2hpbGROb2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlSW1tZWRpYXRlQ2hpbGQoZnJvbnQsIG5ld0ltbWVkaWF0ZUNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmlzRW1wdHkoKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgbnVtQ2hpbGRyZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmNvdW50KCk7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIHZhbChleHBvcnRGb3JtYXQpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xyXG4gICAgICAgIGxldCBudW1LZXlzID0gMCwgbWF4S2V5ID0gMCwgYWxsSW50ZWdlcktleXMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgb2JqW2tleV0gPSBjaGlsZE5vZGUudmFsKGV4cG9ydEZvcm1hdCk7XHJcbiAgICAgICAgICAgIG51bUtleXMrKztcclxuICAgICAgICAgICAgaWYgKGFsbEludGVnZXJLZXlzICYmIENoaWxkcmVuTm9kZS5JTlRFR0VSX1JFR0VYUF8udGVzdChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhLZXkgPSBNYXRoLm1heChtYXhLZXksIE51bWJlcihrZXkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFsbEludGVnZXJLZXlzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIWV4cG9ydEZvcm1hdCAmJiBhbGxJbnRlZ2VyS2V5cyAmJiBtYXhLZXkgPCAyICogbnVtS2V5cykge1xyXG4gICAgICAgICAgICAvLyBjb252ZXJ0IHRvIGFycmF5LlxyXG4gICAgICAgICAgICBjb25zdCBhcnJheSA9IFtdO1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICAgICAgICAgICAgYXJyYXlba2V5XSA9IG9ialtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChleHBvcnRGb3JtYXQgJiYgIXRoaXMuZ2V0UHJpb3JpdHkoKS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIG9ialsnLnByaW9yaXR5J10gPSB0aGlzLmdldFByaW9yaXR5KCkudmFsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGhhc2goKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGF6eUhhc2hfID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxldCB0b0hhc2ggPSAnJztcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0b0hhc2ggKz1cclxuICAgICAgICAgICAgICAgICAgICAncHJpb3JpdHk6JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5SGFzaFRleHQodGhpcy5nZXRQcmlvcml0eSgpLnZhbCgpKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc6JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgKGtleSwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEhhc2ggPSBjaGlsZE5vZGUuaGFzaCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkSGFzaCAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b0hhc2ggKz0gJzonICsga2V5ICsgJzonICsgY2hpbGRIYXNoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5sYXp5SGFzaF8gPSB0b0hhc2ggPT09ICcnID8gJycgOiBzaGExKHRvSGFzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmxhenlIYXNoXztcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgZ2V0UHJlZGVjZXNzb3JDaGlsZE5hbWUoY2hpbGROYW1lLCBjaGlsZE5vZGUsIGluZGV4KSB7XHJcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5yZXNvbHZlSW5kZXhfKGluZGV4KTtcclxuICAgICAgICBpZiAoaWR4KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZWRlY2Vzc29yID0gaWR4LmdldFByZWRlY2Vzc29yS2V5KG5ldyBOYW1lZE5vZGUoY2hpbGROYW1lLCBjaGlsZE5vZGUpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByZWRlY2Vzc29yID8gcHJlZGVjZXNzb3IubmFtZSA6IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8uZ2V0UHJlZGVjZXNzb3JLZXkoY2hpbGROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRGaXJzdENoaWxkTmFtZShpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXhEZWZpbml0aW9uKTtcclxuICAgICAgICBpZiAoaWR4KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbktleSA9IGlkeC5taW5LZXkoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1pbktleSAmJiBtaW5LZXkubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuXy5taW5LZXkoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRGaXJzdENoaWxkKGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGNvbnN0IG1pbktleSA9IHRoaXMuZ2V0Rmlyc3RDaGlsZE5hbWUoaW5kZXhEZWZpbml0aW9uKTtcclxuICAgICAgICBpZiAobWluS2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKG1pbktleSwgdGhpcy5jaGlsZHJlbl8uZ2V0KG1pbktleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhbiBpbmRleCwgcmV0dXJuIHRoZSBrZXkgbmFtZSBvZiB0aGUgbGFyZ2VzdCB2YWx1ZSB3ZSBoYXZlLCBhY2NvcmRpbmcgdG8gdGhhdCBpbmRleFxyXG4gICAgICovXHJcbiAgICBnZXRMYXN0Q2hpbGROYW1lKGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleERlZmluaXRpb24pO1xyXG4gICAgICAgIGlmIChpZHgpIHtcclxuICAgICAgICAgICAgY29uc3QgbWF4S2V5ID0gaWR4Lm1heEtleSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWF4S2V5ICYmIG1heEtleS5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLm1heEtleSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldExhc3RDaGlsZChpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICBjb25zdCBtYXhLZXkgPSB0aGlzLmdldExhc3RDaGlsZE5hbWUoaW5kZXhEZWZpbml0aW9uKTtcclxuICAgICAgICBpZiAobWF4S2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKG1heEtleSwgdGhpcy5jaGlsZHJlbl8uZ2V0KG1heEtleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yRWFjaENoaWxkKGluZGV4LCBhY3Rpb24pIHtcclxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXgpO1xyXG4gICAgICAgIGlmIChpZHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkeC5pbm9yZGVyVHJhdmVyc2FsKHdyYXBwZWROb2RlID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb24od3JhcHBlZE5vZGUubmFtZSwgd3JhcHBlZE5vZGUubm9kZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRJdGVyYXRvcihpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVyYXRvckZyb20oaW5kZXhEZWZpbml0aW9uLm1pblBvc3QoKSwgaW5kZXhEZWZpbml0aW9uKTtcclxuICAgIH1cclxuICAgIGdldEl0ZXJhdG9yRnJvbShzdGFydFBvc3QsIGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleERlZmluaXRpb24pO1xyXG4gICAgICAgIGlmIChpZHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkeC5nZXRJdGVyYXRvckZyb20oc3RhcnRQb3N0LCBrZXkgPT4ga2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5jaGlsZHJlbl8uZ2V0SXRlcmF0b3JGcm9tKHN0YXJ0UG9zdC5uYW1lLCBOYW1lZE5vZGUuV3JhcCk7XHJcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaXRlcmF0b3IucGVlaygpO1xyXG4gICAgICAgICAgICB3aGlsZSAobmV4dCAhPSBudWxsICYmIGluZGV4RGVmaW5pdGlvbi5jb21wYXJlKG5leHQsIHN0YXJ0UG9zdCkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBuZXh0ID0gaXRlcmF0b3IucGVlaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRSZXZlcnNlSXRlcmF0b3IoaW5kZXhEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShpbmRleERlZmluaXRpb24ubWF4UG9zdCgpLCBpbmRleERlZmluaXRpb24pO1xyXG4gICAgfVxyXG4gICAgZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShlbmRQb3N0LCBpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXhEZWZpbml0aW9uKTtcclxuICAgICAgICBpZiAoaWR4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpZHguZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShlbmRQb3N0LCBrZXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuY2hpbGRyZW5fLmdldFJldmVyc2VJdGVyYXRvckZyb20oZW5kUG9zdC5uYW1lLCBOYW1lZE5vZGUuV3JhcCk7XHJcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaXRlcmF0b3IucGVlaygpO1xyXG4gICAgICAgICAgICB3aGlsZSAobmV4dCAhPSBudWxsICYmIGluZGV4RGVmaW5pdGlvbi5jb21wYXJlKG5leHQsIGVuZFBvc3QpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgbmV4dCA9IGl0ZXJhdG9yLnBlZWsoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29tcGFyZVRvKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGlmIChvdGhlci5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG90aGVyLmlzTGVhZk5vZGUoKSB8fCBvdGhlci5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG90aGVyID09PSBNQVhfTk9ERSkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBNdXN0IGJlIGFub3RoZXIgbm9kZSB3aXRoIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB3aXRoSW5kZXgoaW5kZXhEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgaWYgKGluZGV4RGVmaW5pdGlvbiA9PT0gS0VZX0lOREVYIHx8XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBfLmhhc0luZGV4KGluZGV4RGVmaW5pdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleE1hcCA9IHRoaXMuaW5kZXhNYXBfLmFkZEluZGV4KGluZGV4RGVmaW5pdGlvbiwgdGhpcy5jaGlsZHJlbl8pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZSh0aGlzLmNoaWxkcmVuXywgdGhpcy5wcmlvcml0eU5vZGVfLCBuZXdJbmRleE1hcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNJbmRleGVkKGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4ID09PSBLRVlfSU5ERVggfHwgdGhpcy5pbmRleE1hcF8uaGFzSW5kZXgoaW5kZXgpO1xyXG4gICAgfVxyXG4gICAgZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvdGhlci5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgb3RoZXJDaGlsZHJlbk5vZGUgPSBvdGhlcjtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldFByaW9yaXR5KCkuZXF1YWxzKG90aGVyQ2hpbGRyZW5Ob2RlLmdldFByaW9yaXR5KCkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jaGlsZHJlbl8uY291bnQoKSA9PT0gb3RoZXJDaGlsZHJlbk5vZGUuY2hpbGRyZW5fLmNvdW50KCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRoaXNJdGVyID0gdGhpcy5nZXRJdGVyYXRvcihQUklPUklUWV9JTkRFWCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvdGhlckl0ZXIgPSBvdGhlckNoaWxkcmVuTm9kZS5nZXRJdGVyYXRvcihQUklPUklUWV9JTkRFWCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGhpc0N1cnJlbnQgPSB0aGlzSXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgb3RoZXJDdXJyZW50ID0gb3RoZXJJdGVyLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzQ3VycmVudCAmJiBvdGhlckN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc0N1cnJlbnQubmFtZSAhPT0gb3RoZXJDdXJyZW50Lm5hbWUgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXNDdXJyZW50Lm5vZGUuZXF1YWxzKG90aGVyQ3VycmVudC5ub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNDdXJyZW50ID0gdGhpc0l0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG90aGVyQ3VycmVudCA9IG90aGVySXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0N1cnJlbnQgPT09IG51bGwgJiYgb3RoZXJDdXJyZW50ID09PSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgU29ydGVkTWFwIG9yZGVyZWQgYnkgaW5kZXgsIG9yIG51bGwgaWYgdGhlIGRlZmF1bHQgKGJ5LWtleSkgb3JkZXJpbmcgY2FuIGJlIHVzZWRcclxuICAgICAqIGluc3RlYWQuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICByZXNvbHZlSW5kZXhfKGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGlmIChpbmRleERlZmluaXRpb24gPT09IEtFWV9JTkRFWCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4TWFwXy5nZXQoaW5kZXhEZWZpbml0aW9uLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5DaGlsZHJlbk5vZGUuSU5URUdFUl9SRUdFWFBfID0gL14oMHxbMS05XVxcZCopJC87XHJcbmNsYXNzIE1heE5vZGUgZXh0ZW5kcyBDaGlsZHJlbk5vZGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIobmV3IFNvcnRlZE1hcChOQU1FX0NPTVBBUkFUT1IpLCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgSW5kZXhNYXAuRGVmYXVsdCk7XHJcbiAgICB9XHJcbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcclxuICAgICAgICBpZiAob3RoZXIgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICAvLyBOb3QgdGhhdCB3ZSBldmVyeSBjb21wYXJlIGl0LCBidXQgTUFYX05PREUgaXMgb25seSBldmVyIGVxdWFsIHRvIGl0c2VsZlxyXG4gICAgICAgIHJldHVybiBvdGhlciA9PT0gdGhpcztcclxuICAgIH1cclxuICAgIGdldFByaW9yaXR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgfVxyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE1hcmtlciB0aGF0IHdpbGwgc29ydCBoaWdoZXIgdGhhbiBhbnkgb3RoZXIgc25hcHNob3QuXHJcbiAqL1xyXG5jb25zdCBNQVhfTk9ERSA9IG5ldyBNYXhOb2RlKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE5hbWVkTm9kZSwge1xyXG4gICAgTUlOOiB7XHJcbiAgICAgICAgdmFsdWU6IG5ldyBOYW1lZE5vZGUoTUlOX05BTUUsIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKVxyXG4gICAgfSxcclxuICAgIE1BWDoge1xyXG4gICAgICAgIHZhbHVlOiBuZXcgTmFtZWROb2RlKE1BWF9OQU1FLCBNQVhfTk9ERSlcclxuICAgIH1cclxufSk7XHJcbi8qKlxyXG4gKiBSZWZlcmVuY2UgRXh0ZW5zaW9uc1xyXG4gKi9cclxuS2V5SW5kZXguX19FTVBUWV9OT0RFID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbkxlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IgPSBDaGlsZHJlbk5vZGU7XHJcbnNldE1heE5vZGUkMShNQVhfTk9ERSk7XHJcbnNldE1heE5vZGUoTUFYX05PREUpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBVU0VfSElOWkUgPSB0cnVlO1xyXG4vKipcclxuICogQ29uc3RydWN0cyBhIHNuYXBzaG90IG5vZGUgcmVwcmVzZW50aW5nIHRoZSBwYXNzZWQgSlNPTiBhbmQgcmV0dXJucyBpdC5cclxuICogQHBhcmFtIGpzb24gLSBKU09OIHRvIGNyZWF0ZSBhIG5vZGUgZm9yLlxyXG4gKiBAcGFyYW0gcHJpb3JpdHkgLSBPcHRpb25hbCBwcmlvcml0eSB0byB1c2UuICBUaGlzIHdpbGwgYmUgaWdub3JlZCBpZiB0aGVcclxuICogcGFzc2VkIEpTT04gY29udGFpbnMgYSAucHJpb3JpdHkgcHJvcGVydHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBub2RlRnJvbUpTT04oanNvbiwgcHJpb3JpdHkgPSBudWxsKSB7XHJcbiAgICBpZiAoanNvbiA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YganNvbiA9PT0gJ29iamVjdCcgJiYgJy5wcmlvcml0eScgaW4ganNvbikge1xyXG4gICAgICAgIHByaW9yaXR5ID0ganNvblsnLnByaW9yaXR5J107XHJcbiAgICB9XHJcbiAgICBhc3NlcnQocHJpb3JpdHkgPT09IG51bGwgfHxcclxuICAgICAgICB0eXBlb2YgcHJpb3JpdHkgPT09ICdzdHJpbmcnIHx8XHJcbiAgICAgICAgdHlwZW9mIHByaW9yaXR5ID09PSAnbnVtYmVyJyB8fFxyXG4gICAgICAgICh0eXBlb2YgcHJpb3JpdHkgPT09ICdvYmplY3QnICYmICcuc3YnIGluIHByaW9yaXR5KSwgJ0ludmFsaWQgcHJpb3JpdHkgdHlwZSBmb3VuZDogJyArIHR5cGVvZiBwcmlvcml0eSk7XHJcbiAgICBpZiAodHlwZW9mIGpzb24gPT09ICdvYmplY3QnICYmICcudmFsdWUnIGluIGpzb24gJiYganNvblsnLnZhbHVlJ10gIT09IG51bGwpIHtcclxuICAgICAgICBqc29uID0ganNvblsnLnZhbHVlJ107XHJcbiAgICB9XHJcbiAgICAvLyBWYWxpZCBsZWFmIG5vZGVzIGluY2x1ZGUgbm9uLW9iamVjdHMgb3Igc2VydmVyLXZhbHVlIHdyYXBwZXIgb2JqZWN0c1xyXG4gICAgaWYgKHR5cGVvZiBqc29uICE9PSAnb2JqZWN0JyB8fCAnLnN2JyBpbiBqc29uKSB7XHJcbiAgICAgICAgY29uc3QganNvbkxlYWYgPSBqc29uO1xyXG4gICAgICAgIHJldHVybiBuZXcgTGVhZk5vZGUoanNvbkxlYWYsIG5vZGVGcm9tSlNPTihwcmlvcml0eSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKCEoanNvbiBpbnN0YW5jZW9mIEFycmF5KSAmJiBVU0VfSElOWkUpIHtcclxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgIGxldCBjaGlsZHJlbkhhdmVQcmlvcml0eSA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGhpbnplSnNvbk9iaiA9IGpzb247XHJcbiAgICAgICAgZWFjaChoaW56ZUpzb25PYmosIChrZXksIGNoaWxkKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChrZXkuc3Vic3RyaW5nKDAsIDEpICE9PSAnLicpIHtcclxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBtZXRhZGF0YSBub2Rlc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gbm9kZUZyb21KU09OKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIGlmICghY2hpbGROb2RlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuSGF2ZVByaW9yaXR5ID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5IYXZlUHJpb3JpdHkgfHwgIWNoaWxkTm9kZS5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5ldyBOYW1lZE5vZGUoa2V5LCBjaGlsZE5vZGUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjaGlsZFNldCA9IGJ1aWxkQ2hpbGRTZXQoY2hpbGRyZW4sIE5BTUVfT05MWV9DT01QQVJBVE9SLCBuYW1lZE5vZGUgPT4gbmFtZWROb2RlLm5hbWUsIE5BTUVfQ09NUEFSQVRPUik7XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuSGF2ZVByaW9yaXR5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNvcnRlZENoaWxkU2V0ID0gYnVpbGRDaGlsZFNldChjaGlsZHJlbiwgUFJJT1JJVFlfSU5ERVguZ2V0Q29tcGFyZSgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGlsZHJlbk5vZGUoY2hpbGRTZXQsIG5vZGVGcm9tSlNPTihwcmlvcml0eSksIG5ldyBJbmRleE1hcCh7ICcucHJpb3JpdHknOiBzb3J0ZWRDaGlsZFNldCB9LCB7ICcucHJpb3JpdHknOiBQUklPUklUWV9JTkRFWCB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZShjaGlsZFNldCwgbm9kZUZyb21KU09OKHByaW9yaXR5KSwgSW5kZXhNYXAuRGVmYXVsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICBlYWNoKGpzb24sIChrZXksIGNoaWxkRGF0YSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY29udGFpbnMoanNvbiwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdWJzdHJpbmcoMCwgMSkgIT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBtZXRhZGF0YSBub2Rlcy5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBub2RlRnJvbUpTT04oY2hpbGREYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlLmlzTGVhZk5vZGUoKSB8fCAhY2hpbGROb2RlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS51cGRhdGVJbW1lZGlhdGVDaGlsZChrZXksIGNoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUudXBkYXRlUHJpb3JpdHkobm9kZUZyb21KU09OKHByaW9yaXR5KSk7XHJcbiAgICB9XHJcbn1cclxuc2V0Tm9kZUZyb21KU09OKG5vZGVGcm9tSlNPTik7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIFBhdGhJbmRleCBleHRlbmRzIEluZGV4IHtcclxuICAgIGNvbnN0cnVjdG9yKGluZGV4UGF0aF8pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaW5kZXhQYXRoXyA9IGluZGV4UGF0aF87XHJcbiAgICAgICAgYXNzZXJ0KCFwYXRoSXNFbXB0eShpbmRleFBhdGhfKSAmJiBwYXRoR2V0RnJvbnQoaW5kZXhQYXRoXykgIT09ICcucHJpb3JpdHknLCBcIkNhbid0IGNyZWF0ZSBQYXRoSW5kZXggd2l0aCBlbXB0eSBwYXRoIG9yIC5wcmlvcml0eSBrZXlcIik7XHJcbiAgICB9XHJcbiAgICBleHRyYWN0Q2hpbGQoc25hcCkge1xyXG4gICAgICAgIHJldHVybiBzbmFwLmdldENoaWxkKHRoaXMuaW5kZXhQYXRoXyk7XHJcbiAgICB9XHJcbiAgICBpc0RlZmluZWRPbihub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuICFub2RlLmdldENoaWxkKHRoaXMuaW5kZXhQYXRoXykuaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgY29tcGFyZShhLCBiKSB7XHJcbiAgICAgICAgY29uc3QgYUNoaWxkID0gdGhpcy5leHRyYWN0Q2hpbGQoYS5ub2RlKTtcclxuICAgICAgICBjb25zdCBiQ2hpbGQgPSB0aGlzLmV4dHJhY3RDaGlsZChiLm5vZGUpO1xyXG4gICAgICAgIGNvbnN0IGluZGV4Q21wID0gYUNoaWxkLmNvbXBhcmVUbyhiQ2hpbGQpO1xyXG4gICAgICAgIGlmIChpbmRleENtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZUNvbXBhcmUoYS5uYW1lLCBiLm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4Q21wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1ha2VQb3N0KGluZGV4VmFsdWUsIG5hbWUpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSBub2RlRnJvbUpTT04oaW5kZXhWYWx1ZSk7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLnVwZGF0ZUNoaWxkKHRoaXMuaW5kZXhQYXRoXywgdmFsdWVOb2RlKTtcclxuICAgICAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShuYW1lLCBub2RlKTtcclxuICAgIH1cclxuICAgIG1heFBvc3QoKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLnVwZGF0ZUNoaWxkKHRoaXMuaW5kZXhQYXRoXywgTUFYX05PREUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKE1BWF9OQU1FLCBub2RlKTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBwYXRoU2xpY2UodGhpcy5pbmRleFBhdGhfLCAwKS5qb2luKCcvJyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgVmFsdWVJbmRleCBleHRlbmRzIEluZGV4IHtcclxuICAgIGNvbXBhcmUoYSwgYikge1xyXG4gICAgICAgIGNvbnN0IGluZGV4Q21wID0gYS5ub2RlLmNvbXBhcmVUbyhiLm5vZGUpO1xyXG4gICAgICAgIGlmIChpbmRleENtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZUNvbXBhcmUoYS5uYW1lLCBiLm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4Q21wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzRGVmaW5lZE9uKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGluZGV4ZWRWYWx1ZUNoYW5nZWQob2xkTm9kZSwgbmV3Tm9kZSkge1xyXG4gICAgICAgIHJldHVybiAhb2xkTm9kZS5lcXVhbHMobmV3Tm9kZSk7XHJcbiAgICB9XHJcbiAgICBtaW5Qb3N0KCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcmV0dXJuIE5hbWVkTm9kZS5NSU47XHJcbiAgICB9XHJcbiAgICBtYXhQb3N0KCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcmV0dXJuIE5hbWVkTm9kZS5NQVg7XHJcbiAgICB9XHJcbiAgICBtYWtlUG9zdChpbmRleFZhbHVlLCBuYW1lKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gbm9kZUZyb21KU09OKGluZGV4VmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKG5hbWUsIHZhbHVlTm9kZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFN0cmluZyByZXByZXNlbnRhdGlvbiBmb3IgaW5jbHVzaW9uIGluIGEgcXVlcnkgc3BlY1xyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gJy52YWx1ZSc7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgVkFMVUVfSU5ERVggPSBuZXcgVmFsdWVJbmRleCgpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBjaGFuZ2VWYWx1ZShzbmFwc2hvdE5vZGUpIHtcclxuICAgIHJldHVybiB7IHR5cGU6IFwidmFsdWVcIiAvKiBDaGFuZ2VUeXBlLlZBTFVFICovLCBzbmFwc2hvdE5vZGUgfTtcclxufVxyXG5mdW5jdGlvbiBjaGFuZ2VDaGlsZEFkZGVkKGNoaWxkTmFtZSwgc25hcHNob3ROb2RlKSB7XHJcbiAgICByZXR1cm4geyB0eXBlOiBcImNoaWxkX2FkZGVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9BRERFRCAqLywgc25hcHNob3ROb2RlLCBjaGlsZE5hbWUgfTtcclxufVxyXG5mdW5jdGlvbiBjaGFuZ2VDaGlsZFJlbW92ZWQoY2hpbGROYW1lLCBzbmFwc2hvdE5vZGUpIHtcclxuICAgIHJldHVybiB7IHR5cGU6IFwiY2hpbGRfcmVtb3ZlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfUkVNT1ZFRCAqLywgc25hcHNob3ROb2RlLCBjaGlsZE5hbWUgfTtcclxufVxyXG5mdW5jdGlvbiBjaGFuZ2VDaGlsZENoYW5nZWQoY2hpbGROYW1lLCBzbmFwc2hvdE5vZGUsIG9sZFNuYXApIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJjaGlsZF9jaGFuZ2VkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9DSEFOR0VEICovLFxyXG4gICAgICAgIHNuYXBzaG90Tm9kZSxcclxuICAgICAgICBjaGlsZE5hbWUsXHJcbiAgICAgICAgb2xkU25hcFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjaGFuZ2VDaGlsZE1vdmVkKGNoaWxkTmFtZSwgc25hcHNob3ROb2RlKSB7XHJcbiAgICByZXR1cm4geyB0eXBlOiBcImNoaWxkX21vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9NT1ZFRCAqLywgc25hcHNob3ROb2RlLCBjaGlsZE5hbWUgfTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRG9lc24ndCByZWFsbHkgZmlsdGVyIG5vZGVzIGJ1dCBhcHBsaWVzIGFuIGluZGV4IHRvIHRoZSBub2RlIGFuZCBrZWVwcyB0cmFjayBvZiBhbnkgY2hhbmdlc1xyXG4gKi9cclxuY2xhc3MgSW5kZXhlZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihpbmRleF8pIHtcclxuICAgICAgICB0aGlzLmluZGV4XyA9IGluZGV4XztcclxuICAgIH1cclxuICAgIHVwZGF0ZUNoaWxkKHNuYXAsIGtleSwgbmV3Q2hpbGQsIGFmZmVjdGVkUGF0aCwgc291cmNlLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcikge1xyXG4gICAgICAgIGFzc2VydChzbmFwLmlzSW5kZXhlZCh0aGlzLmluZGV4XyksICdBIG5vZGUgbXVzdCBiZSBpbmRleGVkIGlmIG9ubHkgYSBjaGlsZCBpcyB1cGRhdGVkJyk7XHJcbiAgICAgICAgY29uc3Qgb2xkQ2hpbGQgPSBzbmFwLmdldEltbWVkaWF0ZUNoaWxkKGtleSk7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgYW55dGhpbmcgYWN0dWFsbHkgY2hhbmdlZC5cclxuICAgICAgICBpZiAob2xkQ2hpbGQuZ2V0Q2hpbGQoYWZmZWN0ZWRQYXRoKS5lcXVhbHMobmV3Q2hpbGQuZ2V0Q2hpbGQoYWZmZWN0ZWRQYXRoKSkpIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUncyBhbiBlZGdlIGNhc2Ugd2hlcmUgYSBjaGlsZCBjYW4gZW50ZXIgb3IgbGVhdmUgdGhlIHZpZXcgYmVjYXVzZSBhZmZlY3RlZFBhdGggd2FzIHNldCB0byBudWxsLlxyXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIGFmZmVjdGVkUGF0aCB3aWxsIGFwcGVhciBudWxsIGluIGJvdGggdGhlIG9sZCBhbmQgbmV3IHNuYXBzaG90cy4gIFNvIHdlIG5lZWRcclxuICAgICAgICAgICAgLy8gdG8gYXZvaWQgdHJlYXRpbmcgdGhlc2UgY2FzZXMgYXMgXCJub3RoaW5nIGNoYW5nZWQuXCJcclxuICAgICAgICAgICAgaWYgKG9sZENoaWxkLmlzRW1wdHkoKSA9PT0gbmV3Q2hpbGQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIGNoYW5nZWQuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFzc2VydCBzaG91bGQgYmUgdmFsaWQsIGJ1dCBpdCdzIGV4cGVuc2l2ZSAoY2FuIGRvbWluYXRlIHBlcmYgdGVzdGluZykgc28gZG9uJ3QgYWN0dWFsbHkgZG8gaXQuXHJcbiAgICAgICAgICAgICAgICAvL2Fzc2VydChvbGRDaGlsZC5lcXVhbHMobmV3Q2hpbGQpLCAnT2xkIGFuZCBuZXcgc25hcHNob3RzIHNob3VsZCBiZSBlcXVhbC4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRDaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzbmFwLmhhc0NoaWxkKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkUmVtb3ZlZChrZXksIG9sZENoaWxkKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoc25hcC5pc0xlYWZOb2RlKCksICdBIGNoaWxkIHJlbW92ZSB3aXRob3V0IGFuIG9sZCBjaGlsZCBvbmx5IG1ha2VzIHNlbnNlIG9uIGEgbGVhZiBub2RlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob2xkQ2hpbGQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQWRkZWQoa2V5LCBuZXdDaGlsZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3B0Q2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShjaGFuZ2VDaGlsZENoYW5nZWQoa2V5LCBuZXdDaGlsZCwgb2xkQ2hpbGQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc25hcC5pc0xlYWZOb2RlKCkgJiYgbmV3Q2hpbGQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBub2RlIGlzIGluZGV4ZWRcclxuICAgICAgICAgICAgcmV0dXJuIHNuYXAudXBkYXRlSW1tZWRpYXRlQ2hpbGQoa2V5LCBuZXdDaGlsZCkud2l0aEluZGV4KHRoaXMuaW5kZXhfKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVGdWxsTm9kZShvbGRTbmFwLCBuZXdTbmFwLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcikge1xyXG4gICAgICAgIGlmIChvcHRDaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICghb2xkU25hcC5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgICAgIG9sZFNuYXAuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1NuYXAuaGFzQ2hpbGQoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkUmVtb3ZlZChrZXksIGNoaWxkTm9kZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbmV3U25hcC5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgICAgIG5ld1NuYXAuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2xkU25hcC5oYXNDaGlsZChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZENoaWxkID0gb2xkU25hcC5nZXRJbW1lZGlhdGVDaGlsZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9sZENoaWxkLmVxdWFscyhjaGlsZE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQ2hhbmdlZChrZXksIGNoaWxkTm9kZSwgb2xkQ2hpbGQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0Q2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShjaGFuZ2VDaGlsZEFkZGVkKGtleSwgY2hpbGROb2RlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld1NuYXAud2l0aEluZGV4KHRoaXMuaW5kZXhfKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVByaW9yaXR5KG9sZFNuYXAsIG5ld1ByaW9yaXR5KSB7XHJcbiAgICAgICAgaWYgKG9sZFNuYXAuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvbGRTbmFwLnVwZGF0ZVByaW9yaXR5KG5ld1ByaW9yaXR5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmaWx0ZXJzTm9kZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXhlZEZpbHRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGdldEluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4XztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRmlsdGVycyBub2RlcyBieSByYW5nZSBhbmQgdXNlcyBhbiBJbmRleEZpbHRlciB0byB0cmFjayBhbnkgY2hhbmdlcyBhZnRlciBmaWx0ZXJpbmcgdGhlIG5vZGVcclxuICovXHJcbmNsYXNzIFJhbmdlZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcclxuICAgICAgICB0aGlzLmluZGV4ZWRGaWx0ZXJfID0gbmV3IEluZGV4ZWRGaWx0ZXIocGFyYW1zLmdldEluZGV4KCkpO1xyXG4gICAgICAgIHRoaXMuaW5kZXhfID0gcGFyYW1zLmdldEluZGV4KCk7XHJcbiAgICAgICAgdGhpcy5zdGFydFBvc3RfID0gUmFuZ2VkRmlsdGVyLmdldFN0YXJ0UG9zdF8ocGFyYW1zKTtcclxuICAgICAgICB0aGlzLmVuZFBvc3RfID0gUmFuZ2VkRmlsdGVyLmdldEVuZFBvc3RfKHBhcmFtcyk7XHJcbiAgICAgICAgdGhpcy5zdGFydElzSW5jbHVzaXZlXyA9ICFwYXJhbXMuc3RhcnRBZnRlclNldF87XHJcbiAgICAgICAgdGhpcy5lbmRJc0luY2x1c2l2ZV8gPSAhcGFyYW1zLmVuZEJlZm9yZVNldF87XHJcbiAgICB9XHJcbiAgICBnZXRTdGFydFBvc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRQb3N0XztcclxuICAgIH1cclxuICAgIGdldEVuZFBvc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kUG9zdF87XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKG5vZGUpIHtcclxuICAgICAgICBjb25zdCBpc1dpdGhpblN0YXJ0ID0gdGhpcy5zdGFydElzSW5jbHVzaXZlX1xyXG4gICAgICAgICAgICA/IHRoaXMuaW5kZXhfLmNvbXBhcmUodGhpcy5nZXRTdGFydFBvc3QoKSwgbm9kZSkgPD0gMFxyXG4gICAgICAgICAgICA6IHRoaXMuaW5kZXhfLmNvbXBhcmUodGhpcy5nZXRTdGFydFBvc3QoKSwgbm9kZSkgPCAwO1xyXG4gICAgICAgIGNvbnN0IGlzV2l0aGluRW5kID0gdGhpcy5lbmRJc0luY2x1c2l2ZV9cclxuICAgICAgICAgICAgPyB0aGlzLmluZGV4Xy5jb21wYXJlKG5vZGUsIHRoaXMuZ2V0RW5kUG9zdCgpKSA8PSAwXHJcbiAgICAgICAgICAgIDogdGhpcy5pbmRleF8uY29tcGFyZShub2RlLCB0aGlzLmdldEVuZFBvc3QoKSkgPCAwO1xyXG4gICAgICAgIHJldHVybiBpc1dpdGhpblN0YXJ0ICYmIGlzV2l0aGluRW5kO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQ2hpbGQoc25hcCwga2V5LCBuZXdDaGlsZCwgYWZmZWN0ZWRQYXRoLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm1hdGNoZXMobmV3IE5hbWVkTm9kZShrZXksIG5ld0NoaWxkKSkpIHtcclxuICAgICAgICAgICAgbmV3Q2hpbGQgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhlZEZpbHRlcl8udXBkYXRlQ2hpbGQoc25hcCwga2V5LCBuZXdDaGlsZCwgYWZmZWN0ZWRQYXRoLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUZ1bGxOb2RlKG9sZFNuYXAsIG5ld1NuYXAsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgaWYgKG5ld1NuYXAuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgY2hpbGRyZW4gbm9kZSB3aXRoIHRoZSBjb3JyZWN0IGluZGV4LCBub3QgYSBsZWFmIG5vZGU7XHJcbiAgICAgICAgICAgIG5ld1NuYXAgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGZpbHRlcmVkID0gbmV3U25hcC53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xyXG4gICAgICAgIC8vIERvbid0IHN1cHBvcnQgcHJpb3JpdGllcyBvbiBxdWVyaWVzXHJcbiAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC51cGRhdGVQcmlvcml0eShDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSk7XHJcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgbmV3U25hcC5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIChrZXksIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXNlbGYubWF0Y2hlcyhuZXcgTmFtZWROb2RlKGtleSwgY2hpbGROb2RlKSkpIHtcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQudXBkYXRlSW1tZWRpYXRlQ2hpbGQoa2V5LCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleGVkRmlsdGVyXy51cGRhdGVGdWxsTm9kZShvbGRTbmFwLCBmaWx0ZXJlZCwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUHJpb3JpdHkob2xkU25hcCwgbmV3UHJpb3JpdHkpIHtcclxuICAgICAgICAvLyBEb24ndCBzdXBwb3J0IHByaW9yaXRpZXMgb24gcXVlcmllc1xyXG4gICAgICAgIHJldHVybiBvbGRTbmFwO1xyXG4gICAgfVxyXG4gICAgZmlsdGVyc05vZGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXhlZEZpbHRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleGVkRmlsdGVyXztcclxuICAgIH1cclxuICAgIGdldEluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4XztcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRTdGFydFBvc3RfKHBhcmFtcykge1xyXG4gICAgICAgIGlmIChwYXJhbXMuaGFzU3RhcnQoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBzdGFydE5hbWUgPSBwYXJhbXMuZ2V0SW5kZXhTdGFydE5hbWUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5nZXRJbmRleCgpLm1ha2VQb3N0KHBhcmFtcy5nZXRJbmRleFN0YXJ0VmFsdWUoKSwgc3RhcnROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXMuZ2V0SW5kZXgoKS5taW5Qb3N0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldEVuZFBvc3RfKHBhcmFtcykge1xyXG4gICAgICAgIGlmIChwYXJhbXMuaGFzRW5kKCkpIHtcclxuICAgICAgICAgICAgY29uc3QgZW5kTmFtZSA9IHBhcmFtcy5nZXRJbmRleEVuZE5hbWUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5nZXRJbmRleCgpLm1ha2VQb3N0KHBhcmFtcy5nZXRJbmRleEVuZFZhbHVlKCksIGVuZE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5nZXRJbmRleCgpLm1heFBvc3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFwcGxpZXMgYSBsaW1pdCBhbmQgYSByYW5nZSB0byBhIG5vZGUgYW5kIHVzZXMgUmFuZ2VkRmlsdGVyIHRvIGRvIHRoZSBoZWF2eSBsaWZ0aW5nIHdoZXJlIHBvc3NpYmxlXHJcbiAqL1xyXG5jbGFzcyBMaW1pdGVkRmlsdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xyXG4gICAgICAgIHRoaXMud2l0aGluRGlyZWN0aW9uYWxTdGFydCA9IChub2RlKSA9PiB0aGlzLnJldmVyc2VfID8gdGhpcy53aXRoaW5FbmRQb3N0KG5vZGUpIDogdGhpcy53aXRoaW5TdGFydFBvc3Qobm9kZSk7XHJcbiAgICAgICAgdGhpcy53aXRoaW5EaXJlY3Rpb25hbEVuZCA9IChub2RlKSA9PiB0aGlzLnJldmVyc2VfID8gdGhpcy53aXRoaW5TdGFydFBvc3Qobm9kZSkgOiB0aGlzLndpdGhpbkVuZFBvc3Qobm9kZSk7XHJcbiAgICAgICAgdGhpcy53aXRoaW5TdGFydFBvc3QgPSAobm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb21wYXJlUmVzID0gdGhpcy5pbmRleF8uY29tcGFyZSh0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0U3RhcnRQb3N0KCksIG5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydElzSW5jbHVzaXZlXyA/IGNvbXBhcmVSZXMgPD0gMCA6IGNvbXBhcmVSZXMgPCAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy53aXRoaW5FbmRQb3N0ID0gKG5vZGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29tcGFyZVJlcyA9IHRoaXMuaW5kZXhfLmNvbXBhcmUobm9kZSwgdGhpcy5yYW5nZWRGaWx0ZXJfLmdldEVuZFBvc3QoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZElzSW5jbHVzaXZlXyA/IGNvbXBhcmVSZXMgPD0gMCA6IGNvbXBhcmVSZXMgPCAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5yYW5nZWRGaWx0ZXJfID0gbmV3IFJhbmdlZEZpbHRlcihwYXJhbXMpO1xyXG4gICAgICAgIHRoaXMuaW5kZXhfID0gcGFyYW1zLmdldEluZGV4KCk7XHJcbiAgICAgICAgdGhpcy5saW1pdF8gPSBwYXJhbXMuZ2V0TGltaXQoKTtcclxuICAgICAgICB0aGlzLnJldmVyc2VfID0gIXBhcmFtcy5pc1ZpZXdGcm9tTGVmdCgpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRJc0luY2x1c2l2ZV8gPSAhcGFyYW1zLnN0YXJ0QWZ0ZXJTZXRfO1xyXG4gICAgICAgIHRoaXMuZW5kSXNJbmNsdXNpdmVfID0gIXBhcmFtcy5lbmRCZWZvcmVTZXRfO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQ2hpbGQoc25hcCwga2V5LCBuZXdDaGlsZCwgYWZmZWN0ZWRQYXRoLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJhbmdlZEZpbHRlcl8ubWF0Y2hlcyhuZXcgTmFtZWROb2RlKGtleSwgbmV3Q2hpbGQpKSkge1xyXG4gICAgICAgICAgICBuZXdDaGlsZCA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc25hcC5nZXRJbW1lZGlhdGVDaGlsZChrZXkpLmVxdWFscyhuZXdDaGlsZCkpIHtcclxuICAgICAgICAgICAgLy8gTm8gY2hhbmdlXHJcbiAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzbmFwLm51bUNoaWxkcmVuKCkgPCB0aGlzLmxpbWl0Xykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yYW5nZWRGaWx0ZXJfXHJcbiAgICAgICAgICAgICAgICAuZ2V0SW5kZXhlZEZpbHRlcigpXHJcbiAgICAgICAgICAgICAgICAudXBkYXRlQ2hpbGQoc25hcCwga2V5LCBuZXdDaGlsZCwgYWZmZWN0ZWRQYXRoLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bGxMaW1pdFVwZGF0ZUNoaWxkXyhzbmFwLCBrZXksIG5ld0NoaWxkLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVGdWxsTm9kZShvbGRTbmFwLCBuZXdTbmFwLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcikge1xyXG4gICAgICAgIGxldCBmaWx0ZXJlZDtcclxuICAgICAgICBpZiAobmV3U25hcC5pc0xlYWZOb2RlKCkgfHwgbmV3U25hcC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBjaGlsZHJlbiBub2RlIHdpdGggdGhlIGNvcnJlY3QgaW5kZXgsIG5vdCBhIGxlYWYgbm9kZTtcclxuICAgICAgICAgICAgZmlsdGVyZWQgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERS53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGltaXRfICogMiA8IG5ld1NuYXAubnVtQ2hpbGRyZW4oKSAmJlxyXG4gICAgICAgICAgICAgICAgbmV3U25hcC5pc0luZGV4ZWQodGhpcy5pbmRleF8pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFYXNpZXIgdG8gYnVpbGQgdXAgYSBzbmFwc2hvdCwgc2luY2Ugd2hhdCB3ZSdyZSBnaXZlbiBoYXMgbW9yZSB0aGFuIHR3aWNlIHRoZSBlbGVtZW50cyB3ZSB3YW50XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZCA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLndpdGhJbmRleCh0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgICAgICAgICAvLyBhbmNob3IgdG8gdGhlIHN0YXJ0UG9zdCwgZW5kUG9zdCwgb3IgbGFzdCBlbGVtZW50IGFzIGFwcHJvcHJpYXRlXHJcbiAgICAgICAgICAgICAgICBsZXQgaXRlcmF0b3I7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXZlcnNlXykge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gbmV3U25hcC5nZXRSZXZlcnNlSXRlcmF0b3JGcm9tKHRoaXMucmFuZ2VkRmlsdGVyXy5nZXRFbmRQb3N0KCksIHRoaXMuaW5kZXhfKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gbmV3U25hcC5nZXRJdGVyYXRvckZyb20odGhpcy5yYW5nZWRGaWx0ZXJfLmdldFN0YXJ0UG9zdCgpLCB0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGl0ZXJhdG9yLmhhc05leHQoKSAmJiBjb3VudCA8IHRoaXMubGltaXRfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZXJhdG9yLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMud2l0aGluRGlyZWN0aW9uYWxTdGFydChuZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIG5vdCByZWFjaGVkIHRoZSBzdGFydCwgc2tpcCB0byB0aGUgbmV4dCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy53aXRoaW5EaXJlY3Rpb25hbEVuZChuZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIHJlYWNoZWQgdGhlIGVuZCwgc3RvcCBhZGRpbmcgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKG5leHQubmFtZSwgbmV4dC5ub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgc25hcCBjb250YWlucyBsZXNzIHRoYW4gdHdpY2UgdGhlIGxpbWl0LiBGYXN0ZXIgdG8gZGVsZXRlIGZyb20gdGhlIHNuYXAgdGhhbiBidWlsZCB1cCBhIG5ldyBvbmVcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gbmV3U25hcC53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xyXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3Qgc3VwcG9ydCBwcmlvcml0aWVzIG9uIHF1ZXJpZXNcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQudXBkYXRlUHJpb3JpdHkoQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGl0ZXJhdG9yO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmV2ZXJzZV8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvciA9IGZpbHRlcmVkLmdldFJldmVyc2VJdGVyYXRvcih0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvciA9IGZpbHRlcmVkLmdldEl0ZXJhdG9yKHRoaXMuaW5kZXhfKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXRlcmF0b3IuaGFzTmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZXJhdG9yLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpblJhbmdlID0gY291bnQgPCB0aGlzLmxpbWl0XyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndpdGhpbkRpcmVjdGlvbmFsU3RhcnQobmV4dCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53aXRoaW5EaXJlY3Rpb25hbEVuZChuZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5SYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC51cGRhdGVJbW1lZGlhdGVDaGlsZChuZXh0Lm5hbWUsIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VkRmlsdGVyX1xyXG4gICAgICAgICAgICAuZ2V0SW5kZXhlZEZpbHRlcigpXHJcbiAgICAgICAgICAgIC51cGRhdGVGdWxsTm9kZShvbGRTbmFwLCBmaWx0ZXJlZCwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUHJpb3JpdHkob2xkU25hcCwgbmV3UHJpb3JpdHkpIHtcclxuICAgICAgICAvLyBEb24ndCBzdXBwb3J0IHByaW9yaXRpZXMgb24gcXVlcmllc1xyXG4gICAgICAgIHJldHVybiBvbGRTbmFwO1xyXG4gICAgfVxyXG4gICAgZmlsdGVyc05vZGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXhlZEZpbHRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZWRGaWx0ZXJfLmdldEluZGV4ZWRGaWx0ZXIoKTtcclxuICAgIH1cclxuICAgIGdldEluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4XztcclxuICAgIH1cclxuICAgIGZ1bGxMaW1pdFVwZGF0ZUNoaWxkXyhzbmFwLCBjaGlsZEtleSwgY2hpbGRTbmFwLCBzb3VyY2UsIGNoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgLy8gVE9ETzogcmVuYW1lIGFsbCBjYWNoZSBzdHVmZiBldGMgdG8gZ2VuZXJhbCBzbmFwIHRlcm1pbm9sb2d5XHJcbiAgICAgICAgbGV0IGNtcDtcclxuICAgICAgICBpZiAodGhpcy5yZXZlcnNlXykge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleENtcCA9IHRoaXMuaW5kZXhfLmdldENvbXBhcmUoKTtcclxuICAgICAgICAgICAgY21wID0gKGEsIGIpID0+IGluZGV4Q21wKGIsIGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY21wID0gdGhpcy5pbmRleF8uZ2V0Q29tcGFyZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvbGRFdmVudENhY2hlID0gc25hcDtcclxuICAgICAgICBhc3NlcnQob2xkRXZlbnRDYWNoZS5udW1DaGlsZHJlbigpID09PSB0aGlzLmxpbWl0XywgJycpO1xyXG4gICAgICAgIGNvbnN0IG5ld0NoaWxkTmFtZWROb2RlID0gbmV3IE5hbWVkTm9kZShjaGlsZEtleSwgY2hpbGRTbmFwKTtcclxuICAgICAgICBjb25zdCB3aW5kb3dCb3VuZGFyeSA9IHRoaXMucmV2ZXJzZV9cclxuICAgICAgICAgICAgPyBvbGRFdmVudENhY2hlLmdldEZpcnN0Q2hpbGQodGhpcy5pbmRleF8pXHJcbiAgICAgICAgICAgIDogb2xkRXZlbnRDYWNoZS5nZXRMYXN0Q2hpbGQodGhpcy5pbmRleF8pO1xyXG4gICAgICAgIGNvbnN0IGluUmFuZ2UgPSB0aGlzLnJhbmdlZEZpbHRlcl8ubWF0Y2hlcyhuZXdDaGlsZE5hbWVkTm9kZSk7XHJcbiAgICAgICAgaWYgKG9sZEV2ZW50Q2FjaGUuaGFzQ2hpbGQoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZENoaWxkU25hcCA9IG9sZEV2ZW50Q2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xyXG4gICAgICAgICAgICBsZXQgbmV4dENoaWxkID0gc291cmNlLmdldENoaWxkQWZ0ZXJDaGlsZCh0aGlzLmluZGV4Xywgd2luZG93Qm91bmRhcnksIHRoaXMucmV2ZXJzZV8pO1xyXG4gICAgICAgICAgICB3aGlsZSAobmV4dENoaWxkICE9IG51bGwgJiZcclxuICAgICAgICAgICAgICAgIChuZXh0Q2hpbGQubmFtZSA9PT0gY2hpbGRLZXkgfHwgb2xkRXZlbnRDYWNoZS5oYXNDaGlsZChuZXh0Q2hpbGQubmFtZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBhIHdlaXJkIGVkZ2UgY2FzZSB3aGVyZSBhIG5vZGUgaXMgdXBkYXRlZCBhcyBwYXJ0IG9mIGEgbWVyZ2UgaW4gdGhlIHdyaXRlIHRyZWUsIGJ1dCBoYXNuJ3RcclxuICAgICAgICAgICAgICAgIC8vIGJlZW4gYXBwbGllZCB0byB0aGUgbGltaXRlZCBmaWx0ZXIgeWV0LiBJZ25vcmUgdGhpcyBuZXh0IGNoaWxkIHdoaWNoIHdpbGwgYmUgdXBkYXRlZCBsYXRlciBpblxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGxpbWl0ZWQgZmlsdGVyLi4uXHJcbiAgICAgICAgICAgICAgICBuZXh0Q2hpbGQgPSBzb3VyY2UuZ2V0Q2hpbGRBZnRlckNoaWxkKHRoaXMuaW5kZXhfLCBuZXh0Q2hpbGQsIHRoaXMucmV2ZXJzZV8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXBhcmVOZXh0ID0gbmV4dENoaWxkID09IG51bGwgPyAxIDogY21wKG5leHRDaGlsZCwgbmV3Q2hpbGROYW1lZE5vZGUpO1xyXG4gICAgICAgICAgICBjb25zdCByZW1haW5zSW5XaW5kb3cgPSBpblJhbmdlICYmICFjaGlsZFNuYXAuaXNFbXB0eSgpICYmIGNvbXBhcmVOZXh0ID49IDA7XHJcbiAgICAgICAgICAgIGlmIChyZW1haW5zSW5XaW5kb3cpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShjaGFuZ2VDaGlsZENoYW5nZWQoY2hpbGRLZXksIGNoaWxkU25hcCwgb2xkQ2hpbGRTbmFwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkRXZlbnRDYWNoZS51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZEtleSwgY2hpbGRTbmFwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShjaGFuZ2VDaGlsZFJlbW92ZWQoY2hpbGRLZXksIG9sZENoaWxkU25hcCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RXZlbnRDYWNoZSA9IG9sZEV2ZW50Q2FjaGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXksIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZEluUmFuZ2UgPSBuZXh0Q2hpbGQgIT0gbnVsbCAmJiB0aGlzLnJhbmdlZEZpbHRlcl8ubWF0Y2hlcyhuZXh0Q2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZEluUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlQWNjdW11bGF0b3IgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQWRkZWQobmV4dENoaWxkLm5hbWUsIG5leHRDaGlsZC5ub2RlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdFdmVudENhY2hlLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKG5leHRDaGlsZC5uYW1lLCBuZXh0Q2hpbGQubm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3RXZlbnRDYWNoZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGlsZFNuYXAuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIC8vIHdlJ3JlIGRlbGV0aW5nIGEgbm9kZSwgYnV0IGl0IHdhcyBub3QgaW4gdGhlIHdpbmRvdywgc28gaWdub3JlIGl0XHJcbiAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpblJhbmdlKSB7XHJcbiAgICAgICAgICAgIGlmIChjbXAod2luZG93Qm91bmRhcnksIG5ld0NoaWxkTmFtZWROb2RlKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlQWNjdW11bGF0b3IgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoY2hhbmdlQ2hpbGRSZW1vdmVkKHdpbmRvd0JvdW5kYXJ5Lm5hbWUsIHdpbmRvd0JvdW5kYXJ5Lm5vZGUpKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQWRkZWQoY2hpbGRLZXksIGNoaWxkU25hcCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZEV2ZW50Q2FjaGVcclxuICAgICAgICAgICAgICAgICAgICAudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXksIGNoaWxkU25hcClcclxuICAgICAgICAgICAgICAgICAgICAudXBkYXRlSW1tZWRpYXRlQ2hpbGQod2luZG93Qm91bmRhcnkubmFtZSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNuYXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhpcyBjbGFzcyBpcyBhbiBpbW11dGFibGUtZnJvbS10aGUtcHVibGljLWFwaSBzdHJ1Y3QgY29udGFpbmluZyBhIHNldCBvZiBxdWVyeSBwYXJhbWV0ZXJzIGRlZmluaW5nIGFcclxuICogcmFuZ2UgdG8gYmUgcmV0dXJuZWQgZm9yIGEgcGFydGljdWxhciBsb2NhdGlvbi4gSXQgaXMgYXNzdW1lZCB0aGF0IHZhbGlkYXRpb24gb2YgcGFyYW1ldGVycyBpcyBkb25lIGF0IHRoZVxyXG4gKiB1c2VyLWZhY2luZyBBUEkgbGV2ZWwsIHNvIGl0IGlzIG5vdCBkb25lIGhlcmUuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgUXVlcnlQYXJhbXMge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5saW1pdFNldF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnN0YXJ0U2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3RhcnROYW1lU2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3RhcnRBZnRlclNldF8gPSBmYWxzZTsgLy8gY2FuIG9ubHkgYmUgdHJ1ZSBpZiBzdGFydFNldF8gaXMgdHJ1ZVxyXG4gICAgICAgIHRoaXMuZW5kU2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZW5kTmFtZVNldF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVuZEJlZm9yZVNldF8gPSBmYWxzZTsgLy8gY2FuIG9ubHkgYmUgdHJ1ZSBpZiBlbmRTZXRfIGlzIHRydWVcclxuICAgICAgICB0aGlzLmxpbWl0XyA9IDA7XHJcbiAgICAgICAgdGhpcy52aWV3RnJvbV8gPSAnJztcclxuICAgICAgICB0aGlzLmluZGV4U3RhcnRWYWx1ZV8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5kZXhTdGFydE5hbWVfID0gJyc7XHJcbiAgICAgICAgdGhpcy5pbmRleEVuZFZhbHVlXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbmRleEVuZE5hbWVfID0gJyc7XHJcbiAgICAgICAgdGhpcy5pbmRleF8gPSBQUklPUklUWV9JTkRFWDtcclxuICAgIH1cclxuICAgIGhhc1N0YXJ0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0U2V0XztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBpdCB3b3VsZCByZXR1cm4gZnJvbSBsZWZ0LlxyXG4gICAgICovXHJcbiAgICBpc1ZpZXdGcm9tTGVmdCgpIHtcclxuICAgICAgICBpZiAodGhpcy52aWV3RnJvbV8gPT09ICcnKSB7XHJcbiAgICAgICAgICAgIC8vIGxpbWl0KCksIHJhdGhlciB0aGFuIGxpbWl0VG9GaXJzdCBvciBsaW1pdFRvTGFzdCB3YXMgY2FsbGVkLlxyXG4gICAgICAgICAgICAvLyBUaGlzIG1lYW5zIHRoYXQgb25seSBvbmUgb2Ygc3RhcnRTZXRfIGFuZCBlbmRTZXRfIGlzIHRydWUuIFVzZSB0aGVtXHJcbiAgICAgICAgICAgIC8vIHRvIGNhbGN1bGF0ZSB3aGljaCBzaWRlIG9mIHRoZSB2aWV3IHRvIGFuY2hvciB0by4gSWYgbmVpdGhlciBpcyBzZXQsXHJcbiAgICAgICAgICAgIC8vIGFuY2hvciB0byB0aGUgZW5kLlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydFNldF87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3RnJvbV8gPT09IFwibFwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLlZJRVdfRlJPTV9MRUZUICovO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT25seSB2YWxpZCB0byBjYWxsIGlmIGhhc1N0YXJ0KCkgcmV0dXJucyB0cnVlXHJcbiAgICAgKi9cclxuICAgIGdldEluZGV4U3RhcnRWYWx1ZSgpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5zdGFydFNldF8sICdPbmx5IHZhbGlkIGlmIHN0YXJ0IGhhcyBiZWVuIHNldCcpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4U3RhcnRWYWx1ZV87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNTdGFydCgpIHJldHVybnMgdHJ1ZS5cclxuICAgICAqIFJldHVybnMgdGhlIHN0YXJ0aW5nIGtleSBuYW1lIGZvciB0aGUgcmFuZ2UgZGVmaW5lZCBieSB0aGVzZSBxdWVyeSBwYXJhbWV0ZXJzXHJcbiAgICAgKi9cclxuICAgIGdldEluZGV4U3RhcnROYW1lKCkge1xyXG4gICAgICAgIGFzc2VydCh0aGlzLnN0YXJ0U2V0XywgJ09ubHkgdmFsaWQgaWYgc3RhcnQgaGFzIGJlZW4gc2V0Jyk7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhcnROYW1lU2V0Xykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleFN0YXJ0TmFtZV87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTUlOX05BTUU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFzRW5kKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZFNldF87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNFbmQoKSByZXR1cm5zIHRydWUuXHJcbiAgICAgKi9cclxuICAgIGdldEluZGV4RW5kVmFsdWUoKSB7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMuZW5kU2V0XywgJ09ubHkgdmFsaWQgaWYgZW5kIGhhcyBiZWVuIHNldCcpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4RW5kVmFsdWVfO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPbmx5IHZhbGlkIHRvIGNhbGwgaWYgaGFzRW5kKCkgcmV0dXJucyB0cnVlLlxyXG4gICAgICogUmV0dXJucyB0aGUgZW5kIGtleSBuYW1lIGZvciB0aGUgcmFuZ2UgZGVmaW5lZCBieSB0aGVzZSBxdWVyeSBwYXJhbWV0ZXJzXHJcbiAgICAgKi9cclxuICAgIGdldEluZGV4RW5kTmFtZSgpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5lbmRTZXRfLCAnT25seSB2YWxpZCBpZiBlbmQgaGFzIGJlZW4gc2V0Jyk7XHJcbiAgICAgICAgaWYgKHRoaXMuZW5kTmFtZVNldF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhFbmROYW1lXztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNQVhfTkFNRTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYXNMaW1pdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5saW1pdFNldF87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgYSBsaW1pdCBoYXMgYmVlbiBzZXQgYW5kIGl0IGhhcyBiZWVuIGV4cGxpY2l0bHkgYW5jaG9yZWRcclxuICAgICAqL1xyXG4gICAgaGFzQW5jaG9yZWRMaW1pdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5saW1pdFNldF8gJiYgdGhpcy52aWV3RnJvbV8gIT09ICcnO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPbmx5IHZhbGlkIHRvIGNhbGwgaWYgaGFzTGltaXQoKSByZXR1cm5zIHRydWVcclxuICAgICAqL1xyXG4gICAgZ2V0TGltaXQoKSB7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMubGltaXRTZXRfLCAnT25seSB2YWxpZCBpZiBsaW1pdCBoYXMgYmVlbiBzZXQnKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5saW1pdF87XHJcbiAgICB9XHJcbiAgICBnZXRJbmRleCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleF87XHJcbiAgICB9XHJcbiAgICBsb2Fkc0FsbERhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuICEodGhpcy5zdGFydFNldF8gfHwgdGhpcy5lbmRTZXRfIHx8IHRoaXMubGltaXRTZXRfKTtcclxuICAgIH1cclxuICAgIGlzRGVmYXVsdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2Fkc0FsbERhdGEoKSAmJiB0aGlzLmluZGV4XyA9PT0gUFJJT1JJVFlfSU5ERVg7XHJcbiAgICB9XHJcbiAgICBjb3B5KCkge1xyXG4gICAgICAgIGNvbnN0IGNvcHkgPSBuZXcgUXVlcnlQYXJhbXMoKTtcclxuICAgICAgICBjb3B5LmxpbWl0U2V0XyA9IHRoaXMubGltaXRTZXRfO1xyXG4gICAgICAgIGNvcHkubGltaXRfID0gdGhpcy5saW1pdF87XHJcbiAgICAgICAgY29weS5zdGFydFNldF8gPSB0aGlzLnN0YXJ0U2V0XztcclxuICAgICAgICBjb3B5LnN0YXJ0QWZ0ZXJTZXRfID0gdGhpcy5zdGFydEFmdGVyU2V0XztcclxuICAgICAgICBjb3B5LmluZGV4U3RhcnRWYWx1ZV8gPSB0aGlzLmluZGV4U3RhcnRWYWx1ZV87XHJcbiAgICAgICAgY29weS5zdGFydE5hbWVTZXRfID0gdGhpcy5zdGFydE5hbWVTZXRfO1xyXG4gICAgICAgIGNvcHkuaW5kZXhTdGFydE5hbWVfID0gdGhpcy5pbmRleFN0YXJ0TmFtZV87XHJcbiAgICAgICAgY29weS5lbmRTZXRfID0gdGhpcy5lbmRTZXRfO1xyXG4gICAgICAgIGNvcHkuZW5kQmVmb3JlU2V0XyA9IHRoaXMuZW5kQmVmb3JlU2V0XztcclxuICAgICAgICBjb3B5LmluZGV4RW5kVmFsdWVfID0gdGhpcy5pbmRleEVuZFZhbHVlXztcclxuICAgICAgICBjb3B5LmVuZE5hbWVTZXRfID0gdGhpcy5lbmROYW1lU2V0XztcclxuICAgICAgICBjb3B5LmluZGV4RW5kTmFtZV8gPSB0aGlzLmluZGV4RW5kTmFtZV87XHJcbiAgICAgICAgY29weS5pbmRleF8gPSB0aGlzLmluZGV4XztcclxuICAgICAgICBjb3B5LnZpZXdGcm9tXyA9IHRoaXMudmlld0Zyb21fO1xyXG4gICAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5UGFyYW1zR2V0Tm9kZUZpbHRlcihxdWVyeVBhcmFtcykge1xyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmxvYWRzQWxsRGF0YSgpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleGVkRmlsdGVyKHF1ZXJ5UGFyYW1zLmdldEluZGV4KCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocXVlcnlQYXJhbXMuaGFzTGltaXQoKSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGltaXRlZEZpbHRlcihxdWVyeVBhcmFtcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlZEZpbHRlcihxdWVyeVBhcmFtcyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNMaW1pdFRvRmlyc3QocXVlcnlQYXJhbXMsIG5ld0xpbWl0KSB7XHJcbiAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtcy5jb3B5KCk7XHJcbiAgICBuZXdQYXJhbXMubGltaXRTZXRfID0gdHJ1ZTtcclxuICAgIG5ld1BhcmFtcy5saW1pdF8gPSBuZXdMaW1pdDtcclxuICAgIG5ld1BhcmFtcy52aWV3RnJvbV8gPSBcImxcIiAvKiBXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5WSUVXX0ZST01fTEVGVCAqLztcclxuICAgIHJldHVybiBuZXdQYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNMaW1pdFRvTGFzdChxdWVyeVBhcmFtcywgbmV3TGltaXQpIHtcclxuICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zLmNvcHkoKTtcclxuICAgIG5ld1BhcmFtcy5saW1pdFNldF8gPSB0cnVlO1xyXG4gICAgbmV3UGFyYW1zLmxpbWl0XyA9IG5ld0xpbWl0O1xyXG4gICAgbmV3UGFyYW1zLnZpZXdGcm9tXyA9IFwiclwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLlZJRVdfRlJPTV9SSUdIVCAqLztcclxuICAgIHJldHVybiBuZXdQYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNTdGFydEF0KHF1ZXJ5UGFyYW1zLCBpbmRleFZhbHVlLCBrZXkpIHtcclxuICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zLmNvcHkoKTtcclxuICAgIG5ld1BhcmFtcy5zdGFydFNldF8gPSB0cnVlO1xyXG4gICAgaWYgKGluZGV4VmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGluZGV4VmFsdWUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgbmV3UGFyYW1zLmluZGV4U3RhcnRWYWx1ZV8gPSBpbmRleFZhbHVlO1xyXG4gICAgaWYgKGtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgbmV3UGFyYW1zLnN0YXJ0TmFtZVNldF8gPSB0cnVlO1xyXG4gICAgICAgIG5ld1BhcmFtcy5pbmRleFN0YXJ0TmFtZV8gPSBrZXk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBuZXdQYXJhbXMuc3RhcnROYW1lU2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIG5ld1BhcmFtcy5pbmRleFN0YXJ0TmFtZV8gPSAnJztcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdQYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNTdGFydEFmdGVyKHF1ZXJ5UGFyYW1zLCBpbmRleFZhbHVlLCBrZXkpIHtcclxuICAgIGxldCBwYXJhbXM7XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuaW5kZXhfID09PSBLRVlfSU5ERVggfHwgISFrZXkpIHtcclxuICAgICAgICBwYXJhbXMgPSBxdWVyeVBhcmFtc1N0YXJ0QXQocXVlcnlQYXJhbXMsIGluZGV4VmFsdWUsIGtleSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwYXJhbXMgPSBxdWVyeVBhcmFtc1N0YXJ0QXQocXVlcnlQYXJhbXMsIGluZGV4VmFsdWUsIE1BWF9OQU1FKTtcclxuICAgIH1cclxuICAgIHBhcmFtcy5zdGFydEFmdGVyU2V0XyA9IHRydWU7XHJcbiAgICByZXR1cm4gcGFyYW1zO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5UGFyYW1zRW5kQXQocXVlcnlQYXJhbXMsIGluZGV4VmFsdWUsIGtleSkge1xyXG4gICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXMuY29weSgpO1xyXG4gICAgbmV3UGFyYW1zLmVuZFNldF8gPSB0cnVlO1xyXG4gICAgaWYgKGluZGV4VmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGluZGV4VmFsdWUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgbmV3UGFyYW1zLmluZGV4RW5kVmFsdWVfID0gaW5kZXhWYWx1ZTtcclxuICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIG5ld1BhcmFtcy5lbmROYW1lU2V0XyA9IHRydWU7XHJcbiAgICAgICAgbmV3UGFyYW1zLmluZGV4RW5kTmFtZV8gPSBrZXk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBuZXdQYXJhbXMuZW5kTmFtZVNldF8gPSBmYWxzZTtcclxuICAgICAgICBuZXdQYXJhbXMuaW5kZXhFbmROYW1lXyA9ICcnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld1BhcmFtcztcclxufVxyXG5mdW5jdGlvbiBxdWVyeVBhcmFtc0VuZEJlZm9yZShxdWVyeVBhcmFtcywgaW5kZXhWYWx1ZSwga2V5KSB7XHJcbiAgICBsZXQgcGFyYW1zO1xyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmluZGV4XyA9PT0gS0VZX0lOREVYIHx8ICEha2V5KSB7XHJcbiAgICAgICAgcGFyYW1zID0gcXVlcnlQYXJhbXNFbmRBdChxdWVyeVBhcmFtcywgaW5kZXhWYWx1ZSwga2V5KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHBhcmFtcyA9IHF1ZXJ5UGFyYW1zRW5kQXQocXVlcnlQYXJhbXMsIGluZGV4VmFsdWUsIE1JTl9OQU1FKTtcclxuICAgIH1cclxuICAgIHBhcmFtcy5lbmRCZWZvcmVTZXRfID0gdHJ1ZTtcclxuICAgIHJldHVybiBwYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNPcmRlckJ5KHF1ZXJ5UGFyYW1zLCBpbmRleCkge1xyXG4gICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXMuY29weSgpO1xyXG4gICAgbmV3UGFyYW1zLmluZGV4XyA9IGluZGV4O1xyXG4gICAgcmV0dXJuIG5ld1BhcmFtcztcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHNldCBvZiBSRVNUIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJzIHJlcHJlc2VudGluZyB0aGlzIHF1ZXJ5LlxyXG4gKlxyXG4gKiBAcmV0dXJucyBxdWVyeSBzdHJpbmcgcGFyYW1ldGVyc1xyXG4gKi9cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNUb1Jlc3RRdWVyeVN0cmluZ1BhcmFtZXRlcnMocXVlcnlQYXJhbXMpIHtcclxuICAgIGNvbnN0IHFzID0ge307XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuaXNEZWZhdWx0KCkpIHtcclxuICAgICAgICByZXR1cm4gcXM7XHJcbiAgICB9XHJcbiAgICBsZXQgb3JkZXJCeTtcclxuICAgIGlmIChxdWVyeVBhcmFtcy5pbmRleF8gPT09IFBSSU9SSVRZX0lOREVYKSB7XHJcbiAgICAgICAgb3JkZXJCeSA9IFwiJHByaW9yaXR5XCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuUFJJT1JJVFlfSU5ERVggKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChxdWVyeVBhcmFtcy5pbmRleF8gPT09IFZBTFVFX0lOREVYKSB7XHJcbiAgICAgICAgb3JkZXJCeSA9IFwiJHZhbHVlXCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuVkFMVUVfSU5ERVggKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChxdWVyeVBhcmFtcy5pbmRleF8gPT09IEtFWV9JTkRFWCkge1xyXG4gICAgICAgIG9yZGVyQnkgPSBcIiRrZXlcIiAvKiBSRVNUX1FVRVJZX0NPTlNUQU5UUy5LRVlfSU5ERVggKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhc3NlcnQocXVlcnlQYXJhbXMuaW5kZXhfIGluc3RhbmNlb2YgUGF0aEluZGV4LCAnVW5yZWNvZ25pemVkIGluZGV4IHR5cGUhJyk7XHJcbiAgICAgICAgb3JkZXJCeSA9IHF1ZXJ5UGFyYW1zLmluZGV4Xy50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgcXNbXCJvcmRlckJ5XCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuT1JERVJfQlkgKi9dID0gc3RyaW5naWZ5KG9yZGVyQnkpO1xyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLnN0YXJ0U2V0Xykge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0UGFyYW0gPSBxdWVyeVBhcmFtcy5zdGFydEFmdGVyU2V0X1xyXG4gICAgICAgICAgICA/IFwic3RhcnRBZnRlclwiIC8qIFJFU1RfUVVFUllfQ09OU1RBTlRTLlNUQVJUX0FGVEVSICovXHJcbiAgICAgICAgICAgIDogXCJzdGFydEF0XCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuU1RBUlRfQVQgKi87XHJcbiAgICAgICAgcXNbc3RhcnRQYXJhbV0gPSBzdHJpbmdpZnkocXVlcnlQYXJhbXMuaW5kZXhTdGFydFZhbHVlXyk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zLnN0YXJ0TmFtZVNldF8pIHtcclxuICAgICAgICAgICAgcXNbc3RhcnRQYXJhbV0gKz0gJywnICsgc3RyaW5naWZ5KHF1ZXJ5UGFyYW1zLmluZGV4U3RhcnROYW1lXyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmVuZFNldF8pIHtcclxuICAgICAgICBjb25zdCBlbmRQYXJhbSA9IHF1ZXJ5UGFyYW1zLmVuZEJlZm9yZVNldF9cclxuICAgICAgICAgICAgPyBcImVuZEJlZm9yZVwiIC8qIFJFU1RfUVVFUllfQ09OU1RBTlRTLkVORF9CRUZPUkUgKi9cclxuICAgICAgICAgICAgOiBcImVuZEF0XCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuRU5EX0FUICovO1xyXG4gICAgICAgIHFzW2VuZFBhcmFtXSA9IHN0cmluZ2lmeShxdWVyeVBhcmFtcy5pbmRleEVuZFZhbHVlXyk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zLmVuZE5hbWVTZXRfKSB7XHJcbiAgICAgICAgICAgIHFzW2VuZFBhcmFtXSArPSAnLCcgKyBzdHJpbmdpZnkocXVlcnlQYXJhbXMuaW5kZXhFbmROYW1lXyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmxpbWl0U2V0Xykge1xyXG4gICAgICAgIGlmIChxdWVyeVBhcmFtcy5pc1ZpZXdGcm9tTGVmdCgpKSB7XHJcbiAgICAgICAgICAgIHFzW1wibGltaXRUb0ZpcnN0XCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuTElNSVRfVE9fRklSU1QgKi9dID0gcXVlcnlQYXJhbXMubGltaXRfO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcXNbXCJsaW1pdFRvTGFzdFwiIC8qIFJFU1RfUVVFUllfQ09OU1RBTlRTLkxJTUlUX1RPX0xBU1QgKi9dID0gcXVlcnlQYXJhbXMubGltaXRfO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBxcztcclxufVxyXG5mdW5jdGlvbiBxdWVyeVBhcmFtc0dldFF1ZXJ5T2JqZWN0KHF1ZXJ5UGFyYW1zKSB7XHJcbiAgICBjb25zdCBvYmogPSB7fTtcclxuICAgIGlmIChxdWVyeVBhcmFtcy5zdGFydFNldF8pIHtcclxuICAgICAgICBvYmpbXCJzcFwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYX1NUQVJUX1ZBTFVFICovXSA9XHJcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmluZGV4U3RhcnRWYWx1ZV87XHJcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zLnN0YXJ0TmFtZVNldF8pIHtcclxuICAgICAgICAgICAgb2JqW1wic25cIiAvKiBXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5JTkRFWF9TVEFSVF9OQU1FICovXSA9XHJcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5pbmRleFN0YXJ0TmFtZV87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ialtcInNpblwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYX1NUQVJUX0lTX0lOQ0xVU0lWRSAqL10gPVxyXG4gICAgICAgICAgICAhcXVlcnlQYXJhbXMuc3RhcnRBZnRlclNldF87XHJcbiAgICB9XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuZW5kU2V0Xykge1xyXG4gICAgICAgIG9ialtcImVwXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuSU5ERVhfRU5EX1ZBTFVFICovXSA9IHF1ZXJ5UGFyYW1zLmluZGV4RW5kVmFsdWVfO1xyXG4gICAgICAgIGlmIChxdWVyeVBhcmFtcy5lbmROYW1lU2V0Xykge1xyXG4gICAgICAgICAgICBvYmpbXCJlblwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYX0VORF9OQU1FICovXSA9IHF1ZXJ5UGFyYW1zLmluZGV4RW5kTmFtZV87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ialtcImVpblwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYX0VORF9JU19JTkNMVVNJVkUgKi9dID1cclxuICAgICAgICAgICAgIXF1ZXJ5UGFyYW1zLmVuZEJlZm9yZVNldF87XHJcbiAgICB9XHJcbiAgICBpZiAocXVlcnlQYXJhbXMubGltaXRTZXRfKSB7XHJcbiAgICAgICAgb2JqW1wibFwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLkxJTUlUICovXSA9IHF1ZXJ5UGFyYW1zLmxpbWl0XztcclxuICAgICAgICBsZXQgdmlld0Zyb20gPSBxdWVyeVBhcmFtcy52aWV3RnJvbV87XHJcbiAgICAgICAgaWYgKHZpZXdGcm9tID09PSAnJykge1xyXG4gICAgICAgICAgICBpZiAocXVlcnlQYXJhbXMuaXNWaWV3RnJvbUxlZnQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmlld0Zyb20gPSBcImxcIiAvKiBXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5WSUVXX0ZST01fTEVGVCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZpZXdGcm9tID0gXCJyXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuVklFV19GUk9NX1JJR0hUICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ialtcInZmXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuVklFV19GUk9NICovXSA9IHZpZXdGcm9tO1xyXG4gICAgfVxyXG4gICAgLy8gRm9yIG5vdywgcHJpb3JpdHkgaW5kZXggaXMgdGhlIGRlZmF1bHQsIHNvIHdlIG9ubHkgc3BlY2lmeSBpZiBpdCdzIHNvbWUgb3RoZXIgaW5kZXhcclxuICAgIGlmIChxdWVyeVBhcmFtcy5pbmRleF8gIT09IFBSSU9SSVRZX0lOREVYKSB7XHJcbiAgICAgICAgb2JqW1wiaVwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYICovXSA9IHF1ZXJ5UGFyYW1zLmluZGV4Xy50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iajtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgU2VydmVyQWN0aW9ucyB0aGF0IGNvbW11bmljYXRlcyB3aXRoIHRoZSBzZXJ2ZXIgdmlhIFJFU1QgcmVxdWVzdHMuXHJcbiAqIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGNyYXdsZXJzLCB3aGVyZSB3ZSBkb24ndCB3YW50IHRvIHNwaW4gdXAgYSBmdWxsXHJcbiAqIHBlcnNpc3RlbnQgY29ubmVjdGlvbiAodXNpbmcgV2ViU29ja2V0cyBvciBsb25nLXBvbGxpbmcpXHJcbiAqL1xyXG5jbGFzcyBSZWFkb25seVJlc3RDbGllbnQgZXh0ZW5kcyBTZXJ2ZXJBY3Rpb25zIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHJlcG9JbmZvXyAtIERhdGEgYWJvdXQgdGhlIG5hbWVzcGFjZSB3ZSBhcmUgY29ubmVjdGluZyB0b1xyXG4gICAgICogQHBhcmFtIG9uRGF0YVVwZGF0ZV8gLSBBIGNhbGxiYWNrIGZvciBuZXcgZGF0YSBmcm9tIHRoZSBzZXJ2ZXJcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocmVwb0luZm9fLCBvbkRhdGFVcGRhdGVfLCBhdXRoVG9rZW5Qcm92aWRlcl8sIGFwcENoZWNrVG9rZW5Qcm92aWRlcl8pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMucmVwb0luZm9fID0gcmVwb0luZm9fO1xyXG4gICAgICAgIHRoaXMub25EYXRhVXBkYXRlXyA9IG9uRGF0YVVwZGF0ZV87XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5Qcm92aWRlcl8gPSBhdXRoVG9rZW5Qcm92aWRlcl87XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuUHJvdmlkZXJfID0gYXBwQ2hlY2tUb2tlblByb3ZpZGVyXztcclxuICAgICAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKC4uLlsqXSl9ICovXHJcbiAgICAgICAgdGhpcy5sb2dfID0gbG9nV3JhcHBlcigncDpyZXN0OicpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdlIGRvbid0IGFjdHVhbGx5IG5lZWQgdG8gdHJhY2sgbGlzdGVucywgZXhjZXB0IHRvIHByZXZlbnQgdXMgY2FsbGluZyBhbiBvbkNvbXBsZXRlIGZvciBhIGxpc3RlblxyXG4gICAgICAgICAqIHRoYXQncyBiZWVuIHJlbW92ZWQuIDotL1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGlzdGVuc18gPSB7fTtcclxuICAgIH1cclxuICAgIHJlcG9ydFN0YXRzKHN0YXRzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldExpc3RlbklkXyhxdWVyeSwgdGFnKSB7XHJcbiAgICAgICAgaWYgKHRhZyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAndGFnJCcgKyB0YWc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3NlcnQocXVlcnkuX3F1ZXJ5UGFyYW1zLmlzRGVmYXVsdCgpLCBcInNob3VsZCBoYXZlIGEgdGFnIGlmIGl0J3Mgbm90IGEgZGVmYXVsdCBxdWVyeS5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBxdWVyeS5fcGF0aC50b1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgbGlzdGVuKHF1ZXJ5LCBjdXJyZW50SGFzaEZuLCB0YWcsIG9uQ29tcGxldGUpIHtcclxuICAgICAgICBjb25zdCBwYXRoU3RyaW5nID0gcXVlcnkuX3BhdGgudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmxvZ18oJ0xpc3RlbiBjYWxsZWQgZm9yICcgKyBwYXRoU3RyaW5nICsgJyAnICsgcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcik7XHJcbiAgICAgICAgLy8gTWFyayB0aGlzIGxpc3RlbmVyIHNvIHdlIGNhbiB0ZWxsIGlmIGl0J3MgcmVtb3ZlZC5cclxuICAgICAgICBjb25zdCBsaXN0ZW5JZCA9IFJlYWRvbmx5UmVzdENsaWVudC5nZXRMaXN0ZW5JZF8ocXVlcnksIHRhZyk7XHJcbiAgICAgICAgY29uc3QgdGhpc0xpc3RlbiA9IHt9O1xyXG4gICAgICAgIHRoaXMubGlzdGVuc19bbGlzdGVuSWRdID0gdGhpc0xpc3RlbjtcclxuICAgICAgICBjb25zdCBxdWVyeVN0cmluZ1BhcmFtZXRlcnMgPSBxdWVyeVBhcmFtc1RvUmVzdFF1ZXJ5U3RyaW5nUGFyYW1ldGVycyhxdWVyeS5fcXVlcnlQYXJhbXMpO1xyXG4gICAgICAgIHRoaXMucmVzdFJlcXVlc3RfKHBhdGhTdHJpbmcgKyAnLmpzb24nLCBxdWVyeVN0cmluZ1BhcmFtZXRlcnMsIChlcnJvciwgcmVzdWx0KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gcmVzdWx0O1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IgPT09IDQwNCkge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBlcnJvciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVycm9yID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGF0YVVwZGF0ZV8ocGF0aFN0cmluZywgZGF0YSwgLyppc01lcmdlPSovIGZhbHNlLCB0YWcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzYWZlR2V0KHRoaXMubGlzdGVuc18sIGxpc3RlbklkKSA9PT0gdGhpc0xpc3Rlbikge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0YXR1cztcclxuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSAnb2snO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgPT09IDQwMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9ICdwZXJtaXNzaW9uX2RlbmllZCc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSAncmVzdF9lcnJvcjonICsgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKHN0YXR1cywgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgdW5saXN0ZW4ocXVlcnksIHRhZykge1xyXG4gICAgICAgIGNvbnN0IGxpc3RlbklkID0gUmVhZG9ubHlSZXN0Q2xpZW50LmdldExpc3RlbklkXyhxdWVyeSwgdGFnKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5saXN0ZW5zX1tsaXN0ZW5JZF07XHJcbiAgICB9XHJcbiAgICBnZXQocXVlcnkpIHtcclxuICAgICAgICBjb25zdCBxdWVyeVN0cmluZ1BhcmFtZXRlcnMgPSBxdWVyeVBhcmFtc1RvUmVzdFF1ZXJ5U3RyaW5nUGFyYW1ldGVycyhxdWVyeS5fcXVlcnlQYXJhbXMpO1xyXG4gICAgICAgIGNvbnN0IHBhdGhTdHJpbmcgPSBxdWVyeS5fcGF0aC50b1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgdGhpcy5yZXN0UmVxdWVzdF8ocGF0aFN0cmluZyArICcuanNvbicsIHF1ZXJ5U3RyaW5nUGFyYW1ldGVycywgKGVycm9yLCByZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIGlmIChlcnJvciA9PT0gNDA0KSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGVycm9yID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXJyb3IgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25EYXRhVXBkYXRlXyhwYXRoU3RyaW5nLCBkYXRhLCBcclxuICAgICAgICAgICAgICAgIC8qaXNNZXJnZT0qLyBmYWxzZSwgXHJcbiAgICAgICAgICAgICAgICAvKnRhZz0qLyBudWxsKTtcclxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QobmV3IEVycm9yKGRhdGEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICByZWZyZXNoQXV0aFRva2VuKHRva2VuKSB7XHJcbiAgICAgICAgLy8gbm8tb3Agc2luY2Ugd2UganVzdCBhbHdheXMgY2FsbCBnZXRUb2tlbi5cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgYSBSRVNUIHJlcXVlc3QgdG8gdGhlIGdpdmVuIHBhdGgsIHdpdGggdGhlIHByb3ZpZGVkIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJzLFxyXG4gICAgICogYW5kIGFueSBhdXRoIGNyZWRlbnRpYWxzIHdlIGhhdmUuXHJcbiAgICAgKi9cclxuICAgIHJlc3RSZXF1ZXN0XyhwYXRoU3RyaW5nLCBxdWVyeVN0cmluZ1BhcmFtZXRlcnMgPSB7fSwgY2FsbGJhY2spIHtcclxuICAgICAgICBxdWVyeVN0cmluZ1BhcmFtZXRlcnNbJ2Zvcm1hdCddID0gJ2V4cG9ydCc7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgdGhpcy5hdXRoVG9rZW5Qcm92aWRlcl8uZ2V0VG9rZW4oLypmb3JjZVJlZnJlc2g9Ki8gZmFsc2UpLFxyXG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrVG9rZW5Qcm92aWRlcl8uZ2V0VG9rZW4oLypmb3JjZVJlZnJlc2g9Ki8gZmFsc2UpXHJcbiAgICAgICAgXSkudGhlbigoW2F1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbl0pID0+IHtcclxuICAgICAgICAgICAgaWYgKGF1dGhUb2tlbiAmJiBhdXRoVG9rZW4uYWNjZXNzVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5U3RyaW5nUGFyYW1ldGVyc1snYXV0aCddID0gYXV0aFRva2VuLmFjY2Vzc1Rva2VuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhcHBDaGVja1Rva2VuICYmIGFwcENoZWNrVG9rZW4udG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5U3RyaW5nUGFyYW1ldGVyc1snYWMnXSA9IGFwcENoZWNrVG9rZW4udG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdXJsID0gKHRoaXMucmVwb0luZm9fLnNlY3VyZSA/ICdodHRwczovLycgOiAnaHR0cDovLycpICtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVwb0luZm9fLmhvc3QgK1xyXG4gICAgICAgICAgICAgICAgcGF0aFN0cmluZyArXHJcbiAgICAgICAgICAgICAgICAnPycgK1xyXG4gICAgICAgICAgICAgICAgJ25zPScgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvSW5mb18ubmFtZXNwYWNlICtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nKHF1ZXJ5U3RyaW5nUGFyYW1ldGVycyk7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnU2VuZGluZyBSRVNUIHJlcXVlc3QgZm9yICcgKyB1cmwpO1xyXG4gICAgICAgICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiB4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nXygnUkVTVCBSZXNwb25zZSBmb3IgJyArIHVybCArICcgcmVjZWl2ZWQuIHN0YXR1czonLCB4aHIuc3RhdHVzLCAncmVzcG9uc2U6JywgeGhyLnJlc3BvbnNlVGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IGpzb25FdmFsKHhoci5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuKCdGYWlsZWQgdG8gcGFyc2UgSlNPTiByZXNwb25zZSBmb3IgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnOiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gNDAxIGFuZCA0MDQgYXJlIGV4cGVjdGVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyAhPT0gNDAxICYmIHhoci5zdGF0dXMgIT09IDQwNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybignR290IHVuc3VjY2Vzc2Z1bCBSRVNUIHJlc3BvbnNlIGZvciAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgU3RhdHVzOiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh4aHIuc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB4aHIub3BlbignR0VUJywgdXJsLCAvKmFzeW5jaHJvbm91cz0qLyB0cnVlKTtcclxuICAgICAgICAgICAgeGhyLnNlbmQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogTXV0YWJsZSBvYmplY3Qgd2hpY2ggYmFzaWNhbGx5IGp1c3Qgc3RvcmVzIGEgcmVmZXJlbmNlIHRvIHRoZSBcImxhdGVzdFwiIGltbXV0YWJsZSBzbmFwc2hvdC5cclxuICovXHJcbmNsYXNzIFNuYXBzaG90SG9sZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucm9vdE5vZGVfID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICB9XHJcbiAgICBnZXROb2RlKHBhdGgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290Tm9kZV8uZ2V0Q2hpbGQocGF0aCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVTbmFwc2hvdChwYXRoLCBuZXdTbmFwc2hvdE5vZGUpIHtcclxuICAgICAgICB0aGlzLnJvb3ROb2RlXyA9IHRoaXMucm9vdE5vZGVfLnVwZGF0ZUNoaWxkKHBhdGgsIG5ld1NuYXBzaG90Tm9kZSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gbmV3U3BhcnNlU25hcHNob3RUcmVlKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB2YWx1ZTogbnVsbCxcclxuICAgICAgICBjaGlsZHJlbjogbmV3IE1hcCgpXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBTdG9yZXMgdGhlIGdpdmVuIG5vZGUgYXQgdGhlIHNwZWNpZmllZCBwYXRoLiBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgbm9kZVxyXG4gKiBhdCBhIHNoYWxsb3dlciBwYXRoLCBpdCBtZXJnZXMgdGhlIG5ldyBkYXRhIGludG8gdGhhdCBzbmFwc2hvdCBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGF0aCAtIFBhdGggdG8gbG9vayB1cCBzbmFwc2hvdCBmb3IuXHJcbiAqIEBwYXJhbSBkYXRhIC0gVGhlIG5ldyBkYXRhLCBvciBudWxsLlxyXG4gKi9cclxuZnVuY3Rpb24gc3BhcnNlU25hcHNob3RUcmVlUmVtZW1iZXIoc3BhcnNlU25hcHNob3RUcmVlLCBwYXRoLCBkYXRhKSB7XHJcbiAgICBpZiAocGF0aElzRW1wdHkocGF0aCkpIHtcclxuICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUgPSBkYXRhO1xyXG4gICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5jbGVhcigpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlID0gc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlLnVwZGF0ZUNoaWxkKHBhdGgsIGRhdGEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRLZXkgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICAgICAgaWYgKCFzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uaGFzKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uc2V0KGNoaWxkS2V5LCBuZXdTcGFyc2VTbmFwc2hvdFRyZWUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLmdldChjaGlsZEtleSk7XHJcbiAgICAgICAgcGF0aCA9IHBhdGhQb3BGcm9udChwYXRoKTtcclxuICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWVSZW1lbWJlcihjaGlsZCwgcGF0aCwgZGF0YSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFB1cmdlIHRoZSBkYXRhIGF0IHBhdGggZnJvbSB0aGUgY2FjaGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoIC0gUGF0aCB0byBsb29rIHVwIHNuYXBzaG90IGZvci5cclxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGlzIG5vZGUgc2hvdWxkIG5vdyBiZSByZW1vdmVkLlxyXG4gKi9cclxuZnVuY3Rpb24gc3BhcnNlU25hcHNob3RUcmVlRm9yZ2V0KHNwYXJzZVNuYXBzaG90VHJlZSwgcGF0aCkge1xyXG4gICAgaWYgKHBhdGhJc0VtcHR5KHBhdGgpKSB7XHJcbiAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlID0gbnVsbDtcclxuICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uY2xlYXIoKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHNwYXJzZVNuYXBzaG90VHJlZS52YWx1ZS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIHRyeWluZyB0byBmb3JnZXQgYSBub2RlIHRoYXQgZG9lc24ndCBleGlzdFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCB0cmVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlUmVtZW1iZXIoc3BhcnNlU25hcHNob3RUcmVlLCBuZXcgUGF0aChrZXkpLCB0cmVlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwYXJzZVNuYXBzaG90VHJlZUZvcmdldChzcGFyc2VTbmFwc2hvdFRyZWUsIHBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5zaXplID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZEtleSA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgICAgICAgICAgcGF0aCA9IHBhdGhQb3BGcm9udChwYXRoKTtcclxuICAgICAgICAgICAgaWYgKHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5oYXMoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzYWZlVG9SZW1vdmUgPSBzcGFyc2VTbmFwc2hvdFRyZWVGb3JnZXQoc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLmdldChjaGlsZEtleSksIHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNhZmVUb1JlbW92ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5kZWxldGUoY2hpbGRLZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uc2l6ZSA9PT0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVjdXJzaXZlbHkgaXRlcmF0ZXMgdGhyb3VnaCBhbGwgb2YgdGhlIHN0b3JlZCB0cmVlIGFuZCBjYWxscyB0aGVcclxuICogY2FsbGJhY2sgb24gZWFjaCBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBwcmVmaXhQYXRoIC0gUGF0aCB0byBsb29rIHVwIG5vZGUgZm9yLlxyXG4gKiBAcGFyYW0gZnVuYyAtIFRoZSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggdHJlZS5cclxuICovXHJcbmZ1bmN0aW9uIHNwYXJzZVNuYXBzaG90VHJlZUZvckVhY2hUcmVlKHNwYXJzZVNuYXBzaG90VHJlZSwgcHJlZml4UGF0aCwgZnVuYykge1xyXG4gICAgaWYgKHNwYXJzZVNuYXBzaG90VHJlZS52YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGZ1bmMocHJlZml4UGF0aCwgc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZUZvckVhY2hDaGlsZChzcGFyc2VTbmFwc2hvdFRyZWUsIChrZXksIHRyZWUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IG5ldyBQYXRoKHByZWZpeFBhdGgudG9TdHJpbmcoKSArICcvJyArIGtleSk7XHJcbiAgICAgICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZUZvckVhY2hUcmVlKHRyZWUsIHBhdGgsIGZ1bmMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGVhY2ggaW1tZWRpYXRlIGNoaWxkIGFuZCB0cmlnZ2VycyB0aGUgY2FsbGJhY2suXHJcbiAqIE9ubHkgc2VlbXMgdG8gYmUgdXNlZCBpbiB0ZXN0cy5cclxuICpcclxuICogQHBhcmFtIGZ1bmMgLSBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIGNoaWxkLlxyXG4gKi9cclxuZnVuY3Rpb24gc3BhcnNlU25hcHNob3RUcmVlRm9yRWFjaENoaWxkKHNwYXJzZVNuYXBzaG90VHJlZSwgZnVuYykge1xyXG4gICAgc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLmZvckVhY2goKHRyZWUsIGtleSkgPT4ge1xyXG4gICAgICAgIGZ1bmMoa2V5LCB0cmVlKTtcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkZWx0YSBmcm9tIHRoZSBwcmV2aW91cyBjYWxsIHRvIGdldCBzdGF0cy5cclxuICpcclxuICogQHBhcmFtIGNvbGxlY3Rpb25fIC0gVGhlIGNvbGxlY3Rpb24gdG8gXCJsaXN0ZW5cIiB0by5cclxuICovXHJcbmNsYXNzIFN0YXRzTGlzdGVuZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29sbGVjdGlvbl8pIHtcclxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25fID0gY29sbGVjdGlvbl87XHJcbiAgICAgICAgdGhpcy5sYXN0XyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXQoKSB7XHJcbiAgICAgICAgY29uc3QgbmV3U3RhdHMgPSB0aGlzLmNvbGxlY3Rpb25fLmdldCgpO1xyXG4gICAgICAgIGNvbnN0IGRlbHRhID0gT2JqZWN0LmFzc2lnbih7fSwgbmV3U3RhdHMpO1xyXG4gICAgICAgIGlmICh0aGlzLmxhc3RfKSB7XHJcbiAgICAgICAgICAgIGVhY2godGhpcy5sYXN0XywgKHN0YXQsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBkZWx0YVtzdGF0XSA9IGRlbHRhW3N0YXRdIC0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxhc3RfID0gbmV3U3RhdHM7XHJcbiAgICAgICAgcmV0dXJuIGRlbHRhO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIEFzc3VtaW5nIHNvbWUgYXBwcyBtYXkgaGF2ZSBhIHNob3J0IGFtb3VudCBvZiB0aW1lIG9uIHBhZ2UsIGFuZCBhIGJ1bGsgb2YgZmlyZWJhc2Ugb3BlcmF0aW9ucyBwcm9iYWJseVxyXG4vLyBoYXBwZW4gb24gcGFnZSBsb2FkLCB3ZSB0cnkgdG8gcmVwb3J0IG91ciBmaXJzdCBzZXQgb2Ygc3RhdHMgcHJldHR5IHF1aWNrbHksIGJ1dCB3ZSB3YWl0IGF0IGxlYXN0IDEwXHJcbi8vIHNlY29uZHMgdG8gdHJ5IHRvIGVuc3VyZSB0aGUgRmlyZWJhc2UgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCAvIHNldHRsZWQuXHJcbmNvbnN0IEZJUlNUX1NUQVRTX01JTl9USU1FID0gMTAgKiAxMDAwO1xyXG5jb25zdCBGSVJTVF9TVEFUU19NQVhfVElNRSA9IDMwICogMTAwMDtcclxuLy8gV2UnbGwgY29udGludWUgdG8gcmVwb3J0IHN0YXRzIG9uIGF2ZXJhZ2UgZXZlcnkgNSBtaW51dGVzLlxyXG5jb25zdCBSRVBPUlRfU1RBVFNfSU5URVJWQUwgPSA1ICogNjAgKiAxMDAwO1xyXG5jbGFzcyBTdGF0c1JlcG9ydGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbGxlY3Rpb24sIHNlcnZlcl8pIHtcclxuICAgICAgICB0aGlzLnNlcnZlcl8gPSBzZXJ2ZXJfO1xyXG4gICAgICAgIHRoaXMuc3RhdHNUb1JlcG9ydF8gPSB7fTtcclxuICAgICAgICB0aGlzLnN0YXRzTGlzdGVuZXJfID0gbmV3IFN0YXRzTGlzdGVuZXIoY29sbGVjdGlvbik7XHJcbiAgICAgICAgY29uc3QgdGltZW91dCA9IEZJUlNUX1NUQVRTX01JTl9USU1FICtcclxuICAgICAgICAgICAgKEZJUlNUX1NUQVRTX01BWF9USU1FIC0gRklSU1RfU1RBVFNfTUlOX1RJTUUpICogTWF0aC5yYW5kb20oKTtcclxuICAgICAgICBzZXRUaW1lb3V0Tm9uQmxvY2tpbmcodGhpcy5yZXBvcnRTdGF0c18uYmluZCh0aGlzKSwgTWF0aC5mbG9vcih0aW1lb3V0KSk7XHJcbiAgICB9XHJcbiAgICByZXBvcnRTdGF0c18oKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdHMgPSB0aGlzLnN0YXRzTGlzdGVuZXJfLmdldCgpO1xyXG4gICAgICAgIGNvbnN0IHJlcG9ydGVkU3RhdHMgPSB7fTtcclxuICAgICAgICBsZXQgaGF2ZVN0YXRzVG9SZXBvcnQgPSBmYWxzZTtcclxuICAgICAgICBlYWNoKHN0YXRzLCAoc3RhdCwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID4gMCAmJiBjb250YWlucyh0aGlzLnN0YXRzVG9SZXBvcnRfLCBzdGF0KSkge1xyXG4gICAgICAgICAgICAgICAgcmVwb3J0ZWRTdGF0c1tzdGF0XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaGF2ZVN0YXRzVG9SZXBvcnQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGhhdmVTdGF0c1RvUmVwb3J0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VydmVyXy5yZXBvcnRTdGF0cyhyZXBvcnRlZFN0YXRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcXVldWUgb3VyIG5leHQgcnVuLlxyXG4gICAgICAgIHNldFRpbWVvdXROb25CbG9ja2luZyh0aGlzLnJlcG9ydFN0YXRzXy5iaW5kKHRoaXMpLCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyICogUkVQT1JUX1NUQVRTX0lOVEVSVkFMKSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqXHJcbiAqIEBlbnVtXHJcbiAqL1xyXG52YXIgT3BlcmF0aW9uVHlwZTtcclxuKGZ1bmN0aW9uIChPcGVyYXRpb25UeXBlKSB7XHJcbiAgICBPcGVyYXRpb25UeXBlW09wZXJhdGlvblR5cGVbXCJPVkVSV1JJVEVcIl0gPSAwXSA9IFwiT1ZFUldSSVRFXCI7XHJcbiAgICBPcGVyYXRpb25UeXBlW09wZXJhdGlvblR5cGVbXCJNRVJHRVwiXSA9IDFdID0gXCJNRVJHRVwiO1xyXG4gICAgT3BlcmF0aW9uVHlwZVtPcGVyYXRpb25UeXBlW1wiQUNLX1VTRVJfV1JJVEVcIl0gPSAyXSA9IFwiQUNLX1VTRVJfV1JJVEVcIjtcclxuICAgIE9wZXJhdGlvblR5cGVbT3BlcmF0aW9uVHlwZVtcIkxJU1RFTl9DT01QTEVURVwiXSA9IDNdID0gXCJMSVNURU5fQ09NUExFVEVcIjtcclxufSkoT3BlcmF0aW9uVHlwZSB8fCAoT3BlcmF0aW9uVHlwZSA9IHt9KSk7XHJcbmZ1bmN0aW9uIG5ld09wZXJhdGlvblNvdXJjZVVzZXIoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZyb21Vc2VyOiB0cnVlLFxyXG4gICAgICAgIGZyb21TZXJ2ZXI6IGZhbHNlLFxyXG4gICAgICAgIHF1ZXJ5SWQ6IG51bGwsXHJcbiAgICAgICAgdGFnZ2VkOiBmYWxzZVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXIoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZyb21Vc2VyOiBmYWxzZSxcclxuICAgICAgICBmcm9tU2VydmVyOiB0cnVlLFxyXG4gICAgICAgIHF1ZXJ5SWQ6IG51bGwsXHJcbiAgICAgICAgdGFnZ2VkOiBmYWxzZVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXJUYWdnZWRRdWVyeShxdWVyeUlkKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZyb21Vc2VyOiBmYWxzZSxcclxuICAgICAgICBmcm9tU2VydmVyOiB0cnVlLFxyXG4gICAgICAgIHF1ZXJ5SWQsXHJcbiAgICAgICAgdGFnZ2VkOiB0cnVlXHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEFja1VzZXJXcml0ZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBhZmZlY3RlZFRyZWUgLSBBIHRyZWUgY29udGFpbmluZyB0cnVlIGZvciBlYWNoIGFmZmVjdGVkIHBhdGguIEFmZmVjdGVkIHBhdGhzIGNhbid0IG92ZXJsYXAuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovIHBhdGgsIFxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovIGFmZmVjdGVkVHJlZSwgXHJcbiAgICAvKiogQGluaGVyaXREb2MgKi8gcmV2ZXJ0KSB7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICB0aGlzLmFmZmVjdGVkVHJlZSA9IGFmZmVjdGVkVHJlZTtcclxuICAgICAgICB0aGlzLnJldmVydCA9IHJldmVydDtcclxuICAgICAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSBPcGVyYXRpb25UeXBlLkFDS19VU0VSX1dSSVRFO1xyXG4gICAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gbmV3T3BlcmF0aW9uU291cmNlVXNlcigpO1xyXG4gICAgfVxyXG4gICAgb3BlcmF0aW9uRm9yQ2hpbGQoY2hpbGROYW1lKSB7XHJcbiAgICAgICAgaWYgKCFwYXRoSXNFbXB0eSh0aGlzLnBhdGgpKSB7XHJcbiAgICAgICAgICAgIGFzc2VydChwYXRoR2V0RnJvbnQodGhpcy5wYXRoKSA9PT0gY2hpbGROYW1lLCAnb3BlcmF0aW9uRm9yQ2hpbGQgY2FsbGVkIGZvciB1bnJlbGF0ZWQgY2hpbGQuJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWNrVXNlcldyaXRlKHBhdGhQb3BGcm9udCh0aGlzLnBhdGgpLCB0aGlzLmFmZmVjdGVkVHJlZSwgdGhpcy5yZXZlcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmFmZmVjdGVkVHJlZS52YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLmFmZmVjdGVkVHJlZS5jaGlsZHJlbi5pc0VtcHR5KCksICdhZmZlY3RlZFRyZWUgc2hvdWxkIG5vdCBoYXZlIG92ZXJsYXBwaW5nIGFmZmVjdGVkIHBhdGhzLicpO1xyXG4gICAgICAgICAgICAvLyBBbGwgY2hpbGQgbG9jYXRpb25zIGFyZSBhZmZlY3RlZCBhcyB3ZWxsOyBqdXN0IHJldHVybiBzYW1lIG9wZXJhdGlvbi5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFRyZWUgPSB0aGlzLmFmZmVjdGVkVHJlZS5zdWJ0cmVlKG5ldyBQYXRoKGNoaWxkTmFtZSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFja1VzZXJXcml0ZShuZXdFbXB0eVBhdGgoKSwgY2hpbGRUcmVlLCB0aGlzLnJldmVydCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIExpc3RlbkNvbXBsZXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgcGF0aCkge1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gT3BlcmF0aW9uVHlwZS5MSVNURU5fQ09NUExFVEU7XHJcbiAgICB9XHJcbiAgICBvcGVyYXRpb25Gb3JDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkodGhpcy5wYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IExpc3RlbkNvbXBsZXRlKHRoaXMuc291cmNlLCBuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IExpc3RlbkNvbXBsZXRlKHRoaXMuc291cmNlLCBwYXRoUG9wRnJvbnQodGhpcy5wYXRoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIE92ZXJ3cml0ZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHBhdGgsIHNuYXApIHtcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgIHRoaXMuc25hcCA9IHNuYXA7XHJcbiAgICAgICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gT3BlcmF0aW9uVHlwZS5PVkVSV1JJVEU7XHJcbiAgICB9XHJcbiAgICBvcGVyYXRpb25Gb3JDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkodGhpcy5wYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE92ZXJ3cml0ZSh0aGlzLnNvdXJjZSwgbmV3RW1wdHlQYXRoKCksIHRoaXMuc25hcC5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgT3ZlcndyaXRlKHRoaXMuc291cmNlLCBwYXRoUG9wRnJvbnQodGhpcy5wYXRoKSwgdGhpcy5zbmFwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgTWVyZ2Uge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogQGluaGVyaXREb2MgKi8gc291cmNlLCBcclxuICAgIC8qKiBAaW5oZXJpdERvYyAqLyBwYXRoLCBcclxuICAgIC8qKiBAaW5oZXJpdERvYyAqLyBjaGlsZHJlbikge1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9IE9wZXJhdGlvblR5cGUuTUVSR0U7XHJcbiAgICB9XHJcbiAgICBvcGVyYXRpb25Gb3JDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkodGhpcy5wYXRoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFRyZWUgPSB0aGlzLmNoaWxkcmVuLnN1YnRyZWUobmV3IFBhdGgoY2hpbGROYW1lKSk7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZFRyZWUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNoaWxkIGlzIHVuYWZmZWN0ZWRcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkVHJlZS52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHNuYXBzaG90IGZvciB0aGUgY2hpbGQgaW4gcXVlc3Rpb24uICBUaGlzIGJlY29tZXMgYW4gb3ZlcndyaXRlIG9mIHRoZSBjaGlsZC5cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgT3ZlcndyaXRlKHRoaXMuc291cmNlLCBuZXdFbXB0eVBhdGgoKSwgY2hpbGRUcmVlLnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBtZXJnZSBhdCBhIGRlZXBlciBsZXZlbFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNZXJnZSh0aGlzLnNvdXJjZSwgbmV3RW1wdHlQYXRoKCksIGNoaWxkVHJlZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFzc2VydChwYXRoR2V0RnJvbnQodGhpcy5wYXRoKSA9PT0gY2hpbGROYW1lLCBcIkNhbid0IGdldCBhIG1lcmdlIGZvciBhIGNoaWxkIG5vdCBvbiB0aGUgcGF0aCBvZiB0aGUgb3BlcmF0aW9uXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE1lcmdlKHRoaXMuc291cmNlLCBwYXRoUG9wRnJvbnQodGhpcy5wYXRoKSwgdGhpcy5jaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICgnT3BlcmF0aW9uKCcgK1xyXG4gICAgICAgICAgICB0aGlzLnBhdGggK1xyXG4gICAgICAgICAgICAnOiAnICtcclxuICAgICAgICAgICAgdGhpcy5zb3VyY2UudG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICcgbWVyZ2U6ICcgK1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnRvU3RyaW5nKCkgK1xyXG4gICAgICAgICAgICAnKScpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGNhY2hlIG5vZGUgb25seSBzdG9yZXMgY29tcGxldGUgY2hpbGRyZW4uIEFkZGl0aW9uYWxseSBpdCBob2xkcyBhIGZsYWcgd2hldGhlciB0aGUgbm9kZSBjYW4gYmUgY29uc2lkZXJlZCBmdWxseVxyXG4gKiBpbml0aWFsaXplZCBpbiB0aGUgc2Vuc2UgdGhhdCB3ZSBrbm93IGF0IG9uZSBwb2ludCBpbiB0aW1lIHRoaXMgcmVwcmVzZW50ZWQgYSB2YWxpZCBzdGF0ZSBvZiB0aGUgd29ybGQsIGUuZy5cclxuICogaW5pdGlhbGl6ZWQgd2l0aCBkYXRhIGZyb20gdGhlIHNlcnZlciwgb3IgYSBjb21wbGV0ZSBvdmVyd3JpdGUgYnkgdGhlIGNsaWVudC4gVGhlIGZpbHRlcmVkIGZsYWcgYWxzbyB0cmFja3NcclxuICogd2hldGhlciBhIG5vZGUgcG90ZW50aWFsbHkgaGFkIGNoaWxkcmVuIHJlbW92ZWQgZHVlIHRvIGEgZmlsdGVyLlxyXG4gKi9cclxuY2xhc3MgQ2FjaGVOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKG5vZGVfLCBmdWxseUluaXRpYWxpemVkXywgZmlsdGVyZWRfKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlXyA9IG5vZGVfO1xyXG4gICAgICAgIHRoaXMuZnVsbHlJbml0aWFsaXplZF8gPSBmdWxseUluaXRpYWxpemVkXztcclxuICAgICAgICB0aGlzLmZpbHRlcmVkXyA9IGZpbHRlcmVkXztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgbm9kZSB3YXMgZnVsbHkgaW5pdGlhbGl6ZWQgd2l0aCBlaXRoZXIgc2VydmVyIGRhdGEgb3IgYSBjb21wbGV0ZSBvdmVyd3JpdGUgYnkgdGhlIGNsaWVudFxyXG4gICAgICovXHJcbiAgICBpc0Z1bGx5SW5pdGlhbGl6ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVsbHlJbml0aWFsaXplZF87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIG5vZGUgaXMgcG90ZW50aWFsbHkgbWlzc2luZyBjaGlsZHJlbiBkdWUgdG8gYSBmaWx0ZXIgYXBwbGllZCB0byB0aGUgbm9kZVxyXG4gICAgICovXHJcbiAgICBpc0ZpbHRlcmVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcmVkXztcclxuICAgIH1cclxuICAgIGlzQ29tcGxldGVGb3JQYXRoKHBhdGgpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNGdWxseUluaXRpYWxpemVkKCkgJiYgIXRoaXMuZmlsdGVyZWRfO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjaGlsZEtleSA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpO1xyXG4gICAgfVxyXG4gICAgaXNDb21wbGV0ZUZvckNoaWxkKGtleSkge1xyXG4gICAgICAgIHJldHVybiAoKHRoaXMuaXNGdWxseUluaXRpYWxpemVkKCkgJiYgIXRoaXMuZmlsdGVyZWRfKSB8fCB0aGlzLm5vZGVfLmhhc0NoaWxkKGtleSkpO1xyXG4gICAgfVxyXG4gICAgZ2V0Tm9kZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlXztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gRXZlbnRHZW5lcmF0b3IgaXMgdXNlZCB0byBjb252ZXJ0IFwicmF3XCIgY2hhbmdlcyAoQ2hhbmdlKSBhcyBjb21wdXRlZCBieSB0aGVcclxuICogQ2FjaGVEaWZmZXIgaW50byBhY3R1YWwgZXZlbnRzIChFdmVudCkgdGhhdCBjYW4gYmUgcmFpc2VkLiAgU2VlIGdlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlcygpXHJcbiAqIGZvciBkZXRhaWxzLlxyXG4gKlxyXG4gKi9cclxuY2xhc3MgRXZlbnRHZW5lcmF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IocXVlcnlfKSB7XHJcbiAgICAgICAgdGhpcy5xdWVyeV8gPSBxdWVyeV87XHJcbiAgICAgICAgdGhpcy5pbmRleF8gPSB0aGlzLnF1ZXJ5Xy5fcXVlcnlQYXJhbXMuZ2V0SW5kZXgoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2l2ZW4gYSBzZXQgb2YgcmF3IGNoYW5nZXMgKG5vIG1vdmVkIGV2ZW50cyBhbmQgcHJldk5hbWUgbm90IHNwZWNpZmllZCB5ZXQpLCBhbmQgYSBzZXQgb2ZcclxuICogRXZlbnRSZWdpc3RyYXRpb25zIHRoYXQgc2hvdWxkIGJlIG5vdGlmaWVkIG9mIHRoZXNlIGNoYW5nZXMsIGdlbmVyYXRlIHRoZSBhY3R1YWwgZXZlbnRzIHRvIGJlIHJhaXNlZC5cclxuICpcclxuICogTm90ZXM6XHJcbiAqICAtIGNoaWxkX21vdmVkIGV2ZW50cyB3aWxsIGJlIHN5bnRoZXNpemVkIGF0IHRoaXMgdGltZSBmb3IgYW55IGNoaWxkX2NoYW5nZWQgZXZlbnRzIHRoYXQgYWZmZWN0XHJcbiAqICAgIG91ciBpbmRleC5cclxuICogIC0gcHJldk5hbWUgd2lsbCBiZSBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBpbmRleCBvcmRlcmluZy5cclxuICovXHJcbmZ1bmN0aW9uIGV2ZW50R2VuZXJhdG9yR2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzKGV2ZW50R2VuZXJhdG9yLCBjaGFuZ2VzLCBldmVudENhY2hlLCBldmVudFJlZ2lzdHJhdGlvbnMpIHtcclxuICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xyXG4gICAgY29uc3QgbW92ZXMgPSBbXTtcclxuICAgIGNoYW5nZXMuZm9yRWFjaChjaGFuZ2UgPT4ge1xyXG4gICAgICAgIGlmIChjaGFuZ2UudHlwZSA9PT0gXCJjaGlsZF9jaGFuZ2VkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9DSEFOR0VEICovICYmXHJcbiAgICAgICAgICAgIGV2ZW50R2VuZXJhdG9yLmluZGV4Xy5pbmRleGVkVmFsdWVDaGFuZ2VkKGNoYW5nZS5vbGRTbmFwLCBjaGFuZ2Uuc25hcHNob3ROb2RlKSkge1xyXG4gICAgICAgICAgICBtb3Zlcy5wdXNoKGNoYW5nZUNoaWxkTW92ZWQoY2hhbmdlLmNoaWxkTmFtZSwgY2hhbmdlLnNuYXBzaG90Tm9kZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgZXZlbnRHZW5lcmF0b3JHZW5lcmF0ZUV2ZW50c0ZvclR5cGUoZXZlbnRHZW5lcmF0b3IsIGV2ZW50cywgXCJjaGlsZF9yZW1vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9SRU1PVkVEICovLCBjaGFuZ2VzLCBldmVudFJlZ2lzdHJhdGlvbnMsIGV2ZW50Q2FjaGUpO1xyXG4gICAgZXZlbnRHZW5lcmF0b3JHZW5lcmF0ZUV2ZW50c0ZvclR5cGUoZXZlbnRHZW5lcmF0b3IsIGV2ZW50cywgXCJjaGlsZF9hZGRlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQURERUQgKi8sIGNoYW5nZXMsIGV2ZW50UmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSk7XHJcbiAgICBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yVHlwZShldmVudEdlbmVyYXRvciwgZXZlbnRzLCBcImNoaWxkX21vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9NT1ZFRCAqLywgbW92ZXMsIGV2ZW50UmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSk7XHJcbiAgICBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yVHlwZShldmVudEdlbmVyYXRvciwgZXZlbnRzLCBcImNoaWxkX2NoYW5nZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX0NIQU5HRUQgKi8sIGNoYW5nZXMsIGV2ZW50UmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSk7XHJcbiAgICBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yVHlwZShldmVudEdlbmVyYXRvciwgZXZlbnRzLCBcInZhbHVlXCIgLyogQ2hhbmdlVHlwZS5WQUxVRSAqLywgY2hhbmdlcywgZXZlbnRSZWdpc3RyYXRpb25zLCBldmVudENhY2hlKTtcclxuICAgIHJldHVybiBldmVudHM7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGNoYW5nZXMgb2YgYSBzaW5nbGUgY2hhbmdlIHR5cGUsIGdlbmVyYXRlIHRoZSBjb3JyZXNwb25kaW5nIGV2ZW50cy5cclxuICovXHJcbmZ1bmN0aW9uIGV2ZW50R2VuZXJhdG9yR2VuZXJhdGVFdmVudHNGb3JUeXBlKGV2ZW50R2VuZXJhdG9yLCBldmVudHMsIGV2ZW50VHlwZSwgY2hhbmdlcywgcmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSkge1xyXG4gICAgY29uc3QgZmlsdGVyZWRDaGFuZ2VzID0gY2hhbmdlcy5maWx0ZXIoY2hhbmdlID0+IGNoYW5nZS50eXBlID09PSBldmVudFR5cGUpO1xyXG4gICAgZmlsdGVyZWRDaGFuZ2VzLnNvcnQoKGEsIGIpID0+IGV2ZW50R2VuZXJhdG9yQ29tcGFyZUNoYW5nZXMoZXZlbnRHZW5lcmF0b3IsIGEsIGIpKTtcclxuICAgIGZpbHRlcmVkQ2hhbmdlcy5mb3JFYWNoKGNoYW5nZSA9PiB7XHJcbiAgICAgICAgY29uc3QgbWF0ZXJpYWxpemVkQ2hhbmdlID0gZXZlbnRHZW5lcmF0b3JNYXRlcmlhbGl6ZVNpbmdsZUNoYW5nZShldmVudEdlbmVyYXRvciwgY2hhbmdlLCBldmVudENhY2hlKTtcclxuICAgICAgICByZWdpc3RyYXRpb25zLmZvckVhY2gocmVnaXN0cmF0aW9uID0+IHtcclxuICAgICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbi5yZXNwb25kc1RvKGNoYW5nZS50eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRzLnB1c2gocmVnaXN0cmF0aW9uLmNyZWF0ZUV2ZW50KG1hdGVyaWFsaXplZENoYW5nZSwgZXZlbnRHZW5lcmF0b3IucXVlcnlfKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGV2ZW50R2VuZXJhdG9yTWF0ZXJpYWxpemVTaW5nbGVDaGFuZ2UoZXZlbnRHZW5lcmF0b3IsIGNoYW5nZSwgZXZlbnRDYWNoZSkge1xyXG4gICAgaWYgKGNoYW5nZS50eXBlID09PSAndmFsdWUnIHx8IGNoYW5nZS50eXBlID09PSAnY2hpbGRfcmVtb3ZlZCcpIHtcclxuICAgICAgICByZXR1cm4gY2hhbmdlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY2hhbmdlLnByZXZOYW1lID0gZXZlbnRDYWNoZS5nZXRQcmVkZWNlc3NvckNoaWxkTmFtZShjaGFuZ2UuY2hpbGROYW1lLCBjaGFuZ2Uuc25hcHNob3ROb2RlLCBldmVudEdlbmVyYXRvci5pbmRleF8pO1xyXG4gICAgICAgIHJldHVybiBjaGFuZ2U7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZXZlbnRHZW5lcmF0b3JDb21wYXJlQ2hhbmdlcyhldmVudEdlbmVyYXRvciwgYSwgYikge1xyXG4gICAgaWYgKGEuY2hpbGROYW1lID09IG51bGwgfHwgYi5jaGlsZE5hbWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IGFzc2VydGlvbkVycm9yKCdTaG91bGQgb25seSBjb21wYXJlIGNoaWxkXyBldmVudHMuJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhV3JhcHBlZCA9IG5ldyBOYW1lZE5vZGUoYS5jaGlsZE5hbWUsIGEuc25hcHNob3ROb2RlKTtcclxuICAgIGNvbnN0IGJXcmFwcGVkID0gbmV3IE5hbWVkTm9kZShiLmNoaWxkTmFtZSwgYi5zbmFwc2hvdE5vZGUpO1xyXG4gICAgcmV0dXJuIGV2ZW50R2VuZXJhdG9yLmluZGV4Xy5jb21wYXJlKGFXcmFwcGVkLCBiV3JhcHBlZCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gbmV3Vmlld0NhY2hlKGV2ZW50Q2FjaGUsIHNlcnZlckNhY2hlKSB7XHJcbiAgICByZXR1cm4geyBldmVudENhY2hlLCBzZXJ2ZXJDYWNoZSB9O1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdDYWNoZVVwZGF0ZUV2ZW50U25hcCh2aWV3Q2FjaGUsIGV2ZW50U25hcCwgY29tcGxldGUsIGZpbHRlcmVkKSB7XHJcbiAgICByZXR1cm4gbmV3Vmlld0NhY2hlKG5ldyBDYWNoZU5vZGUoZXZlbnRTbmFwLCBjb21wbGV0ZSwgZmlsdGVyZWQpLCB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUpO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdDYWNoZVVwZGF0ZVNlcnZlclNuYXAodmlld0NhY2hlLCBzZXJ2ZXJTbmFwLCBjb21wbGV0ZSwgZmlsdGVyZWQpIHtcclxuICAgIHJldHVybiBuZXdWaWV3Q2FjaGUodmlld0NhY2hlLmV2ZW50Q2FjaGUsIG5ldyBDYWNoZU5vZGUoc2VydmVyU25hcCwgY29tcGxldGUsIGZpbHRlcmVkKSk7XHJcbn1cclxuZnVuY3Rpb24gdmlld0NhY2hlR2V0Q29tcGxldGVFdmVudFNuYXAodmlld0NhY2hlKSB7XHJcbiAgICByZXR1cm4gdmlld0NhY2hlLmV2ZW50Q2FjaGUuaXNGdWxseUluaXRpYWxpemVkKClcclxuICAgICAgICA/IHZpZXdDYWNoZS5ldmVudENhY2hlLmdldE5vZGUoKVxyXG4gICAgICAgIDogbnVsbDtcclxufVxyXG5mdW5jdGlvbiB2aWV3Q2FjaGVHZXRDb21wbGV0ZVNlcnZlclNuYXAodmlld0NhY2hlKSB7XHJcbiAgICByZXR1cm4gdmlld0NhY2hlLnNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpXHJcbiAgICAgICAgPyB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpXHJcbiAgICAgICAgOiBudWxsO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmxldCBlbXB0eUNoaWxkcmVuU2luZ2xldG9uO1xyXG4vKipcclxuICogU2luZ2xldG9uIGVtcHR5IGNoaWxkcmVuIGNvbGxlY3Rpb24uXHJcbiAqXHJcbiAqL1xyXG5jb25zdCBFbXB0eUNoaWxkcmVuID0gKCkgPT4ge1xyXG4gICAgaWYgKCFlbXB0eUNoaWxkcmVuU2luZ2xldG9uKSB7XHJcbiAgICAgICAgZW1wdHlDaGlsZHJlblNpbmdsZXRvbiA9IG5ldyBTb3J0ZWRNYXAoc3RyaW5nQ29tcGFyZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW1wdHlDaGlsZHJlblNpbmdsZXRvbjtcclxufTtcclxuLyoqXHJcbiAqIEEgdHJlZSB3aXRoIGltbXV0YWJsZSBlbGVtZW50cy5cclxuICovXHJcbmNsYXNzIEltbXV0YWJsZVRyZWUge1xyXG4gICAgY29uc3RydWN0b3IodmFsdWUsIGNoaWxkcmVuID0gRW1wdHlDaGlsZHJlbigpKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tT2JqZWN0KG9iaikge1xyXG4gICAgICAgIGxldCB0cmVlID0gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgZWFjaChvYmosIChjaGlsZFBhdGgsIGNoaWxkU25hcCkgPT4ge1xyXG4gICAgICAgICAgICB0cmVlID0gdHJlZS5zZXQobmV3IFBhdGgoY2hpbGRQYXRoKSwgY2hpbGRTbmFwKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdHJlZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgZW1wdHkgYW5kIHRoZXJlIGFyZSBubyBjaGlsZHJlblxyXG4gICAgICovXHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSBudWxsICYmIHRoaXMuY2hpbGRyZW4uaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIHBhdGggYW5kIHByZWRpY2F0ZSwgcmV0dXJuIHRoZSBmaXJzdCBub2RlIGFuZCB0aGUgcGF0aCB0byB0aGF0IG5vZGVcclxuICAgICAqIHdoZXJlIHRoZSBwcmVkaWNhdGUgcmV0dXJucyB0cnVlLlxyXG4gICAgICpcclxuICAgICAqIFRPRE8gRG8gYSBwZXJmIHRlc3QgLS0gSWYgd2UncmUgY3JlYXRpbmcgYSBidW5jaCBvZiBge3BhdGg6IHZhbHVlOn1gXHJcbiAgICAgKiBvYmplY3RzIG9uIHRoZSB3YXkgYmFjayBvdXQsIGl0IG1heSBiZSBiZXR0ZXIgdG8gcGFzcyBkb3duIGEgcGF0aFNvRmFyIG9iai5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVsYXRpdmVQYXRoIC0gVGhlIHJlbWFpbmRlciBvZiB0aGUgcGF0aFxyXG4gICAgICogQHBhcmFtIHByZWRpY2F0ZSAtIFRoZSBwcmVkaWNhdGUgdG8gc2F0aXNmeSB0byByZXR1cm4gYSBub2RlXHJcbiAgICAgKi9cclxuICAgIGZpbmRSb290TW9zdE1hdGNoaW5nUGF0aEFuZFZhbHVlKHJlbGF0aXZlUGF0aCwgcHJlZGljYXRlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgIT0gbnVsbCAmJiBwcmVkaWNhdGUodGhpcy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgcGF0aDogbmV3RW1wdHlQYXRoKCksIHZhbHVlOiB0aGlzLnZhbHVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocGF0aElzRW1wdHkocmVsYXRpdmVQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChyZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEV4aXN0aW5nUGF0aEFuZFZhbHVlID0gY2hpbGQuZmluZFJvb3RNb3N0TWF0Y2hpbmdQYXRoQW5kVmFsdWUocGF0aFBvcEZyb250KHJlbGF0aXZlUGF0aCksIHByZWRpY2F0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkRXhpc3RpbmdQYXRoQW5kVmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGhDaGlsZChuZXcgUGF0aChmcm9udCksIGNoaWxkRXhpc3RpbmdQYXRoQW5kVmFsdWUucGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHBhdGg6IGZ1bGxQYXRoLCB2YWx1ZTogY2hpbGRFeGlzdGluZ1BhdGhBbmRWYWx1ZS52YWx1ZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmQsIGlmIGl0IGV4aXN0cywgdGhlIHNob3J0ZXN0IHN1YnBhdGggb2YgdGhlIGdpdmVuIHBhdGggdGhhdCBwb2ludHMgYSBkZWZpbmVkXHJcbiAgICAgKiB2YWx1ZSBpbiB0aGUgdHJlZVxyXG4gICAgICovXHJcbiAgICBmaW5kUm9vdE1vc3RWYWx1ZUFuZFBhdGgocmVsYXRpdmVQYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFJvb3RNb3N0TWF0Y2hpbmdQYXRoQW5kVmFsdWUocmVsYXRpdmVQYXRoLCAoKSA9PiB0cnVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIHN1YnRyZWUgYXQgdGhlIGdpdmVuIHBhdGhcclxuICAgICAqL1xyXG4gICAgc3VidHJlZShyZWxhdGl2ZVBhdGgpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocmVsYXRpdmVQYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb250ID0gcGF0aEdldEZyb250KHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkVHJlZSA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkVHJlZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkVHJlZS5zdWJ0cmVlKHBhdGhQb3BGcm9udChyZWxhdGl2ZVBhdGgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlVHJlZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIHZhbHVlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVsYXRpdmVQYXRoIC0gUGF0aCB0byBzZXQgdmFsdWUgYXQuXHJcbiAgICAgKiBAcGFyYW0gdG9TZXQgLSBWYWx1ZSB0byBzZXQuXHJcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRpbmcgdHJlZS5cclxuICAgICAqL1xyXG4gICAgc2V0KHJlbGF0aXZlUGF0aCwgdG9TZXQpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocmVsYXRpdmVQYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUodG9TZXQsIHRoaXMuY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocmVsYXRpdmVQYXRoKTtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCkgfHwgbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkID0gY2hpbGQuc2V0KHBhdGhQb3BGcm9udChyZWxhdGl2ZVBhdGgpLCB0b1NldCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5pbnNlcnQoZnJvbnQsIG5ld0NoaWxkKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKHRoaXMudmFsdWUsIG5ld0NoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIHZhbHVlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVsYXRpdmVQYXRoIC0gUGF0aCB0byB2YWx1ZSB0byByZW1vdmUuXHJcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRpbmcgdHJlZS5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKHJlbGF0aXZlUGF0aCkge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShyZWxhdGl2ZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKG51bGwsIHRoaXMuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChyZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDaGlsZCA9IGNoaWxkLnJlbW92ZShwYXRoUG9wRnJvbnQocmVsYXRpdmVQYXRoKSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3Q2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hpbGQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnJlbW92ZShmcm9udCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uaW5zZXJ0KGZyb250LCBuZXdDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbCAmJiBuZXdDaGlsZHJlbi5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUodGhpcy52YWx1ZSwgbmV3Q2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSB2YWx1ZSBmcm9tIHRoZSB0cmVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZWxhdGl2ZVBhdGggLSBQYXRoIHRvIGdldCB2YWx1ZSBmb3IuXHJcbiAgICAgKiBAcmV0dXJucyBWYWx1ZSBhdCBwYXRoLCBvciBudWxsLlxyXG4gICAgICovXHJcbiAgICBnZXQocmVsYXRpdmVQYXRoKSB7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHJlbGF0aXZlUGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChyZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuZ2V0KHBhdGhQb3BGcm9udChyZWxhdGl2ZVBhdGgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXBsYWNlIHRoZSBzdWJ0cmVlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB3aXRoIHRoZSBnaXZlbiBuZXcgdHJlZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVsYXRpdmVQYXRoIC0gUGF0aCB0byByZXBsYWNlIHN1YnRyZWUgZm9yLlxyXG4gICAgICogQHBhcmFtIG5ld1RyZWUgLSBOZXcgdHJlZS5cclxuICAgICAqIEByZXR1cm5zIFJlc3VsdGluZyB0cmVlLlxyXG4gICAgICovXHJcbiAgICBzZXRUcmVlKHJlbGF0aXZlUGF0aCwgbmV3VHJlZSkge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShyZWxhdGl2ZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdUcmVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocmVsYXRpdmVQYXRoKTtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCkgfHwgbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkID0gY2hpbGQuc2V0VHJlZShwYXRoUG9wRnJvbnQocmVsYXRpdmVQYXRoKSwgbmV3VHJlZSk7XHJcbiAgICAgICAgICAgIGxldCBuZXdDaGlsZHJlbjtcclxuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnJlbW92ZShmcm9udCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uaW5zZXJ0KGZyb250LCBuZXdDaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKHRoaXMudmFsdWUsIG5ld0NoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm1zIGEgZGVwdGggZmlyc3QgZm9sZCBvbiB0aGlzIHRyZWUuIFRyYW5zZm9ybXMgYSB0cmVlIGludG8gYSBzaW5nbGVcclxuICAgICAqIHZhbHVlLCBnaXZlbiBhIGZ1bmN0aW9uIHRoYXQgb3BlcmF0ZXMgb24gdGhlIHBhdGggdG8gYSBub2RlLCBhbiBvcHRpb25hbFxyXG4gICAgICogY3VycmVudCB2YWx1ZSwgYW5kIGEgbWFwIG9mIGNoaWxkIG5hbWVzIHRvIGZvbGRlZCBzdWJ0cmVlc1xyXG4gICAgICovXHJcbiAgICBmb2xkKGZuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9sZF8obmV3RW1wdHlQYXRoKCksIGZuKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVjdXJzaXZlIGhlbHBlciBmb3IgcHVibGljLWZhY2luZyBmb2xkKCkgbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIGZvbGRfKHBhdGhTb0ZhciwgZm4pIHtcclxuICAgICAgICBjb25zdCBhY2N1bSA9IHt9O1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbCgoY2hpbGRLZXksIGNoaWxkVHJlZSkgPT4ge1xyXG4gICAgICAgICAgICBhY2N1bVtjaGlsZEtleV0gPSBjaGlsZFRyZWUuZm9sZF8ocGF0aENoaWxkKHBhdGhTb0ZhciwgY2hpbGRLZXkpLCBmbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZuKHBhdGhTb0ZhciwgdGhpcy52YWx1ZSwgYWNjdW0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSBmaXJzdCBtYXRjaGluZyB2YWx1ZSBvbiB0aGUgZ2l2ZW4gcGF0aC4gUmV0dXJuIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgZiB0byBpdC5cclxuICAgICAqL1xyXG4gICAgZmluZE9uUGF0aChwYXRoLCBmKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZE9uUGF0aF8ocGF0aCwgbmV3RW1wdHlQYXRoKCksIGYpO1xyXG4gICAgfVxyXG4gICAgZmluZE9uUGF0aF8ocGF0aFRvRm9sbG93LCBwYXRoU29GYXIsIGYpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnZhbHVlID8gZihwYXRoU29GYXIsIHRoaXMudmFsdWUpIDogZmFsc2U7XHJcbiAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHBhdGhUb0ZvbGxvdykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aFRvRm9sbG93KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dENoaWxkLmZpbmRPblBhdGhfKHBhdGhQb3BGcm9udChwYXRoVG9Gb2xsb3cpLCBwYXRoQ2hpbGQocGF0aFNvRmFyLCBmcm9udCksIGYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3JlYWNoT25QYXRoKHBhdGgsIGYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb3JlYWNoT25QYXRoXyhwYXRoLCBuZXdFbXB0eVBhdGgoKSwgZik7XHJcbiAgICB9XHJcbiAgICBmb3JlYWNoT25QYXRoXyhwYXRoVG9Gb2xsb3csIGN1cnJlbnRSZWxhdGl2ZVBhdGgsIGYpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocGF0aFRvRm9sbG93KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBmKGN1cnJlbnRSZWxhdGl2ZVBhdGgsIHRoaXMudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb250ID0gcGF0aEdldEZyb250KHBhdGhUb0ZvbGxvdyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcclxuICAgICAgICAgICAgaWYgKG5leHRDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRDaGlsZC5mb3JlYWNoT25QYXRoXyhwYXRoUG9wRnJvbnQocGF0aFRvRm9sbG93KSwgcGF0aENoaWxkKGN1cnJlbnRSZWxhdGl2ZVBhdGgsIGZyb250KSwgZik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxzIHRoZSBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBub2RlIGluIHRoZSB0cmVlIHRoYXQgaGFzIGEgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGYgLSBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSBwYXRoIGZyb20gdGhlIHJvb3Qgb2YgdGhlIHRyZWUgdG9cclxuICAgICAqIGEgbm9kZSwgYW5kIHRoZSB2YWx1ZSBhdCB0aGF0IG5vZGUuIENhbGxlZCBpbiBkZXB0aC1maXJzdCBvcmRlci5cclxuICAgICAqL1xyXG4gICAgZm9yZWFjaChmKSB7XHJcbiAgICAgICAgdGhpcy5mb3JlYWNoXyhuZXdFbXB0eVBhdGgoKSwgZik7XHJcbiAgICB9XHJcbiAgICBmb3JlYWNoXyhjdXJyZW50UmVsYXRpdmVQYXRoLCBmKSB7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKChjaGlsZE5hbWUsIGNoaWxkVHJlZSkgPT4ge1xyXG4gICAgICAgICAgICBjaGlsZFRyZWUuZm9yZWFjaF8ocGF0aENoaWxkKGN1cnJlbnRSZWxhdGl2ZVBhdGgsIGNoaWxkTmFtZSksIGYpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLnZhbHVlKSB7XHJcbiAgICAgICAgICAgIGYoY3VycmVudFJlbGF0aXZlUGF0aCwgdGhpcy52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yZWFjaENoaWxkKGYpIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkTmFtZSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZFRyZWUudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGYoY2hpbGROYW1lLCBjaGlsZFRyZWUudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgaG9sZHMgYSBjb2xsZWN0aW9uIG9mIHdyaXRlcyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIG5vZGVzIGluIHVuaXNvbi4gSXQgYWJzdHJhY3RzIGF3YXkgdGhlIGxvZ2ljIHdpdGhcclxuICogZGVhbGluZyB3aXRoIHByaW9yaXR5IHdyaXRlcyBhbmQgbXVsdGlwbGUgbmVzdGVkIHdyaXRlcy4gQXQgYW55IGdpdmVuIHBhdGggdGhlcmUgaXMgb25seSBhbGxvd2VkIHRvIGJlIG9uZSB3cml0ZVxyXG4gKiBtb2RpZnlpbmcgdGhhdCBwYXRoLiBBbnkgd3JpdGUgdG8gYW4gZXhpc3RpbmcgcGF0aCBvciBzaGFkb3dpbmcgYW4gZXhpc3RpbmcgcGF0aCB3aWxsIG1vZGlmeSB0aGF0IGV4aXN0aW5nIHdyaXRlXHJcbiAqIHRvIHJlZmxlY3QgdGhlIHdyaXRlIGFkZGVkLlxyXG4gKi9cclxuY2xhc3MgQ29tcG91bmRXcml0ZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3cml0ZVRyZWVfKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZVRyZWVfID0gd3JpdGVUcmVlXztcclxuICAgIH1cclxuICAgIHN0YXRpYyBlbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUobmV3IEltbXV0YWJsZVRyZWUobnVsbCkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbXBvdW5kV3JpdGVBZGRXcml0ZShjb21wb3VuZFdyaXRlLCBwYXRoLCBub2RlKSB7XHJcbiAgICBpZiAocGF0aElzRW1wdHkocGF0aCkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUobmV3IEltbXV0YWJsZVRyZWUobm9kZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgcm9vdG1vc3QgPSBjb21wb3VuZFdyaXRlLndyaXRlVHJlZV8uZmluZFJvb3RNb3N0VmFsdWVBbmRQYXRoKHBhdGgpO1xyXG4gICAgICAgIGlmIChyb290bW9zdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJvb3RNb3N0UGF0aCA9IHJvb3Rtb3N0LnBhdGg7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHJvb3Rtb3N0LnZhbHVlO1xyXG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgocm9vdE1vc3RQYXRoLCBwYXRoKTtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS51cGRhdGVDaGlsZChyZWxhdGl2ZVBhdGgsIG5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUoY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLnNldChyb290TW9zdFBhdGgsIHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzdWJ0cmVlID0gbmV3IEltbXV0YWJsZVRyZWUobm9kZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1dyaXRlVHJlZSA9IGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXy5zZXRUcmVlKHBhdGgsIHN1YnRyZWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUobmV3V3JpdGVUcmVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcG91bmRXcml0ZUFkZFdyaXRlcyhjb21wb3VuZFdyaXRlLCBwYXRoLCB1cGRhdGVzKSB7XHJcbiAgICBsZXQgbmV3V3JpdGUgPSBjb21wb3VuZFdyaXRlO1xyXG4gICAgZWFjaCh1cGRhdGVzLCAoY2hpbGRLZXksIG5vZGUpID0+IHtcclxuICAgICAgICBuZXdXcml0ZSA9IGNvbXBvdW5kV3JpdGVBZGRXcml0ZShuZXdXcml0ZSwgcGF0aENoaWxkKHBhdGgsIGNoaWxkS2V5KSwgbm9kZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZXdXcml0ZTtcclxufVxyXG4vKipcclxuICogV2lsbCByZW1vdmUgYSB3cml0ZSBhdCB0aGUgZ2l2ZW4gcGF0aCBhbmQgZGVlcGVyIHBhdGhzLiBUaGlzIHdpbGwgPGVtPm5vdDwvZW0+IG1vZGlmeSBhIHdyaXRlIGF0IGEgaGlnaGVyXHJcbiAqIGxvY2F0aW9uLCB3aGljaCBtdXN0IGJlIHJlbW92ZWQgYnkgY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIHRoYXQgcGF0aC5cclxuICpcclxuICogQHBhcmFtIGNvbXBvdW5kV3JpdGUgLSBUaGUgQ29tcG91bmRXcml0ZSB0byByZW1vdmUuXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggYXQgd2hpY2ggYSB3cml0ZSBhbmQgYWxsIGRlZXBlciB3cml0ZXMgc2hvdWxkIGJlIHJlbW92ZWRcclxuICogQHJldHVybnMgVGhlIG5ldyBDb21wb3VuZFdyaXRlIHdpdGggdGhlIHJlbW92ZWQgcGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gY29tcG91bmRXcml0ZVJlbW92ZVdyaXRlKGNvbXBvdW5kV3JpdGUsIHBhdGgpIHtcclxuICAgIGlmIChwYXRoSXNFbXB0eShwYXRoKSkge1xyXG4gICAgICAgIHJldHVybiBDb21wb3VuZFdyaXRlLmVtcHR5KCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBuZXdXcml0ZVRyZWUgPSBjb21wb3VuZFdyaXRlLndyaXRlVHJlZV8uc2V0VHJlZShwYXRoLCBuZXcgSW1tdXRhYmxlVHJlZShudWxsKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZFdyaXRlKG5ld1dyaXRlVHJlZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciB0aGlzIENvbXBvdW5kV3JpdGUgd2lsbCBmdWxseSBvdmVyd3JpdGUgYSBub2RlIGF0IGEgZ2l2ZW4gbG9jYXRpb24gYW5kIGNhbiB0aGVyZWZvcmUgYmVcclxuICogY29uc2lkZXJlZCBcImNvbXBsZXRlXCIuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb21wb3VuZFdyaXRlIC0gVGhlIENvbXBvdW5kV3JpdGUgdG8gY2hlY2suXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gY2hlY2sgZm9yXHJcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlcmUgaXMgYSBjb21wbGV0ZSB3cml0ZSBhdCB0aGF0IHBhdGhcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBvdW5kV3JpdGVIYXNDb21wbGV0ZVdyaXRlKGNvbXBvdW5kV3JpdGUsIHBhdGgpIHtcclxuICAgIHJldHVybiBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVOb2RlKGNvbXBvdW5kV3JpdGUsIHBhdGgpICE9IG51bGw7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBub2RlIGZvciBhIHBhdGggaWYgYW5kIG9ubHkgaWYgdGhlIG5vZGUgaXMgYSBcImNvbXBsZXRlXCIgb3ZlcndyaXRlIGF0IHRoYXQgcGF0aC4gVGhpcyB3aWxsIG5vdCBhZ2dyZWdhdGVcclxuICogd3JpdGVzIGZyb20gZGVlcGVyIHBhdGhzLCBidXQgd2lsbCByZXR1cm4gY2hpbGQgbm9kZXMgZnJvbSBhIG1vcmUgc2hhbGxvdyBwYXRoLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29tcG91bmRXcml0ZSAtIFRoZSBDb21wb3VuZFdyaXRlIHRvIGdldCB0aGUgbm9kZSBmcm9tLlxyXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIGdldCBhIGNvbXBsZXRlIHdyaXRlXHJcbiAqIEByZXR1cm5zIFRoZSBub2RlIGlmIGNvbXBsZXRlIGF0IHRoYXQgcGF0aCwgb3IgbnVsbCBvdGhlcndpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVOb2RlKGNvbXBvdW5kV3JpdGUsIHBhdGgpIHtcclxuICAgIGNvbnN0IHJvb3Rtb3N0ID0gY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLmZpbmRSb290TW9zdFZhbHVlQW5kUGF0aChwYXRoKTtcclxuICAgIGlmIChyb290bW9zdCAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlX1xyXG4gICAgICAgICAgICAuZ2V0KHJvb3Rtb3N0LnBhdGgpXHJcbiAgICAgICAgICAgIC5nZXRDaGlsZChuZXdSZWxhdGl2ZVBhdGgocm9vdG1vc3QucGF0aCwgcGF0aCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYWxsIGNoaWxkcmVuIHRoYXQgYXJlIGd1YXJhbnRlZWQgdG8gYmUgYSBjb21wbGV0ZSBvdmVyd3JpdGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb21wb3VuZFdyaXRlIC0gVGhlIENvbXBvdW5kV3JpdGUgdG8gZ2V0IGNoaWxkcmVuIGZyb20uXHJcbiAqIEByZXR1cm5zIEEgbGlzdCBvZiBhbGwgY29tcGxldGUgY2hpbGRyZW4uXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVDaGlsZHJlbihjb21wb3VuZFdyaXRlKSB7XHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xyXG4gICAgY29uc3Qgbm9kZSA9IGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXy52YWx1ZTtcclxuICAgIGlmIChub2RlICE9IG51bGwpIHtcclxuICAgICAgICAvLyBJZiBpdCdzIGEgbGVhZiBub2RlLCBpdCBoYXMgbm8gY2hpbGRyZW47IHNvIG5vdGhpbmcgdG8gZG8uXHJcbiAgICAgICAgaWYgKCFub2RlLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICBub2RlLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgKGNoaWxkTmFtZSwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5ldyBOYW1lZE5vZGUoY2hpbGROYW1lLCBjaGlsZE5vZGUpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkTmFtZSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZFRyZWUudmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChuZXcgTmFtZWROb2RlKGNoaWxkTmFtZSwgY2hpbGRUcmVlLnZhbHVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBjaGlsZHJlbjtcclxufVxyXG5mdW5jdGlvbiBjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlKGNvbXBvdW5kV3JpdGUsIHBhdGgpIHtcclxuICAgIGlmIChwYXRoSXNFbXB0eShwYXRoKSkge1xyXG4gICAgICAgIHJldHVybiBjb21wb3VuZFdyaXRlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgc2hhZG93aW5nTm9kZSA9IGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZU5vZGUoY29tcG91bmRXcml0ZSwgcGF0aCk7XHJcbiAgICAgICAgaWYgKHNoYWRvd2luZ05vZGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUobmV3IEltbXV0YWJsZVRyZWUoc2hhZG93aW5nTm9kZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZFdyaXRlKGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXy5zdWJ0cmVlKHBhdGgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIENvbXBvdW5kV3JpdGUgaXMgZW1wdHkgYW5kIHRoZXJlZm9yZSBkb2VzIG5vdCBtb2RpZnkgYW55IG5vZGVzLlxyXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoaXMgQ29tcG91bmRXcml0ZSBpcyBlbXB0eVxyXG4gKi9cclxuZnVuY3Rpb24gY29tcG91bmRXcml0ZUlzRW1wdHkoY29tcG91bmRXcml0ZSkge1xyXG4gICAgcmV0dXJuIGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXy5pc0VtcHR5KCk7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgdGhpcyBDb21wb3VuZFdyaXRlIHRvIGEgbm9kZS4gVGhlIG5vZGUgaXMgcmV0dXJuZWQgd2l0aCBhbGwgd3JpdGVzIGZyb20gdGhpcyBDb21wb3VuZFdyaXRlIGFwcGxpZWQgdG8gdGhlXHJcbiAqIG5vZGVcclxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBhcHBseSB0aGlzIENvbXBvdW5kV3JpdGUgdG9cclxuICogQHJldHVybnMgVGhlIG5vZGUgd2l0aCBhbGwgd3JpdGVzIGFwcGxpZWRcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBvdW5kV3JpdGVBcHBseShjb21wb3VuZFdyaXRlLCBub2RlKSB7XHJcbiAgICByZXR1cm4gYXBwbHlTdWJ0cmVlV3JpdGUobmV3RW1wdHlQYXRoKCksIGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXywgbm9kZSk7XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlTdWJ0cmVlV3JpdGUocmVsYXRpdmVQYXRoLCB3cml0ZVRyZWUsIG5vZGUpIHtcclxuICAgIGlmICh3cml0ZVRyZWUudmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIFNpbmNlIHRoZXJlIGEgd3JpdGUgaXMgYWx3YXlzIGEgbGVhZiwgd2UncmUgZG9uZSBoZXJlXHJcbiAgICAgICAgcmV0dXJuIG5vZGUudXBkYXRlQ2hpbGQocmVsYXRpdmVQYXRoLCB3cml0ZVRyZWUudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IHByaW9yaXR5V3JpdGUgPSBudWxsO1xyXG4gICAgICAgIHdyaXRlVHJlZS5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKChjaGlsZEtleSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZEtleSA9PT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHByaW9yaXRpZXMgYXQgdGhlIGVuZCBzbyB3ZSBkb24ndCB1cGRhdGUgcHJpb3JpdGllcyBmb3IgZWl0aGVyIGVtcHR5IG5vZGVzIG9yIGZvcmdldFxyXG4gICAgICAgICAgICAgICAgLy8gdG8gYXBwbHkgcHJpb3JpdGllcyB0byBlbXB0eSBub2RlcyB0aGF0IGFyZSBsYXRlciBmaWxsZWRcclxuICAgICAgICAgICAgICAgIGFzc2VydChjaGlsZFRyZWUudmFsdWUgIT09IG51bGwsICdQcmlvcml0eSB3cml0ZXMgbXVzdCBhbHdheXMgYmUgbGVhZiBub2RlcycpO1xyXG4gICAgICAgICAgICAgICAgcHJpb3JpdHlXcml0ZSA9IGNoaWxkVHJlZS52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBhcHBseVN1YnRyZWVXcml0ZShwYXRoQ2hpbGQocmVsYXRpdmVQYXRoLCBjaGlsZEtleSksIGNoaWxkVHJlZSwgbm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwcmlvcml0eSB3cml0ZSwgd2Ugb25seSBhcHBseSBpdCBpZiB0aGUgbm9kZSBpcyBub3QgZW1wdHlcclxuICAgICAgICBpZiAoIW5vZGUuZ2V0Q2hpbGQocmVsYXRpdmVQYXRoKS5pc0VtcHR5KCkgJiYgcHJpb3JpdHlXcml0ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZS51cGRhdGVDaGlsZChwYXRoQ2hpbGQocmVsYXRpdmVQYXRoLCAnLnByaW9yaXR5JyksIHByaW9yaXR5V3JpdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ3JlYXRlIGEgbmV3IFdyaXRlVHJlZVJlZiBmb3IgdGhlIGdpdmVuIHBhdGguIEZvciB1c2Ugd2l0aCBhIG5ldyBzeW5jIHBvaW50IGF0IHRoZSBnaXZlbiBwYXRoLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlQ2hpbGRXcml0ZXMod3JpdGVUcmVlLCBwYXRoKSB7XHJcbiAgICByZXR1cm4gbmV3V3JpdGVUcmVlUmVmKHBhdGgsIHdyaXRlVHJlZSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlY29yZCBhIG5ldyBvdmVyd3JpdGUgZnJvbSB1c2VyIGNvZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB2aXNpYmxlIC0gVGhpcyBpcyBzZXQgdG8gZmFsc2UgYnkgc29tZSB0cmFuc2FjdGlvbnMuIEl0IHNob3VsZCBiZSBleGNsdWRlZCBmcm9tIGV2ZW50IGNhY2hlc1xyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlQWRkT3ZlcndyaXRlKHdyaXRlVHJlZSwgcGF0aCwgc25hcCwgd3JpdGVJZCwgdmlzaWJsZSkge1xyXG4gICAgYXNzZXJ0KHdyaXRlSWQgPiB3cml0ZVRyZWUubGFzdFdyaXRlSWQsICdTdGFja2luZyBhbiBvbGRlciB3cml0ZSBvbiB0b3Agb2YgbmV3ZXIgb25lcycpO1xyXG4gICAgaWYgKHZpc2libGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHZpc2libGUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgd3JpdGVUcmVlLmFsbFdyaXRlcy5wdXNoKHtcclxuICAgICAgICBwYXRoLFxyXG4gICAgICAgIHNuYXAsXHJcbiAgICAgICAgd3JpdGVJZCxcclxuICAgICAgICB2aXNpYmxlXHJcbiAgICB9KTtcclxuICAgIGlmICh2aXNpYmxlKSB7XHJcbiAgICAgICAgd3JpdGVUcmVlLnZpc2libGVXcml0ZXMgPSBjb21wb3VuZFdyaXRlQWRkV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHBhdGgsIHNuYXApO1xyXG4gICAgfVxyXG4gICAgd3JpdGVUcmVlLmxhc3RXcml0ZUlkID0gd3JpdGVJZDtcclxufVxyXG4vKipcclxuICogUmVjb3JkIGEgbmV3IG1lcmdlIGZyb20gdXNlciBjb2RlLlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlQWRkTWVyZ2Uod3JpdGVUcmVlLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlSWQpIHtcclxuICAgIGFzc2VydCh3cml0ZUlkID4gd3JpdGVUcmVlLmxhc3RXcml0ZUlkLCAnU3RhY2tpbmcgYW4gb2xkZXIgbWVyZ2Ugb24gdG9wIG9mIG5ld2VyIG9uZXMnKTtcclxuICAgIHdyaXRlVHJlZS5hbGxXcml0ZXMucHVzaCh7XHJcbiAgICAgICAgcGF0aCxcclxuICAgICAgICBjaGlsZHJlbjogY2hhbmdlZENoaWxkcmVuLFxyXG4gICAgICAgIHdyaXRlSWQsXHJcbiAgICAgICAgdmlzaWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICB3cml0ZVRyZWUudmlzaWJsZVdyaXRlcyA9IGNvbXBvdW5kV3JpdGVBZGRXcml0ZXMod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHBhdGgsIGNoYW5nZWRDaGlsZHJlbik7XHJcbiAgICB3cml0ZVRyZWUubGFzdFdyaXRlSWQgPSB3cml0ZUlkO1xyXG59XHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUdldFdyaXRlKHdyaXRlVHJlZSwgd3JpdGVJZCkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cml0ZVRyZWUuYWxsV3JpdGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcmVjb3JkID0gd3JpdGVUcmVlLmFsbFdyaXRlc1tpXTtcclxuICAgICAgICBpZiAocmVjb3JkLndyaXRlSWQgPT09IHdyaXRlSWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4vKipcclxuICogUmVtb3ZlIGEgd3JpdGUgKGVpdGhlciBhbiBvdmVyd3JpdGUgb3IgbWVyZ2UpIHRoYXQgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGFja25vd2xlZGdlIGJ5IHRoZSBzZXJ2ZXIuIFJlY2FsY3VsYXRlc1xyXG4gKiB0aGUgdHJlZSBpZiBuZWNlc3NhcnkuICBXZSByZXR1cm4gdHJ1ZSBpZiBpdCBtYXkgaGF2ZSBiZWVuIHZpc2libGUsIG1lYW5pbmcgdmlld3MgbmVlZCB0byByZWV2YWx1YXRlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB3cml0ZSBtYXkgaGF2ZSBiZWVuIHZpc2libGUgKG1lYW5pbmcgd2UnbGwgbmVlZCB0byByZWV2YWx1YXRlIC8gcmFpc2VcclxuICogZXZlbnRzIGFzIGEgcmVzdWx0KS5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlbW92ZVdyaXRlKHdyaXRlVHJlZSwgd3JpdGVJZCkge1xyXG4gICAgLy8gTm90ZTogZGlzYWJsaW5nIHRoaXMgY2hlY2suIEl0IGNvdWxkIGJlIGEgdHJhbnNhY3Rpb24gdGhhdCBwcmVlbXB0ZWQgYW5vdGhlciB0cmFuc2FjdGlvbiwgYW5kIHRodXMgd2FzIGFwcGxpZWRcclxuICAgIC8vIG91dCBvZiBvcmRlci5cclxuICAgIC8vY29uc3QgdmFsaWRDbGVhciA9IHJldmVydCB8fCB0aGlzLmFsbFdyaXRlc18ubGVuZ3RoID09PSAwIHx8IHdyaXRlSWQgPD0gdGhpcy5hbGxXcml0ZXNfWzBdLndyaXRlSWQ7XHJcbiAgICAvL2Fzc2VydCh2YWxpZENsZWFyLCBcIkVpdGhlciB3ZSBkb24ndCBoYXZlIHRoaXMgd3JpdGUsIG9yIGl0J3MgdGhlIGZpcnN0IG9uZSBpbiB0aGUgcXVldWVcIik7XHJcbiAgICBjb25zdCBpZHggPSB3cml0ZVRyZWUuYWxsV3JpdGVzLmZpbmRJbmRleChzID0+IHtcclxuICAgICAgICByZXR1cm4gcy53cml0ZUlkID09PSB3cml0ZUlkO1xyXG4gICAgfSk7XHJcbiAgICBhc3NlcnQoaWR4ID49IDAsICdyZW1vdmVXcml0ZSBjYWxsZWQgd2l0aCBub25leGlzdGVudCB3cml0ZUlkLicpO1xyXG4gICAgY29uc3Qgd3JpdGVUb1JlbW92ZSA9IHdyaXRlVHJlZS5hbGxXcml0ZXNbaWR4XTtcclxuICAgIHdyaXRlVHJlZS5hbGxXcml0ZXMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICBsZXQgcmVtb3ZlZFdyaXRlV2FzVmlzaWJsZSA9IHdyaXRlVG9SZW1vdmUudmlzaWJsZTtcclxuICAgIGxldCByZW1vdmVkV3JpdGVPdmVybGFwc1dpdGhPdGhlcldyaXRlcyA9IGZhbHNlO1xyXG4gICAgbGV0IGkgPSB3cml0ZVRyZWUuYWxsV3JpdGVzLmxlbmd0aCAtIDE7XHJcbiAgICB3aGlsZSAocmVtb3ZlZFdyaXRlV2FzVmlzaWJsZSAmJiBpID49IDApIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50V3JpdGUgPSB3cml0ZVRyZWUuYWxsV3JpdGVzW2ldO1xyXG4gICAgICAgIGlmIChjdXJyZW50V3JpdGUudmlzaWJsZSkge1xyXG4gICAgICAgICAgICBpZiAoaSA+PSBpZHggJiZcclxuICAgICAgICAgICAgICAgIHdyaXRlVHJlZVJlY29yZENvbnRhaW5zUGF0aF8oY3VycmVudFdyaXRlLCB3cml0ZVRvUmVtb3ZlLnBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVtb3ZlZCB3cml0ZSB3YXMgY29tcGxldGVseSBzaGFkb3dlZCBieSBhIHN1YnNlcXVlbnQgd3JpdGUuXHJcbiAgICAgICAgICAgICAgICByZW1vdmVkV3JpdGVXYXNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGF0aENvbnRhaW5zKHdyaXRlVG9SZW1vdmUucGF0aCwgY3VycmVudFdyaXRlLnBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFaXRoZXIgd2UncmUgY292ZXJpbmcgc29tZSB3cml0ZXMgb3IgdGhleSdyZSBjb3ZlcmluZyBwYXJ0IG9mIHVzIChkZXBlbmRpbmcgb24gd2hpY2ggY2FtZSBmaXJzdCkuXHJcbiAgICAgICAgICAgICAgICByZW1vdmVkV3JpdGVPdmVybGFwc1dpdGhPdGhlcldyaXRlcyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaS0tO1xyXG4gICAgfVxyXG4gICAgaWYgKCFyZW1vdmVkV3JpdGVXYXNWaXNpYmxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmVtb3ZlZFdyaXRlT3ZlcmxhcHNXaXRoT3RoZXJXcml0ZXMpIHtcclxuICAgICAgICAvLyBUaGVyZSdzIHNvbWUgc2hhZG93aW5nIGdvaW5nIG9uLiBKdXN0IHJlYnVpbGQgdGhlIHZpc2libGUgd3JpdGVzIGZyb20gc2NyYXRjaC5cclxuICAgICAgICB3cml0ZVRyZWVSZXNldFRyZWVfKHdyaXRlVHJlZSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBUaGVyZSdzIG5vIHNoYWRvd2luZy4gIFdlIGNhbiBzYWZlbHkganVzdCByZW1vdmUgdGhlIHdyaXRlKHMpIGZyb20gdmlzaWJsZVdyaXRlcy5cclxuICAgICAgICBpZiAod3JpdGVUb1JlbW92ZS5zbmFwKSB7XHJcbiAgICAgICAgICAgIHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzID0gY29tcG91bmRXcml0ZVJlbW92ZVdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCB3cml0ZVRvUmVtb3ZlLnBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB3cml0ZVRvUmVtb3ZlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICBlYWNoKGNoaWxkcmVuLCAoY2hpbGROYW1lKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVRyZWUudmlzaWJsZVdyaXRlcyA9IGNvbXBvdW5kV3JpdGVSZW1vdmVXcml0ZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgcGF0aENoaWxkKHdyaXRlVG9SZW1vdmUucGF0aCwgY2hpbGROYW1lKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB3cml0ZVRyZWVSZWNvcmRDb250YWluc1BhdGhfKHdyaXRlUmVjb3JkLCBwYXRoKSB7XHJcbiAgICBpZiAod3JpdGVSZWNvcmQuc25hcCkge1xyXG4gICAgICAgIHJldHVybiBwYXRoQ29udGFpbnMod3JpdGVSZWNvcmQucGF0aCwgcGF0aCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkTmFtZSBpbiB3cml0ZVJlY29yZC5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBpZiAod3JpdGVSZWNvcmQuY2hpbGRyZW4uaGFzT3duUHJvcGVydHkoY2hpbGROYW1lKSAmJlxyXG4gICAgICAgICAgICAgICAgcGF0aENvbnRhaW5zKHBhdGhDaGlsZCh3cml0ZVJlY29yZC5wYXRoLCBjaGlsZE5hbWUpLCBwYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZS1sYXllciB0aGUgd3JpdGVzIGFuZCBtZXJnZXMgaW50byBhIHRyZWUgc28gd2UgY2FuIGVmZmljaWVudGx5IGNhbGN1bGF0ZSBldmVudCBzbmFwc2hvdHNcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlc2V0VHJlZV8od3JpdGVUcmVlKSB7XHJcbiAgICB3cml0ZVRyZWUudmlzaWJsZVdyaXRlcyA9IHdyaXRlVHJlZUxheWVyVHJlZV8od3JpdGVUcmVlLmFsbFdyaXRlcywgd3JpdGVUcmVlRGVmYXVsdEZpbHRlcl8sIG5ld0VtcHR5UGF0aCgpKTtcclxuICAgIGlmICh3cml0ZVRyZWUuYWxsV3JpdGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB3cml0ZVRyZWUubGFzdFdyaXRlSWQgPVxyXG4gICAgICAgICAgICB3cml0ZVRyZWUuYWxsV3JpdGVzW3dyaXRlVHJlZS5hbGxXcml0ZXMubGVuZ3RoIC0gMV0ud3JpdGVJZDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHdyaXRlVHJlZS5sYXN0V3JpdGVJZCA9IC0xO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBmaWx0ZXIgdXNlZCB3aGVuIGNvbnN0cnVjdGluZyB0aGUgdHJlZS4gS2VlcCBldmVyeXRoaW5nIHRoYXQncyB2aXNpYmxlLlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlRGVmYXVsdEZpbHRlcl8od3JpdGUpIHtcclxuICAgIHJldHVybiB3cml0ZS52aXNpYmxlO1xyXG59XHJcbi8qKlxyXG4gKiBTdGF0aWMgbWV0aG9kLiBHaXZlbiBhbiBhcnJheSBvZiBXcml0ZVJlY29yZHMsIGEgZmlsdGVyIGZvciB3aGljaCBvbmVzIHRvIGluY2x1ZGUsIGFuZCBhIHBhdGgsIGNvbnN0cnVjdCB0aGUgdHJlZSBvZlxyXG4gKiBldmVudCBkYXRhIGF0IHRoYXQgcGF0aC5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUxheWVyVHJlZV8od3JpdGVzLCBmaWx0ZXIsIHRyZWVSb290KSB7XHJcbiAgICBsZXQgY29tcG91bmRXcml0ZSA9IENvbXBvdW5kV3JpdGUuZW1wdHkoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd3JpdGVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgY29uc3Qgd3JpdGUgPSB3cml0ZXNbaV07XHJcbiAgICAgICAgLy8gVGhlb3J5LCBhIGxhdGVyIHNldCB3aWxsIGVpdGhlcjpcclxuICAgICAgICAvLyBhKSBhYm9ydCBhIHJlbGV2YW50IHRyYW5zYWN0aW9uLCBzbyBubyBuZWVkIHRvIHdvcnJ5IGFib3V0IGV4Y2x1ZGluZyBpdCBmcm9tIGNhbGN1bGF0aW5nIHRoYXQgdHJhbnNhY3Rpb25cclxuICAgICAgICAvLyBiKSBub3QgYmUgcmVsZXZhbnQgdG8gYSB0cmFuc2FjdGlvbiAoc2VwYXJhdGUgYnJhbmNoKSwgc28gYWdhaW4gd2lsbCBub3QgYWZmZWN0IHRoZSBkYXRhIGZvciB0aGF0IHRyYW5zYWN0aW9uXHJcbiAgICAgICAgaWYgKGZpbHRlcih3cml0ZSkpIHtcclxuICAgICAgICAgICAgY29uc3Qgd3JpdGVQYXRoID0gd3JpdGUucGF0aDtcclxuICAgICAgICAgICAgbGV0IHJlbGF0aXZlUGF0aDtcclxuICAgICAgICAgICAgaWYgKHdyaXRlLnNuYXApIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXRoQ29udGFpbnModHJlZVJvb3QsIHdyaXRlUGF0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgodHJlZVJvb3QsIHdyaXRlUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG91bmRXcml0ZSA9IGNvbXBvdW5kV3JpdGVBZGRXcml0ZShjb21wb3VuZFdyaXRlLCByZWxhdGl2ZVBhdGgsIHdyaXRlLnNuYXApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGF0aENvbnRhaW5zKHdyaXRlUGF0aCwgdHJlZVJvb3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHdyaXRlUGF0aCwgdHJlZVJvb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kV3JpdGUgPSBjb21wb3VuZFdyaXRlQWRkV3JpdGUoY29tcG91bmRXcml0ZSwgbmV3RW1wdHlQYXRoKCksIHdyaXRlLnNuYXAuZ2V0Q2hpbGQocmVsYXRpdmVQYXRoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh3cml0ZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGhDb250YWlucyh0cmVlUm9vdCwgd3JpdGVQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aCh0cmVlUm9vdCwgd3JpdGVQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb3VuZFdyaXRlID0gY29tcG91bmRXcml0ZUFkZFdyaXRlcyhjb21wb3VuZFdyaXRlLCByZWxhdGl2ZVBhdGgsIHdyaXRlLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhdGhDb250YWlucyh3cml0ZVBhdGgsIHRyZWVSb290KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aCh3cml0ZVBhdGgsIHRyZWVSb290KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aElzRW1wdHkocmVsYXRpdmVQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZFdyaXRlID0gY29tcG91bmRXcml0ZUFkZFdyaXRlcyhjb21wb3VuZFdyaXRlLCBuZXdFbXB0eVBhdGgoKSwgd3JpdGUuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBzYWZlR2V0KHdyaXRlLmNoaWxkcmVuLCBwYXRoR2V0RnJvbnQocmVsYXRpdmVQYXRoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgZXhpc3RzIGEgY2hpbGQgaW4gdGhpcyBub2RlIHRoYXQgbWF0Y2hlcyB0aGUgcm9vdCBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWVwTm9kZSA9IGNoaWxkLmdldENoaWxkKHBhdGhQb3BGcm9udChyZWxhdGl2ZVBhdGgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kV3JpdGUgPSBjb21wb3VuZFdyaXRlQWRkV3JpdGUoY29tcG91bmRXcml0ZSwgbmV3RW1wdHlQYXRoKCksIGRlZXBOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IoJ1dyaXRlUmVjb3JkIHNob3VsZCBoYXZlIC5zbmFwIG9yIC5jaGlsZHJlbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbXBvdW5kV3JpdGU7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIG9wdGlvbmFsLCB1bmRlcmx5aW5nIHNlcnZlciBkYXRhLCBhbmQgYW4gb3B0aW9uYWwgc2V0IG9mIGNvbnN0cmFpbnRzIChleGNsdWRlIHNvbWUgc2V0cywgaW5jbHVkZSBoaWRkZW5cclxuICogd3JpdGVzKSwgYXR0ZW1wdCB0byBjYWxjdWxhdGUgYSBjb21wbGV0ZSBzbmFwc2hvdCBmb3IgdGhlIGdpdmVuIHBhdGhcclxuICpcclxuICogQHBhcmFtIHdyaXRlSWRzVG9FeGNsdWRlIC0gQW4gb3B0aW9uYWwgc2V0IHRvIGJlIGV4Y2x1ZGVkXHJcbiAqIEBwYXJhbSBpbmNsdWRlSGlkZGVuV3JpdGVzIC0gRGVmYXVsdHMgdG8gZmFsc2UsIHdoZXRoZXIgb3Igbm90IHRvIGxheWVyIG9uIHdyaXRlcyB3aXRoIHZpc2libGUgc2V0IHRvIGZhbHNlXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlKHdyaXRlVHJlZSwgdHJlZVBhdGgsIGNvbXBsZXRlU2VydmVyQ2FjaGUsIHdyaXRlSWRzVG9FeGNsdWRlLCBpbmNsdWRlSGlkZGVuV3JpdGVzKSB7XHJcbiAgICBpZiAoIXdyaXRlSWRzVG9FeGNsdWRlICYmICFpbmNsdWRlSGlkZGVuV3JpdGVzKSB7XHJcbiAgICAgICAgY29uc3Qgc2hhZG93aW5nTm9kZSA9IGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZU5vZGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHRyZWVQYXRoKTtcclxuICAgICAgICBpZiAoc2hhZG93aW5nTm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaGFkb3dpbmdOb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgc3ViTWVyZ2UgPSBjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCB0cmVlUGF0aCk7XHJcbiAgICAgICAgICAgIGlmIChjb21wb3VuZFdyaXRlSXNFbXB0eShzdWJNZXJnZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZVNlcnZlckNhY2hlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBsZXRlU2VydmVyQ2FjaGUgPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgIWNvbXBvdW5kV3JpdGVIYXNDb21wbGV0ZVdyaXRlKHN1Yk1lcmdlLCBuZXdFbXB0eVBhdGgoKSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHdvdWxkbid0IGhhdmUgYSBjb21wbGV0ZSBzbmFwc2hvdCwgc2luY2UgdGhlcmUncyBubyB1bmRlcmx5aW5nIGRhdGEgYW5kIG5vIGNvbXBsZXRlIHNoYWRvd1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXllcmVkQ2FjaGUgPSBjb21wbGV0ZVNlcnZlckNhY2hlIHx8IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvdW5kV3JpdGVBcHBseShzdWJNZXJnZSwgbGF5ZXJlZENhY2hlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG1lcmdlID0gY29tcG91bmRXcml0ZUNoaWxkQ29tcG91bmRXcml0ZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgdHJlZVBhdGgpO1xyXG4gICAgICAgIGlmICghaW5jbHVkZUhpZGRlbldyaXRlcyAmJiBjb21wb3VuZFdyaXRlSXNFbXB0eShtZXJnZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlU2VydmVyQ2FjaGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgc2VydmVyIGNhY2hlIGlzIG51bGwsIGFuZCB3ZSBkb24ndCBoYXZlIGEgY29tcGxldGUgY2FjaGUsIHdlIG5lZWQgdG8gcmV0dXJuIG51bGxcclxuICAgICAgICAgICAgaWYgKCFpbmNsdWRlSGlkZGVuV3JpdGVzICYmXHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZVNlcnZlckNhY2hlID09IG51bGwgJiZcclxuICAgICAgICAgICAgICAgICFjb21wb3VuZFdyaXRlSGFzQ29tcGxldGVXcml0ZShtZXJnZSwgbmV3RW1wdHlQYXRoKCkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IGZ1bmN0aW9uICh3cml0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHdyaXRlLnZpc2libGUgfHwgaW5jbHVkZUhpZGRlbldyaXRlcykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCF3cml0ZUlkc1RvRXhjbHVkZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIX53cml0ZUlkc1RvRXhjbHVkZS5pbmRleE9mKHdyaXRlLndyaXRlSWQpKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAocGF0aENvbnRhaW5zKHdyaXRlLnBhdGgsIHRyZWVQYXRoKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aENvbnRhaW5zKHRyZWVQYXRoLCB3cml0ZS5wYXRoKSkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lcmdlQXRQYXRoID0gd3JpdGVUcmVlTGF5ZXJUcmVlXyh3cml0ZVRyZWUuYWxsV3JpdGVzLCBmaWx0ZXIsIHRyZWVQYXRoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxheWVyZWRDYWNoZSA9IGNvbXBsZXRlU2VydmVyQ2FjaGUgfHwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG91bmRXcml0ZUFwcGx5KG1lcmdlQXRQYXRoLCBsYXllcmVkQ2FjaGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBXaXRoIG9wdGlvbmFsLCB1bmRlcmx5aW5nIHNlcnZlciBkYXRhLCBhdHRlbXB0IHRvIHJldHVybiBhIGNoaWxkcmVuIG5vZGUgb2YgY2hpbGRyZW4gdGhhdCB3ZSBoYXZlIGNvbXBsZXRlIGRhdGEgZm9yLlxyXG4gKiBVc2VkIHdoZW4gY3JlYXRpbmcgbmV3IHZpZXdzLCB0byBwcmUtZmlsbCB0aGVpciBjb21wbGV0ZSBldmVudCBjaGlsZHJlbiBzbmFwc2hvdC5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4od3JpdGVUcmVlLCB0cmVlUGF0aCwgY29tcGxldGVTZXJ2ZXJDaGlsZHJlbikge1xyXG4gICAgbGV0IGNvbXBsZXRlQ2hpbGRyZW4gPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgIGNvbnN0IHRvcExldmVsU2V0ID0gY29tcG91bmRXcml0ZUdldENvbXBsZXRlTm9kZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgdHJlZVBhdGgpO1xyXG4gICAgaWYgKHRvcExldmVsU2V0KSB7XHJcbiAgICAgICAgaWYgKCF0b3BMZXZlbFNldC5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgLy8gd2UncmUgc2hhZG93aW5nIGV2ZXJ5dGhpbmcuIFJldHVybiB0aGUgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgIHRvcExldmVsU2V0LmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgKGNoaWxkTmFtZSwgY2hpbGRTbmFwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZUNoaWxkcmVuID0gY29tcGxldGVDaGlsZHJlbi51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUsIGNoaWxkU25hcCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29tcGxldGVDaGlsZHJlbjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNvbXBsZXRlU2VydmVyQ2hpbGRyZW4pIHtcclxuICAgICAgICAvLyBMYXllciBhbnkgY2hpbGRyZW4gd2UgaGF2ZSBvbiB0b3Agb2YgdGhpc1xyXG4gICAgICAgIC8vIFdlIGtub3cgd2UgZG9uJ3QgaGF2ZSBhIHRvcC1sZXZlbCBzZXQsIHNvIGp1c3QgZW51bWVyYXRlIGV4aXN0aW5nIGNoaWxkcmVuXHJcbiAgICAgICAgY29uc3QgbWVyZ2UgPSBjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCB0cmVlUGF0aCk7XHJcbiAgICAgICAgY29tcGxldGVTZXJ2ZXJDaGlsZHJlbi5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIChjaGlsZE5hbWUsIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBub2RlID0gY29tcG91bmRXcml0ZUFwcGx5KGNvbXBvdW5kV3JpdGVDaGlsZENvbXBvdW5kV3JpdGUobWVyZ2UsIG5ldyBQYXRoKGNoaWxkTmFtZSkpLCBjaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICBjb21wbGV0ZUNoaWxkcmVuID0gY29tcGxldGVDaGlsZHJlbi51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUsIG5vZGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIEFkZCBhbnkgY29tcGxldGUgY2hpbGRyZW4gd2UgaGF2ZSBmcm9tIHRoZSBzZXRcclxuICAgICAgICBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVDaGlsZHJlbihtZXJnZSkuZm9yRWFjaChuYW1lZE5vZGUgPT4ge1xyXG4gICAgICAgICAgICBjb21wbGV0ZUNoaWxkcmVuID0gY29tcGxldGVDaGlsZHJlbi51cGRhdGVJbW1lZGlhdGVDaGlsZChuYW1lZE5vZGUubmFtZSwgbmFtZWROb2RlLm5vZGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb21wbGV0ZUNoaWxkcmVuO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBhbnl0aGluZyB0byBsYXllciBvbiB0b3Agb2YuIExheWVyIG9uIGFueSBjaGlsZHJlbiB3ZSBoYXZlXHJcbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGNhbiByZXR1cm4gYW4gZW1wdHkgc25hcCBpZiB3ZSBoYXZlIGEgZGVmaW5lZCBkZWxldGVcclxuICAgICAgICBjb25zdCBtZXJnZSA9IGNvbXBvdW5kV3JpdGVDaGlsZENvbXBvdW5kV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHRyZWVQYXRoKTtcclxuICAgICAgICBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVDaGlsZHJlbihtZXJnZSkuZm9yRWFjaChuYW1lZE5vZGUgPT4ge1xyXG4gICAgICAgICAgICBjb21wbGV0ZUNoaWxkcmVuID0gY29tcGxldGVDaGlsZHJlbi51cGRhdGVJbW1lZGlhdGVDaGlsZChuYW1lZE5vZGUubmFtZSwgbmFtZWROb2RlLm5vZGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb21wbGV0ZUNoaWxkcmVuO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBHaXZlbiB0aGF0IHRoZSB1bmRlcmx5aW5nIHNlcnZlciBkYXRhIGhhcyB1cGRhdGVkLCBkZXRlcm1pbmUgd2hhdCwgaWYgYW55dGhpbmcsIG5lZWRzIHRvIGJlXHJcbiAqIGFwcGxpZWQgdG8gdGhlIGV2ZW50IGNhY2hlLlxyXG4gKlxyXG4gKiBQb3NzaWJpbGl0aWVzOlxyXG4gKlxyXG4gKiAxLiBObyB3cml0ZXMgYXJlIHNoYWRvd2luZy4gRXZlbnRzIHNob3VsZCBiZSByYWlzZWQsIHRoZSBzbmFwIHRvIGJlIGFwcGxpZWQgY29tZXMgZnJvbSB0aGUgc2VydmVyIGRhdGFcclxuICpcclxuICogMi4gU29tZSB3cml0ZSBpcyBjb21wbGV0ZWx5IHNoYWRvd2luZy4gTm8gZXZlbnRzIHRvIGJlIHJhaXNlZFxyXG4gKlxyXG4gKiAzLiBJcyBwYXJ0aWFsbHkgc2hhZG93ZWQuIEV2ZW50c1xyXG4gKlxyXG4gKiBFaXRoZXIgZXhpc3RpbmdFdmVudFNuYXAgb3IgZXhpc3RpbmdTZXJ2ZXJTbmFwIG11c3QgZXhpc3RcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUNhbGNFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJPdmVyd3JpdGUod3JpdGVUcmVlLCB0cmVlUGF0aCwgY2hpbGRQYXRoLCBleGlzdGluZ0V2ZW50U25hcCwgZXhpc3RpbmdTZXJ2ZXJTbmFwKSB7XHJcbiAgICBhc3NlcnQoZXhpc3RpbmdFdmVudFNuYXAgfHwgZXhpc3RpbmdTZXJ2ZXJTbmFwLCAnRWl0aGVyIGV4aXN0aW5nRXZlbnRTbmFwIG9yIGV4aXN0aW5nU2VydmVyU25hcCBtdXN0IGV4aXN0Jyk7XHJcbiAgICBjb25zdCBwYXRoID0gcGF0aENoaWxkKHRyZWVQYXRoLCBjaGlsZFBhdGgpO1xyXG4gICAgaWYgKGNvbXBvdW5kV3JpdGVIYXNDb21wbGV0ZVdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCBwYXRoKSkge1xyXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgY2FuIHByb2JhYmx5IGd1YXJhbnRlZSB0aGF0IHdlJ3JlIGluIGNhc2UgMiwgbWVhbmluZyBubyBldmVudHNcclxuICAgICAgICAvLyBNYXkgbmVlZCB0byBjaGVjayB2aXNpYmlsaXR5IHdoaWxlIGRvaW5nIHRoZSBmaW5kUm9vdE1vc3RWYWx1ZUFuZFBhdGggY2FsbFxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gTm8gY29tcGxldGUgc2hhZG93aW5nLiBXZSdyZSBlaXRoZXIgcGFydGlhbGx5IHNoYWRvd2luZyBvciBub3Qgc2hhZG93aW5nIGF0IGFsbC5cclxuICAgICAgICBjb25zdCBjaGlsZE1lcmdlID0gY29tcG91bmRXcml0ZUNoaWxkQ29tcG91bmRXcml0ZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgcGF0aCk7XHJcbiAgICAgICAgaWYgKGNvbXBvdW5kV3JpdGVJc0VtcHR5KGNoaWxkTWVyZ2UpKSB7XHJcbiAgICAgICAgICAgIC8vIFdlJ3JlIG5vdCBzaGFkb3dpbmcgYXQgYWxsLiBDYXNlIDFcclxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nU2VydmVyU25hcC5nZXRDaGlsZChjaGlsZFBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBtb3JlIGVmZmljaWVudCBpZiB0aGUgc2VydmVyTm9kZSArIHVwZGF0ZXMgZG9lc24ndCBjaGFuZ2UgdGhlIGV2ZW50U25hcFxyXG4gICAgICAgICAgICAvLyBIb3dldmVyIHRoaXMgaXMgdHJpY2t5IHRvIGZpbmQgb3V0LCBzaW5jZSB1c2VyIHVwZGF0ZXMgZG9uJ3QgbmVjZXNzYXJ5IGNoYW5nZSB0aGUgc2VydmVyXHJcbiAgICAgICAgICAgIC8vIHNuYXAsIGUuZy4gcHJpb3JpdHkgdXBkYXRlcyBvbiBlbXB0eSBub2Rlcywgb3IgZGVlcCBkZWxldGVzLiBBbm90aGVyIHNwZWNpYWwgY2FzZSBpcyBpZiB0aGUgc2VydmVyXHJcbiAgICAgICAgICAgIC8vIGFkZHMgbm9kZXMsIGJ1dCBkb2Vzbid0IGNoYW5nZSBhbnkgZXhpc3Rpbmcgd3JpdGVzLiBJdCBpcyB0aGVyZWZvcmUgbm90IGVub3VnaCB0b1xyXG4gICAgICAgICAgICAvLyBvbmx5IGNoZWNrIGlmIHRoZSB1cGRhdGVzIGNoYW5nZSB0aGUgc2VydmVyTm9kZS5cclxuICAgICAgICAgICAgLy8gTWF5YmUgY2hlY2sgaWYgdGhlIG1lcmdlIHRyZWUgY29udGFpbnMgdGhlc2Ugc3BlY2lhbCBjYXNlcyBhbmQgb25seSBkbyBhIGZ1bGwgb3ZlcndyaXRlIGluIHRoYXQgY2FzZT9cclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBvdW5kV3JpdGVBcHBseShjaGlsZE1lcmdlLCBleGlzdGluZ1NlcnZlclNuYXAuZ2V0Q2hpbGQoY2hpbGRQYXRoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgY29tcGxldGUgY2hpbGQgZm9yIGEgZ2l2ZW4gc2VydmVyIHNuYXAgYWZ0ZXIgYXBwbHlpbmcgYWxsIHVzZXIgd3JpdGVzIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9cclxuICogY29tcGxldGUgY2hpbGQgZm9yIHRoaXMgQ2hpbGRLZXkuXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVDYWxjQ29tcGxldGVDaGlsZCh3cml0ZVRyZWUsIHRyZWVQYXRoLCBjaGlsZEtleSwgZXhpc3RpbmdTZXJ2ZXJTbmFwKSB7XHJcbiAgICBjb25zdCBwYXRoID0gcGF0aENoaWxkKHRyZWVQYXRoLCBjaGlsZEtleSk7XHJcbiAgICBjb25zdCBzaGFkb3dpbmdOb2RlID0gY29tcG91bmRXcml0ZUdldENvbXBsZXRlTm9kZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgcGF0aCk7XHJcbiAgICBpZiAoc2hhZG93aW5nTm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHNoYWRvd2luZ05vZGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoZXhpc3RpbmdTZXJ2ZXJTbmFwLmlzQ29tcGxldGVGb3JDaGlsZChjaGlsZEtleSkpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRNZXJnZSA9IGNvbXBvdW5kV3JpdGVDaGlsZENvbXBvdW5kV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHBhdGgpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcG91bmRXcml0ZUFwcGx5KGNoaWxkTWVyZ2UsIGV4aXN0aW5nU2VydmVyU25hcC5nZXROb2RlKCkuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIG5vZGUgaWYgdGhlcmUgaXMgYSBjb21wbGV0ZSBvdmVyd3JpdGUgZm9yIHRoaXMgcGF0aC4gTW9yZSBzcGVjaWZpY2FsbHksIGlmIHRoZXJlIGlzIGEgd3JpdGUgYXRcclxuICogYSBoaWdoZXIgcGF0aCwgdGhpcyB3aWxsIHJldHVybiB0aGUgY2hpbGQgb2YgdGhhdCB3cml0ZSByZWxhdGl2ZSB0byB0aGUgd3JpdGUgYW5kIHRoaXMgcGF0aC5cclxuICogUmV0dXJucyBudWxsIGlmIHRoZXJlIGlzIG5vIHdyaXRlIGF0IHRoaXMgcGF0aC5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVNoYWRvd2luZ1dyaXRlKHdyaXRlVHJlZSwgcGF0aCkge1xyXG4gICAgcmV0dXJuIGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZU5vZGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHBhdGgpO1xyXG59XHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHdoZW4gcHJvY2Vzc2luZyBjaGlsZCByZW1vdmUgZXZlbnRzIG9uIGEgcXVlcnkuIElmIHdlIGNhbiwgd2UgcHVsbCBpbiBjaGlsZHJlbiB0aGF0IHdlcmUgb3V0c2lkZVxyXG4gKiB0aGUgd2luZG93LCBidXQgbWF5IG5vdyBiZSBpbiB0aGUgd2luZG93LlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlQ2FsY0luZGV4ZWRTbGljZSh3cml0ZVRyZWUsIHRyZWVQYXRoLCBjb21wbGV0ZVNlcnZlckRhdGEsIHN0YXJ0UG9zdCwgY291bnQsIHJldmVyc2UsIGluZGV4KSB7XHJcbiAgICBsZXQgdG9JdGVyYXRlO1xyXG4gICAgY29uc3QgbWVyZ2UgPSBjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCB0cmVlUGF0aCk7XHJcbiAgICBjb25zdCBzaGFkb3dpbmdOb2RlID0gY29tcG91bmRXcml0ZUdldENvbXBsZXRlTm9kZShtZXJnZSwgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgaWYgKHNoYWRvd2luZ05vZGUgIT0gbnVsbCkge1xyXG4gICAgICAgIHRvSXRlcmF0ZSA9IHNoYWRvd2luZ05vZGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjb21wbGV0ZVNlcnZlckRhdGEgIT0gbnVsbCkge1xyXG4gICAgICAgIHRvSXRlcmF0ZSA9IGNvbXBvdW5kV3JpdGVBcHBseShtZXJnZSwgY29tcGxldGVTZXJ2ZXJEYXRhKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIG5vIGNoaWxkcmVuIHRvIGl0ZXJhdGUgb25cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICB0b0l0ZXJhdGUgPSB0b0l0ZXJhdGUud2l0aEluZGV4KGluZGV4KTtcclxuICAgIGlmICghdG9JdGVyYXRlLmlzRW1wdHkoKSAmJiAhdG9JdGVyYXRlLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgIGNvbnN0IG5vZGVzID0gW107XHJcbiAgICAgICAgY29uc3QgY21wID0gaW5kZXguZ2V0Q29tcGFyZSgpO1xyXG4gICAgICAgIGNvbnN0IGl0ZXIgPSByZXZlcnNlXHJcbiAgICAgICAgICAgID8gdG9JdGVyYXRlLmdldFJldmVyc2VJdGVyYXRvckZyb20oc3RhcnRQb3N0LCBpbmRleClcclxuICAgICAgICAgICAgOiB0b0l0ZXJhdGUuZ2V0SXRlcmF0b3JGcm9tKHN0YXJ0UG9zdCwgaW5kZXgpO1xyXG4gICAgICAgIGxldCBuZXh0ID0gaXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgd2hpbGUgKG5leHQgJiYgbm9kZXMubGVuZ3RoIDwgY291bnQpIHtcclxuICAgICAgICAgICAgaWYgKGNtcChuZXh0LCBzdGFydFBvc3QpICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5leHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5leHQgPSBpdGVyLmdldE5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5ld1dyaXRlVHJlZSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmlzaWJsZVdyaXRlczogQ29tcG91bmRXcml0ZS5lbXB0eSgpLFxyXG4gICAgICAgIGFsbFdyaXRlczogW10sXHJcbiAgICAgICAgbGFzdFdyaXRlSWQ6IC0xXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBJZiBwb3NzaWJsZSwgcmV0dXJucyBhIGNvbXBsZXRlIGV2ZW50IGNhY2hlLCB1c2luZyB0aGUgdW5kZXJseWluZyBzZXJ2ZXIgZGF0YSBpZiBwb3NzaWJsZS4gSW4gYWRkaXRpb24sIGNhbiBiZSB1c2VkXHJcbiAqIHRvIGdldCBhIGNhY2hlIHRoYXQgaW5jbHVkZXMgaGlkZGVuIHdyaXRlcywgYW5kIGV4Y2x1ZGVzIGFyYml0cmFyeSB3cml0ZXMuIE5vdGUgdGhhdCBjdXN0b21pemluZyB0aGUgcmV0dXJuZWQgbm9kZVxyXG4gKiBjYW4gbGVhZCB0byBhIG1vcmUgZXhwZW5zaXZlIGNhbGN1bGF0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gd3JpdGVJZHNUb0V4Y2x1ZGUgLSBPcHRpb25hbCB3cml0ZXMgdG8gZXhjbHVkZS5cclxuICogQHBhcmFtIGluY2x1ZGVIaWRkZW5Xcml0ZXMgLSBEZWZhdWx0cyB0byBmYWxzZSwgd2hldGhlciBvciBub3QgdG8gbGF5ZXIgb24gd3JpdGVzIHdpdGggdmlzaWJsZSBzZXQgdG8gZmFsc2VcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVUcmVlUmVmLCBjb21wbGV0ZVNlcnZlckNhY2hlLCB3cml0ZUlkc1RvRXhjbHVkZSwgaW5jbHVkZUhpZGRlbldyaXRlcykge1xyXG4gICAgcmV0dXJuIHdyaXRlVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVUcmVlUmVmLndyaXRlVHJlZSwgd3JpdGVUcmVlUmVmLnRyZWVQYXRoLCBjb21wbGV0ZVNlcnZlckNhY2hlLCB3cml0ZUlkc1RvRXhjbHVkZSwgaW5jbHVkZUhpZGRlbldyaXRlcyk7XHJcbn1cclxuLyoqXHJcbiAqIElmIHBvc3NpYmxlLCByZXR1cm5zIGEgY2hpbGRyZW4gbm9kZSBjb250YWluaW5nIGFsbCBvZiB0aGUgY29tcGxldGUgY2hpbGRyZW4gd2UgaGF2ZSBkYXRhIGZvci4gVGhlIHJldHVybmVkIGRhdGEgaXMgYVxyXG4gKiBtaXggb2YgdGhlIGdpdmVuIHNlcnZlciBkYXRhIGFuZCB3cml0ZSBkYXRhLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlRXZlbnRDaGlsZHJlbih3cml0ZVRyZWVSZWYsIGNvbXBsZXRlU2VydmVyQ2hpbGRyZW4pIHtcclxuICAgIHJldHVybiB3cml0ZVRyZWVDYWxjQ29tcGxldGVFdmVudENoaWxkcmVuKHdyaXRlVHJlZVJlZi53cml0ZVRyZWUsIHdyaXRlVHJlZVJlZi50cmVlUGF0aCwgY29tcGxldGVTZXJ2ZXJDaGlsZHJlbik7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIHRoYXQgZWl0aGVyIHRoZSB1bmRlcmx5aW5nIHNlcnZlciBkYXRhIGhhcyB1cGRhdGVkIG9yIHRoZSBvdXRzdGFuZGluZyB3cml0ZXMgaGF2ZSB1cGRhdGVkLCBkZXRlcm1pbmUgd2hhdCxcclxuICogaWYgYW55dGhpbmcsIG5lZWRzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGV2ZW50IGNhY2hlLlxyXG4gKlxyXG4gKiBQb3NzaWJpbGl0aWVzOlxyXG4gKlxyXG4gKiAxLiBObyB3cml0ZXMgYXJlIHNoYWRvd2luZy4gRXZlbnRzIHNob3VsZCBiZSByYWlzZWQsIHRoZSBzbmFwIHRvIGJlIGFwcGxpZWQgY29tZXMgZnJvbSB0aGUgc2VydmVyIGRhdGFcclxuICpcclxuICogMi4gU29tZSB3cml0ZSBpcyBjb21wbGV0ZWx5IHNoYWRvd2luZy4gTm8gZXZlbnRzIHRvIGJlIHJhaXNlZFxyXG4gKlxyXG4gKiAzLiBJcyBwYXJ0aWFsbHkgc2hhZG93ZWQuIEV2ZW50cyBzaG91bGQgYmUgcmFpc2VkXHJcbiAqXHJcbiAqIEVpdGhlciBleGlzdGluZ0V2ZW50U25hcCBvciBleGlzdGluZ1NlcnZlclNuYXAgbXVzdCBleGlzdCwgdGhpcyBpcyB2YWxpZGF0ZWQgdmlhIGFuIGFzc2VydFxyXG4gKlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlUmVmQ2FsY0V2ZW50Q2FjaGVBZnRlclNlcnZlck92ZXJ3cml0ZSh3cml0ZVRyZWVSZWYsIHBhdGgsIGV4aXN0aW5nRXZlbnRTbmFwLCBleGlzdGluZ1NlcnZlclNuYXApIHtcclxuICAgIHJldHVybiB3cml0ZVRyZWVDYWxjRXZlbnRDYWNoZUFmdGVyU2VydmVyT3ZlcndyaXRlKHdyaXRlVHJlZVJlZi53cml0ZVRyZWUsIHdyaXRlVHJlZVJlZi50cmVlUGF0aCwgcGF0aCwgZXhpc3RpbmdFdmVudFNuYXAsIGV4aXN0aW5nU2VydmVyU25hcCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBub2RlIGlmIHRoZXJlIGlzIGEgY29tcGxldGUgb3ZlcndyaXRlIGZvciB0aGlzIHBhdGguIE1vcmUgc3BlY2lmaWNhbGx5LCBpZiB0aGVyZSBpcyBhIHdyaXRlIGF0XHJcbiAqIGEgaGlnaGVyIHBhdGgsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGNoaWxkIG9mIHRoYXQgd3JpdGUgcmVsYXRpdmUgdG8gdGhlIHdyaXRlIGFuZCB0aGlzIHBhdGguXHJcbiAqIFJldHVybnMgbnVsbCBpZiB0aGVyZSBpcyBubyB3cml0ZSBhdCB0aGlzIHBhdGguXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVSZWZTaGFkb3dpbmdXcml0ZSh3cml0ZVRyZWVSZWYsIHBhdGgpIHtcclxuICAgIHJldHVybiB3cml0ZVRyZWVTaGFkb3dpbmdXcml0ZSh3cml0ZVRyZWVSZWYud3JpdGVUcmVlLCBwYXRoQ2hpbGQod3JpdGVUcmVlUmVmLnRyZWVQYXRoLCBwYXRoKSk7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgd2hlbiBwcm9jZXNzaW5nIGNoaWxkIHJlbW92ZSBldmVudHMgb24gYSBxdWVyeS4gSWYgd2UgY2FuLCB3ZSBwdWxsIGluIGNoaWxkcmVuIHRoYXQgd2VyZSBvdXRzaWRlXHJcbiAqIHRoZSB3aW5kb3csIGJ1dCBtYXkgbm93IGJlIGluIHRoZSB3aW5kb3dcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlZkNhbGNJbmRleGVkU2xpY2Uod3JpdGVUcmVlUmVmLCBjb21wbGV0ZVNlcnZlckRhdGEsIHN0YXJ0UG9zdCwgY291bnQsIHJldmVyc2UsIGluZGV4KSB7XHJcbiAgICByZXR1cm4gd3JpdGVUcmVlQ2FsY0luZGV4ZWRTbGljZSh3cml0ZVRyZWVSZWYud3JpdGVUcmVlLCB3cml0ZVRyZWVSZWYudHJlZVBhdGgsIGNvbXBsZXRlU2VydmVyRGF0YSwgc3RhcnRQb3N0LCBjb3VudCwgcmV2ZXJzZSwgaW5kZXgpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgY29tcGxldGUgY2hpbGQgZm9yIGEgZ2l2ZW4gc2VydmVyIHNuYXAgYWZ0ZXIgYXBwbHlpbmcgYWxsIHVzZXIgd3JpdGVzIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9cclxuICogY29tcGxldGUgY2hpbGQgZm9yIHRoaXMgQ2hpbGRLZXkuXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVDaGlsZCh3cml0ZVRyZWVSZWYsIGNoaWxkS2V5LCBleGlzdGluZ1NlcnZlckNhY2hlKSB7XHJcbiAgICByZXR1cm4gd3JpdGVUcmVlQ2FsY0NvbXBsZXRlQ2hpbGQod3JpdGVUcmVlUmVmLndyaXRlVHJlZSwgd3JpdGVUcmVlUmVmLnRyZWVQYXRoLCBjaGlsZEtleSwgZXhpc3RpbmdTZXJ2ZXJDYWNoZSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybiBhIFdyaXRlVHJlZVJlZiBmb3IgYSBjaGlsZC5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlZkNoaWxkKHdyaXRlVHJlZVJlZiwgY2hpbGROYW1lKSB7XHJcbiAgICByZXR1cm4gbmV3V3JpdGVUcmVlUmVmKHBhdGhDaGlsZCh3cml0ZVRyZWVSZWYudHJlZVBhdGgsIGNoaWxkTmFtZSksIHdyaXRlVHJlZVJlZi53cml0ZVRyZWUpO1xyXG59XHJcbmZ1bmN0aW9uIG5ld1dyaXRlVHJlZVJlZihwYXRoLCB3cml0ZVRyZWUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHJlZVBhdGg6IHBhdGgsXHJcbiAgICAgICAgd3JpdGVUcmVlXHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIENoaWxkQ2hhbmdlQWNjdW11bGF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICB0cmFja0NoaWxkQ2hhbmdlKGNoYW5nZSkge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSBjaGFuZ2UudHlwZTtcclxuICAgICAgICBjb25zdCBjaGlsZEtleSA9IGNoYW5nZS5jaGlsZE5hbWU7XHJcbiAgICAgICAgYXNzZXJ0KHR5cGUgPT09IFwiY2hpbGRfYWRkZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX0FEREVEICovIHx8XHJcbiAgICAgICAgICAgIHR5cGUgPT09IFwiY2hpbGRfY2hhbmdlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQ0hBTkdFRCAqLyB8fFxyXG4gICAgICAgICAgICB0eXBlID09PSBcImNoaWxkX3JlbW92ZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX1JFTU9WRUQgKi8sICdPbmx5IGNoaWxkIGNoYW5nZXMgc3VwcG9ydGVkIGZvciB0cmFja2luZycpO1xyXG4gICAgICAgIGFzc2VydChjaGlsZEtleSAhPT0gJy5wcmlvcml0eScsICdPbmx5IG5vbi1wcmlvcml0eSBjaGlsZCBjaGFuZ2VzIGNhbiBiZSB0cmFja2VkLicpO1xyXG4gICAgICAgIGNvbnN0IG9sZENoYW5nZSA9IHRoaXMuY2hhbmdlTWFwLmdldChjaGlsZEtleSk7XHJcbiAgICAgICAgaWYgKG9sZENoYW5nZSkge1xyXG4gICAgICAgICAgICBjb25zdCBvbGRUeXBlID0gb2xkQ2hhbmdlLnR5cGU7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImNoaWxkX2FkZGVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9BRERFRCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgb2xkVHlwZSA9PT0gXCJjaGlsZF9yZW1vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9SRU1PVkVEICovKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZU1hcC5zZXQoY2hpbGRLZXksIGNoYW5nZUNoaWxkQ2hhbmdlZChjaGlsZEtleSwgY2hhbmdlLnNuYXBzaG90Tm9kZSwgb2xkQ2hhbmdlLnNuYXBzaG90Tm9kZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiY2hpbGRfcmVtb3ZlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfUkVNT1ZFRCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgb2xkVHlwZSA9PT0gXCJjaGlsZF9hZGRlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQURERUQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwLmRlbGV0ZShjaGlsZEtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJjaGlsZF9yZW1vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9SRU1PVkVEICovICYmXHJcbiAgICAgICAgICAgICAgICBvbGRUeXBlID09PSBcImNoaWxkX2NoYW5nZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX0NIQU5HRUQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwLnNldChjaGlsZEtleSwgY2hhbmdlQ2hpbGRSZW1vdmVkKGNoaWxkS2V5LCBvbGRDaGFuZ2Uub2xkU25hcCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiY2hpbGRfY2hhbmdlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQ0hBTkdFRCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgb2xkVHlwZSA9PT0gXCJjaGlsZF9hZGRlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQURERUQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwLnNldChjaGlsZEtleSwgY2hhbmdlQ2hpbGRBZGRlZChjaGlsZEtleSwgY2hhbmdlLnNuYXBzaG90Tm9kZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiY2hpbGRfY2hhbmdlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQ0hBTkdFRCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgb2xkVHlwZSA9PT0gXCJjaGlsZF9jaGFuZ2VkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9DSEFOR0VEICovKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZU1hcC5zZXQoY2hpbGRLZXksIGNoYW5nZUNoaWxkQ2hhbmdlZChjaGlsZEtleSwgY2hhbmdlLnNuYXBzaG90Tm9kZSwgb2xkQ2hhbmdlLm9sZFNuYXApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGFzc2VydGlvbkVycm9yKCdJbGxlZ2FsIGNvbWJpbmF0aW9uIG9mIGNoYW5nZXM6ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZSArXHJcbiAgICAgICAgICAgICAgICAgICAgJyBvY2N1cnJlZCBhZnRlciAnICtcclxuICAgICAgICAgICAgICAgICAgICBvbGRDaGFuZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5nZU1hcC5zZXQoY2hpbGRLZXksIGNoYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0Q2hhbmdlcygpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNoYW5nZU1hcC52YWx1ZXMoKSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIENvbXBsZXRlQ2hpbGRTb3VyY2UgdGhhdCBuZXZlciByZXR1cm5zIGFueSBhZGRpdGlvbmFsIGNoaWxkcmVuXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbmNsYXNzIE5vQ29tcGxldGVDaGlsZFNvdXJjZV8ge1xyXG4gICAgZ2V0Q29tcGxldGVDaGlsZChjaGlsZEtleSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2hpbGRBZnRlckNoaWxkKGluZGV4LCBjaGlsZCwgcmV2ZXJzZSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTaW5nbGV0b24gaW5zdGFuY2UuXHJcbiAqL1xyXG5jb25zdCBOT19DT01QTEVURV9DSElMRF9TT1VSQ0UgPSBuZXcgTm9Db21wbGV0ZUNoaWxkU291cmNlXygpO1xyXG4vKipcclxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgQ29tcGxldGVDaGlsZFNvdXJjZSB0aGF0IHVzZXMgYSBXcml0ZVRyZWUgaW4gYWRkaXRpb24gdG8gYW55IG90aGVyIHNlcnZlciBkYXRhIG9yXHJcbiAqIG9sZCBldmVudCBjYWNoZXMgYXZhaWxhYmxlIHRvIGNhbGN1bGF0ZSBjb21wbGV0ZSBjaGlsZHJlbi5cclxuICovXHJcbmNsYXNzIFdyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2Uge1xyXG4gICAgY29uc3RydWN0b3Iod3JpdGVzXywgdmlld0NhY2hlXywgb3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8gPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZXNfID0gd3JpdGVzXztcclxuICAgICAgICB0aGlzLnZpZXdDYWNoZV8gPSB2aWV3Q2FjaGVfO1xyXG4gICAgICAgIHRoaXMub3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8gPSBvcHRDb21wbGV0ZVNlcnZlckNhY2hlXztcclxuICAgIH1cclxuICAgIGdldENvbXBsZXRlQ2hpbGQoY2hpbGRLZXkpIHtcclxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy52aWV3Q2FjaGVfLmV2ZW50Q2FjaGU7XHJcbiAgICAgICAgaWYgKG5vZGUuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5nZXROb2RlKCkuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VydmVyTm9kZSA9IHRoaXMub3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8gIT0gbnVsbFxyXG4gICAgICAgICAgICAgICAgPyBuZXcgQ2FjaGVOb2RlKHRoaXMub3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8sIHRydWUsIGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgOiB0aGlzLnZpZXdDYWNoZV8uc2VydmVyQ2FjaGU7XHJcbiAgICAgICAgICAgIHJldHVybiB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVDaGlsZCh0aGlzLndyaXRlc18sIGNoaWxkS2V5LCBzZXJ2ZXJOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRDaGlsZEFmdGVyQ2hpbGQoaW5kZXgsIGNoaWxkLCByZXZlcnNlKSB7XHJcbiAgICAgICAgY29uc3QgY29tcGxldGVTZXJ2ZXJEYXRhID0gdGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlXyAhPSBudWxsXHJcbiAgICAgICAgICAgID8gdGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlX1xyXG4gICAgICAgICAgICA6IHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh0aGlzLnZpZXdDYWNoZV8pO1xyXG4gICAgICAgIGNvbnN0IG5vZGVzID0gd3JpdGVUcmVlUmVmQ2FsY0luZGV4ZWRTbGljZSh0aGlzLndyaXRlc18sIGNvbXBsZXRlU2VydmVyRGF0YSwgY2hpbGQsIDEsIHJldmVyc2UsIGluZGV4KTtcclxuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzWzBdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdWaWV3UHJvY2Vzc29yKGZpbHRlcikge1xyXG4gICAgcmV0dXJuIHsgZmlsdGVyIH07XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3NvckFzc2VydEluZGV4ZWQodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlKSB7XHJcbiAgICBhc3NlcnQodmlld0NhY2hlLmV2ZW50Q2FjaGUuZ2V0Tm9kZSgpLmlzSW5kZXhlZCh2aWV3UHJvY2Vzc29yLmZpbHRlci5nZXRJbmRleCgpKSwgJ0V2ZW50IHNuYXAgbm90IGluZGV4ZWQnKTtcclxuICAgIGFzc2VydCh2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpLmlzSW5kZXhlZCh2aWV3UHJvY2Vzc29yLmZpbHRlci5nZXRJbmRleCgpKSwgJ1NlcnZlciBzbmFwIG5vdCBpbmRleGVkJyk7XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3NvckFwcGx5T3BlcmF0aW9uKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgb3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSkge1xyXG4gICAgY29uc3QgYWNjdW11bGF0b3IgPSBuZXcgQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvcigpO1xyXG4gICAgbGV0IG5ld1ZpZXdDYWNoZSwgZmlsdGVyU2VydmVyTm9kZTtcclxuICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gT3BlcmF0aW9uVHlwZS5PVkVSV1JJVEUpIHtcclxuICAgICAgICBjb25zdCBvdmVyd3JpdGUgPSBvcGVyYXRpb247XHJcbiAgICAgICAgaWYgKG92ZXJ3cml0ZS5zb3VyY2UuZnJvbVVzZXIpIHtcclxuICAgICAgICAgICAgbmV3Vmlld0NhY2hlID0gdmlld1Byb2Nlc3NvckFwcGx5VXNlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCBvbGRWaWV3Q2FjaGUsIG92ZXJ3cml0ZS5wYXRoLCBvdmVyd3JpdGUuc25hcCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFzc2VydChvdmVyd3JpdGUuc291cmNlLmZyb21TZXJ2ZXIsICdVbmtub3duIHNvdXJjZS4nKTtcclxuICAgICAgICAgICAgLy8gV2UgZmlsdGVyIHRoZSBub2RlIGlmIGl0J3MgYSB0YWdnZWQgdXBkYXRlIG9yIHRoZSBub2RlIGhhcyBiZWVuIHByZXZpb3VzbHkgZmlsdGVyZWQgIGFuZCB0aGVcclxuICAgICAgICAgICAgLy8gdXBkYXRlIGlzIG5vdCBhdCB0aGUgcm9vdCBpbiB3aGljaCBjYXNlIGl0IGlzIG9rIChhbmQgbmVjZXNzYXJ5KSB0byBtYXJrIHRoZSBub2RlIHVuZmlsdGVyZWRcclxuICAgICAgICAgICAgLy8gYWdhaW5cclxuICAgICAgICAgICAgZmlsdGVyU2VydmVyTm9kZSA9XHJcbiAgICAgICAgICAgICAgICBvdmVyd3JpdGUuc291cmNlLnRhZ2dlZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChvbGRWaWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGaWx0ZXJlZCgpICYmICFwYXRoSXNFbXB0eShvdmVyd3JpdGUucGF0aCkpO1xyXG4gICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJPdmVyd3JpdGUodmlld1Byb2Nlc3Nvciwgb2xkVmlld0NhY2hlLCBvdmVyd3JpdGUucGF0aCwgb3ZlcndyaXRlLnNuYXAsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3BlcmF0aW9uLnR5cGUgPT09IE9wZXJhdGlvblR5cGUuTUVSR0UpIHtcclxuICAgICAgICBjb25zdCBtZXJnZSA9IG9wZXJhdGlvbjtcclxuICAgICAgICBpZiAobWVyZ2Uuc291cmNlLmZyb21Vc2VyKSB7XHJcbiAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHZpZXdQcm9jZXNzb3JBcHBseVVzZXJNZXJnZSh2aWV3UHJvY2Vzc29yLCBvbGRWaWV3Q2FjaGUsIG1lcmdlLnBhdGgsIG1lcmdlLmNoaWxkcmVuLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXNzZXJ0KG1lcmdlLnNvdXJjZS5mcm9tU2VydmVyLCAnVW5rbm93biBzb3VyY2UuJyk7XHJcbiAgICAgICAgICAgIC8vIFdlIGZpbHRlciB0aGUgbm9kZSBpZiBpdCdzIGEgdGFnZ2VkIHVwZGF0ZSBvciB0aGUgbm9kZSBoYXMgYmVlbiBwcmV2aW91c2x5IGZpbHRlcmVkXHJcbiAgICAgICAgICAgIGZpbHRlclNlcnZlck5vZGUgPVxyXG4gICAgICAgICAgICAgICAgbWVyZ2Uuc291cmNlLnRhZ2dlZCB8fCBvbGRWaWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGaWx0ZXJlZCgpO1xyXG4gICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJNZXJnZSh2aWV3UHJvY2Vzc29yLCBvbGRWaWV3Q2FjaGUsIG1lcmdlLnBhdGgsIG1lcmdlLmNoaWxkcmVuLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG9wZXJhdGlvbi50eXBlID09PSBPcGVyYXRpb25UeXBlLkFDS19VU0VSX1dSSVRFKSB7XHJcbiAgICAgICAgY29uc3QgYWNrVXNlcldyaXRlID0gb3BlcmF0aW9uO1xyXG4gICAgICAgIGlmICghYWNrVXNlcldyaXRlLnJldmVydCkge1xyXG4gICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQWNrVXNlcldyaXRlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgYWNrVXNlcldyaXRlLnBhdGgsIGFja1VzZXJXcml0ZS5hZmZlY3RlZFRyZWUsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yUmV2ZXJ0VXNlcldyaXRlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgYWNrVXNlcldyaXRlLnBhdGgsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3BlcmF0aW9uLnR5cGUgPT09IE9wZXJhdGlvblR5cGUuTElTVEVOX0NPTVBMRVRFKSB7XHJcbiAgICAgICAgbmV3Vmlld0NhY2hlID0gdmlld1Byb2Nlc3Nvckxpc3RlbkNvbXBsZXRlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgb3BlcmF0aW9uLnBhdGgsIHdyaXRlc0NhY2hlLCBhY2N1bXVsYXRvcik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBhc3NlcnRpb25FcnJvcignVW5rbm93biBvcGVyYXRpb24gdHlwZTogJyArIG9wZXJhdGlvbi50eXBlKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGNoYW5nZXMgPSBhY2N1bXVsYXRvci5nZXRDaGFuZ2VzKCk7XHJcbiAgICB2aWV3UHJvY2Vzc29yTWF5YmVBZGRWYWx1ZUV2ZW50KG9sZFZpZXdDYWNoZSwgbmV3Vmlld0NhY2hlLCBjaGFuZ2VzKTtcclxuICAgIHJldHVybiB7IHZpZXdDYWNoZTogbmV3Vmlld0NhY2hlLCBjaGFuZ2VzIH07XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3Nvck1heWJlQWRkVmFsdWVFdmVudChvbGRWaWV3Q2FjaGUsIG5ld1ZpZXdDYWNoZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIGNvbnN0IGV2ZW50U25hcCA9IG5ld1ZpZXdDYWNoZS5ldmVudENhY2hlO1xyXG4gICAgaWYgKGV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgIGNvbnN0IGlzTGVhZk9yRW1wdHkgPSBldmVudFNuYXAuZ2V0Tm9kZSgpLmlzTGVhZk5vZGUoKSB8fCBldmVudFNuYXAuZ2V0Tm9kZSgpLmlzRW1wdHkoKTtcclxuICAgICAgICBjb25zdCBvbGRDb21wbGV0ZVNuYXAgPSB2aWV3Q2FjaGVHZXRDb21wbGV0ZUV2ZW50U25hcChvbGRWaWV3Q2FjaGUpO1xyXG4gICAgICAgIGlmIChhY2N1bXVsYXRvci5sZW5ndGggPiAwIHx8XHJcbiAgICAgICAgICAgICFvbGRWaWV3Q2FjaGUuZXZlbnRDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fFxyXG4gICAgICAgICAgICAoaXNMZWFmT3JFbXB0eSAmJiAhZXZlbnRTbmFwLmdldE5vZGUoKS5lcXVhbHMob2xkQ29tcGxldGVTbmFwKSkgfHxcclxuICAgICAgICAgICAgIWV2ZW50U25hcC5nZXROb2RlKCkuZ2V0UHJpb3JpdHkoKS5lcXVhbHMob2xkQ29tcGxldGVTbmFwLmdldFByaW9yaXR5KCkpKSB7XHJcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yLnB1c2goY2hhbmdlVmFsdWUodmlld0NhY2hlR2V0Q29tcGxldGVFdmVudFNuYXAobmV3Vmlld0NhY2hlKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yR2VuZXJhdGVFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJFdmVudCh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUsIGNoYW5nZVBhdGgsIHdyaXRlc0NhY2hlLCBzb3VyY2UsIGFjY3VtdWxhdG9yKSB7XHJcbiAgICBjb25zdCBvbGRFdmVudFNuYXAgPSB2aWV3Q2FjaGUuZXZlbnRDYWNoZTtcclxuICAgIGlmICh3cml0ZVRyZWVSZWZTaGFkb3dpbmdXcml0ZSh3cml0ZXNDYWNoZSwgY2hhbmdlUGF0aCkgIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIHdlIGhhdmUgYSBzaGFkb3dpbmcgd3JpdGUsIGlnbm9yZSBjaGFuZ2VzXHJcbiAgICAgICAgcmV0dXJuIHZpZXdDYWNoZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCBuZXdFdmVudENhY2hlLCBzZXJ2ZXJOb2RlO1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShjaGFuZ2VQYXRoKSkge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBmaWd1cmUgb3V0IGhvdyB0aGlzIHBsYXlzIHdpdGggXCJzbGlkaW5nIGFjayB3aW5kb3dzXCJcclxuICAgICAgICAgICAgYXNzZXJ0KHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgJ0lmIGNoYW5nZSBwYXRoIGlzIGVtcHR5LCB3ZSBtdXN0IGhhdmUgY29tcGxldGUgc2VydmVyIGRhdGEnKTtcclxuICAgICAgICAgICAgaWYgKHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0ZpbHRlcmVkKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gc3BlY2lhbCBjYXNlIHRoaXMsIGJlY2F1c2Ugd2UgbmVlZCB0byBvbmx5IGFwcGx5IHdyaXRlcyB0byBjb21wbGV0ZSBjaGlsZHJlbiwgb3JcclxuICAgICAgICAgICAgICAgIC8vIHdlIG1pZ2h0IGVuZCB1cCByYWlzaW5nIGV2ZW50cyBmb3IgaW5jb21wbGV0ZSBjaGlsZHJlbi4gSWYgdGhlIHNlcnZlciBkYXRhIGlzIGZpbHRlcmVkIGRlZXBcclxuICAgICAgICAgICAgICAgIC8vIHdyaXRlcyBjYW5ub3QgYmUgZ3VhcmFudGVlZCB0byBiZSBjb21wbGV0ZVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyQ2FjaGUgPSB2aWV3Q2FjaGVHZXRDb21wbGV0ZVNlcnZlclNuYXAodmlld0NhY2hlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRlQ2hpbGRyZW4gPSBzZXJ2ZXJDYWNoZSBpbnN0YW5jZW9mIENoaWxkcmVuTm9kZVxyXG4gICAgICAgICAgICAgICAgICAgID8gc2VydmVyQ2FjaGVcclxuICAgICAgICAgICAgICAgICAgICA6IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGxldGVFdmVudENoaWxkcmVuID0gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlRXZlbnRDaGlsZHJlbih3cml0ZXNDYWNoZSwgY29tcGxldGVDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdmlld1Byb2Nlc3Nvci5maWx0ZXIudXBkYXRlRnVsbE5vZGUodmlld0NhY2hlLmV2ZW50Q2FjaGUuZ2V0Tm9kZSgpLCBjb21wbGV0ZUV2ZW50Q2hpbGRyZW4sIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRlTm9kZSA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVzQ2FjaGUsIHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh2aWV3Q2FjaGUpKTtcclxuICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVGdWxsTm9kZSh2aWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCksIGNvbXBsZXRlTm9kZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZEtleSA9IHBhdGhHZXRGcm9udChjaGFuZ2VQYXRoKTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkS2V5ID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KHBhdGhHZXRMZW5ndGgoY2hhbmdlUGF0aCkgPT09IDEsIFwiQ2FuJ3QgaGF2ZSBhIHByaW9yaXR5IHdpdGggYWRkaXRpb25hbCBwYXRoIGNvbXBvbmVudHNcIik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRFdmVudE5vZGUgPSBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgc2VydmVyTm9kZSA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5nZXROb2RlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBtaWdodCBoYXZlIG92ZXJ3cml0ZXMgZm9yIHRoaXMgcHJpb3JpdHlcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcmlvcml0eSA9IHdyaXRlVHJlZVJlZkNhbGNFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJPdmVyd3JpdGUod3JpdGVzQ2FjaGUsIGNoYW5nZVBhdGgsIG9sZEV2ZW50Tm9kZSwgc2VydmVyTm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlZFByaW9yaXR5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdmlld1Byb2Nlc3Nvci5maWx0ZXIudXBkYXRlUHJpb3JpdHkob2xkRXZlbnROb2RlLCB1cGRhdGVkUHJpb3JpdHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJpb3JpdHkgZGlkbid0IGNoYW5nZSwga2VlcCBvbGQgbm9kZVxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDaGFuZ2VQYXRoID0gcGF0aFBvcEZyb250KGNoYW5nZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGNoaWxkXHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3RXZlbnRDaGlsZDtcclxuICAgICAgICAgICAgICAgIGlmIChvbGRFdmVudFNuYXAuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlck5vZGUgPSB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50Q2hpbGRVcGRhdGUgPSB3cml0ZVRyZWVSZWZDYWxjRXZlbnRDYWNoZUFmdGVyU2VydmVyT3ZlcndyaXRlKHdyaXRlc0NhY2hlLCBjaGFuZ2VQYXRoLCBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpLCBzZXJ2ZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRDaGlsZFVwZGF0ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2hpbGQgPSBvbGRFdmVudFNuYXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXROb2RlKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC51cGRhdGVDaGlsZChjaGlsZENoYW5nZVBhdGgsIGV2ZW50Q2hpbGRVcGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyBjaGFuZ2VkLCBqdXN0IGtlZXAgdGhlIG9sZCBjaGlsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENoaWxkID0gb2xkRXZlbnRTbmFwLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDaGlsZCA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUNoaWxkKHdyaXRlc0NhY2hlLCBjaGlsZEtleSwgdmlld0NhY2hlLnNlcnZlckNhY2hlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChuZXdFdmVudENoaWxkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdmlld1Byb2Nlc3Nvci5maWx0ZXIudXBkYXRlQ2hpbGQob2xkRXZlbnRTbmFwLmdldE5vZGUoKSwgY2hpbGRLZXksIG5ld0V2ZW50Q2hpbGQsIGNoaWxkQ2hhbmdlUGF0aCwgc291cmNlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBubyBjb21wbGV0ZSBjaGlsZCBhdmFpbGFibGUgb3Igbm8gY2hhbmdlXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IG9sZEV2ZW50U25hcC5nZXROb2RlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZpZXdDYWNoZVVwZGF0ZUV2ZW50U25hcCh2aWV3Q2FjaGUsIG5ld0V2ZW50Q2FjaGUsIG9sZEV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fCBwYXRoSXNFbXB0eShjaGFuZ2VQYXRoKSwgdmlld1Byb2Nlc3Nvci5maWx0ZXIuZmlsdGVyc05vZGVzKCkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCBvbGRWaWV3Q2FjaGUsIGNoYW5nZVBhdGgsIGNoYW5nZWRTbmFwLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIGNvbnN0IG9sZFNlcnZlclNuYXAgPSBvbGRWaWV3Q2FjaGUuc2VydmVyQ2FjaGU7XHJcbiAgICBsZXQgbmV3U2VydmVyQ2FjaGU7XHJcbiAgICBjb25zdCBzZXJ2ZXJGaWx0ZXIgPSBmaWx0ZXJTZXJ2ZXJOb2RlXHJcbiAgICAgICAgPyB2aWV3UHJvY2Vzc29yLmZpbHRlclxyXG4gICAgICAgIDogdmlld1Byb2Nlc3Nvci5maWx0ZXIuZ2V0SW5kZXhlZEZpbHRlcigpO1xyXG4gICAgaWYgKHBhdGhJc0VtcHR5KGNoYW5nZVBhdGgpKSB7XHJcbiAgICAgICAgbmV3U2VydmVyQ2FjaGUgPSBzZXJ2ZXJGaWx0ZXIudXBkYXRlRnVsbE5vZGUob2xkU2VydmVyU25hcC5nZXROb2RlKCksIGNoYW5nZWRTbmFwLCBudWxsKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNlcnZlckZpbHRlci5maWx0ZXJzTm9kZXMoKSAmJiAhb2xkU2VydmVyU25hcC5pc0ZpbHRlcmVkKCkpIHtcclxuICAgICAgICAvLyB3ZSB3YW50IHRvIGZpbHRlciB0aGUgc2VydmVyIG5vZGUsIGJ1dCB3ZSBkaWRuJ3QgZmlsdGVyIHRoZSBzZXJ2ZXIgbm9kZSB5ZXQsIHNvIHNpbXVsYXRlIGEgZnVsbCB1cGRhdGVcclxuICAgICAgICBjb25zdCBuZXdTZXJ2ZXJOb2RlID0gb2xkU2VydmVyU25hcFxyXG4gICAgICAgICAgICAuZ2V0Tm9kZSgpXHJcbiAgICAgICAgICAgIC51cGRhdGVDaGlsZChjaGFuZ2VQYXRoLCBjaGFuZ2VkU25hcCk7XHJcbiAgICAgICAgbmV3U2VydmVyQ2FjaGUgPSBzZXJ2ZXJGaWx0ZXIudXBkYXRlRnVsbE5vZGUob2xkU2VydmVyU25hcC5nZXROb2RlKCksIG5ld1NlcnZlck5vZGUsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRLZXkgPSBwYXRoR2V0RnJvbnQoY2hhbmdlUGF0aCk7XHJcbiAgICAgICAgaWYgKCFvbGRTZXJ2ZXJTbmFwLmlzQ29tcGxldGVGb3JQYXRoKGNoYW5nZVBhdGgpICYmXHJcbiAgICAgICAgICAgIHBhdGhHZXRMZW5ndGgoY2hhbmdlUGF0aCkgPiAxKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IHVwZGF0ZSBpbmNvbXBsZXRlIG5vZGVzIHdpdGggdXBkYXRlcyBpbnRlbmRlZCBmb3Igb3RoZXIgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgIHJldHVybiBvbGRWaWV3Q2FjaGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNoaWxkQ2hhbmdlUGF0aCA9IHBhdGhQb3BGcm9udChjaGFuZ2VQYXRoKTtcclxuICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBvbGRTZXJ2ZXJTbmFwLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgY29uc3QgbmV3Q2hpbGROb2RlID0gY2hpbGROb2RlLnVwZGF0ZUNoaWxkKGNoaWxkQ2hhbmdlUGF0aCwgY2hhbmdlZFNuYXApO1xyXG4gICAgICAgIGlmIChjaGlsZEtleSA9PT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgbmV3U2VydmVyQ2FjaGUgPSBzZXJ2ZXJGaWx0ZXIudXBkYXRlUHJpb3JpdHkob2xkU2VydmVyU25hcC5nZXROb2RlKCksIG5ld0NoaWxkTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZXdTZXJ2ZXJDYWNoZSA9IHNlcnZlckZpbHRlci51cGRhdGVDaGlsZChvbGRTZXJ2ZXJTbmFwLmdldE5vZGUoKSwgY2hpbGRLZXksIG5ld0NoaWxkTm9kZSwgY2hpbGRDaGFuZ2VQYXRoLCBOT19DT01QTEVURV9DSElMRF9TT1VSQ0UsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IG5ld1ZpZXdDYWNoZSA9IHZpZXdDYWNoZVVwZGF0ZVNlcnZlclNuYXAob2xkVmlld0NhY2hlLCBuZXdTZXJ2ZXJDYWNoZSwgb2xkU2VydmVyU25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fCBwYXRoSXNFbXB0eShjaGFuZ2VQYXRoKSwgc2VydmVyRmlsdGVyLmZpbHRlcnNOb2RlcygpKTtcclxuICAgIGNvbnN0IHNvdXJjZSA9IG5ldyBXcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlKHdyaXRlc0NhY2hlLCBuZXdWaWV3Q2FjaGUsIGNvbXBsZXRlQ2FjaGUpO1xyXG4gICAgcmV0dXJuIHZpZXdQcm9jZXNzb3JHZW5lcmF0ZUV2ZW50Q2FjaGVBZnRlclNlcnZlckV2ZW50KHZpZXdQcm9jZXNzb3IsIG5ld1ZpZXdDYWNoZSwgY2hhbmdlUGF0aCwgd3JpdGVzQ2FjaGUsIHNvdXJjZSwgYWNjdW11bGF0b3IpO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JBcHBseVVzZXJPdmVyd3JpdGUodmlld1Byb2Nlc3Nvciwgb2xkVmlld0NhY2hlLCBjaGFuZ2VQYXRoLCBjaGFuZ2VkU25hcCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGFjY3VtdWxhdG9yKSB7XHJcbiAgICBjb25zdCBvbGRFdmVudFNuYXAgPSBvbGRWaWV3Q2FjaGUuZXZlbnRDYWNoZTtcclxuICAgIGxldCBuZXdWaWV3Q2FjaGUsIG5ld0V2ZW50Q2FjaGU7XHJcbiAgICBjb25zdCBzb3VyY2UgPSBuZXcgV3JpdGVUcmVlQ29tcGxldGVDaGlsZFNvdXJjZSh3cml0ZXNDYWNoZSwgb2xkVmlld0NhY2hlLCBjb21wbGV0ZUNhY2hlKTtcclxuICAgIGlmIChwYXRoSXNFbXB0eShjaGFuZ2VQYXRoKSkge1xyXG4gICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVGdWxsTm9kZShvbGRWaWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCksIGNoYW5nZWRTbmFwLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgbmV3Vmlld0NhY2hlID0gdmlld0NhY2hlVXBkYXRlRXZlbnRTbmFwKG9sZFZpZXdDYWNoZSwgbmV3RXZlbnRDYWNoZSwgdHJ1ZSwgdmlld1Byb2Nlc3Nvci5maWx0ZXIuZmlsdGVyc05vZGVzKCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRLZXkgPSBwYXRoR2V0RnJvbnQoY2hhbmdlUGF0aCk7XHJcbiAgICAgICAgaWYgKGNoaWxkS2V5ID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdmlld1Byb2Nlc3Nvci5maWx0ZXIudXBkYXRlUHJpb3JpdHkob2xkVmlld0NhY2hlLmV2ZW50Q2FjaGUuZ2V0Tm9kZSgpLCBjaGFuZ2VkU25hcCk7XHJcbiAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHZpZXdDYWNoZVVwZGF0ZUV2ZW50U25hcChvbGRWaWV3Q2FjaGUsIG5ld0V2ZW50Q2FjaGUsIG9sZEV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgb2xkRXZlbnRTbmFwLmlzRmlsdGVyZWQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZENoYW5nZVBhdGggPSBwYXRoUG9wRnJvbnQoY2hhbmdlUGF0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZENoaWxkID0gb2xkRXZlbnRTbmFwLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgICAgIGxldCBuZXdDaGlsZDtcclxuICAgICAgICAgICAgaWYgKHBhdGhJc0VtcHR5KGNoaWxkQ2hhbmdlUGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIENoaWxkIG92ZXJ3cml0ZSwgd2UgY2FuIHJlcGxhY2UgdGhlIGNoaWxkXHJcbiAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNoYW5nZWRTbmFwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gc291cmNlLmdldENvbXBsZXRlQ2hpbGQoY2hpbGRLZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGhHZXRCYWNrKGNoaWxkQ2hhbmdlUGF0aCkgPT09ICcucHJpb3JpdHknICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5nZXRDaGlsZChwYXRoUGFyZW50KGNoaWxkQ2hhbmdlUGF0aCkpLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgcHJpb3JpdHkgdXBkYXRlIG9uIGFuIGVtcHR5IG5vZGUuIElmIHRoaXMgbm9kZSBleGlzdHMgb24gdGhlIHNlcnZlciwgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlcnZlciB3aWxsIHNlbmQgZG93biB0aGUgcHJpb3JpdHkgaW4gdGhlIHVwZGF0ZSwgc28gaWdub3JlIGZvciBub3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBjaGlsZE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNoaWxkTm9kZS51cGRhdGVDaGlsZChjaGlsZENoYW5nZVBhdGgsIGNoYW5nZWRTbmFwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBjb21wbGV0ZSBjaGlsZCBub2RlIGF2YWlsYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFvbGRDaGlsZC5lcXVhbHMobmV3Q2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFdmVudFNuYXAgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVDaGlsZChvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpLCBjaGlsZEtleSwgbmV3Q2hpbGQsIGNoaWxkQ2hhbmdlUGF0aCwgc291cmNlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3Q2FjaGVVcGRhdGVFdmVudFNuYXAob2xkVmlld0NhY2hlLCBuZXdFdmVudFNuYXAsIG9sZEV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgdmlld1Byb2Nlc3Nvci5maWx0ZXIuZmlsdGVyc05vZGVzKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3Vmlld0NhY2hlID0gb2xkVmlld0NhY2hlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld1ZpZXdDYWNoZTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yQ2FjaGVIYXNDaGlsZCh2aWV3Q2FjaGUsIGNoaWxkS2V5KSB7XHJcbiAgICByZXR1cm4gdmlld0NhY2hlLmV2ZW50Q2FjaGUuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yQXBwbHlVc2VyTWVyZ2Uodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIC8vIEhBQ0s6IEluIHRoZSBjYXNlIG9mIGEgbGltaXQgcXVlcnksIHRoZXJlIG1heSBiZSBzb21lIGNoYW5nZXMgdGhhdCBidW1wIHRoaW5ncyBvdXQgb2YgdGhlXHJcbiAgICAvLyB3aW5kb3cgbGVhdmluZyByb29tIGZvciBuZXcgaXRlbXMuICBJdCdzIGltcG9ydGFudCB3ZSBwcm9jZXNzIHRoZXNlIGNoYW5nZXMgZmlyc3QsIHNvIHdlXHJcbiAgICAvLyBpdGVyYXRlIHRoZSBjaGFuZ2VzIHR3aWNlLCBmaXJzdCBwcm9jZXNzaW5nIGFueSB0aGF0IGFmZmVjdCBpdGVtcyBjdXJyZW50bHkgaW4gdmlldy5cclxuICAgIC8vIFRPRE86IEkgY29uc2lkZXIgYW4gaXRlbSBcImluIHZpZXdcIiBpZiBjYWNoZUhhc0NoaWxkIGlzIHRydWUsIHdoaWNoIGNoZWNrcyBib3RoIHRoZSBzZXJ2ZXJcclxuICAgIC8vIGFuZCBldmVudCBzbmFwLiAgSSdtIG5vdCBzdXJlIGlmIHRoaXMgd2lsbCByZXN1bHQgaW4gZWRnZSBjYXNlcyB3aGVuIGEgY2hpbGQgaXMgaW4gb25lIGJ1dFxyXG4gICAgLy8gbm90IHRoZSBvdGhlci5cclxuICAgIGxldCBjdXJWaWV3Q2FjaGUgPSB2aWV3Q2FjaGU7XHJcbiAgICBjaGFuZ2VkQ2hpbGRyZW4uZm9yZWFjaCgocmVsYXRpdmVQYXRoLCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICBjb25zdCB3cml0ZVBhdGggPSBwYXRoQ2hpbGQocGF0aCwgcmVsYXRpdmVQYXRoKTtcclxuICAgICAgICBpZiAodmlld1Byb2Nlc3NvckNhY2hlSGFzQ2hpbGQodmlld0NhY2hlLCBwYXRoR2V0RnJvbnQod3JpdGVQYXRoKSkpIHtcclxuICAgICAgICAgICAgY3VyVmlld0NhY2hlID0gdmlld1Byb2Nlc3NvckFwcGx5VXNlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCBjdXJWaWV3Q2FjaGUsIHdyaXRlUGF0aCwgY2hpbGROb2RlLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNoYW5nZWRDaGlsZHJlbi5mb3JlYWNoKChyZWxhdGl2ZVBhdGgsIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHdyaXRlUGF0aCA9IHBhdGhDaGlsZChwYXRoLCByZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgIGlmICghdmlld1Byb2Nlc3NvckNhY2hlSGFzQ2hpbGQodmlld0NhY2hlLCBwYXRoR2V0RnJvbnQod3JpdGVQYXRoKSkpIHtcclxuICAgICAgICAgICAgY3VyVmlld0NhY2hlID0gdmlld1Byb2Nlc3NvckFwcGx5VXNlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCBjdXJWaWV3Q2FjaGUsIHdyaXRlUGF0aCwgY2hpbGROb2RlLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjdXJWaWV3Q2FjaGU7XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3NvckFwcGx5TWVyZ2Uodmlld1Byb2Nlc3Nvciwgbm9kZSwgbWVyZ2UpIHtcclxuICAgIG1lcmdlLmZvcmVhY2goKHJlbGF0aXZlUGF0aCwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgbm9kZSA9IG5vZGUudXBkYXRlQ2hpbGQocmVsYXRpdmVQYXRoLCBjaGlsZE5vZGUpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbm9kZTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJNZXJnZSh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUsIHBhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcikge1xyXG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNhY2hlIHlldCwgdGhpcyBtZXJnZSB3YXMgaW50ZW5kZWQgZm9yIGEgcHJldmlvdXNseSBsaXN0ZW4gaW4gdGhlIHNhbWUgbG9jYXRpb24uIElnbm9yZSBpdCBhbmRcclxuICAgIC8vIHdhaXQgZm9yIHRoZSBjb21wbGV0ZSBkYXRhIHVwZGF0ZSBjb21pbmcgc29vbi5cclxuICAgIGlmICh2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpLmlzRW1wdHkoKSAmJlxyXG4gICAgICAgICF2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCkpIHtcclxuICAgICAgICByZXR1cm4gdmlld0NhY2hlO1xyXG4gICAgfVxyXG4gICAgLy8gSEFDSzogSW4gdGhlIGNhc2Ugb2YgYSBsaW1pdCBxdWVyeSwgdGhlcmUgbWF5IGJlIHNvbWUgY2hhbmdlcyB0aGF0IGJ1bXAgdGhpbmdzIG91dCBvZiB0aGVcclxuICAgIC8vIHdpbmRvdyBsZWF2aW5nIHJvb20gZm9yIG5ldyBpdGVtcy4gIEl0J3MgaW1wb3J0YW50IHdlIHByb2Nlc3MgdGhlc2UgY2hhbmdlcyBmaXJzdCwgc28gd2VcclxuICAgIC8vIGl0ZXJhdGUgdGhlIGNoYW5nZXMgdHdpY2UsIGZpcnN0IHByb2Nlc3NpbmcgYW55IHRoYXQgYWZmZWN0IGl0ZW1zIGN1cnJlbnRseSBpbiB2aWV3LlxyXG4gICAgLy8gVE9ETzogSSBjb25zaWRlciBhbiBpdGVtIFwiaW4gdmlld1wiIGlmIGNhY2hlSGFzQ2hpbGQgaXMgdHJ1ZSwgd2hpY2ggY2hlY2tzIGJvdGggdGhlIHNlcnZlclxyXG4gICAgLy8gYW5kIGV2ZW50IHNuYXAuICBJJ20gbm90IHN1cmUgaWYgdGhpcyB3aWxsIHJlc3VsdCBpbiBlZGdlIGNhc2VzIHdoZW4gYSBjaGlsZCBpcyBpbiBvbmUgYnV0XHJcbiAgICAvLyBub3QgdGhlIG90aGVyLlxyXG4gICAgbGV0IGN1clZpZXdDYWNoZSA9IHZpZXdDYWNoZTtcclxuICAgIGxldCB2aWV3TWVyZ2VUcmVlO1xyXG4gICAgaWYgKHBhdGhJc0VtcHR5KHBhdGgpKSB7XHJcbiAgICAgICAgdmlld01lcmdlVHJlZSA9IGNoYW5nZWRDaGlsZHJlbjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZpZXdNZXJnZVRyZWUgPSBuZXcgSW1tdXRhYmxlVHJlZShudWxsKS5zZXRUcmVlKHBhdGgsIGNoYW5nZWRDaGlsZHJlbik7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZXJ2ZXJOb2RlID0gdmlld0NhY2hlLnNlcnZlckNhY2hlLmdldE5vZGUoKTtcclxuICAgIHZpZXdNZXJnZVRyZWUuY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbCgoY2hpbGRLZXksIGNoaWxkVHJlZSkgPT4ge1xyXG4gICAgICAgIGlmIChzZXJ2ZXJOb2RlLmhhc0NoaWxkKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJDaGlsZCA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZVxyXG4gICAgICAgICAgICAgICAgLmdldE5vZGUoKVxyXG4gICAgICAgICAgICAgICAgLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSB2aWV3UHJvY2Vzc29yQXBwbHlNZXJnZSh2aWV3UHJvY2Vzc29yLCBzZXJ2ZXJDaGlsZCwgY2hpbGRUcmVlKTtcclxuICAgICAgICAgICAgY3VyVmlld0NhY2hlID0gdmlld1Byb2Nlc3NvckFwcGx5U2VydmVyT3ZlcndyaXRlKHZpZXdQcm9jZXNzb3IsIGN1clZpZXdDYWNoZSwgbmV3IFBhdGgoY2hpbGRLZXkpLCBuZXdDaGlsZCwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB2aWV3TWVyZ2VUcmVlLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkS2V5LCBjaGlsZE1lcmdlVHJlZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGlzVW5rbm93bkRlZXBNZXJnZSA9ICF2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSAmJlxyXG4gICAgICAgICAgICBjaGlsZE1lcmdlVHJlZS52YWx1ZSA9PT0gbnVsbDtcclxuICAgICAgICBpZiAoIXNlcnZlck5vZGUuaGFzQ2hpbGQoY2hpbGRLZXkpICYmICFpc1Vua25vd25EZWVwTWVyZ2UpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VydmVyQ2hpbGQgPSB2aWV3Q2FjaGUuc2VydmVyQ2FjaGVcclxuICAgICAgICAgICAgICAgIC5nZXROb2RlKClcclxuICAgICAgICAgICAgICAgIC5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkID0gdmlld1Byb2Nlc3NvckFwcGx5TWVyZ2Uodmlld1Byb2Nlc3Nvciwgc2VydmVyQ2hpbGQsIGNoaWxkTWVyZ2VUcmVlKTtcclxuICAgICAgICAgICAgY3VyVmlld0NhY2hlID0gdmlld1Byb2Nlc3NvckFwcGx5U2VydmVyT3ZlcndyaXRlKHZpZXdQcm9jZXNzb3IsIGN1clZpZXdDYWNoZSwgbmV3IFBhdGgoY2hpbGRLZXkpLCBuZXdDaGlsZCwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gY3VyVmlld0NhY2hlO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JBY2tVc2VyV3JpdGUodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlLCBhY2tQYXRoLCBhZmZlY3RlZFRyZWUsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBhY2N1bXVsYXRvcikge1xyXG4gICAgaWYgKHdyaXRlVHJlZVJlZlNoYWRvd2luZ1dyaXRlKHdyaXRlc0NhY2hlLCBhY2tQYXRoKSAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpZXdDYWNoZTtcclxuICAgIH1cclxuICAgIC8vIE9ubHkgZmlsdGVyIHNlcnZlciBub2RlIGlmIGl0IGlzIGN1cnJlbnRseSBmaWx0ZXJlZFxyXG4gICAgY29uc3QgZmlsdGVyU2VydmVyTm9kZSA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0ZpbHRlcmVkKCk7XHJcbiAgICAvLyBFc3NlbnRpYWxseSB3ZSdsbCBqdXN0IGdldCBvdXIgZXhpc3Rpbmcgc2VydmVyIGNhY2hlIGZvciB0aGUgYWZmZWN0ZWQgcGF0aHMgYW5kIHJlLWFwcGx5IGl0IGFzIGEgc2VydmVyIHVwZGF0ZVxyXG4gICAgLy8gbm93IHRoYXQgaXQgd29uJ3QgYmUgc2hhZG93ZWQuXHJcbiAgICBjb25zdCBzZXJ2ZXJDYWNoZSA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZTtcclxuICAgIGlmIChhZmZlY3RlZFRyZWUudmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIFRoaXMgaXMgYW4gb3ZlcndyaXRlLlxyXG4gICAgICAgIGlmICgocGF0aElzRW1wdHkoYWNrUGF0aCkgJiYgc2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCkpIHx8XHJcbiAgICAgICAgICAgIHNlcnZlckNhY2hlLmlzQ29tcGxldGVGb3JQYXRoKGFja1BhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJPdmVyd3JpdGUodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlLCBhY2tQYXRoLCBzZXJ2ZXJDYWNoZS5nZXROb2RlKCkuZ2V0Q2hpbGQoYWNrUGF0aCksIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhdGhJc0VtcHR5KGFja1BhdGgpKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBnb29meSBlZGdlIGNhc2Ugd2hlcmUgd2UgYXJlIGFja2luZyBkYXRhIGF0IHRoaXMgbG9jYXRpb24gYnV0IGRvbid0IGhhdmUgZnVsbCBkYXRhLiAgV2VcclxuICAgICAgICAgICAgLy8gc2hvdWxkIGp1c3QgcmUtYXBwbHkgd2hhdGV2ZXIgd2UgaGF2ZSBpbiBvdXIgY2FjaGUgYXMgYSBtZXJnZS5cclxuICAgICAgICAgICAgbGV0IGNoYW5nZWRDaGlsZHJlbiA9IG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZS5nZXROb2RlKCkuZm9yRWFjaENoaWxkKEtFWV9JTkRFWCwgKG5hbWUsIG5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZWRDaGlsZHJlbiA9IGNoYW5nZWRDaGlsZHJlbi5zZXQobmV3IFBhdGgobmFtZSksIG5vZGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck1lcmdlKHZpZXdQcm9jZXNzb3IsIHZpZXdDYWNoZSwgYWNrUGF0aCwgY2hhbmdlZENoaWxkcmVuLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZpZXdDYWNoZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBUaGlzIGlzIGEgbWVyZ2UuXHJcbiAgICAgICAgbGV0IGNoYW5nZWRDaGlsZHJlbiA9IG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgIGFmZmVjdGVkVHJlZS5mb3JlYWNoKChtZXJnZVBhdGgsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlckNhY2hlUGF0aCA9IHBhdGhDaGlsZChhY2tQYXRoLCBtZXJnZVBhdGgpO1xyXG4gICAgICAgICAgICBpZiAoc2VydmVyQ2FjaGUuaXNDb21wbGV0ZUZvclBhdGgoc2VydmVyQ2FjaGVQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlZENoaWxkcmVuID0gY2hhbmdlZENoaWxkcmVuLnNldChtZXJnZVBhdGgsIHNlcnZlckNhY2hlLmdldE5vZGUoKS5nZXRDaGlsZChzZXJ2ZXJDYWNoZVBhdGgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJNZXJnZSh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUsIGFja1BhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yTGlzdGVuQ29tcGxldGUodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlLCBwYXRoLCB3cml0ZXNDYWNoZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIGNvbnN0IG9sZFNlcnZlck5vZGUgPSB2aWV3Q2FjaGUuc2VydmVyQ2FjaGU7XHJcbiAgICBjb25zdCBuZXdWaWV3Q2FjaGUgPSB2aWV3Q2FjaGVVcGRhdGVTZXJ2ZXJTbmFwKHZpZXdDYWNoZSwgb2xkU2VydmVyTm9kZS5nZXROb2RlKCksIG9sZFNlcnZlck5vZGUuaXNGdWxseUluaXRpYWxpemVkKCkgfHwgcGF0aElzRW1wdHkocGF0aCksIG9sZFNlcnZlck5vZGUuaXNGaWx0ZXJlZCgpKTtcclxuICAgIHJldHVybiB2aWV3UHJvY2Vzc29yR2VuZXJhdGVFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJFdmVudCh2aWV3UHJvY2Vzc29yLCBuZXdWaWV3Q2FjaGUsIHBhdGgsIHdyaXRlc0NhY2hlLCBOT19DT01QTEVURV9DSElMRF9TT1VSQ0UsIGFjY3VtdWxhdG9yKTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yUmV2ZXJ0VXNlcldyaXRlKHZpZXdQcm9jZXNzb3IsIHZpZXdDYWNoZSwgcGF0aCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlU2VydmVyQ2FjaGUsIGFjY3VtdWxhdG9yKSB7XHJcbiAgICBsZXQgY29tcGxldGU7XHJcbiAgICBpZiAod3JpdGVUcmVlUmVmU2hhZG93aW5nV3JpdGUod3JpdGVzQ2FjaGUsIHBhdGgpICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdmlld0NhY2hlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgc291cmNlID0gbmV3IFdyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2Uod3JpdGVzQ2FjaGUsIHZpZXdDYWNoZSwgY29tcGxldGVTZXJ2ZXJDYWNoZSk7XHJcbiAgICAgICAgY29uc3Qgb2xkRXZlbnRDYWNoZSA9IHZpZXdDYWNoZS5ldmVudENhY2hlLmdldE5vZGUoKTtcclxuICAgICAgICBsZXQgbmV3RXZlbnRDYWNoZTtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocGF0aCkgfHwgcGF0aEdldEZyb250KHBhdGgpID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICBsZXQgbmV3Tm9kZTtcclxuICAgICAgICAgICAgaWYgKHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgbmV3Tm9kZSA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVzQ2FjaGUsIHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh2aWV3Q2FjaGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlckNoaWxkcmVuID0gdmlld0NhY2hlLnNlcnZlckNhY2hlLmdldE5vZGUoKTtcclxuICAgICAgICAgICAgICAgIGFzc2VydChzZXJ2ZXJDaGlsZHJlbiBpbnN0YW5jZW9mIENoaWxkcmVuTm9kZSwgJ3NlcnZlckNoaWxkcmVuIHdvdWxkIGJlIGNvbXBsZXRlIGlmIGxlYWYgbm9kZScpO1xyXG4gICAgICAgICAgICAgICAgbmV3Tm9kZSA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4od3JpdGVzQ2FjaGUsIHNlcnZlckNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXdOb2RlID0gbmV3Tm9kZTtcclxuICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHZpZXdQcm9jZXNzb3IuZmlsdGVyLnVwZGF0ZUZ1bGxOb2RlKG9sZEV2ZW50Q2FjaGUsIG5ld05vZGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkS2V5ID0gcGF0aEdldEZyb250KHBhdGgpO1xyXG4gICAgICAgICAgICBsZXQgbmV3Q2hpbGQgPSB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVDaGlsZCh3cml0ZXNDYWNoZSwgY2hpbGRLZXksIHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZSk7XHJcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZCA9PSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBvbGRFdmVudENhY2hlLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHZpZXdQcm9jZXNzb3IuZmlsdGVyLnVwZGF0ZUNoaWxkKG9sZEV2ZW50Q2FjaGUsIGNoaWxkS2V5LCBuZXdDaGlsZCwgcGF0aFBvcEZyb250KHBhdGgpLCBzb3VyY2UsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh2aWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCkuaGFzQ2hpbGQoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBObyBjb21wbGV0ZSBjaGlsZCBhdmFpbGFibGUsIGRlbGV0ZSB0aGUgZXhpc3Rpbmcgb25lLCBpZiBhbnlcclxuICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVDaGlsZChvbGRFdmVudENhY2hlLCBjaGlsZEtleSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUsIHBhdGhQb3BGcm9udChwYXRoKSwgc291cmNlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gb2xkRXZlbnRDYWNoZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV3RXZlbnRDYWNoZS5pc0VtcHR5KCkgJiZcclxuICAgICAgICAgICAgICAgIHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgbWlnaHQgaGF2ZSByZXZlcnRlZCBhbGwgY2hpbGQgd3JpdGVzLiBNYXliZSB0aGUgb2xkIGV2ZW50IHdhcyBhIGxlYWYgbm9kZVxyXG4gICAgICAgICAgICAgICAgY29tcGxldGUgPSB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVFdmVudENhY2hlKHdyaXRlc0NhY2hlLCB2aWV3Q2FjaGVHZXRDb21wbGV0ZVNlcnZlclNuYXAodmlld0NhY2hlKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGUuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHZpZXdQcm9jZXNzb3IuZmlsdGVyLnVwZGF0ZUZ1bGxOb2RlKG5ld0V2ZW50Q2FjaGUsIGNvbXBsZXRlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcGxldGUgPVxyXG4gICAgICAgICAgICB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCkgfHxcclxuICAgICAgICAgICAgICAgIHdyaXRlVHJlZVJlZlNoYWRvd2luZ1dyaXRlKHdyaXRlc0NhY2hlLCBuZXdFbXB0eVBhdGgoKSkgIT0gbnVsbDtcclxuICAgICAgICByZXR1cm4gdmlld0NhY2hlVXBkYXRlRXZlbnRTbmFwKHZpZXdDYWNoZSwgbmV3RXZlbnRDYWNoZSwgY29tcGxldGUsIHZpZXdQcm9jZXNzb3IuZmlsdGVyLmZpbHRlcnNOb2RlcygpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSB2aWV3IHJlcHJlc2VudHMgYSBzcGVjaWZpYyBsb2NhdGlvbiBhbmQgcXVlcnkgdGhhdCBoYXMgMSBvciBtb3JlIGV2ZW50IHJlZ2lzdHJhdGlvbnMuXHJcbiAqXHJcbiAqIEl0IGRvZXMgc2V2ZXJhbCB0aGluZ3M6XHJcbiAqICAtIE1haW50YWlucyB0aGUgbGlzdCBvZiBldmVudCByZWdpc3RyYXRpb25zIGZvciB0aGlzIGxvY2F0aW9uL3F1ZXJ5LlxyXG4gKiAgLSBNYWludGFpbnMgYSBjYWNoZSBvZiB0aGUgZGF0YSB2aXNpYmxlIGZvciB0aGlzIGxvY2F0aW9uL3F1ZXJ5LlxyXG4gKiAgLSBBcHBsaWVzIG5ldyBvcGVyYXRpb25zICh2aWEgYXBwbHlPcGVyYXRpb24pLCB1cGRhdGVzIHRoZSBjYWNoZSwgYW5kIGJhc2VkIG9uIHRoZSBldmVudFxyXG4gKiAgICByZWdpc3RyYXRpb25zIHJldHVybnMgdGhlIHNldCBvZiBldmVudHMgdG8gYmUgcmFpc2VkLlxyXG4gKi9cclxuY2xhc3MgVmlldyB7XHJcbiAgICBjb25zdHJ1Y3RvcihxdWVyeV8sIGluaXRpYWxWaWV3Q2FjaGUpIHtcclxuICAgICAgICB0aGlzLnF1ZXJ5XyA9IHF1ZXJ5XztcclxuICAgICAgICB0aGlzLmV2ZW50UmVnaXN0cmF0aW9uc18gPSBbXTtcclxuICAgICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnF1ZXJ5Xy5fcXVlcnlQYXJhbXM7XHJcbiAgICAgICAgY29uc3QgaW5kZXhGaWx0ZXIgPSBuZXcgSW5kZXhlZEZpbHRlcihwYXJhbXMuZ2V0SW5kZXgoKSk7XHJcbiAgICAgICAgY29uc3QgZmlsdGVyID0gcXVlcnlQYXJhbXNHZXROb2RlRmlsdGVyKHBhcmFtcyk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzb3JfID0gbmV3Vmlld1Byb2Nlc3NvcihmaWx0ZXIpO1xyXG4gICAgICAgIGNvbnN0IGluaXRpYWxTZXJ2ZXJDYWNoZSA9IGluaXRpYWxWaWV3Q2FjaGUuc2VydmVyQ2FjaGU7XHJcbiAgICAgICAgY29uc3QgaW5pdGlhbEV2ZW50Q2FjaGUgPSBpbml0aWFsVmlld0NhY2hlLmV2ZW50Q2FjaGU7XHJcbiAgICAgICAgLy8gRG9uJ3QgZmlsdGVyIHNlcnZlciBub2RlIHdpdGggb3RoZXIgZmlsdGVyIHRoYW4gaW5kZXgsIHdhaXQgZm9yIHRhZ2dlZCBsaXN0ZW5cclxuICAgICAgICBjb25zdCBzZXJ2ZXJTbmFwID0gaW5kZXhGaWx0ZXIudXBkYXRlRnVsbE5vZGUoQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUsIGluaXRpYWxTZXJ2ZXJDYWNoZS5nZXROb2RlKCksIG51bGwpO1xyXG4gICAgICAgIGNvbnN0IGV2ZW50U25hcCA9IGZpbHRlci51cGRhdGVGdWxsTm9kZShDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgaW5pdGlhbEV2ZW50Q2FjaGUuZ2V0Tm9kZSgpLCBudWxsKTtcclxuICAgICAgICBjb25zdCBuZXdTZXJ2ZXJDYWNoZSA9IG5ldyBDYWNoZU5vZGUoc2VydmVyU25hcCwgaW5pdGlhbFNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpLCBpbmRleEZpbHRlci5maWx0ZXJzTm9kZXMoKSk7XHJcbiAgICAgICAgY29uc3QgbmV3RXZlbnRDYWNoZSA9IG5ldyBDYWNoZU5vZGUoZXZlbnRTbmFwLCBpbml0aWFsRXZlbnRDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgZmlsdGVyLmZpbHRlcnNOb2RlcygpKTtcclxuICAgICAgICB0aGlzLnZpZXdDYWNoZV8gPSBuZXdWaWV3Q2FjaGUobmV3RXZlbnRDYWNoZSwgbmV3U2VydmVyQ2FjaGUpO1xyXG4gICAgICAgIHRoaXMuZXZlbnRHZW5lcmF0b3JfID0gbmV3IEV2ZW50R2VuZXJhdG9yKHRoaXMucXVlcnlfKTtcclxuICAgIH1cclxuICAgIGdldCBxdWVyeSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeV87XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmlld0dldFNlcnZlckNhY2hlKHZpZXcpIHtcclxuICAgIHJldHVybiB2aWV3LnZpZXdDYWNoZV8uc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdHZXRDb21wbGV0ZU5vZGUodmlldykge1xyXG4gICAgcmV0dXJuIHZpZXdDYWNoZUdldENvbXBsZXRlRXZlbnRTbmFwKHZpZXcudmlld0NhY2hlXyk7XHJcbn1cclxuZnVuY3Rpb24gdmlld0dldENvbXBsZXRlU2VydmVyQ2FjaGUodmlldywgcGF0aCkge1xyXG4gICAgY29uc3QgY2FjaGUgPSB2aWV3Q2FjaGVHZXRDb21wbGV0ZVNlcnZlclNuYXAodmlldy52aWV3Q2FjaGVfKTtcclxuICAgIGlmIChjYWNoZSkge1xyXG4gICAgICAgIC8vIElmIHRoaXMgaXNuJ3QgYSBcImxvYWRzQWxsRGF0YVwiIHZpZXcsIHRoZW4gY2FjaGUgaXNuJ3QgYWN0dWFsbHkgYSBjb21wbGV0ZSBjYWNoZSBhbmRcclxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHNlZSBpZiBpdCBjb250YWlucyB0aGUgY2hpbGQgd2UncmUgaW50ZXJlc3RlZCBpbi5cclxuICAgICAgICBpZiAodmlldy5xdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkgfHxcclxuICAgICAgICAgICAgKCFwYXRoSXNFbXB0eShwYXRoKSAmJlxyXG4gICAgICAgICAgICAgICAgIWNhY2hlLmdldEltbWVkaWF0ZUNoaWxkKHBhdGhHZXRGcm9udChwYXRoKSkuaXNFbXB0eSgpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0Q2hpbGQocGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gdmlld0lzRW1wdHkodmlldykge1xyXG4gICAgcmV0dXJuIHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zXy5sZW5ndGggPT09IDA7XHJcbn1cclxuZnVuY3Rpb24gdmlld0FkZEV2ZW50UmVnaXN0cmF0aW9uKHZpZXcsIGV2ZW50UmVnaXN0cmF0aW9uKSB7XHJcbiAgICB2aWV3LmV2ZW50UmVnaXN0cmF0aW9uc18ucHVzaChldmVudFJlZ2lzdHJhdGlvbik7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSBldmVudFJlZ2lzdHJhdGlvbiAtIElmIG51bGwsIHJlbW92ZSBhbGwgY2FsbGJhY2tzLlxyXG4gKiBAcGFyYW0gY2FuY2VsRXJyb3IgLSBJZiBhIGNhbmNlbEVycm9yIGlzIHByb3ZpZGVkLCBhcHByb3ByaWF0ZSBjYW5jZWwgZXZlbnRzIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAqIEByZXR1cm5zIENhbmNlbCBldmVudHMsIGlmIGNhbmNlbEVycm9yIHdhcyBwcm92aWRlZC5cclxuICovXHJcbmZ1bmN0aW9uIHZpZXdSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbih2aWV3LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpIHtcclxuICAgIGNvbnN0IGNhbmNlbEV2ZW50cyA9IFtdO1xyXG4gICAgaWYgKGNhbmNlbEVycm9yKSB7XHJcbiAgICAgICAgYXNzZXJ0KGV2ZW50UmVnaXN0cmF0aW9uID09IG51bGwsICdBIGNhbmNlbCBzaG91bGQgY2FuY2VsIGFsbCBldmVudCByZWdpc3RyYXRpb25zLicpO1xyXG4gICAgICAgIGNvbnN0IHBhdGggPSB2aWV3LnF1ZXJ5Ll9wYXRoO1xyXG4gICAgICAgIHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zXy5mb3JFYWNoKHJlZ2lzdHJhdGlvbiA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1heWJlRXZlbnQgPSByZWdpc3RyYXRpb24uY3JlYXRlQ2FuY2VsRXZlbnQoY2FuY2VsRXJyb3IsIHBhdGgpO1xyXG4gICAgICAgICAgICBpZiAobWF5YmVFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgY2FuY2VsRXZlbnRzLnB1c2gobWF5YmVFdmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChldmVudFJlZ2lzdHJhdGlvbikge1xyXG4gICAgICAgIGxldCByZW1haW5pbmcgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zXy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zX1tpXTtcclxuICAgICAgICAgICAgaWYgKCFleGlzdGluZy5tYXRjaGVzKGV2ZW50UmVnaXN0cmF0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgcmVtYWluaW5nLnB1c2goZXhpc3RpbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50UmVnaXN0cmF0aW9uLmhhc0FueUNhbGxiYWNrKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIHJlbW92aW5nIGp1c3QgdGhpcyBvbmVcclxuICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5jb25jYXQodmlldy5ldmVudFJlZ2lzdHJhdGlvbnNfLnNsaWNlKGkgKyAxKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2aWV3LmV2ZW50UmVnaXN0cmF0aW9uc18gPSByZW1haW5pbmc7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2aWV3LmV2ZW50UmVnaXN0cmF0aW9uc18gPSBbXTtcclxuICAgIH1cclxuICAgIHJldHVybiBjYW5jZWxFdmVudHM7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgdGhlIGdpdmVuIE9wZXJhdGlvbiwgdXBkYXRlcyBvdXIgY2FjaGUsIGFuZCByZXR1cm5zIHRoZSBhcHByb3ByaWF0ZSBldmVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiB2aWV3QXBwbHlPcGVyYXRpb24odmlldywgb3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgY29tcGxldGVTZXJ2ZXJDYWNoZSkge1xyXG4gICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSBPcGVyYXRpb25UeXBlLk1FUkdFICYmXHJcbiAgICAgICAgb3BlcmF0aW9uLnNvdXJjZS5xdWVyeUlkICE9PSBudWxsKSB7XHJcbiAgICAgICAgYXNzZXJ0KHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh2aWV3LnZpZXdDYWNoZV8pLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIGEgZnVsbCBjYWNoZSBiZWZvcmUgaGFuZGxpbmcgbWVyZ2VzJyk7XHJcbiAgICAgICAgYXNzZXJ0KHZpZXdDYWNoZUdldENvbXBsZXRlRXZlbnRTbmFwKHZpZXcudmlld0NhY2hlXyksICdNaXNzaW5nIGV2ZW50IGNhY2hlLCBldmVuIHRob3VnaCB3ZSBoYXZlIGEgc2VydmVyIGNhY2hlJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvbGRWaWV3Q2FjaGUgPSB2aWV3LnZpZXdDYWNoZV87XHJcbiAgICBjb25zdCByZXN1bHQgPSB2aWV3UHJvY2Vzc29yQXBwbHlPcGVyYXRpb24odmlldy5wcm9jZXNzb3JfLCBvbGRWaWV3Q2FjaGUsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlU2VydmVyQ2FjaGUpO1xyXG4gICAgdmlld1Byb2Nlc3NvckFzc2VydEluZGV4ZWQodmlldy5wcm9jZXNzb3JfLCByZXN1bHQudmlld0NhY2hlKTtcclxuICAgIGFzc2VydChyZXN1bHQudmlld0NhY2hlLnNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8XHJcbiAgICAgICAgIW9sZFZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgJ09uY2UgYSBzZXJ2ZXIgc25hcCBpcyBjb21wbGV0ZSwgaXQgc2hvdWxkIG5ldmVyIGdvIGJhY2snKTtcclxuICAgIHZpZXcudmlld0NhY2hlXyA9IHJlc3VsdC52aWV3Q2FjaGU7XHJcbiAgICByZXR1cm4gdmlld0dlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlc18odmlldywgcmVzdWx0LmNoYW5nZXMsIHJlc3VsdC52aWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCksIG51bGwpO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdHZXRJbml0aWFsRXZlbnRzKHZpZXcsIHJlZ2lzdHJhdGlvbikge1xyXG4gICAgY29uc3QgZXZlbnRTbmFwID0gdmlldy52aWV3Q2FjaGVfLmV2ZW50Q2FjaGU7XHJcbiAgICBjb25zdCBpbml0aWFsQ2hhbmdlcyA9IFtdO1xyXG4gICAgaWYgKCFldmVudFNuYXAuZ2V0Tm9kZSgpLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50Tm9kZSA9IGV2ZW50U25hcC5nZXROb2RlKCk7XHJcbiAgICAgICAgZXZlbnROb2RlLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgKGtleSwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGluaXRpYWxDaGFuZ2VzLnB1c2goY2hhbmdlQ2hpbGRBZGRlZChrZXksIGNoaWxkTm9kZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgIGluaXRpYWxDaGFuZ2VzLnB1c2goY2hhbmdlVmFsdWUoZXZlbnRTbmFwLmdldE5vZGUoKSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZpZXdHZW5lcmF0ZUV2ZW50c0ZvckNoYW5nZXNfKHZpZXcsIGluaXRpYWxDaGFuZ2VzLCBldmVudFNuYXAuZ2V0Tm9kZSgpLCByZWdpc3RyYXRpb24pO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdHZW5lcmF0ZUV2ZW50c0ZvckNoYW5nZXNfKHZpZXcsIGNoYW5nZXMsIGV2ZW50Q2FjaGUsIGV2ZW50UmVnaXN0cmF0aW9uKSB7XHJcbiAgICBjb25zdCByZWdpc3RyYXRpb25zID0gZXZlbnRSZWdpc3RyYXRpb25cclxuICAgICAgICA/IFtldmVudFJlZ2lzdHJhdGlvbl1cclxuICAgICAgICA6IHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zXztcclxuICAgIHJldHVybiBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlcyh2aWV3LmV2ZW50R2VuZXJhdG9yXywgY2hhbmdlcywgZXZlbnRDYWNoZSwgcmVnaXN0cmF0aW9ucyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IHJlZmVyZW5jZUNvbnN0cnVjdG9yJDE7XHJcbi8qKlxyXG4gKiBTeW5jUG9pbnQgcmVwcmVzZW50cyBhIHNpbmdsZSBsb2NhdGlvbiBpbiBhIFN5bmNUcmVlIHdpdGggMSBvciBtb3JlIGV2ZW50IHJlZ2lzdHJhdGlvbnMsIG1lYW5pbmcgd2UgbmVlZCB0b1xyXG4gKiBtYWludGFpbiAxIG9yIG1vcmUgVmlld3MgYXQgdGhpcyBsb2NhdGlvbiB0byBjYWNoZSBzZXJ2ZXIgZGF0YSBhbmQgcmFpc2UgYXBwcm9wcmlhdGUgZXZlbnRzIGZvciBzZXJ2ZXIgY2hhbmdlc1xyXG4gKiBhbmQgdXNlciB3cml0ZXMgKHNldCwgdHJhbnNhY3Rpb24sIHVwZGF0ZSkuXHJcbiAqXHJcbiAqIEl0J3MgcmVzcG9uc2libGUgZm9yOlxyXG4gKiAgLSBNYWludGFpbmluZyB0aGUgc2V0IG9mIDEgb3IgbW9yZSB2aWV3cyBuZWNlc3NhcnkgYXQgdGhpcyBsb2NhdGlvbiAoYSBTeW5jUG9pbnQgd2l0aCAwIHZpZXdzIHNob3VsZCBiZSByZW1vdmVkKS5cclxuICogIC0gUHJveHlpbmcgdXNlciAvIHNlcnZlciBvcGVyYXRpb25zIHRvIHRoZSB2aWV3cyBhcyBhcHByb3ByaWF0ZSAoaS5lLiBhcHBseVNlcnZlck92ZXJ3cml0ZSxcclxuICogICAgYXBwbHlVc2VyT3ZlcndyaXRlLCBldGMuKVxyXG4gKi9cclxuY2xhc3MgU3luY1BvaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBWaWV3cyBiZWluZyB0cmFja2VkIGF0IHRoaXMgbG9jYXRpb24gaW4gdGhlIHRyZWUsIHN0b3JlZCBhcyBhIG1hcCB3aGVyZSB0aGUga2V5IGlzIGFcclxuICAgICAgICAgKiBxdWVyeUlkIGFuZCB0aGUgdmFsdWUgaXMgdGhlIFZpZXcgZm9yIHRoYXQgcXVlcnkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBOT1RFOiBUaGlzIGxpc3Qgd2lsbCBiZSBxdWl0ZSBzbWFsbCAodXN1YWxseSAxLCBidXQgcGVyaGFwcyAyIG9yIDM7IGFueSBtb3JlIGlzIGFuIG9kZCB1c2UgY2FzZSkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy52aWV3cyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzeW5jUG9pbnRTZXRSZWZlcmVuY2VDb25zdHJ1Y3Rvcih2YWwpIHtcclxuICAgIGFzc2VydCghcmVmZXJlbmNlQ29uc3RydWN0b3IkMSwgJ19fcmVmZXJlbmNlQ29uc3RydWN0b3IgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkJyk7XHJcbiAgICByZWZlcmVuY2VDb25zdHJ1Y3RvciQxID0gdmFsO1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNQb2ludEdldFJlZmVyZW5jZUNvbnN0cnVjdG9yKCkge1xyXG4gICAgYXNzZXJ0KHJlZmVyZW5jZUNvbnN0cnVjdG9yJDEsICdSZWZlcmVuY2UudHMgaGFzIG5vdCBiZWVuIGxvYWRlZCcpO1xyXG4gICAgcmV0dXJuIHJlZmVyZW5jZUNvbnN0cnVjdG9yJDE7XHJcbn1cclxuZnVuY3Rpb24gc3luY1BvaW50SXNFbXB0eShzeW5jUG9pbnQpIHtcclxuICAgIHJldHVybiBzeW5jUG9pbnQudmlld3Muc2l6ZSA9PT0gMDtcclxufVxyXG5mdW5jdGlvbiBzeW5jUG9pbnRBcHBseU9wZXJhdGlvbihzeW5jUG9pbnQsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIG9wdENvbXBsZXRlU2VydmVyQ2FjaGUpIHtcclxuICAgIGNvbnN0IHF1ZXJ5SWQgPSBvcGVyYXRpb24uc291cmNlLnF1ZXJ5SWQ7XHJcbiAgICBpZiAocXVlcnlJZCAhPT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IHZpZXcgPSBzeW5jUG9pbnQudmlld3MuZ2V0KHF1ZXJ5SWQpO1xyXG4gICAgICAgIGFzc2VydCh2aWV3ICE9IG51bGwsICdTeW5jVHJlZSBnYXZlIHVzIGFuIG9wIGZvciBhbiBpbnZhbGlkIHF1ZXJ5LicpO1xyXG4gICAgICAgIHJldHVybiB2aWV3QXBwbHlPcGVyYXRpb24odmlldywgb3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgb3B0Q29tcGxldGVTZXJ2ZXJDYWNoZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCB2aWV3IG9mIHN5bmNQb2ludC52aWV3cy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHZpZXdBcHBseU9wZXJhdGlvbih2aWV3LCBvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBvcHRDb21wbGV0ZVNlcnZlckNhY2hlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudHM7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdldCBhIHZpZXcgZm9yIHRoZSBzcGVjaWZpZWQgcXVlcnkuXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSB0byByZXR1cm4gYSB2aWV3IGZvclxyXG4gKiBAcGFyYW0gd3JpdGVzQ2FjaGVcclxuICogQHBhcmFtIHNlcnZlckNhY2hlXHJcbiAqIEBwYXJhbSBzZXJ2ZXJDYWNoZUNvbXBsZXRlXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNQb2ludEdldFZpZXcoc3luY1BvaW50LCBxdWVyeSwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBzZXJ2ZXJDYWNoZUNvbXBsZXRlKSB7XHJcbiAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgIGNvbnN0IHZpZXcgPSBzeW5jUG9pbnQudmlld3MuZ2V0KHF1ZXJ5SWQpO1xyXG4gICAgaWYgKCF2aWV3KSB7XHJcbiAgICAgICAgLy8gVE9ETzogbWFrZSB3cml0ZXNDYWNoZSB0YWtlIGZsYWcgZm9yIGNvbXBsZXRlIHNlcnZlciBub2RlXHJcbiAgICAgICAgbGV0IGV2ZW50Q2FjaGUgPSB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVFdmVudENhY2hlKHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZUNvbXBsZXRlID8gc2VydmVyQ2FjaGUgOiBudWxsKTtcclxuICAgICAgICBsZXQgZXZlbnRDYWNoZUNvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGV2ZW50Q2FjaGUpIHtcclxuICAgICAgICAgICAgZXZlbnRDYWNoZUNvbXBsZXRlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2VydmVyQ2FjaGUgaW5zdGFuY2VvZiBDaGlsZHJlbk5vZGUpIHtcclxuICAgICAgICAgICAgZXZlbnRDYWNoZSA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4od3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlKTtcclxuICAgICAgICAgICAgZXZlbnRDYWNoZUNvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBldmVudENhY2hlID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgIGV2ZW50Q2FjaGVDb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB2aWV3Q2FjaGUgPSBuZXdWaWV3Q2FjaGUobmV3IENhY2hlTm9kZShldmVudENhY2hlLCBldmVudENhY2hlQ29tcGxldGUsIGZhbHNlKSwgbmV3IENhY2hlTm9kZShzZXJ2ZXJDYWNoZSwgc2VydmVyQ2FjaGVDb21wbGV0ZSwgZmFsc2UpKTtcclxuICAgICAgICByZXR1cm4gbmV3IFZpZXcocXVlcnksIHZpZXdDYWNoZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmlldztcclxufVxyXG4vKipcclxuICogQWRkIGFuIGV2ZW50IGNhbGxiYWNrIGZvciB0aGUgc3BlY2lmaWVkIHF1ZXJ5LlxyXG4gKlxyXG4gKiBAcGFyYW0gcXVlcnlcclxuICogQHBhcmFtIGV2ZW50UmVnaXN0cmF0aW9uXHJcbiAqIEBwYXJhbSB3cml0ZXNDYWNoZVxyXG4gKiBAcGFyYW0gc2VydmVyQ2FjaGUgLSBDb21wbGV0ZSBzZXJ2ZXIgY2FjaGUsIGlmIHdlIGhhdmUgaXQuXHJcbiAqIEBwYXJhbSBzZXJ2ZXJDYWNoZUNvbXBsZXRlXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNQb2ludEFkZEV2ZW50UmVnaXN0cmF0aW9uKHN5bmNQb2ludCwgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIHNlcnZlckNhY2hlQ29tcGxldGUpIHtcclxuICAgIGNvbnN0IHZpZXcgPSBzeW5jUG9pbnRHZXRWaWV3KHN5bmNQb2ludCwgcXVlcnksIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgc2VydmVyQ2FjaGVDb21wbGV0ZSk7XHJcbiAgICBpZiAoIXN5bmNQb2ludC52aWV3cy5oYXMocXVlcnkuX3F1ZXJ5SWRlbnRpZmllcikpIHtcclxuICAgICAgICBzeW5jUG9pbnQudmlld3Muc2V0KHF1ZXJ5Ll9xdWVyeUlkZW50aWZpZXIsIHZpZXcpO1xyXG4gICAgfVxyXG4gICAgLy8gVGhpcyBpcyBndWFyYW50ZWVkIHRvIGV4aXN0IG5vdywgd2UganVzdCBjcmVhdGVkIGFueXRoaW5nIHRoYXQgd2FzIG1pc3NpbmdcclxuICAgIHZpZXdBZGRFdmVudFJlZ2lzdHJhdGlvbih2aWV3LCBldmVudFJlZ2lzdHJhdGlvbik7XHJcbiAgICByZXR1cm4gdmlld0dldEluaXRpYWxFdmVudHModmlldywgZXZlbnRSZWdpc3RyYXRpb24pO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmUgZXZlbnQgY2FsbGJhY2socykuICBSZXR1cm4gY2FuY2VsRXZlbnRzIGlmIGEgY2FuY2VsRXJyb3IgaXMgc3BlY2lmaWVkLlxyXG4gKlxyXG4gKiBJZiBxdWVyeSBpcyB0aGUgZGVmYXVsdCBxdWVyeSwgd2UnbGwgY2hlY2sgYWxsIHZpZXdzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50UmVnaXN0cmF0aW9uLlxyXG4gKiBJZiBldmVudFJlZ2lzdHJhdGlvbiBpcyBudWxsLCB3ZSdsbCByZW1vdmUgYWxsIGNhbGxiYWNrcyBmb3IgdGhlIHNwZWNpZmllZCB2aWV3KHMpLlxyXG4gKlxyXG4gKiBAcGFyYW0gZXZlbnRSZWdpc3RyYXRpb24gLSBJZiBudWxsLCByZW1vdmUgYWxsIGNhbGxiYWNrcy5cclxuICogQHBhcmFtIGNhbmNlbEVycm9yIC0gSWYgYSBjYW5jZWxFcnJvciBpcyBwcm92aWRlZCwgYXBwcm9wcmlhdGUgY2FuY2VsIGV2ZW50cyB3aWxsIGJlIHJldHVybmVkLlxyXG4gKiBAcmV0dXJucyByZW1vdmVkIHF1ZXJpZXMgYW5kIGFueSBjYW5jZWwgZXZlbnRzXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jUG9pbnRSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbihzeW5jUG9pbnQsIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpIHtcclxuICAgIGNvbnN0IHF1ZXJ5SWQgPSBxdWVyeS5fcXVlcnlJZGVudGlmaWVyO1xyXG4gICAgY29uc3QgcmVtb3ZlZCA9IFtdO1xyXG4gICAgbGV0IGNhbmNlbEV2ZW50cyA9IFtdO1xyXG4gICAgY29uc3QgaGFkQ29tcGxldGVWaWV3ID0gc3luY1BvaW50SGFzQ29tcGxldGVWaWV3KHN5bmNQb2ludCk7XHJcbiAgICBpZiAocXVlcnlJZCA9PT0gJ2RlZmF1bHQnKSB7XHJcbiAgICAgICAgLy8gV2hlbiB5b3UgZG8gcmVmLm9mZiguLi4pLCB3ZSBzZWFyY2ggYWxsIHZpZXdzIGZvciB0aGUgcmVnaXN0cmF0aW9uIHRvIHJlbW92ZS5cclxuICAgICAgICBmb3IgKGNvbnN0IFt2aWV3UXVlcnlJZCwgdmlld10gb2Ygc3luY1BvaW50LnZpZXdzLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICBjYW5jZWxFdmVudHMgPSBjYW5jZWxFdmVudHMuY29uY2F0KHZpZXdSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbih2aWV3LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpKTtcclxuICAgICAgICAgICAgaWYgKHZpZXdJc0VtcHR5KHZpZXcpKSB7XHJcbiAgICAgICAgICAgICAgICBzeW5jUG9pbnQudmlld3MuZGVsZXRlKHZpZXdRdWVyeUlkKTtcclxuICAgICAgICAgICAgICAgIC8vIFdlJ2xsIGRlYWwgd2l0aCBjb21wbGV0ZSB2aWV3cyBsYXRlci5cclxuICAgICAgICAgICAgICAgIGlmICghdmlldy5xdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkLnB1c2godmlldy5xdWVyeSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gdGhlIHNwZWNpZmljIHZpZXcuXHJcbiAgICAgICAgY29uc3QgdmlldyA9IHN5bmNQb2ludC52aWV3cy5nZXQocXVlcnlJZCk7XHJcbiAgICAgICAgaWYgKHZpZXcpIHtcclxuICAgICAgICAgICAgY2FuY2VsRXZlbnRzID0gY2FuY2VsRXZlbnRzLmNvbmNhdCh2aWV3UmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24odmlldywgZXZlbnRSZWdpc3RyYXRpb24sIGNhbmNlbEVycm9yKSk7XHJcbiAgICAgICAgICAgIGlmICh2aWV3SXNFbXB0eSh2aWV3KSkge1xyXG4gICAgICAgICAgICAgICAgc3luY1BvaW50LnZpZXdzLmRlbGV0ZShxdWVyeUlkKTtcclxuICAgICAgICAgICAgICAgIC8vIFdlJ2xsIGRlYWwgd2l0aCBjb21wbGV0ZSB2aWV3cyBsYXRlci5cclxuICAgICAgICAgICAgICAgIGlmICghdmlldy5xdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkLnB1c2godmlldy5xdWVyeSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaGFkQ29tcGxldGVWaWV3ICYmICFzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcoc3luY1BvaW50KSkge1xyXG4gICAgICAgIC8vIFdlIHJlbW92ZWQgb3VyIGxhc3QgY29tcGxldGUgdmlldy5cclxuICAgICAgICByZW1vdmVkLnB1c2gobmV3IChzeW5jUG9pbnRHZXRSZWZlcmVuY2VDb25zdHJ1Y3RvcigpKShxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IHJlbW92ZWQsIGV2ZW50czogY2FuY2VsRXZlbnRzIH07XHJcbn1cclxuZnVuY3Rpb24gc3luY1BvaW50R2V0UXVlcnlWaWV3cyhzeW5jUG9pbnQpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgZm9yIChjb25zdCB2aWV3IG9mIHN5bmNQb2ludC52aWV3cy52YWx1ZXMoKSkge1xyXG4gICAgICAgIGlmICghdmlldy5xdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2godmlldyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byB0aGUgZGVzaXJlZCBjb21wbGV0ZSBzbmFwc2hvdFxyXG4gKiBAcmV0dXJucyBBIGNvbXBsZXRlIGNhY2hlLCBpZiBpdCBleGlzdHNcclxuICovXHJcbmZ1bmN0aW9uIHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoc3luY1BvaW50LCBwYXRoKSB7XHJcbiAgICBsZXQgc2VydmVyQ2FjaGUgPSBudWxsO1xyXG4gICAgZm9yIChjb25zdCB2aWV3IG9mIHN5bmNQb2ludC52aWV3cy52YWx1ZXMoKSkge1xyXG4gICAgICAgIHNlcnZlckNhY2hlID0gc2VydmVyQ2FjaGUgfHwgdmlld0dldENvbXBsZXRlU2VydmVyQ2FjaGUodmlldywgcGF0aCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2VydmVyQ2FjaGU7XHJcbn1cclxuZnVuY3Rpb24gc3luY1BvaW50Vmlld0ZvclF1ZXJ5KHN5bmNQb2ludCwgcXVlcnkpIHtcclxuICAgIGNvbnN0IHBhcmFtcyA9IHF1ZXJ5Ll9xdWVyeVBhcmFtcztcclxuICAgIGlmIChwYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICByZXR1cm4gc3luY1BvaW50R2V0Q29tcGxldGVWaWV3KHN5bmNQb2ludCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgICAgICByZXR1cm4gc3luY1BvaW50LnZpZXdzLmdldChxdWVyeUlkKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzeW5jUG9pbnRWaWV3RXhpc3RzRm9yUXVlcnkoc3luY1BvaW50LCBxdWVyeSkge1xyXG4gICAgcmV0dXJuIHN5bmNQb2ludFZpZXdGb3JRdWVyeShzeW5jUG9pbnQsIHF1ZXJ5KSAhPSBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNQb2ludEhhc0NvbXBsZXRlVmlldyhzeW5jUG9pbnQpIHtcclxuICAgIHJldHVybiBzeW5jUG9pbnRHZXRDb21wbGV0ZVZpZXcoc3luY1BvaW50KSAhPSBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNQb2ludEdldENvbXBsZXRlVmlldyhzeW5jUG9pbnQpIHtcclxuICAgIGZvciAoY29uc3QgdmlldyBvZiBzeW5jUG9pbnQudmlld3MudmFsdWVzKCkpIHtcclxuICAgICAgICBpZiAodmlldy5xdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZpZXc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IHJlZmVyZW5jZUNvbnN0cnVjdG9yO1xyXG5mdW5jdGlvbiBzeW5jVHJlZVNldFJlZmVyZW5jZUNvbnN0cnVjdG9yKHZhbCkge1xyXG4gICAgYXNzZXJ0KCFyZWZlcmVuY2VDb25zdHJ1Y3RvciwgJ19fcmVmZXJlbmNlQ29uc3RydWN0b3IgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkJyk7XHJcbiAgICByZWZlcmVuY2VDb25zdHJ1Y3RvciA9IHZhbDtcclxufVxyXG5mdW5jdGlvbiBzeW5jVHJlZUdldFJlZmVyZW5jZUNvbnN0cnVjdG9yKCkge1xyXG4gICAgYXNzZXJ0KHJlZmVyZW5jZUNvbnN0cnVjdG9yLCAnUmVmZXJlbmNlLnRzIGhhcyBub3QgYmVlbiBsb2FkZWQnKTtcclxuICAgIHJldHVybiByZWZlcmVuY2VDb25zdHJ1Y3RvcjtcclxufVxyXG4vKipcclxuICogU3RhdGljIHRyYWNrZXIgZm9yIG5leHQgcXVlcnkgdGFnLlxyXG4gKi9cclxubGV0IHN5bmNUcmVlTmV4dFF1ZXJ5VGFnXyA9IDE7XHJcbi8qKlxyXG4gKiBTeW5jVHJlZSBpcyB0aGUgY2VudHJhbCBjbGFzcyBmb3IgbWFuYWdpbmcgZXZlbnQgY2FsbGJhY2sgcmVnaXN0cmF0aW9uLCBkYXRhIGNhY2hpbmcsIHZpZXdzXHJcbiAqIChxdWVyeSBwcm9jZXNzaW5nKSwgYW5kIGV2ZW50IGdlbmVyYXRpb24uICBUaGVyZSBhcmUgdHlwaWNhbGx5IHR3byBTeW5jVHJlZSBpbnN0YW5jZXMgZm9yXHJcbiAqIGVhY2ggUmVwbywgb25lIGZvciB0aGUgbm9ybWFsIEZpcmViYXNlIGRhdGEsIGFuZCBvbmUgZm9yIHRoZSAuaW5mbyBkYXRhLlxyXG4gKlxyXG4gKiBJdCBoYXMgYSBudW1iZXIgb2YgcmVzcG9uc2liaWxpdGllcywgaW5jbHVkaW5nOlxyXG4gKiAgLSBUcmFja2luZyBhbGwgdXNlciBldmVudCBjYWxsYmFja3MgKHJlZ2lzdGVyZWQgdmlhIGFkZEV2ZW50UmVnaXN0cmF0aW9uKCkgYW5kIHJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKCkpLlxyXG4gKiAgLSBBcHBseWluZyBhbmQgY2FjaGluZyBkYXRhIGNoYW5nZXMgZm9yIHVzZXIgc2V0KCksIHRyYW5zYWN0aW9uKCksIGFuZCB1cGRhdGUoKSBjYWxsc1xyXG4gKiAgICAoYXBwbHlVc2VyT3ZlcndyaXRlKCksIGFwcGx5VXNlck1lcmdlKCkpLlxyXG4gKiAgLSBBcHBseWluZyBhbmQgY2FjaGluZyBkYXRhIGNoYW5nZXMgZm9yIHNlcnZlciBkYXRhIGNoYW5nZXMgKGFwcGx5U2VydmVyT3ZlcndyaXRlKCksXHJcbiAqICAgIGFwcGx5U2VydmVyTWVyZ2UoKSkuXHJcbiAqICAtIEdlbmVyYXRpbmcgdXNlci1mYWNpbmcgZXZlbnRzIGZvciBzZXJ2ZXIgYW5kIHVzZXIgY2hhbmdlcyAoYWxsIG9mIHRoZSBhcHBseSogbWV0aG9kc1xyXG4gKiAgICByZXR1cm4gdGhlIHNldCBvZiBldmVudHMgdGhhdCBuZWVkIHRvIGJlIHJhaXNlZCBhcyBhIHJlc3VsdCkuXHJcbiAqICAtIE1haW50YWluaW5nIHRoZSBhcHByb3ByaWF0ZSBzZXQgb2Ygc2VydmVyIGxpc3RlbnMgdG8gZW5zdXJlIHdlIGFyZSBhbHdheXMgc3Vic2NyaWJlZFxyXG4gKiAgICB0byB0aGUgY29ycmVjdCBzZXQgb2YgcGF0aHMgYW5kIHF1ZXJpZXMgdG8gc2F0aXNmeSB0aGUgY3VycmVudCBzZXQgb2YgdXNlciBldmVudFxyXG4gKiAgICBjYWxsYmFja3MgKGxpc3RlbnMgYXJlIHN0YXJ0ZWQvc3RvcHBlZCB1c2luZyB0aGUgcHJvdmlkZWQgbGlzdGVuUHJvdmlkZXIpLlxyXG4gKlxyXG4gKiBOT1RFOiBBbHRob3VnaCBTeW5jVHJlZSB0cmFja3MgZXZlbnQgY2FsbGJhY2tzIGFuZCBjYWxjdWxhdGVzIGV2ZW50cyB0byByYWlzZSwgdGhlIGFjdHVhbFxyXG4gKiBldmVudHMgYXJlIHJldHVybmVkIHRvIHRoZSBjYWxsZXIgcmF0aGVyIHRoYW4gcmFpc2VkIHN5bmNocm9ub3VzbHkuXHJcbiAqXHJcbiAqL1xyXG5jbGFzcyBTeW5jVHJlZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBsaXN0ZW5Qcm92aWRlcl8gLSBVc2VkIGJ5IFN5bmNUcmVlIHRvIHN0YXJ0IC8gc3RvcCBsaXN0ZW5pbmdcclxuICAgICAqICAgdG8gc2VydmVyIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxpc3RlblByb3ZpZGVyXykge1xyXG4gICAgICAgIHRoaXMubGlzdGVuUHJvdmlkZXJfID0gbGlzdGVuUHJvdmlkZXJfO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyZWUgb2YgU3luY1BvaW50cy4gIFRoZXJlJ3MgYSBTeW5jUG9pbnQgYXQgYW55IGxvY2F0aW9uIHRoYXQgaGFzIDEgb3IgbW9yZSB2aWV3cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN5bmNQb2ludFRyZWVfID0gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSB0cmVlIG9mIGFsbCBwZW5kaW5nIHVzZXIgd3JpdGVzICh1c2VyLWluaXRpYXRlZCBzZXQoKSdzLCB0cmFuc2FjdGlvbigpJ3MsIHVwZGF0ZSgpJ3MsIGV0Yy4pLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1dyaXRlVHJlZV8gPSBuZXdXcml0ZVRyZWUoKTtcclxuICAgICAgICB0aGlzLnRhZ1RvUXVlcnlNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5xdWVyeVRvVGFnTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBcHBseSB0aGUgZGF0YSBjaGFuZ2VzIGZvciBhIHVzZXItZ2VuZXJhdGVkIHNldCgpIG9yIHRyYW5zYWN0aW9uKCkgY2FsbC5cclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseVVzZXJPdmVyd3JpdGUoc3luY1RyZWUsIHBhdGgsIG5ld0RhdGEsIHdyaXRlSWQsIHZpc2libGUpIHtcclxuICAgIC8vIFJlY29yZCBwZW5kaW5nIHdyaXRlLlxyXG4gICAgd3JpdGVUcmVlQWRkT3ZlcndyaXRlKHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfLCBwYXRoLCBuZXdEYXRhLCB3cml0ZUlkLCB2aXNpYmxlKTtcclxuICAgIGlmICghdmlzaWJsZSkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBzeW5jVHJlZUFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzXyhzeW5jVHJlZSwgbmV3IE92ZXJ3cml0ZShuZXdPcGVyYXRpb25Tb3VyY2VVc2VyKCksIHBhdGgsIG5ld0RhdGEpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQXBwbHkgdGhlIGRhdGEgZnJvbSBhIHVzZXItZ2VuZXJhdGVkIHVwZGF0ZSgpIGNhbGxcclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseVVzZXJNZXJnZShzeW5jVHJlZSwgcGF0aCwgY2hhbmdlZENoaWxkcmVuLCB3cml0ZUlkKSB7XHJcbiAgICAvLyBSZWNvcmQgcGVuZGluZyBtZXJnZS5cclxuICAgIHdyaXRlVHJlZUFkZE1lcmdlKHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlSWQpO1xyXG4gICAgY29uc3QgY2hhbmdlVHJlZSA9IEltbXV0YWJsZVRyZWUuZnJvbU9iamVjdChjaGFuZ2VkQ2hpbGRyZW4pO1xyXG4gICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBuZXcgTWVyZ2UobmV3T3BlcmF0aW9uU291cmNlVXNlcigpLCBwYXRoLCBjaGFuZ2VUcmVlKSk7XHJcbn1cclxuLyoqXHJcbiAqIEFja25vd2xlZGdlIGEgcGVuZGluZyB1c2VyIHdyaXRlIHRoYXQgd2FzIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB3aXRoIGFwcGx5VXNlck92ZXJ3cml0ZSgpIG9yIGFwcGx5VXNlck1lcmdlKCkuXHJcbiAqXHJcbiAqIEBwYXJhbSByZXZlcnQgLSBUcnVlIGlmIHRoZSBnaXZlbiB3cml0ZSBmYWlsZWQgYW5kIG5lZWRzIHRvIGJlIHJldmVydGVkXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQWNrVXNlcldyaXRlKHN5bmNUcmVlLCB3cml0ZUlkLCByZXZlcnQgPSBmYWxzZSkge1xyXG4gICAgY29uc3Qgd3JpdGUgPSB3cml0ZVRyZWVHZXRXcml0ZShzeW5jVHJlZS5wZW5kaW5nV3JpdGVUcmVlXywgd3JpdGVJZCk7XHJcbiAgICBjb25zdCBuZWVkVG9SZWV2YWx1YXRlID0gd3JpdGVUcmVlUmVtb3ZlV3JpdGUoc3luY1RyZWUucGVuZGluZ1dyaXRlVHJlZV8sIHdyaXRlSWQpO1xyXG4gICAgaWYgKCFuZWVkVG9SZWV2YWx1YXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IGFmZmVjdGVkVHJlZSA9IG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgIGlmICh3cml0ZS5zbmFwICE9IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gb3ZlcndyaXRlXHJcbiAgICAgICAgICAgIGFmZmVjdGVkVHJlZSA9IGFmZmVjdGVkVHJlZS5zZXQobmV3RW1wdHlQYXRoKCksIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWFjaCh3cml0ZS5jaGlsZHJlbiwgKHBhdGhTdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGFmZmVjdGVkVHJlZSA9IGFmZmVjdGVkVHJlZS5zZXQobmV3IFBhdGgocGF0aFN0cmluZyksIHRydWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBuZXcgQWNrVXNlcldyaXRlKHdyaXRlLnBhdGgsIGFmZmVjdGVkVHJlZSwgcmV2ZXJ0KSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFwcGx5IG5ldyBzZXJ2ZXIgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCBwYXRoLi5cclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseVNlcnZlck92ZXJ3cml0ZShzeW5jVHJlZSwgcGF0aCwgbmV3RGF0YSkge1xyXG4gICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBuZXcgT3ZlcndyaXRlKG5ld09wZXJhdGlvblNvdXJjZVNlcnZlcigpLCBwYXRoLCBuZXdEYXRhKSk7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGx5IG5ldyBzZXJ2ZXIgZGF0YSB0byBiZSBtZXJnZWQgaW4gYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBFdmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5U2VydmVyTWVyZ2Uoc3luY1RyZWUsIHBhdGgsIGNoYW5nZWRDaGlsZHJlbikge1xyXG4gICAgY29uc3QgY2hhbmdlVHJlZSA9IEltbXV0YWJsZVRyZWUuZnJvbU9iamVjdChjaGFuZ2VkQ2hpbGRyZW4pO1xyXG4gICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBuZXcgTWVyZ2UobmV3T3BlcmF0aW9uU291cmNlU2VydmVyKCksIHBhdGgsIGNoYW5nZVRyZWUpKTtcclxufVxyXG4vKipcclxuICogQXBwbHkgYSBsaXN0ZW4gY29tcGxldGUgZm9yIGEgcXVlcnlcclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseUxpc3RlbkNvbXBsZXRlKHN5bmNUcmVlLCBwYXRoKSB7XHJcbiAgICByZXR1cm4gc3luY1RyZWVBcHBseU9wZXJhdGlvblRvU3luY1BvaW50c18oc3luY1RyZWUsIG5ldyBMaXN0ZW5Db21wbGV0ZShuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXIoKSwgcGF0aCkpO1xyXG59XHJcbi8qKlxyXG4gKiBBcHBseSBhIGxpc3RlbiBjb21wbGV0ZSBmb3IgYSB0YWdnZWQgcXVlcnlcclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseVRhZ2dlZExpc3RlbkNvbXBsZXRlKHN5bmNUcmVlLCBwYXRoLCB0YWcpIHtcclxuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gc3luY1RyZWVRdWVyeUtleUZvclRhZ18oc3luY1RyZWUsIHRhZyk7XHJcbiAgICBpZiAocXVlcnlLZXkpIHtcclxuICAgICAgICBjb25zdCByID0gc3luY1RyZWVQYXJzZVF1ZXJ5S2V5XyhxdWVyeUtleSk7XHJcbiAgICAgICAgY29uc3QgcXVlcnlQYXRoID0gci5wYXRoLCBxdWVyeUlkID0gci5xdWVyeUlkO1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChxdWVyeVBhdGgsIHBhdGgpO1xyXG4gICAgICAgIGNvbnN0IG9wID0gbmV3IExpc3RlbkNvbXBsZXRlKG5ld09wZXJhdGlvblNvdXJjZVNlcnZlclRhZ2dlZFF1ZXJ5KHF1ZXJ5SWQpLCByZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgIHJldHVybiBzeW5jVHJlZUFwcGx5VGFnZ2VkT3BlcmF0aW9uXyhzeW5jVHJlZSwgcXVlcnlQYXRoLCBvcCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBXZSd2ZSBhbHJlYWR5IHJlbW92ZWQgdGhlIHF1ZXJ5LiBObyBiaWcgZGVhbCwgaWdub3JlIHRoZSB1cGRhdGVcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZSBldmVudCBjYWxsYmFjayhzKS5cclxuICpcclxuICogSWYgcXVlcnkgaXMgdGhlIGRlZmF1bHQgcXVlcnksIHdlJ2xsIGNoZWNrIGFsbCBxdWVyaWVzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50UmVnaXN0cmF0aW9uLlxyXG4gKiBJZiBldmVudFJlZ2lzdHJhdGlvbiBpcyBudWxsLCB3ZSdsbCByZW1vdmUgYWxsIGNhbGxiYWNrcyBmb3IgdGhlIHNwZWNpZmllZCBxdWVyeS9xdWVyaWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0gZXZlbnRSZWdpc3RyYXRpb24gLSBJZiBudWxsLCBhbGwgY2FsbGJhY2tzIGFyZSByZW1vdmVkLlxyXG4gKiBAcGFyYW0gY2FuY2VsRXJyb3IgLSBJZiBhIGNhbmNlbEVycm9yIGlzIHByb3ZpZGVkLCBhcHByb3ByaWF0ZSBjYW5jZWwgZXZlbnRzIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAqIEBwYXJhbSBza2lwTGlzdGVuZXJEZWR1cCAtIFdoZW4gcGVyZm9ybWluZyBhIGBnZXQoKWAsIHdlIGRvbid0IGFkZCBhbnkgbmV3IGxpc3RlbmVycywgc28gbm9cclxuICogIGRlZHVwaW5nIG5lZWRzIHRvIHRha2UgcGxhY2UuIFRoaXMgZmxhZyBhbGxvd3MgdG9nZ2xpbmcgb2YgdGhhdCBiZWhhdmlvclxyXG4gKiBAcmV0dXJucyBDYW5jZWwgZXZlbnRzLCBpZiBjYW5jZWxFcnJvciB3YXMgcHJvdmlkZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZVJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHN5bmNUcmVlLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24sIGNhbmNlbEVycm9yLCBza2lwTGlzdGVuZXJEZWR1cCA9IGZhbHNlKSB7XHJcbiAgICAvLyBGaW5kIHRoZSBzeW5jUG9pbnQgZmlyc3QuIFRoZW4gZGVhbCB3aXRoIHdoZXRoZXIgb3Igbm90IGl0IGhhcyBtYXRjaGluZyBsaXN0ZW5lcnNcclxuICAgIGNvbnN0IHBhdGggPSBxdWVyeS5fcGF0aDtcclxuICAgIGNvbnN0IG1heWJlU3luY1BvaW50ID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uZ2V0KHBhdGgpO1xyXG4gICAgbGV0IGNhbmNlbEV2ZW50cyA9IFtdO1xyXG4gICAgLy8gQSByZW1vdmFsIG9uIGEgZGVmYXVsdCBxdWVyeSBhZmZlY3RzIGFsbCBxdWVyaWVzIGF0IHRoYXQgbG9jYXRpb24uIEEgcmVtb3ZhbCBvbiBhbiBpbmRleGVkIHF1ZXJ5LCBldmVuIG9uZSB3aXRob3V0XHJcbiAgICAvLyBvdGhlciBxdWVyeSBjb25zdHJhaW50cywgZG9lcyAqbm90KiBhZmZlY3QgYWxsIHF1ZXJpZXMgYXQgdGhhdCBsb2NhdGlvbi4gU28gdGhpcyBjaGVjayBtdXN0IGJlIGZvciAnZGVmYXVsdCcsIGFuZFxyXG4gICAgLy8gbm90IGxvYWRzQWxsRGF0YSgpLlxyXG4gICAgaWYgKG1heWJlU3luY1BvaW50ICYmXHJcbiAgICAgICAgKHF1ZXJ5Ll9xdWVyeUlkZW50aWZpZXIgPT09ICdkZWZhdWx0JyB8fFxyXG4gICAgICAgICAgICBzeW5jUG9pbnRWaWV3RXhpc3RzRm9yUXVlcnkobWF5YmVTeW5jUG9pbnQsIHF1ZXJ5KSkpIHtcclxuICAgICAgICBjb25zdCByZW1vdmVkQW5kRXZlbnRzID0gc3luY1BvaW50UmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24obWF5YmVTeW5jUG9pbnQsIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpO1xyXG4gICAgICAgIGlmIChzeW5jUG9pbnRJc0VtcHR5KG1heWJlU3luY1BvaW50KSkge1xyXG4gICAgICAgICAgICBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXyA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnJlbW92ZShwYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVtb3ZlZCA9IHJlbW92ZWRBbmRFdmVudHMucmVtb3ZlZDtcclxuICAgICAgICBjYW5jZWxFdmVudHMgPSByZW1vdmVkQW5kRXZlbnRzLmV2ZW50cztcclxuICAgICAgICBpZiAoIXNraXBMaXN0ZW5lckRlZHVwKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXZSBtYXkgaGF2ZSBqdXN0IHJlbW92ZWQgb25lIG9mIG1hbnkgbGlzdGVuZXJzIGFuZCBjYW4gc2hvcnQtY2lyY3VpdCB0aGlzIHdob2xlIHByb2Nlc3NcclxuICAgICAgICAgICAgICogV2UgbWF5IGFsc28gbm90IGhhdmUgcmVtb3ZlZCBhIGRlZmF1bHQgbGlzdGVuZXIsIGluIHdoaWNoIGNhc2UgYWxsIG9mIHRoZSBkZXNjZW5kYW50IGxpc3RlbmVycyBzaG91bGQgYWxyZWFkeSBiZVxyXG4gICAgICAgICAgICAgKiBwcm9wZXJseSBzZXQgdXAuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAvLyBTaW5jZSBpbmRleGVkIHF1ZXJpZXMgY2FuIHNoYWRvdyBpZiB0aGV5IGRvbid0IGhhdmUgb3RoZXIgcXVlcnkgY29uc3RyYWludHMsIGNoZWNrIGZvciBsb2Fkc0FsbERhdGEoKSwgaW5zdGVhZCBvZlxyXG4gICAgICAgICAgICAvLyBxdWVyeUlkID09PSAnZGVmYXVsdCdcclxuICAgICAgICAgICAgY29uc3QgcmVtb3ZpbmdEZWZhdWx0ID0gLTEgIT09XHJcbiAgICAgICAgICAgICAgICByZW1vdmVkLmZpbmRJbmRleChxdWVyeSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBjb3ZlcmVkID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uZmluZE9uUGF0aChwYXRoLCAocmVsYXRpdmVQYXRoLCBwYXJlbnRTeW5jUG9pbnQpID0+IHN5bmNQb2ludEhhc0NvbXBsZXRlVmlldyhwYXJlbnRTeW5jUG9pbnQpKTtcclxuICAgICAgICAgICAgaWYgKHJlbW92aW5nRGVmYXVsdCAmJiAhY292ZXJlZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3VidHJlZSA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnN1YnRyZWUocGF0aCk7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBhcmUgcG90ZW50aWFsbHkgY2hpbGQgbGlzdGVuZXJzLiBEZXRlcm1pbmUgd2hhdCBpZiBhbnkgbGlzdGVucyB3ZSBuZWVkIHRvIHNlbmQgYmVmb3JlIGV4ZWN1dGluZyB0aGVcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92YWxcclxuICAgICAgICAgICAgICAgIGlmICghc3VidHJlZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGZvbGQgb3ZlciBvdXIgc3VidHJlZSBhbmQgY29sbGVjdCB0aGUgbGlzdGVuZXJzIHRvIHNlbmRcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdWaWV3cyA9IHN5bmNUcmVlQ29sbGVjdERpc3RpbmN0Vmlld3NGb3JTdWJUcmVlXyhzdWJ0cmVlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBPaywgd2UndmUgY29sbGVjdGVkIGFsbCB0aGUgbGlzdGVucyB3ZSBuZWVkLiBTZXQgdGhlbSB1cC5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld1ZpZXdzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXdWaWV3c1tpXSwgbmV3UXVlcnkgPSB2aWV3LnF1ZXJ5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IHN5bmNUcmVlQ3JlYXRlTGlzdGVuZXJGb3JWaWV3XyhzeW5jVHJlZSwgdmlldyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNUcmVlLmxpc3RlblByb3ZpZGVyXy5zdGFydExpc3RlbmluZyhzeW5jVHJlZVF1ZXJ5Rm9yTGlzdGVuaW5nXyhuZXdRdWVyeSksIHN5bmNUcmVlVGFnRm9yUXVlcnkoc3luY1RyZWUsIG5ld1F1ZXJ5KSwgbGlzdGVuZXIuaGFzaEZuLCBsaXN0ZW5lci5vbkNvbXBsZXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgdGhlcmUncyBub3RoaW5nIGJlbG93IHVzLCBzbyBub3RoaW5nIHdlIG5lZWQgdG8gc3RhcnQgbGlzdGVuaW5nIG9uXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSWYgd2UgcmVtb3ZlZCBhbnl0aGluZyBhbmQgd2UncmUgbm90IGNvdmVyZWQgYnkgYSBoaWdoZXIgdXAgbGlzdGVuLCB3ZSBuZWVkIHRvIHN0b3AgbGlzdGVuaW5nIG9uIHRoaXMgcXVlcnlcclxuICAgICAgICAgICAgLy8gVGhlIGFib3ZlIGJsb2NrIGhhcyB1cyBjb3ZlcmVkIGluIHRlcm1zIG9mIG1ha2luZyBzdXJlIHdlJ3JlIHNldCB1cCBvbiBsaXN0ZW5zIGxvd2VyIGluIHRoZSB0cmVlLlxyXG4gICAgICAgICAgICAvLyBBbHNvLCBub3RlIHRoYXQgaWYgd2UgaGF2ZSBhIGNhbmNlbEVycm9yLCBpdCdzIGFscmVhZHkgYmVlbiByZW1vdmVkIGF0IHRoZSBwcm92aWRlciBsZXZlbC5cclxuICAgICAgICAgICAgaWYgKCFjb3ZlcmVkICYmIHJlbW92ZWQubGVuZ3RoID4gMCAmJiAhY2FuY2VsRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlbW92ZWQgYSBkZWZhdWx0LCB0aGVuIHdlIHdlcmVuJ3QgbGlzdGVuaW5nIG9uIGFueSBvZiB0aGUgb3RoZXIgcXVlcmllcyBoZXJlLiBKdXN0IGNhbmNlbCB0aGUgb25lXHJcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0LiBPdGhlcndpc2UsIHdlIG5lZWQgdG8gaXRlcmF0ZSB0aHJvdWdoIGFuZCBjYW5jZWwgZWFjaCBpbmRpdmlkdWFsIHF1ZXJ5XHJcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZpbmdEZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdGFnIGRlZmF1bHQgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdFRhZyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgc3luY1RyZWUubGlzdGVuUHJvdmlkZXJfLnN0b3BMaXN0ZW5pbmcoc3luY1RyZWVRdWVyeUZvckxpc3RlbmluZ18ocXVlcnkpLCBkZWZhdWx0VGFnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQuZm9yRWFjaCgocXVlcnlUb1JlbW92ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWdUb1JlbW92ZSA9IHN5bmNUcmVlLnF1ZXJ5VG9UYWdNYXAuZ2V0KHN5bmNUcmVlTWFrZVF1ZXJ5S2V5XyhxdWVyeVRvUmVtb3ZlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNUcmVlLmxpc3RlblByb3ZpZGVyXy5zdG9wTGlzdGVuaW5nKHN5bmNUcmVlUXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5VG9SZW1vdmUpLCB0YWdUb1JlbW92ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTm93LCBjbGVhciBhbGwgb2YgdGhlIHRhZ3Mgd2UncmUgdHJhY2tpbmcgZm9yIHRoZSByZW1vdmVkIGxpc3RlbnNcclxuICAgICAgICBzeW5jVHJlZVJlbW92ZVRhZ3NfKHN5bmNUcmVlLCByZW1vdmVkKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjYW5jZWxFdmVudHM7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGx5IG5ldyBzZXJ2ZXIgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCB0YWdnZWQgcXVlcnkuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlUYWdnZWRRdWVyeU92ZXJ3cml0ZShzeW5jVHJlZSwgcGF0aCwgc25hcCwgdGFnKSB7XHJcbiAgICBjb25zdCBxdWVyeUtleSA9IHN5bmNUcmVlUXVlcnlLZXlGb3JUYWdfKHN5bmNUcmVlLCB0YWcpO1xyXG4gICAgaWYgKHF1ZXJ5S2V5ICE9IG51bGwpIHtcclxuICAgICAgICBjb25zdCByID0gc3luY1RyZWVQYXJzZVF1ZXJ5S2V5XyhxdWVyeUtleSk7XHJcbiAgICAgICAgY29uc3QgcXVlcnlQYXRoID0gci5wYXRoLCBxdWVyeUlkID0gci5xdWVyeUlkO1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChxdWVyeVBhdGgsIHBhdGgpO1xyXG4gICAgICAgIGNvbnN0IG9wID0gbmV3IE92ZXJ3cml0ZShuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXJUYWdnZWRRdWVyeShxdWVyeUlkKSwgcmVsYXRpdmVQYXRoLCBzbmFwKTtcclxuICAgICAgICByZXR1cm4gc3luY1RyZWVBcHBseVRhZ2dlZE9wZXJhdGlvbl8oc3luY1RyZWUsIHF1ZXJ5UGF0aCwgb3ApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gUXVlcnkgbXVzdCBoYXZlIGJlZW4gcmVtb3ZlZCBhbHJlYWR5XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBcHBseSBzZXJ2ZXIgZGF0YSB0byBiZSBtZXJnZWQgaW4gZm9yIHRoZSBzcGVjaWZpZWQgdGFnZ2VkIHF1ZXJ5LlxyXG4gKlxyXG4gKiBAcmV0dXJucyBFdmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5VGFnZ2VkUXVlcnlNZXJnZShzeW5jVHJlZSwgcGF0aCwgY2hhbmdlZENoaWxkcmVuLCB0YWcpIHtcclxuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gc3luY1RyZWVRdWVyeUtleUZvclRhZ18oc3luY1RyZWUsIHRhZyk7XHJcbiAgICBpZiAocXVlcnlLZXkpIHtcclxuICAgICAgICBjb25zdCByID0gc3luY1RyZWVQYXJzZVF1ZXJ5S2V5XyhxdWVyeUtleSk7XHJcbiAgICAgICAgY29uc3QgcXVlcnlQYXRoID0gci5wYXRoLCBxdWVyeUlkID0gci5xdWVyeUlkO1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChxdWVyeVBhdGgsIHBhdGgpO1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZVRyZWUgPSBJbW11dGFibGVUcmVlLmZyb21PYmplY3QoY2hhbmdlZENoaWxkcmVuKTtcclxuICAgICAgICBjb25zdCBvcCA9IG5ldyBNZXJnZShuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXJUYWdnZWRRdWVyeShxdWVyeUlkKSwgcmVsYXRpdmVQYXRoLCBjaGFuZ2VUcmVlKTtcclxuICAgICAgICByZXR1cm4gc3luY1RyZWVBcHBseVRhZ2dlZE9wZXJhdGlvbl8oc3luY1RyZWUsIHF1ZXJ5UGF0aCwgb3ApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gV2UndmUgYWxyZWFkeSByZW1vdmVkIHRoZSBxdWVyeS4gTm8gYmlnIGRlYWwsIGlnbm9yZSB0aGUgdXBkYXRlXHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBZGQgYW4gZXZlbnQgY2FsbGJhY2sgZm9yIHRoZSBzcGVjaWZpZWQgcXVlcnkuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQWRkRXZlbnRSZWdpc3RyYXRpb24oc3luY1RyZWUsIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgc2tpcFNldHVwTGlzdGVuZXIgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgcGF0aCA9IHF1ZXJ5Ll9wYXRoO1xyXG4gICAgbGV0IHNlcnZlckNhY2hlID0gbnVsbDtcclxuICAgIGxldCBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgPSBmYWxzZTtcclxuICAgIC8vIEFueSBjb3ZlcmluZyB3cml0ZXMgd2lsbCBuZWNlc3NhcmlseSBiZSBhdCB0aGUgcm9vdCwgc28gcmVhbGx5IGFsbCB3ZSBuZWVkIHRvIGZpbmQgaXMgdGhlIHNlcnZlciBjYWNoZS5cclxuICAgIC8vIENvbnNpZGVyIG9wdGltaXppbmcgdGhpcyBvbmNlIHRoZXJlJ3MgYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZiB3aGF0IGFjdHVhbCBiZWhhdmlvciB3aWxsIGJlLlxyXG4gICAgc3luY1RyZWUuc3luY1BvaW50VHJlZV8uZm9yZWFjaE9uUGF0aChwYXRoLCAocGF0aFRvU3luY1BvaW50LCBzcCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChwYXRoVG9TeW5jUG9pbnQsIHBhdGgpO1xyXG4gICAgICAgIHNlcnZlckNhY2hlID1cclxuICAgICAgICAgICAgc2VydmVyQ2FjaGUgfHwgc3luY1BvaW50R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZShzcCwgcmVsYXRpdmVQYXRoKTtcclxuICAgICAgICBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgPVxyXG4gICAgICAgICAgICBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgfHwgc3luY1BvaW50SGFzQ29tcGxldGVWaWV3KHNwKTtcclxuICAgIH0pO1xyXG4gICAgbGV0IHN5bmNQb2ludCA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLmdldChwYXRoKTtcclxuICAgIGlmICghc3luY1BvaW50KSB7XHJcbiAgICAgICAgc3luY1BvaW50ID0gbmV3IFN5bmNQb2ludCgpO1xyXG4gICAgICAgIHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uc2V0KHBhdGgsIHN5bmNQb2ludCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgPVxyXG4gICAgICAgICAgICBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgfHwgc3luY1BvaW50SGFzQ29tcGxldGVWaWV3KHN5bmNQb2ludCk7XHJcbiAgICAgICAgc2VydmVyQ2FjaGUgPVxyXG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZSB8fCBzeW5jUG9pbnRHZXRDb21wbGV0ZVNlcnZlckNhY2hlKHN5bmNQb2ludCwgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgfVxyXG4gICAgbGV0IHNlcnZlckNhY2hlQ29tcGxldGU7XHJcbiAgICBpZiAoc2VydmVyQ2FjaGUgIT0gbnVsbCkge1xyXG4gICAgICAgIHNlcnZlckNhY2hlQ29tcGxldGUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc2VydmVyQ2FjaGVDb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgICAgIHNlcnZlckNhY2hlID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgY29uc3Qgc3VidHJlZSA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnN1YnRyZWUocGF0aCk7XHJcbiAgICAgICAgc3VidHJlZS5mb3JlYWNoQ2hpbGQoKGNoaWxkTmFtZSwgY2hpbGRTeW5jUG9pbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29tcGxldGVDYWNoZSA9IHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoY2hpbGRTeW5jUG9pbnQsIG5ld0VtcHR5UGF0aCgpKTtcclxuICAgICAgICAgICAgaWYgKGNvbXBsZXRlQ2FjaGUpIHtcclxuICAgICAgICAgICAgICAgIHNlcnZlckNhY2hlID0gc2VydmVyQ2FjaGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lLCBjb21wbGV0ZUNhY2hlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgdmlld0FscmVhZHlFeGlzdHMgPSBzeW5jUG9pbnRWaWV3RXhpc3RzRm9yUXVlcnkoc3luY1BvaW50LCBxdWVyeSk7XHJcbiAgICBpZiAoIXZpZXdBbHJlYWR5RXhpc3RzICYmICFxdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICAvLyBXZSBuZWVkIHRvIHRyYWNrIGEgdGFnIGZvciB0aGlzIHF1ZXJ5XHJcbiAgICAgICAgY29uc3QgcXVlcnlLZXkgPSBzeW5jVHJlZU1ha2VRdWVyeUtleV8ocXVlcnkpO1xyXG4gICAgICAgIGFzc2VydCghc3luY1RyZWUucXVlcnlUb1RhZ01hcC5oYXMocXVlcnlLZXkpLCAnVmlldyBkb2VzIG5vdCBleGlzdCwgYnV0IHdlIGhhdmUgYSB0YWcnKTtcclxuICAgICAgICBjb25zdCB0YWcgPSBzeW5jVHJlZUdldE5leHRRdWVyeVRhZ18oKTtcclxuICAgICAgICBzeW5jVHJlZS5xdWVyeVRvVGFnTWFwLnNldChxdWVyeUtleSwgdGFnKTtcclxuICAgICAgICBzeW5jVHJlZS50YWdUb1F1ZXJ5TWFwLnNldCh0YWcsIHF1ZXJ5S2V5KTtcclxuICAgIH1cclxuICAgIGNvbnN0IHdyaXRlc0NhY2hlID0gd3JpdGVUcmVlQ2hpbGRXcml0ZXMoc3luY1RyZWUucGVuZGluZ1dyaXRlVHJlZV8sIHBhdGgpO1xyXG4gICAgbGV0IGV2ZW50cyA9IHN5bmNQb2ludEFkZEV2ZW50UmVnaXN0cmF0aW9uKHN5bmNQb2ludCwgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIHNlcnZlckNhY2hlQ29tcGxldGUpO1xyXG4gICAgaWYgKCF2aWV3QWxyZWFkeUV4aXN0cyAmJiAhZm91bmRBbmNlc3RvckRlZmF1bHRWaWV3ICYmICFza2lwU2V0dXBMaXN0ZW5lcikge1xyXG4gICAgICAgIGNvbnN0IHZpZXcgPSBzeW5jUG9pbnRWaWV3Rm9yUXVlcnkoc3luY1BvaW50LCBxdWVyeSk7XHJcbiAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZVNldHVwTGlzdGVuZXJfKHN5bmNUcmVlLCBxdWVyeSwgdmlldykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV2ZW50cztcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIGNvbXBsZXRlIGNhY2hlLCBpZiB3ZSBoYXZlIG9uZSwgb2YgdGhlIGRhdGEgYXQgYSBwYXJ0aWN1bGFyIHBhdGguIElmIHRoZSBsb2NhdGlvbiBkb2VzIG5vdCBoYXZlIGFcclxuICogbGlzdGVuZXIgYWJvdmUgaXQsIHdlIHdpbGwgZ2V0IGEgZmFsc2UgXCJudWxsXCIuIFRoaXMgc2hvdWxkbid0IGJlIGEgcHJvYmxlbSBiZWNhdXNlIHRyYW5zYWN0aW9ucyB3aWxsIGFsd2F5c1xyXG4gKiBoYXZlIGEgbGlzdGVuZXIgYWJvdmUsIGFuZCBhdG9taWMgb3BlcmF0aW9ucyB3b3VsZCBjb3JyZWN0bHkgc2hvdyBhIGppdHRlciBvZiA8aW5jcmVtZW50IHZhbHVlPiAtPlxyXG4gKiAgICAgPGluY3JlbWVudGVkIHRvdGFsPiBhcyB0aGUgd3JpdGUgaXMgYXBwbGllZCBsb2NhbGx5IGFuZCB0aGVuIGFja25vd2xlZGdlZCBhdCB0aGUgc2VydmVyLlxyXG4gKlxyXG4gKiBOb3RlOiB0aGlzIG1ldGhvZCB3aWxsICppbmNsdWRlKiBoaWRkZW4gd3JpdGVzIGZyb20gdHJhbnNhY3Rpb24gd2l0aCBhcHBseUxvY2FsbHkgc2V0IHRvIGZhbHNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIHRoZSBkYXRhIHdlIHdhbnRcclxuICogQHBhcmFtIHdyaXRlSWRzVG9FeGNsdWRlIC0gQSBzcGVjaWZpYyBzZXQgdG8gYmUgZXhjbHVkZWRcclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZShzeW5jVHJlZSwgcGF0aCwgd3JpdGVJZHNUb0V4Y2x1ZGUpIHtcclxuICAgIGNvbnN0IGluY2x1ZGVIaWRkZW5TZXRzID0gdHJ1ZTtcclxuICAgIGNvbnN0IHdyaXRlVHJlZSA9IHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfO1xyXG4gICAgY29uc3Qgc2VydmVyQ2FjaGUgPSBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXy5maW5kT25QYXRoKHBhdGgsIChwYXRoU29GYXIsIHN5bmNQb2ludCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChwYXRoU29GYXIsIHBhdGgpO1xyXG4gICAgICAgIGNvbnN0IHNlcnZlckNhY2hlID0gc3luY1BvaW50R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZShzeW5jUG9pbnQsIHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgaWYgKHNlcnZlckNhY2hlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJDYWNoZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB3cml0ZVRyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlKHdyaXRlVHJlZSwgcGF0aCwgc2VydmVyQ2FjaGUsIHdyaXRlSWRzVG9FeGNsdWRlLCBpbmNsdWRlSGlkZGVuU2V0cyk7XHJcbn1cclxuZnVuY3Rpb24gc3luY1RyZWVHZXRTZXJ2ZXJWYWx1ZShzeW5jVHJlZSwgcXVlcnkpIHtcclxuICAgIGNvbnN0IHBhdGggPSBxdWVyeS5fcGF0aDtcclxuICAgIGxldCBzZXJ2ZXJDYWNoZSA9IG51bGw7XHJcbiAgICAvLyBBbnkgY292ZXJpbmcgd3JpdGVzIHdpbGwgbmVjZXNzYXJpbHkgYmUgYXQgdGhlIHJvb3QsIHNvIHJlYWxseSBhbGwgd2UgbmVlZCB0byBmaW5kIGlzIHRoZSBzZXJ2ZXIgY2FjaGUuXHJcbiAgICAvLyBDb25zaWRlciBvcHRpbWl6aW5nIHRoaXMgb25jZSB0aGVyZSdzIGEgYmV0dGVyIHVuZGVyc3RhbmRpbmcgb2Ygd2hhdCBhY3R1YWwgYmVoYXZpb3Igd2lsbCBiZS5cclxuICAgIHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLmZvcmVhY2hPblBhdGgocGF0aCwgKHBhdGhUb1N5bmNQb2ludCwgc3ApID0+IHtcclxuICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgocGF0aFRvU3luY1BvaW50LCBwYXRoKTtcclxuICAgICAgICBzZXJ2ZXJDYWNoZSA9XHJcbiAgICAgICAgICAgIHNlcnZlckNhY2hlIHx8IHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoc3AsIHJlbGF0aXZlUGF0aCk7XHJcbiAgICB9KTtcclxuICAgIGxldCBzeW5jUG9pbnQgPSBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXy5nZXQocGF0aCk7XHJcbiAgICBpZiAoIXN5bmNQb2ludCkge1xyXG4gICAgICAgIHN5bmNQb2ludCA9IG5ldyBTeW5jUG9pbnQoKTtcclxuICAgICAgICBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXyA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnNldChwYXRoLCBzeW5jUG9pbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc2VydmVyQ2FjaGUgPVxyXG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZSB8fCBzeW5jUG9pbnRHZXRDb21wbGV0ZVNlcnZlckNhY2hlKHN5bmNQb2ludCwgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2VydmVyQ2FjaGVDb21wbGV0ZSA9IHNlcnZlckNhY2hlICE9IG51bGw7XHJcbiAgICBjb25zdCBzZXJ2ZXJDYWNoZU5vZGUgPSBzZXJ2ZXJDYWNoZUNvbXBsZXRlXHJcbiAgICAgICAgPyBuZXcgQ2FjaGVOb2RlKHNlcnZlckNhY2hlLCB0cnVlLCBmYWxzZSlcclxuICAgICAgICA6IG51bGw7XHJcbiAgICBjb25zdCB3cml0ZXNDYWNoZSA9IHdyaXRlVHJlZUNoaWxkV3JpdGVzKHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfLCBxdWVyeS5fcGF0aCk7XHJcbiAgICBjb25zdCB2aWV3ID0gc3luY1BvaW50R2V0VmlldyhzeW5jUG9pbnQsIHF1ZXJ5LCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGVDb21wbGV0ZSA/IHNlcnZlckNhY2hlTm9kZS5nZXROb2RlKCkgOiBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgc2VydmVyQ2FjaGVDb21wbGV0ZSk7XHJcbiAgICByZXR1cm4gdmlld0dldENvbXBsZXRlTm9kZSh2aWV3KTtcclxufVxyXG4vKipcclxuICogQSBoZWxwZXIgbWV0aG9kIHRoYXQgdmlzaXRzIGFsbCBkZXNjZW5kYW50IGFuZCBhbmNlc3RvciBTeW5jUG9pbnRzLCBhcHBseWluZyB0aGUgb3BlcmF0aW9uLlxyXG4gKlxyXG4gKiBOT1RFUzpcclxuICogLSBEZXNjZW5kYW50IFN5bmNQb2ludHMgd2lsbCBiZSB2aXNpdGVkIGZpcnN0IChzaW5jZSB3ZSByYWlzZSBldmVudHMgZGVwdGgtZmlyc3QpLlxyXG4gKlxyXG4gKiAtIFdlIGNhbGwgYXBwbHlPcGVyYXRpb24oKSBvbiBlYWNoIFN5bmNQb2ludCBwYXNzaW5nIHRocmVlIHRoaW5nczpcclxuICogICAxLiBBIHZlcnNpb24gb2YgdGhlIE9wZXJhdGlvbiB0aGF0IGhhcyBiZWVuIG1hZGUgcmVsYXRpdmUgdG8gdGhlIFN5bmNQb2ludCBsb2NhdGlvbi5cclxuICogICAyLiBBIFdyaXRlVHJlZVJlZiBvZiBhbnkgd3JpdGVzIHdlIGhhdmUgY2FjaGVkIGF0IHRoZSBTeW5jUG9pbnQgbG9jYXRpb24uXHJcbiAqICAgMy4gQSBzbmFwc2hvdCBOb2RlIHdpdGggY2FjaGVkIHNlcnZlciBkYXRhLCBpZiB3ZSBoYXZlIGl0LlxyXG4gKlxyXG4gKiAtIFdlIGNvbmNhdGVuYXRlIGFsbCBvZiB0aGUgZXZlbnRzIHJldHVybmVkIGJ5IGVhY2ggU3luY1BvaW50IGFuZCByZXR1cm4gdGhlIHJlc3VsdC5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBvcGVyYXRpb24pIHtcclxuICAgIHJldHVybiBzeW5jVHJlZUFwcGx5T3BlcmF0aW9uSGVscGVyXyhvcGVyYXRpb24sIHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLCBcclxuICAgIC8qc2VydmVyQ2FjaGU9Ki8gbnVsbCwgd3JpdGVUcmVlQ2hpbGRXcml0ZXMoc3luY1RyZWUucGVuZGluZ1dyaXRlVHJlZV8sIG5ld0VtcHR5UGF0aCgpKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZSBoZWxwZXIgZm9yIGFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzX1xyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseU9wZXJhdGlvbkhlbHBlcl8ob3BlcmF0aW9uLCBzeW5jUG9pbnRUcmVlLCBzZXJ2ZXJDYWNoZSwgd3JpdGVzQ2FjaGUpIHtcclxuICAgIGlmIChwYXRoSXNFbXB0eShvcGVyYXRpb24ucGF0aCkpIHtcclxuICAgICAgICByZXR1cm4gc3luY1RyZWVBcHBseU9wZXJhdGlvbkRlc2NlbmRhbnRzSGVscGVyXyhvcGVyYXRpb24sIHN5bmNQb2ludFRyZWUsIHNlcnZlckNhY2hlLCB3cml0ZXNDYWNoZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBzeW5jUG9pbnQgPSBzeW5jUG9pbnRUcmVlLmdldChuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBjYWNoZWQgc2VydmVyIGRhdGEsIHNlZSBpZiB3ZSBjYW4gZ2V0IGl0IGZyb20gdGhpcyBTeW5jUG9pbnQuXHJcbiAgICAgICAgaWYgKHNlcnZlckNhY2hlID09IG51bGwgJiYgc3luY1BvaW50ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc2VydmVyQ2FjaGUgPSBzeW5jUG9pbnRHZXRDb21wbGV0ZVNlcnZlckNhY2hlKHN5bmNQb2ludCwgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICAgICAgY29uc3QgY2hpbGROYW1lID0gcGF0aEdldEZyb250KG9wZXJhdGlvbi5wYXRoKTtcclxuICAgICAgICBjb25zdCBjaGlsZE9wZXJhdGlvbiA9IG9wZXJhdGlvbi5vcGVyYXRpb25Gb3JDaGlsZChjaGlsZE5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkVHJlZSA9IHN5bmNQb2ludFRyZWUuY2hpbGRyZW4uZ2V0KGNoaWxkTmFtZSk7XHJcbiAgICAgICAgaWYgKGNoaWxkVHJlZSAmJiBjaGlsZE9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFNlcnZlckNhY2hlID0gc2VydmVyQ2FjaGVcclxuICAgICAgICAgICAgICAgID8gc2VydmVyQ2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKVxyXG4gICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFdyaXRlc0NhY2hlID0gd3JpdGVUcmVlUmVmQ2hpbGQod3JpdGVzQ2FjaGUsIGNoaWxkTmFtZSk7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBcHBseU9wZXJhdGlvbkhlbHBlcl8oY2hpbGRPcGVyYXRpb24sIGNoaWxkVHJlZSwgY2hpbGRTZXJ2ZXJDYWNoZSwgY2hpbGRXcml0ZXNDYWNoZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3luY1BvaW50KSB7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1BvaW50QXBwbHlPcGVyYXRpb24oc3luY1BvaW50LCBvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlbnRzO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZWN1cnNpdmUgaGVscGVyIGZvciBhcHBseU9wZXJhdGlvblRvU3luY1BvaW50c19cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25EZXNjZW5kYW50c0hlbHBlcl8ob3BlcmF0aW9uLCBzeW5jUG9pbnRUcmVlLCBzZXJ2ZXJDYWNoZSwgd3JpdGVzQ2FjaGUpIHtcclxuICAgIGNvbnN0IHN5bmNQb2ludCA9IHN5bmNQb2ludFRyZWUuZ2V0KG5ld0VtcHR5UGF0aCgpKTtcclxuICAgIC8vIElmIHdlIGRvbid0IGhhdmUgY2FjaGVkIHNlcnZlciBkYXRhLCBzZWUgaWYgd2UgY2FuIGdldCBpdCBmcm9tIHRoaXMgU3luY1BvaW50LlxyXG4gICAgaWYgKHNlcnZlckNhY2hlID09IG51bGwgJiYgc3luY1BvaW50ICE9IG51bGwpIHtcclxuICAgICAgICBzZXJ2ZXJDYWNoZSA9IHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoc3luY1BvaW50LCBuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICB9XHJcbiAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICBzeW5jUG9pbnRUcmVlLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkTmFtZSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRTZXJ2ZXJDYWNoZSA9IHNlcnZlckNhY2hlXHJcbiAgICAgICAgICAgID8gc2VydmVyQ2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKVxyXG4gICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgY29uc3QgY2hpbGRXcml0ZXNDYWNoZSA9IHdyaXRlVHJlZVJlZkNoaWxkKHdyaXRlc0NhY2hlLCBjaGlsZE5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkT3BlcmF0aW9uID0gb3BlcmF0aW9uLm9wZXJhdGlvbkZvckNoaWxkKGNoaWxkTmFtZSk7XHJcbiAgICAgICAgaWYgKGNoaWxkT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBcHBseU9wZXJhdGlvbkRlc2NlbmRhbnRzSGVscGVyXyhjaGlsZE9wZXJhdGlvbiwgY2hpbGRUcmVlLCBjaGlsZFNlcnZlckNhY2hlLCBjaGlsZFdyaXRlc0NhY2hlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAoc3luY1BvaW50KSB7XHJcbiAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jUG9pbnRBcHBseU9wZXJhdGlvbihzeW5jUG9pbnQsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXZlbnRzO1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNUcmVlQ3JlYXRlTGlzdGVuZXJGb3JWaWV3XyhzeW5jVHJlZSwgdmlldykge1xyXG4gICAgY29uc3QgcXVlcnkgPSB2aWV3LnF1ZXJ5O1xyXG4gICAgY29uc3QgdGFnID0gc3luY1RyZWVUYWdGb3JRdWVyeShzeW5jVHJlZSwgcXVlcnkpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBoYXNoRm46ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2FjaGUgPSB2aWV3R2V0U2VydmVyQ2FjaGUodmlldykgfHwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZS5oYXNoKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkNvbXBsZXRlOiAoc3RhdHVzKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0YWcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3luY1RyZWVBcHBseVRhZ2dlZExpc3RlbkNvbXBsZXRlKHN5bmNUcmVlLCBxdWVyeS5fcGF0aCwgdGFnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW5jVHJlZUFwcGx5TGlzdGVuQ29tcGxldGUoc3luY1RyZWUsIHF1ZXJ5Ll9wYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIGEgbGlzdGVuIGZhaWxlZCwga2lsbCBhbGwgb2YgdGhlIGxpc3RlbmVycyBoZXJlLCBub3QganVzdCB0aGUgb25lIHRoYXQgdHJpZ2dlcmVkIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBuZWVkIHRvIGJlIHNjb3BlZCB0byBqdXN0IHRoaXMgbGlzdGVuZXIgaWYgd2UgY2hhbmdlIHBlcm1pc3Npb25zIG9uIGZpbHRlcmVkIGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGVycm9yRm9yU2VydmVyQ29kZShzdGF0dXMsIHF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzeW5jVHJlZVJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHN5bmNUcmVlLCBxdWVyeSwgXHJcbiAgICAgICAgICAgICAgICAvKmV2ZW50UmVnaXN0cmF0aW9uKi8gbnVsbCwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogUmV0dXJuIHRoZSB0YWcgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBxdWVyeS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlVGFnRm9yUXVlcnkoc3luY1RyZWUsIHF1ZXJ5KSB7XHJcbiAgICBjb25zdCBxdWVyeUtleSA9IHN5bmNUcmVlTWFrZVF1ZXJ5S2V5XyhxdWVyeSk7XHJcbiAgICByZXR1cm4gc3luY1RyZWUucXVlcnlUb1RhZ01hcC5nZXQocXVlcnlLZXkpO1xyXG59XHJcbi8qKlxyXG4gKiBHaXZlbiBhIHF1ZXJ5LCBjb21wdXRlcyBhIFwicXVlcnlLZXlcIiBzdWl0YWJsZSBmb3IgdXNlIGluIG91ciBxdWVyeVRvVGFnTWFwXy5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlTWFrZVF1ZXJ5S2V5XyhxdWVyeSkge1xyXG4gICAgcmV0dXJuIHF1ZXJ5Ll9wYXRoLnRvU3RyaW5nKCkgKyAnJCcgKyBxdWVyeS5fcXVlcnlJZGVudGlmaWVyO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm4gdGhlIHF1ZXJ5IGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gdGFnLCBpZiB3ZSBoYXZlIG9uZVxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVRdWVyeUtleUZvclRhZ18oc3luY1RyZWUsIHRhZykge1xyXG4gICAgcmV0dXJuIHN5bmNUcmVlLnRhZ1RvUXVlcnlNYXAuZ2V0KHRhZyk7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGEgcXVlcnlLZXkgKGNyZWF0ZWQgYnkgbWFrZVF1ZXJ5S2V5KSwgcGFyc2UgaXQgYmFjayBpbnRvIGEgcGF0aCBhbmQgcXVlcnlJZC5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlUGFyc2VRdWVyeUtleV8ocXVlcnlLZXkpIHtcclxuICAgIGNvbnN0IHNwbGl0SW5kZXggPSBxdWVyeUtleS5pbmRleE9mKCckJyk7XHJcbiAgICBhc3NlcnQoc3BsaXRJbmRleCAhPT0gLTEgJiYgc3BsaXRJbmRleCA8IHF1ZXJ5S2V5Lmxlbmd0aCAtIDEsICdCYWQgcXVlcnlLZXkuJyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHF1ZXJ5SWQ6IHF1ZXJ5S2V5LnN1YnN0cihzcGxpdEluZGV4ICsgMSksXHJcbiAgICAgICAgcGF0aDogbmV3IFBhdGgocXVlcnlLZXkuc3Vic3RyKDAsIHNwbGl0SW5kZXgpKVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQSBoZWxwZXIgbWV0aG9kIHRvIGFwcGx5IHRhZ2dlZCBvcGVyYXRpb25zXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5VGFnZ2VkT3BlcmF0aW9uXyhzeW5jVHJlZSwgcXVlcnlQYXRoLCBvcGVyYXRpb24pIHtcclxuICAgIGNvbnN0IHN5bmNQb2ludCA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLmdldChxdWVyeVBhdGgpO1xyXG4gICAgYXNzZXJ0KHN5bmNQb2ludCwgXCJNaXNzaW5nIHN5bmMgcG9pbnQgZm9yIHF1ZXJ5IHRhZyB0aGF0IHdlJ3JlIHRyYWNraW5nXCIpO1xyXG4gICAgY29uc3Qgd3JpdGVzQ2FjaGUgPSB3cml0ZVRyZWVDaGlsZFdyaXRlcyhzeW5jVHJlZS5wZW5kaW5nV3JpdGVUcmVlXywgcXVlcnlQYXRoKTtcclxuICAgIHJldHVybiBzeW5jUG9pbnRBcHBseU9wZXJhdGlvbihzeW5jUG9pbnQsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIG51bGwpO1xyXG59XHJcbi8qKlxyXG4gKiBUaGlzIGNvbGxhcHNlcyBtdWx0aXBsZSB1bmZpbHRlcmVkIHZpZXdzIGludG8gYSBzaW5nbGUgdmlldywgc2luY2Ugd2Ugb25seSBuZWVkIGEgc2luZ2xlXHJcbiAqIGxpc3RlbmVyIGZvciB0aGVtLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVDb2xsZWN0RGlzdGluY3RWaWV3c0ZvclN1YlRyZWVfKHN1YnRyZWUpIHtcclxuICAgIHJldHVybiBzdWJ0cmVlLmZvbGQoKHJlbGF0aXZlUGF0aCwgbWF5YmVDaGlsZFN5bmNQb2ludCwgY2hpbGRNYXApID0+IHtcclxuICAgICAgICBpZiAobWF5YmVDaGlsZFN5bmNQb2ludCAmJiBzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcobWF5YmVDaGlsZFN5bmNQb2ludCkpIHtcclxuICAgICAgICAgICAgY29uc3QgY29tcGxldGVWaWV3ID0gc3luY1BvaW50R2V0Q29tcGxldGVWaWV3KG1heWJlQ2hpbGRTeW5jUG9pbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gW2NvbXBsZXRlVmlld107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBObyBjb21wbGV0ZSB2aWV3IGhlcmUsIGZsYXR0ZW4gYW55IGRlZXBlciBsaXN0ZW5zIGludG8gYW4gYXJyYXlcclxuICAgICAgICAgICAgbGV0IHZpZXdzID0gW107XHJcbiAgICAgICAgICAgIGlmIChtYXliZUNoaWxkU3luY1BvaW50KSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3cyA9IHN5bmNQb2ludEdldFF1ZXJ5Vmlld3MobWF5YmVDaGlsZFN5bmNQb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWFjaChjaGlsZE1hcCwgKF9rZXksIGNoaWxkVmlld3MpID0+IHtcclxuICAgICAgICAgICAgICAgIHZpZXdzID0gdmlld3MuY29uY2F0KGNoaWxkVmlld3MpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHZpZXdzO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBOb3JtYWxpemVzIGEgcXVlcnkgdG8gYSBxdWVyeSB3ZSBzZW5kIHRoZSBzZXJ2ZXIgZm9yIGxpc3RlbmluZ1xyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCBxdWVyeVxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVRdWVyeUZvckxpc3RlbmluZ18ocXVlcnkpIHtcclxuICAgIGlmIChxdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkgJiYgIXF1ZXJ5Ll9xdWVyeVBhcmFtcy5pc0RlZmF1bHQoKSkge1xyXG4gICAgICAgIC8vIFdlIHRyZWF0IHF1ZXJpZXMgdGhhdCBsb2FkIGFsbCBkYXRhIGFzIGRlZmF1bHQgcXVlcmllc1xyXG4gICAgICAgIC8vIENhc3QgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgcmVmKCkgdGVjaG5pY2FsbHkgcmV0dXJucyBGaXJlYmFzZSB3aGljaCBpcyBhY3R1YWxseSBmYi5hcGkuRmlyZWJhc2Ugd2hpY2ggaW5oZXJpdHNcclxuICAgICAgICAvLyBmcm9tIFF1ZXJ5XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoc3luY1RyZWVHZXRSZWZlcmVuY2VDb25zdHJ1Y3RvcigpKShxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHN5bmNUcmVlUmVtb3ZlVGFnc18oc3luY1RyZWUsIHF1ZXJpZXMpIHtcclxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcXVlcmllcy5sZW5ndGg7ICsraikge1xyXG4gICAgICAgIGNvbnN0IHJlbW92ZWRRdWVyeSA9IHF1ZXJpZXNbal07XHJcbiAgICAgICAgaWYgKCFyZW1vdmVkUXVlcnkuX3F1ZXJ5UGFyYW1zLmxvYWRzQWxsRGF0YSgpKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBoYXZlIGEgdGFnIGZvciB0aGlzXHJcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRRdWVyeUtleSA9IHN5bmNUcmVlTWFrZVF1ZXJ5S2V5XyhyZW1vdmVkUXVlcnkpO1xyXG4gICAgICAgICAgICBjb25zdCByZW1vdmVkUXVlcnlUYWcgPSBzeW5jVHJlZS5xdWVyeVRvVGFnTWFwLmdldChyZW1vdmVkUXVlcnlLZXkpO1xyXG4gICAgICAgICAgICBzeW5jVHJlZS5xdWVyeVRvVGFnTWFwLmRlbGV0ZShyZW1vdmVkUXVlcnlLZXkpO1xyXG4gICAgICAgICAgICBzeW5jVHJlZS50YWdUb1F1ZXJ5TWFwLmRlbGV0ZShyZW1vdmVkUXVlcnlUYWcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogU3RhdGljIGFjY2Vzc29yIGZvciBxdWVyeSB0YWdzLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVHZXROZXh0UXVlcnlUYWdfKCkge1xyXG4gICAgcmV0dXJuIHN5bmNUcmVlTmV4dFF1ZXJ5VGFnXysrO1xyXG59XHJcbi8qKlxyXG4gKiBGb3IgYSBnaXZlbiBuZXcgbGlzdGVuLCBtYW5hZ2UgdGhlIGRlLWR1cGxpY2F0aW9uIG9mIG91dHN0YW5kaW5nIHN1YnNjcmlwdGlvbnMuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoaXMgbWV0aG9kIGNhbiByZXR1cm4gZXZlbnRzIHRvIHN1cHBvcnQgc3luY2hyb25vdXMgZGF0YSBzb3VyY2VzXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZVNldHVwTGlzdGVuZXJfKHN5bmNUcmVlLCBxdWVyeSwgdmlldykge1xyXG4gICAgY29uc3QgcGF0aCA9IHF1ZXJ5Ll9wYXRoO1xyXG4gICAgY29uc3QgdGFnID0gc3luY1RyZWVUYWdGb3JRdWVyeShzeW5jVHJlZSwgcXVlcnkpO1xyXG4gICAgY29uc3QgbGlzdGVuZXIgPSBzeW5jVHJlZUNyZWF0ZUxpc3RlbmVyRm9yVmlld18oc3luY1RyZWUsIHZpZXcpO1xyXG4gICAgY29uc3QgZXZlbnRzID0gc3luY1RyZWUubGlzdGVuUHJvdmlkZXJfLnN0YXJ0TGlzdGVuaW5nKHN5bmNUcmVlUXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5KSwgdGFnLCBsaXN0ZW5lci5oYXNoRm4sIGxpc3RlbmVyLm9uQ29tcGxldGUpO1xyXG4gICAgY29uc3Qgc3VidHJlZSA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnN1YnRyZWUocGF0aCk7XHJcbiAgICAvLyBUaGUgcm9vdCBvZiB0aGlzIHN1YnRyZWUgaGFzIG91ciBxdWVyeS4gV2UncmUgaGVyZSBiZWNhdXNlIHdlIGRlZmluaXRlbHkgbmVlZCB0byBzZW5kIGEgbGlzdGVuIGZvciB0aGF0LCBidXQgd2VcclxuICAgIC8vIG1heSBuZWVkIHRvIHNoYWRvdyBvdGhlciBsaXN0ZW5zIGFzIHdlbGwuXHJcbiAgICBpZiAodGFnKSB7XHJcbiAgICAgICAgYXNzZXJ0KCFzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcoc3VidHJlZS52YWx1ZSksIFwiSWYgd2UncmUgYWRkaW5nIGEgcXVlcnksIGl0IHNob3VsZG4ndCBiZSBzaGFkb3dlZFwiKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFNoYWRvdyBldmVyeXRoaW5nIGF0IG9yIGJlbG93IHRoaXMgbG9jYXRpb24sIHRoaXMgaXMgYSBkZWZhdWx0IGxpc3RlbmVyLlxyXG4gICAgICAgIGNvbnN0IHF1ZXJpZXNUb1N0b3AgPSBzdWJ0cmVlLmZvbGQoKHJlbGF0aXZlUGF0aCwgbWF5YmVDaGlsZFN5bmNQb2ludCwgY2hpbGRNYXApID0+IHtcclxuICAgICAgICAgICAgaWYgKCFwYXRoSXNFbXB0eShyZWxhdGl2ZVBhdGgpICYmXHJcbiAgICAgICAgICAgICAgICBtYXliZUNoaWxkU3luY1BvaW50ICYmXHJcbiAgICAgICAgICAgICAgICBzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcobWF5YmVDaGlsZFN5bmNQb2ludCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbc3luY1BvaW50R2V0Q29tcGxldGVWaWV3KG1heWJlQ2hpbGRTeW5jUG9pbnQpLnF1ZXJ5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vIGRlZmF1bHQgbGlzdGVuZXIgaGVyZSwgZmxhdHRlbiBhbnkgZGVlcGVyIHF1ZXJpZXMgaW50byBhbiBhcnJheVxyXG4gICAgICAgICAgICAgICAgbGV0IHF1ZXJpZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXliZUNoaWxkU3luY1BvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcmllcyA9IHF1ZXJpZXMuY29uY2F0KHN5bmNQb2ludEdldFF1ZXJ5Vmlld3MobWF5YmVDaGlsZFN5bmNQb2ludCkubWFwKHZpZXcgPT4gdmlldy5xdWVyeSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWFjaChjaGlsZE1hcCwgKF9rZXksIGNoaWxkUXVlcmllcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJpZXMgPSBxdWVyaWVzLmNvbmNhdChjaGlsZFF1ZXJpZXMpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcXVlcmllcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVlcmllc1RvU3RvcC5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCBxdWVyeVRvU3RvcCA9IHF1ZXJpZXNUb1N0b3BbaV07XHJcbiAgICAgICAgICAgIHN5bmNUcmVlLmxpc3RlblByb3ZpZGVyXy5zdG9wTGlzdGVuaW5nKHN5bmNUcmVlUXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5VG9TdG9wKSwgc3luY1RyZWVUYWdGb3JRdWVyeShzeW5jVHJlZSwgcXVlcnlUb1N0b3ApKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXZlbnRzO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEV4aXN0aW5nVmFsdWVQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlXykge1xyXG4gICAgICAgIHRoaXMubm9kZV8gPSBub2RlXztcclxuICAgIH1cclxuICAgIGdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5ub2RlXy5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRXhpc3RpbmdWYWx1ZVByb3ZpZGVyKGNoaWxkKTtcclxuICAgIH1cclxuICAgIG5vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZV87XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRGVmZXJyZWRWYWx1ZVByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHN5bmNUcmVlLCBwYXRoKSB7XHJcbiAgICAgICAgdGhpcy5zeW5jVHJlZV8gPSBzeW5jVHJlZTtcclxuICAgICAgICB0aGlzLnBhdGhfID0gcGF0aDtcclxuICAgIH1cclxuICAgIGdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IHBhdGhDaGlsZCh0aGlzLnBhdGhfLCBjaGlsZE5hbWUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRGVmZXJyZWRWYWx1ZVByb3ZpZGVyKHRoaXMuc3luY1RyZWVfLCBjaGlsZFBhdGgpO1xyXG4gICAgfVxyXG4gICAgbm9kZSgpIHtcclxuICAgICAgICByZXR1cm4gc3luY1RyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlKHRoaXMuc3luY1RyZWVfLCB0aGlzLnBhdGhfKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2VuZXJhdGUgcGxhY2Vob2xkZXJzIGZvciBkZWZlcnJlZCB2YWx1ZXMuXHJcbiAqL1xyXG5jb25zdCBnZW5lcmF0ZVdpdGhWYWx1ZXMgPSBmdW5jdGlvbiAodmFsdWVzKSB7XHJcbiAgICB2YWx1ZXMgPSB2YWx1ZXMgfHwge307XHJcbiAgICB2YWx1ZXNbJ3RpbWVzdGFtcCddID0gdmFsdWVzWyd0aW1lc3RhbXAnXSB8fCBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgIHJldHVybiB2YWx1ZXM7XHJcbn07XHJcbi8qKlxyXG4gKiBWYWx1ZSB0byB1c2Ugd2hlbiBmaXJpbmcgbG9jYWwgZXZlbnRzLiBXaGVuIHdyaXRpbmcgc2VydmVyIHZhbHVlcywgZmlyZVxyXG4gKiBsb2NhbCBldmVudHMgd2l0aCBhbiBhcHByb3hpbWF0ZSB2YWx1ZSwgb3RoZXJ3aXNlIHJldHVybiB2YWx1ZSBhcy1pcy5cclxuICovXHJcbmNvbnN0IHJlc29sdmVEZWZlcnJlZExlYWZWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZXhpc3RpbmdWYWwsIHNlcnZlclZhbHVlcykge1xyXG4gICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0KCcuc3YnIGluIHZhbHVlLCAnVW5leHBlY3RlZCBsZWFmIG5vZGUgb3IgcHJpb3JpdHkgY29udGVudHMnKTtcclxuICAgIGlmICh0eXBlb2YgdmFsdWVbJy5zdiddID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlU2NhbGFyRGVmZXJyZWRWYWx1ZSh2YWx1ZVsnLnN2J10sIGV4aXN0aW5nVmFsLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlWycuc3YnXSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICByZXR1cm4gcmVzb2x2ZUNvbXBsZXhEZWZlcnJlZFZhbHVlKHZhbHVlWycuc3YnXSwgZXhpc3RpbmdWYWwpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCAnVW5leHBlY3RlZCBzZXJ2ZXIgdmFsdWU6ICcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgbnVsbCwgMikpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCByZXNvbHZlU2NhbGFyRGVmZXJyZWRWYWx1ZSA9IGZ1bmN0aW9uIChvcCwgZXhpc3RpbmcsIHNlcnZlclZhbHVlcykge1xyXG4gICAgc3dpdGNoIChvcCkge1xyXG4gICAgICAgIGNhc2UgJ3RpbWVzdGFtcCc6XHJcbiAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJWYWx1ZXNbJ3RpbWVzdGFtcCddO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgJ1VuZXhwZWN0ZWQgc2VydmVyIHZhbHVlOiAnICsgb3ApO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCByZXNvbHZlQ29tcGxleERlZmVycmVkVmFsdWUgPSBmdW5jdGlvbiAob3AsIGV4aXN0aW5nLCB1bnVzZWQpIHtcclxuICAgIGlmICghb3AuaGFzT3duUHJvcGVydHkoJ2luY3JlbWVudCcpKSB7XHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCAnVW5leHBlY3RlZCBzZXJ2ZXIgdmFsdWU6ICcgKyBKU09OLnN0cmluZ2lmeShvcCwgbnVsbCwgMikpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGVsdGEgPSBvcFsnaW5jcmVtZW50J107XHJcbiAgICBpZiAodHlwZW9mIGRlbHRhICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGFzc2VydChmYWxzZSwgJ1VuZXhwZWN0ZWQgaW5jcmVtZW50IHZhbHVlOiAnICsgZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZXhpc3RpbmdOb2RlID0gZXhpc3Rpbmcubm9kZSgpO1xyXG4gICAgYXNzZXJ0KGV4aXN0aW5nTm9kZSAhPT0gbnVsbCAmJiB0eXBlb2YgZXhpc3RpbmdOb2RlICE9PSAndW5kZWZpbmVkJywgJ0V4cGVjdGVkIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFIGZvciBudWxscycpO1xyXG4gICAgLy8gSW5jcmVtZW50aW5nIGEgbm9uLW51bWJlciBzZXRzIHRoZSB2YWx1ZSB0byB0aGUgaW5jcmVtZW50ZWQgYW1vdW50XHJcbiAgICBpZiAoIWV4aXN0aW5nTm9kZS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICByZXR1cm4gZGVsdGE7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsZWFmID0gZXhpc3RpbmdOb2RlO1xyXG4gICAgY29uc3QgZXhpc3RpbmdWYWwgPSBsZWFmLmdldFZhbHVlKCk7XHJcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nVmFsICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiBkZWx0YTtcclxuICAgIH1cclxuICAgIC8vIE5vIG5lZWQgdG8gZG8gb3Zlci91bmRlcmZsb3cgYXJpdGhtZXRpYyBoZXJlIGJlY2F1c2UgSlMgb25seSBoYW5kbGVzIGZsb2F0cyB1bmRlciB0aGUgY292ZXJzXHJcbiAgICByZXR1cm4gZXhpc3RpbmdWYWwgKyBkZWx0YTtcclxufTtcclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZWx5IHJlcGxhY2UgYWxsIGRlZmVycmVkIHZhbHVlcyBhbmQgcHJpb3JpdGllcyBpbiB0aGUgdHJlZSB3aXRoIHRoZVxyXG4gKiBzcGVjaWZpZWQgZ2VuZXJhdGVkIHJlcGxhY2VtZW50IHZhbHVlcy5cclxuICogQHBhcmFtIHBhdGggLSBwYXRoIHRvIHdoaWNoIHdyaXRlIGlzIHJlbGF0aXZlXHJcbiAqIEBwYXJhbSBub2RlIC0gbmV3IGRhdGEgd3JpdHRlbiBhdCBwYXRoXHJcbiAqIEBwYXJhbSBzeW5jVHJlZSAtIGN1cnJlbnQgZGF0YVxyXG4gKi9cclxuY29uc3QgcmVzb2x2ZURlZmVycmVkVmFsdWVUcmVlID0gZnVuY3Rpb24gKHBhdGgsIG5vZGUsIHN5bmNUcmVlLCBzZXJ2ZXJWYWx1ZXMpIHtcclxuICAgIHJldHVybiByZXNvbHZlRGVmZXJyZWRWYWx1ZShub2RlLCBuZXcgRGVmZXJyZWRWYWx1ZVByb3ZpZGVyKHN5bmNUcmVlLCBwYXRoKSwgc2VydmVyVmFsdWVzKTtcclxufTtcclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZWx5IHJlcGxhY2UgYWxsIGRlZmVycmVkIHZhbHVlcyBhbmQgcHJpb3JpdGllcyBpbiB0aGUgbm9kZSB3aXRoIHRoZVxyXG4gKiBzcGVjaWZpZWQgZ2VuZXJhdGVkIHJlcGxhY2VtZW50IHZhbHVlcy4gIElmIHRoZXJlIGFyZSBubyBzZXJ2ZXIgdmFsdWVzIGluIHRoZSBub2RlLFxyXG4gKiBpdCdsbCBiZSByZXR1cm5lZCBhcy1pcy5cclxuICovXHJcbmNvbnN0IHJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QgPSBmdW5jdGlvbiAobm9kZSwgZXhpc3RpbmcsIHNlcnZlclZhbHVlcykge1xyXG4gICAgcmV0dXJuIHJlc29sdmVEZWZlcnJlZFZhbHVlKG5vZGUsIG5ldyBFeGlzdGluZ1ZhbHVlUHJvdmlkZXIoZXhpc3RpbmcpLCBzZXJ2ZXJWYWx1ZXMpO1xyXG59O1xyXG5mdW5jdGlvbiByZXNvbHZlRGVmZXJyZWRWYWx1ZShub2RlLCBleGlzdGluZ1ZhbCwgc2VydmVyVmFsdWVzKSB7XHJcbiAgICBjb25zdCByYXdQcmkgPSBub2RlLmdldFByaW9yaXR5KCkudmFsKCk7XHJcbiAgICBjb25zdCBwcmlvcml0eSA9IHJlc29sdmVEZWZlcnJlZExlYWZWYWx1ZShyYXdQcmksIGV4aXN0aW5nVmFsLmdldEltbWVkaWF0ZUNoaWxkKCcucHJpb3JpdHknKSwgc2VydmVyVmFsdWVzKTtcclxuICAgIGxldCBuZXdOb2RlO1xyXG4gICAgaWYgKG5vZGUuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgY29uc3QgbGVhZk5vZGUgPSBub2RlO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gcmVzb2x2ZURlZmVycmVkTGVhZlZhbHVlKGxlYWZOb2RlLmdldFZhbHVlKCksIGV4aXN0aW5nVmFsLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbGVhZk5vZGUuZ2V0VmFsdWUoKSB8fFxyXG4gICAgICAgICAgICBwcmlvcml0eSAhPT0gbGVhZk5vZGUuZ2V0UHJpb3JpdHkoKS52YWwoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IExlYWZOb2RlKHZhbHVlLCBub2RlRnJvbUpTT04ocHJpb3JpdHkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuTm9kZSA9IG5vZGU7XHJcbiAgICAgICAgbmV3Tm9kZSA9IGNoaWxkcmVuTm9kZTtcclxuICAgICAgICBpZiAocHJpb3JpdHkgIT09IGNoaWxkcmVuTm9kZS5nZXRQcmlvcml0eSgpLnZhbCgpKSB7XHJcbiAgICAgICAgICAgIG5ld05vZGUgPSBuZXdOb2RlLnVwZGF0ZVByaW9yaXR5KG5ldyBMZWFmTm9kZShwcmlvcml0eSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGlsZHJlbk5vZGUuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoY2hpbGROYW1lLCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGROb2RlID0gcmVzb2x2ZURlZmVycmVkVmFsdWUoY2hpbGROb2RlLCBleGlzdGluZ1ZhbC5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgICAgICAgICBpZiAobmV3Q2hpbGROb2RlICE9PSBjaGlsZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIG5ld05vZGUgPSBuZXdOb2RlLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXdOb2RlO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGxpZ2h0LXdlaWdodCB0cmVlLCB0cmF2ZXJzYWJsZSBieSBwYXRoLiAgTm9kZXMgY2FuIGhhdmUgYm90aCB2YWx1ZXMgYW5kIGNoaWxkcmVuLlxyXG4gKiBOb2RlcyBhcmUgbm90IGVudW1lcmF0ZWQgKGJ5IGZvckVhY2hDaGlsZCkgdW5sZXNzIHRoZXkgaGF2ZSBhIHZhbHVlIG9yIG5vbi1lbXB0eVxyXG4gKiBjaGlsZHJlbi5cclxuICovXHJcbmNsYXNzIFRyZWUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gbmFtZSAtIE9wdGlvbmFsIG5hbWUgb2YgdGhlIG5vZGUuXHJcbiAgICAgKiBAcGFyYW0gcGFyZW50IC0gT3B0aW9uYWwgcGFyZW50IG5vZGUuXHJcbiAgICAgKiBAcGFyYW0gbm9kZSAtIE9wdGlvbmFsIG5vZGUgdG8gd3JhcC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobmFtZSA9ICcnLCBwYXJlbnQgPSBudWxsLCBub2RlID0geyBjaGlsZHJlbjoge30sIGNoaWxkQ291bnQ6IDAgfSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHN1Yi1UcmVlIGZvciB0aGUgZ2l2ZW4gcGF0aC5cclxuICpcclxuICogQHBhcmFtIHBhdGhPYmogLSBQYXRoIHRvIGxvb2sgdXAuXHJcbiAqIEByZXR1cm5zIFRyZWUgZm9yIHBhdGguXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlU3ViVHJlZSh0cmVlLCBwYXRoT2JqKSB7XHJcbiAgICAvLyBUT0RPOiBSZXF1aXJlIHBhdGhPYmogdG8gYmUgUGF0aD9cclxuICAgIGxldCBwYXRoID0gcGF0aE9iaiBpbnN0YW5jZW9mIFBhdGggPyBwYXRoT2JqIDogbmV3IFBhdGgocGF0aE9iaik7XHJcbiAgICBsZXQgY2hpbGQgPSB0cmVlLCBuZXh0ID0gcGF0aEdldEZyb250KHBhdGgpO1xyXG4gICAgd2hpbGUgKG5leHQgIT09IG51bGwpIHtcclxuICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBzYWZlR2V0KGNoaWxkLm5vZGUuY2hpbGRyZW4sIG5leHQpIHx8IHtcclxuICAgICAgICAgICAgY2hpbGRyZW46IHt9LFxyXG4gICAgICAgICAgICBjaGlsZENvdW50OiAwXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjaGlsZCA9IG5ldyBUcmVlKG5leHQsIGNoaWxkLCBjaGlsZE5vZGUpO1xyXG4gICAgICAgIHBhdGggPSBwYXRoUG9wRnJvbnQocGF0aCk7XHJcbiAgICAgICAgbmV4dCA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjaGlsZDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyB0cmVlIG5vZGUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoZSBkYXRhIG9yIG51bGwgaWYgbm8gZGF0YSBleGlzdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlR2V0VmFsdWUodHJlZSkge1xyXG4gICAgcmV0dXJuIHRyZWUubm9kZS52YWx1ZTtcclxufVxyXG4vKipcclxuICogU2V0cyBkYXRhIHRvIHRoaXMgdHJlZSBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBzZXQuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlU2V0VmFsdWUodHJlZSwgdmFsdWUpIHtcclxuICAgIHRyZWUubm9kZS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgdHJlZVVwZGF0ZVBhcmVudHModHJlZSk7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHRyZWUgaGFzIGFueSBjaGlsZHJlbi5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVIYXNDaGlsZHJlbih0cmVlKSB7XHJcbiAgICByZXR1cm4gdHJlZS5ub2RlLmNoaWxkQ291bnQgPiAwO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB0cmVlIGlzIGVtcHR5IChubyB2YWx1ZSBvciBjaGlsZHJlbikuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlSXNFbXB0eSh0cmVlKSB7XHJcbiAgICByZXR1cm4gdHJlZUdldFZhbHVlKHRyZWUpID09PSB1bmRlZmluZWQgJiYgIXRyZWVIYXNDaGlsZHJlbih0cmVlKTtcclxufVxyXG4vKipcclxuICogQ2FsbHMgYWN0aW9uIGZvciBlYWNoIGNoaWxkIG9mIHRoaXMgdHJlZSBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gYWN0aW9uIC0gQWN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBjaGlsZC5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVGb3JFYWNoQ2hpbGQodHJlZSwgYWN0aW9uKSB7XHJcbiAgICBlYWNoKHRyZWUubm9kZS5jaGlsZHJlbiwgKGNoaWxkLCBjaGlsZFRyZWUpID0+IHtcclxuICAgICAgICBhY3Rpb24obmV3IFRyZWUoY2hpbGQsIHRyZWUsIGNoaWxkVHJlZSkpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIERvZXMgYSBkZXB0aC1maXJzdCB0cmF2ZXJzYWwgb2YgdGhpcyBub2RlJ3MgZGVzY2VuZGFudHMsIGNhbGxpbmcgYWN0aW9uIGZvciBlYWNoIG9uZS5cclxuICpcclxuICogQHBhcmFtIGFjdGlvbiAtIEFjdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2ggY2hpbGQuXHJcbiAqIEBwYXJhbSBpbmNsdWRlU2VsZiAtIFdoZXRoZXIgdG8gY2FsbCBhY3Rpb24gb24gdGhpcyBub2RlIGFzIHdlbGwuIERlZmF1bHRzIHRvXHJcbiAqICAgZmFsc2UuXHJcbiAqIEBwYXJhbSBjaGlsZHJlbkZpcnN0IC0gV2hldGhlciB0byBjYWxsIGFjdGlvbiBvbiBjaGlsZHJlbiBiZWZvcmUgY2FsbGluZyBpdCBvblxyXG4gKiAgIHBhcmVudC5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVGb3JFYWNoRGVzY2VuZGFudCh0cmVlLCBhY3Rpb24sIGluY2x1ZGVTZWxmLCBjaGlsZHJlbkZpcnN0KSB7XHJcbiAgICBpZiAoaW5jbHVkZVNlbGYgJiYgIWNoaWxkcmVuRmlyc3QpIHtcclxuICAgICAgICBhY3Rpb24odHJlZSk7XHJcbiAgICB9XHJcbiAgICB0cmVlRm9yRWFjaENoaWxkKHRyZWUsIGNoaWxkID0+IHtcclxuICAgICAgICB0cmVlRm9yRWFjaERlc2NlbmRhbnQoY2hpbGQsIGFjdGlvbiwgdHJ1ZSwgY2hpbGRyZW5GaXJzdCk7XHJcbiAgICB9KTtcclxuICAgIGlmIChpbmNsdWRlU2VsZiAmJiBjaGlsZHJlbkZpcnN0KSB7XHJcbiAgICAgICAgYWN0aW9uKHRyZWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDYWxscyBhY3Rpb24gb24gZWFjaCBhbmNlc3RvciBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gYWN0aW9uIC0gQWN0aW9uIHRvIGJlIGNhbGxlZCBvbiBlYWNoIHBhcmVudDsgcmV0dXJuXHJcbiAqICAgdHJ1ZSB0byBhYm9ydC5cclxuICogQHBhcmFtIGluY2x1ZGVTZWxmIC0gV2hldGhlciB0byBjYWxsIGFjdGlvbiBvbiB0aGlzIG5vZGUgYXMgd2VsbC5cclxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgYWN0aW9uIGNhbGxiYWNrIHJldHVybmVkIHRydWUuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlRm9yRWFjaEFuY2VzdG9yKHRyZWUsIGFjdGlvbiwgaW5jbHVkZVNlbGYpIHtcclxuICAgIGxldCBub2RlID0gaW5jbHVkZVNlbGYgPyB0cmVlIDogdHJlZS5wYXJlbnQ7XHJcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChhY3Rpb24obm9kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgVGhlIHBhdGggb2YgdGhpcyB0cmVlIG5vZGUsIGFzIGEgUGF0aC5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVHZXRQYXRoKHRyZWUpIHtcclxuICAgIHJldHVybiBuZXcgUGF0aCh0cmVlLnBhcmVudCA9PT0gbnVsbFxyXG4gICAgICAgID8gdHJlZS5uYW1lXHJcbiAgICAgICAgOiB0cmVlR2V0UGF0aCh0cmVlLnBhcmVudCkgKyAnLycgKyB0cmVlLm5hbWUpO1xyXG59XHJcbi8qKlxyXG4gKiBBZGRzIG9yIHJlbW92ZXMgdGhpcyBjaGlsZCBmcm9tIGl0cyBwYXJlbnQgYmFzZWQgb24gd2hldGhlciBpdCdzIGVtcHR5IG9yIG5vdC5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVVcGRhdGVQYXJlbnRzKHRyZWUpIHtcclxuICAgIGlmICh0cmVlLnBhcmVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgIHRyZWVVcGRhdGVDaGlsZCh0cmVlLnBhcmVudCwgdHJlZS5uYW1lLCB0cmVlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQWRkcyBvciByZW1vdmVzIHRoZSBwYXNzZWQgY2hpbGQgdG8gdGhpcyB0cmVlIG5vZGUsIGRlcGVuZGluZyBvbiB3aGV0aGVyIGl0J3MgZW1wdHkuXHJcbiAqXHJcbiAqIEBwYXJhbSBjaGlsZE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY2hpbGQgdG8gdXBkYXRlLlxyXG4gKiBAcGFyYW0gY2hpbGQgLSBUaGUgY2hpbGQgdG8gdXBkYXRlLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJlZVVwZGF0ZUNoaWxkKHRyZWUsIGNoaWxkTmFtZSwgY2hpbGQpIHtcclxuICAgIGNvbnN0IGNoaWxkRW1wdHkgPSB0cmVlSXNFbXB0eShjaGlsZCk7XHJcbiAgICBjb25zdCBjaGlsZEV4aXN0cyA9IGNvbnRhaW5zKHRyZWUubm9kZS5jaGlsZHJlbiwgY2hpbGROYW1lKTtcclxuICAgIGlmIChjaGlsZEVtcHR5ICYmIGNoaWxkRXhpc3RzKSB7XHJcbiAgICAgICAgZGVsZXRlIHRyZWUubm9kZS5jaGlsZHJlbltjaGlsZE5hbWVdO1xyXG4gICAgICAgIHRyZWUubm9kZS5jaGlsZENvdW50LS07XHJcbiAgICAgICAgdHJlZVVwZGF0ZVBhcmVudHModHJlZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghY2hpbGRFbXB0eSAmJiAhY2hpbGRFeGlzdHMpIHtcclxuICAgICAgICB0cmVlLm5vZGUuY2hpbGRyZW5bY2hpbGROYW1lXSA9IGNoaWxkLm5vZGU7XHJcbiAgICAgICAgdHJlZS5ub2RlLmNoaWxkQ291bnQrKztcclxuICAgICAgICB0cmVlVXBkYXRlUGFyZW50cyh0cmVlKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVHJ1ZSBmb3IgaW52YWxpZCBGaXJlYmFzZSBrZXlzXHJcbiAqL1xyXG5jb25zdCBJTlZBTElEX0tFWV9SRUdFWF8gPSAvW1xcW1xcXS4jJFxcL1xcdTAwMDAtXFx1MDAxRlxcdTAwN0ZdLztcclxuLyoqXHJcbiAqIFRydWUgZm9yIGludmFsaWQgRmlyZWJhc2UgcGF0aHMuXHJcbiAqIEFsbG93cyAnLycgaW4gcGF0aHMuXHJcbiAqL1xyXG5jb25zdCBJTlZBTElEX1BBVEhfUkVHRVhfID0gL1tcXFtcXF0uIyRcXHUwMDAwLVxcdTAwMUZcXHUwMDdGXS87XHJcbi8qKlxyXG4gKiBNYXhpbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIGFsbG93IGluIGxlYWYgdmFsdWVcclxuICovXHJcbmNvbnN0IE1BWF9MRUFGX1NJWkVfID0gMTAgKiAxMDI0ICogMTAyNDtcclxuY29uc3QgaXNWYWxpZEtleSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIHJldHVybiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5Lmxlbmd0aCAhPT0gMCAmJiAhSU5WQUxJRF9LRVlfUkVHRVhfLnRlc3Qoa2V5KSk7XHJcbn07XHJcbmNvbnN0IGlzVmFsaWRQYXRoU3RyaW5nID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcpIHtcclxuICAgIHJldHVybiAodHlwZW9mIHBhdGhTdHJpbmcgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgcGF0aFN0cmluZy5sZW5ndGggIT09IDAgJiZcclxuICAgICAgICAhSU5WQUxJRF9QQVRIX1JFR0VYXy50ZXN0KHBhdGhTdHJpbmcpKTtcclxufTtcclxuY29uc3QgaXNWYWxpZFJvb3RQYXRoU3RyaW5nID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcpIHtcclxuICAgIGlmIChwYXRoU3RyaW5nKSB7XHJcbiAgICAgICAgLy8gQWxsb3cgJy8uaW5mby8nIGF0IHRoZSBiZWdpbm5pbmcuXHJcbiAgICAgICAgcGF0aFN0cmluZyA9IHBhdGhTdHJpbmcucmVwbGFjZSgvXlxcLypcXC5pbmZvKFxcL3wkKS8sICcvJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNWYWxpZFBhdGhTdHJpbmcocGF0aFN0cmluZyk7XHJcbn07XHJcbmNvbnN0IGlzVmFsaWRQcmlvcml0eSA9IGZ1bmN0aW9uIChwcmlvcml0eSkge1xyXG4gICAgcmV0dXJuIChwcmlvcml0eSA9PT0gbnVsbCB8fFxyXG4gICAgICAgIHR5cGVvZiBwcmlvcml0eSA9PT0gJ3N0cmluZycgfHxcclxuICAgICAgICAodHlwZW9mIHByaW9yaXR5ID09PSAnbnVtYmVyJyAmJiAhaXNJbnZhbGlkSlNPTk51bWJlcihwcmlvcml0eSkpIHx8XHJcbiAgICAgICAgKHByaW9yaXR5ICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiBwcmlvcml0eSA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgY29udGFpbnMocHJpb3JpdHksICcuc3YnKSkpO1xyXG59O1xyXG4vKipcclxuICogUHJlLXZhbGlkYXRlIGEgZGF0dW0gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIEZpcmViYXNlIGZ1bmN0aW9uLlxyXG4gKi9cclxuY29uc3QgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcgPSBmdW5jdGlvbiAoZm5OYW1lLCB2YWx1ZSwgcGF0aCwgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGVGaXJlYmFzZURhdGEoZXJyb3JQcmVmaXgoZm5OYW1lLCAndmFsdWUnKSwgdmFsdWUsIHBhdGgpO1xyXG59O1xyXG4vKipcclxuICogVmFsaWRhdGUgYSBkYXRhIG9iamVjdCBjbGllbnQtc2lkZSBiZWZvcmUgc2VuZGluZyB0byBzZXJ2ZXIuXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZUZpcmViYXNlRGF0YSA9IGZ1bmN0aW9uIChlcnJvclByZWZpeCwgZGF0YSwgcGF0aF8pIHtcclxuICAgIGNvbnN0IHBhdGggPSBwYXRoXyBpbnN0YW5jZW9mIFBhdGggPyBuZXcgVmFsaWRhdGlvblBhdGgocGF0aF8sIGVycm9yUHJlZml4KSA6IHBhdGhfO1xyXG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArICdjb250YWlucyB1bmRlZmluZWQgJyArIHZhbGlkYXRpb25QYXRoVG9FcnJvclN0cmluZyhwYXRoKSk7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xyXG4gICAgICAgICAgICAnY29udGFpbnMgYSBmdW5jdGlvbiAnICtcclxuICAgICAgICAgICAgdmFsaWRhdGlvblBhdGhUb0Vycm9yU3RyaW5nKHBhdGgpICtcclxuICAgICAgICAgICAgJyB3aXRoIGNvbnRlbnRzID0gJyArXHJcbiAgICAgICAgICAgIGRhdGEudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNJbnZhbGlkSlNPTk51bWJlcihkYXRhKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArXHJcbiAgICAgICAgICAgICdjb250YWlucyAnICtcclxuICAgICAgICAgICAgZGF0YS50b1N0cmluZygpICtcclxuICAgICAgICAgICAgJyAnICtcclxuICAgICAgICAgICAgdmFsaWRhdGlvblBhdGhUb0Vycm9yU3RyaW5nKHBhdGgpKTtcclxuICAgIH1cclxuICAgIC8vIENoZWNrIG1heCBsZWFmIHNpemUsIGJ1dCB0cnkgdG8gYXZvaWQgdGhlIHV0ZjggY29udmVyc2lvbiBpZiB3ZSBjYW4uXHJcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgZGF0YS5sZW5ndGggPiBNQVhfTEVBRl9TSVpFXyAvIDMgJiZcclxuICAgICAgICBzdHJpbmdMZW5ndGgoZGF0YSkgPiBNQVhfTEVBRl9TSVpFXykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArXHJcbiAgICAgICAgICAgICdjb250YWlucyBhIHN0cmluZyBncmVhdGVyIHRoYW4gJyArXHJcbiAgICAgICAgICAgIE1BWF9MRUFGX1NJWkVfICtcclxuICAgICAgICAgICAgJyB1dGY4IGJ5dGVzICcgK1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9uUGF0aFRvRXJyb3JTdHJpbmcocGF0aCkgK1xyXG4gICAgICAgICAgICBcIiAoJ1wiICtcclxuICAgICAgICAgICAgZGF0YS5zdWJzdHJpbmcoMCwgNTApICtcclxuICAgICAgICAgICAgXCIuLi4nKVwiKTtcclxuICAgIH1cclxuICAgIC8vIFRPRE8gPSBQZXJmID0gQ29uc2lkZXIgY29tYmluaW5nIHRoZSByZWN1cnNpdmUgdmFsaWRhdGlvbiBvZiBrZXlzIGludG8gTm9kZUZyb21KU09OXHJcbiAgICAvLyB0byBzYXZlIGV4dHJhIHdhbGtpbmcgb2YgbGFyZ2Ugb2JqZWN0cy5cclxuICAgIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGxldCBoYXNEb3RWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBoYXNBY3R1YWxDaGlsZCA9IGZhbHNlO1xyXG4gICAgICAgIGVhY2goZGF0YSwgKGtleSwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJy52YWx1ZScpIHtcclxuICAgICAgICAgICAgICAgIGhhc0RvdFZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICcucHJpb3JpdHknICYmIGtleSAhPT0gJy5zdicpIHtcclxuICAgICAgICAgICAgICAgIGhhc0FjdHVhbENoaWxkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEtleShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4ICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyBjb250YWlucyBhbiBpbnZhbGlkIGtleSAoJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcpICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUGF0aFRvRXJyb3JTdHJpbmcocGF0aCkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnLiAgS2V5cyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW5kIGNhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIi9cIiwgXCJbXCIsIG9yIFwiXVwiJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFsaWRhdGlvblBhdGhQdXNoKHBhdGgsIGtleSk7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhKGVycm9yUHJlZml4LCB2YWx1ZSwgcGF0aCk7XHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25QYXRoUG9wKHBhdGgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChoYXNEb3RWYWx1ZSAmJiBoYXNBY3R1YWxDaGlsZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xyXG4gICAgICAgICAgICAgICAgJyBjb250YWlucyBcIi52YWx1ZVwiIGNoaWxkICcgK1xyXG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblBhdGhUb0Vycm9yU3RyaW5nKHBhdGgpICtcclxuICAgICAgICAgICAgICAgICcgaW4gYWRkaXRpb24gdG8gYWN0dWFsIGNoaWxkcmVuLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFByZS12YWxpZGF0ZSBwYXRocyBwYXNzZWQgaW4gdGhlIGZpcmViYXNlIGZ1bmN0aW9uLlxyXG4gKi9cclxuY29uc3QgdmFsaWRhdGVGaXJlYmFzZU1lcmdlUGF0aHMgPSBmdW5jdGlvbiAoZXJyb3JQcmVmaXgsIG1lcmdlUGF0aHMpIHtcclxuICAgIGxldCBpLCBjdXJQYXRoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG1lcmdlUGF0aHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjdXJQYXRoID0gbWVyZ2VQYXRoc1tpXTtcclxuICAgICAgICBjb25zdCBrZXlzID0gcGF0aFNsaWNlKGN1clBhdGgpO1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoa2V5c1tqXSA9PT0gJy5wcmlvcml0eScgJiYgaiA9PT0ga2V5cy5sZW5ndGggLSAxKSA7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc1ZhbGlkS2V5KGtleXNbal0pKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xyXG4gICAgICAgICAgICAgICAgICAgICdjb250YWlucyBhbiBpbnZhbGlkIGtleSAoJyArXHJcbiAgICAgICAgICAgICAgICAgICAga2V5c1tqXSArXHJcbiAgICAgICAgICAgICAgICAgICAgJykgaW4gcGF0aCAnICtcclxuICAgICAgICAgICAgICAgICAgICBjdXJQYXRoLnRvU3RyaW5nKCkgK1xyXG4gICAgICAgICAgICAgICAgICAgICcuIEtleXMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyAnICtcclxuICAgICAgICAgICAgICAgICAgICAnYW5kIGNhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIi9cIiwgXCJbXCIsIG9yIFwiXVwiJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBDaGVjayB0aGF0IHVwZGF0ZSBrZXlzIGFyZSBub3QgZGVzY2VuZGFudHMgb2YgZWFjaCBvdGhlci5cclxuICAgIC8vIFdlIHJlbHkgb24gdGhlIHByb3BlcnR5IHRoYXQgc29ydGluZyBndWFyYW50ZWVzIHRoYXQgYW5jZXN0b3JzIGNvbWVcclxuICAgIC8vIHJpZ2h0IGJlZm9yZSBkZXNjZW5kYW50cy5cclxuICAgIG1lcmdlUGF0aHMuc29ydChwYXRoQ29tcGFyZSk7XHJcbiAgICBsZXQgcHJldlBhdGggPSBudWxsO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG1lcmdlUGF0aHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjdXJQYXRoID0gbWVyZ2VQYXRoc1tpXTtcclxuICAgICAgICBpZiAocHJldlBhdGggIT09IG51bGwgJiYgcGF0aENvbnRhaW5zKHByZXZQYXRoLCBjdXJQYXRoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xyXG4gICAgICAgICAgICAgICAgJ2NvbnRhaW5zIGEgcGF0aCAnICtcclxuICAgICAgICAgICAgICAgIHByZXZQYXRoLnRvU3RyaW5nKCkgK1xyXG4gICAgICAgICAgICAgICAgJyB0aGF0IGlzIGFuY2VzdG9yIG9mIGFub3RoZXIgcGF0aCAnICtcclxuICAgICAgICAgICAgICAgIGN1clBhdGgudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXZQYXRoID0gY3VyUGF0aDtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIHByZS12YWxpZGF0ZSBhbiBvYmplY3QgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIGZpcmViYXNlIGZ1bmN0aW9uIChcclxuICogbXVzdCBiZSBhbiBvYmplY3QgLSBlLmcuIGZvciBmaXJlYmFzZS51cGRhdGUoKSkuXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZUZpcmViYXNlTWVyZ2VEYXRhQXJnID0gZnVuY3Rpb24gKGZuTmFtZSwgZGF0YSwgcGF0aCwgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiBkYXRhID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBlcnJvclByZWZpeCQxID0gZXJyb3JQcmVmaXgoZm5OYW1lLCAndmFsdWVzJyk7XHJcbiAgICBpZiAoIShkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JykgfHwgQXJyYXkuaXNBcnJheShkYXRhKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCQxICsgJyBtdXN0IGJlIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjaGlsZHJlbiB0byByZXBsYWNlLicpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbWVyZ2VQYXRocyA9IFtdO1xyXG4gICAgZWFjaChkYXRhLCAoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGN1clBhdGggPSBuZXcgUGF0aChrZXkpO1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhKGVycm9yUHJlZml4JDEsIHZhbHVlLCBwYXRoQ2hpbGQocGF0aCwgY3VyUGF0aCkpO1xyXG4gICAgICAgIGlmIChwYXRoR2V0QmFjayhjdXJQYXRoKSA9PT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkUHJpb3JpdHkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgkMSArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJjb250YWlucyBhbiBpbnZhbGlkIHZhbHVlIGZvciAnXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIGN1clBhdGgudG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICAgICAgICAgXCInLCB3aGljaCBtdXN0IGJlIGEgdmFsaWQgXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICdGaXJlYmFzZSBwcmlvcml0eSAoYSBzdHJpbmcsIGZpbml0ZSBudW1iZXIsIHNlcnZlciB2YWx1ZSwgb3IgbnVsbCkuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbWVyZ2VQYXRocy5wdXNoKGN1clBhdGgpO1xyXG4gICAgfSk7XHJcbiAgICB2YWxpZGF0ZUZpcmViYXNlTWVyZ2VQYXRocyhlcnJvclByZWZpeCQxLCBtZXJnZVBhdGhzKTtcclxufTtcclxuY29uc3QgdmFsaWRhdGVQcmlvcml0eSA9IGZ1bmN0aW9uIChmbk5hbWUsIHByaW9yaXR5LCBvcHRpb25hbCkge1xyXG4gICAgaWYgKG9wdGlvbmFsICYmIHByaW9yaXR5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoaXNJbnZhbGlkSlNPTk51bWJlcihwcmlvcml0eSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCAncHJpb3JpdHknKSArXHJcbiAgICAgICAgICAgICdpcyAnICtcclxuICAgICAgICAgICAgcHJpb3JpdHkudG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICcsIGJ1dCBtdXN0IGJlIGEgdmFsaWQgRmlyZWJhc2UgcHJpb3JpdHkgKGEgc3RyaW5nLCBmaW5pdGUgbnVtYmVyLCAnICtcclxuICAgICAgICAgICAgJ3NlcnZlciB2YWx1ZSwgb3IgbnVsbCkuJyk7XHJcbiAgICB9XHJcbiAgICAvLyBTcGVjaWFsIGNhc2UgdG8gYWxsb3cgaW1wb3J0aW5nIGRhdGEgd2l0aCBhIC5zdi5cclxuICAgIGlmICghaXNWYWxpZFByaW9yaXR5KHByaW9yaXR5KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsICdwcmlvcml0eScpICtcclxuICAgICAgICAgICAgJ211c3QgYmUgYSB2YWxpZCBGaXJlYmFzZSBwcmlvcml0eSAnICtcclxuICAgICAgICAgICAgJyhhIHN0cmluZywgZmluaXRlIG51bWJlciwgc2VydmVyIHZhbHVlLCBvciBudWxsKS4nKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgdmFsaWRhdGVLZXkgPSBmdW5jdGlvbiAoZm5OYW1lLCBhcmd1bWVudE5hbWUsIGtleSwgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiBrZXkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICghaXNWYWxpZEtleShrZXkpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROYW1lKSArXHJcbiAgICAgICAgICAgICd3YXMgYW4gaW52YWxpZCBrZXkgPSBcIicgK1xyXG4gICAgICAgICAgICBrZXkgK1xyXG4gICAgICAgICAgICAnXCIuICBGaXJlYmFzZSBrZXlzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MgYW5kICcgK1xyXG4gICAgICAgICAgICAnY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiL1wiLCBcIltcIiwgb3IgXCJdXCIpLicpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZVBhdGhTdHJpbmcgPSBmdW5jdGlvbiAoZm5OYW1lLCBhcmd1bWVudE5hbWUsIHBhdGhTdHJpbmcsIG9wdGlvbmFsKSB7XHJcbiAgICBpZiAob3B0aW9uYWwgJiYgcGF0aFN0cmluZyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc1ZhbGlkUGF0aFN0cmluZyhwYXRoU3RyaW5nKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TmFtZSkgK1xyXG4gICAgICAgICAgICAnd2FzIGFuIGludmFsaWQgcGF0aCA9IFwiJyArXHJcbiAgICAgICAgICAgIHBhdGhTdHJpbmcgK1xyXG4gICAgICAgICAgICAnXCIuIFBhdGhzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MgYW5kICcgK1xyXG4gICAgICAgICAgICAnY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiW1wiLCBvciBcIl1cIicpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCB2YWxpZGF0ZVJvb3RQYXRoU3RyaW5nID0gZnVuY3Rpb24gKGZuTmFtZSwgYXJndW1lbnROYW1lLCBwYXRoU3RyaW5nLCBvcHRpb25hbCkge1xyXG4gICAgaWYgKHBhdGhTdHJpbmcpIHtcclxuICAgICAgICAvLyBBbGxvdyAnLy5pbmZvLycgYXQgdGhlIGJlZ2lubmluZy5cclxuICAgICAgICBwYXRoU3RyaW5nID0gcGF0aFN0cmluZy5yZXBsYWNlKC9eXFwvKlxcLmluZm8oXFwvfCQpLywgJy8nKTtcclxuICAgIH1cclxuICAgIHZhbGlkYXRlUGF0aFN0cmluZyhmbk5hbWUsIGFyZ3VtZW50TmFtZSwgcGF0aFN0cmluZywgb3B0aW9uYWwpO1xyXG59O1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZVdyaXRhYmxlUGF0aCA9IGZ1bmN0aW9uIChmbk5hbWUsIHBhdGgpIHtcclxuICAgIGlmIChwYXRoR2V0RnJvbnQocGF0aCkgPT09ICcuaW5mbycpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm5OYW1lICsgXCIgZmFpbGVkID0gQ2FuJ3QgbW9kaWZ5IGRhdGEgdW5kZXIgLy5pbmZvL1wiKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgdmFsaWRhdGVVcmwgPSBmdW5jdGlvbiAoZm5OYW1lLCBwYXJzZWRVcmwpIHtcclxuICAgIC8vIFRPRE8gPSBWYWxpZGF0ZSBzZXJ2ZXIgYmV0dGVyLlxyXG4gICAgY29uc3QgcGF0aFN0cmluZyA9IHBhcnNlZFVybC5wYXRoLnRvU3RyaW5nKCk7XHJcbiAgICBpZiAoISh0eXBlb2YgcGFyc2VkVXJsLnJlcG9JbmZvLmhvc3QgPT09ICdzdHJpbmcnKSB8fFxyXG4gICAgICAgIHBhcnNlZFVybC5yZXBvSW5mby5ob3N0Lmxlbmd0aCA9PT0gMCB8fFxyXG4gICAgICAgICghaXNWYWxpZEtleShwYXJzZWRVcmwucmVwb0luZm8ubmFtZXNwYWNlKSAmJlxyXG4gICAgICAgICAgICBwYXJzZWRVcmwucmVwb0luZm8uaG9zdC5zcGxpdCgnOicpWzBdICE9PSAnbG9jYWxob3N0JykgfHxcclxuICAgICAgICAocGF0aFN0cmluZy5sZW5ndGggIT09IDAgJiYgIWlzVmFsaWRSb290UGF0aFN0cmluZyhwYXRoU3RyaW5nKSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCAndXJsJykgK1xyXG4gICAgICAgICAgICAnbXVzdCBiZSBhIHZhbGlkIGZpcmViYXNlIFVSTCBhbmQgJyArXHJcbiAgICAgICAgICAgICd0aGUgcGF0aCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCJbXCIsIG9yIFwiXVwiLicpO1xyXG4gICAgfVxyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGV2ZW50IHF1ZXVlIHNlcnZlcyBhIGZldyBwdXJwb3NlczpcclxuICogMS4gSXQgZW5zdXJlcyB3ZSBtYWludGFpbiBldmVudCBvcmRlciBpbiB0aGUgZmFjZSBvZiBldmVudCBjYWxsYmFja3MgZG9pbmcgb3BlcmF0aW9ucyB0aGF0IHJlc3VsdCBpbiBtb3JlXHJcbiAqICAgIGV2ZW50cyBiZWluZyBxdWV1ZWQuXHJcbiAqIDIuIHJhaXNlUXVldWVkRXZlbnRzKCkgaGFuZGxlcyBiZWluZyBjYWxsZWQgcmVlbnRyYW50bHkgbmljZWx5LiAgVGhhdCBpcywgaWYgaW4gdGhlIGNvdXJzZSBvZiByYWlzaW5nIGV2ZW50cyxcclxuICogICAgcmFpc2VRdWV1ZWRFdmVudHMoKSBpcyBjYWxsZWQgYWdhaW4sIHRoZSBcImlubmVyXCIgY2FsbCB3aWxsIHBpY2sgdXAgcmFpc2luZyBldmVudHMgd2hlcmUgdGhlIFwib3V0ZXJcIiBjYWxsXHJcbiAqICAgIGxlZnQgb2ZmLCBlbnN1cmluZyB0aGF0IHRoZSBldmVudHMgYXJlIHN0aWxsIHJhaXNlZCBzeW5jaHJvbm91c2x5IGFuZCBpbiBvcmRlci5cclxuICogMy4gWW91IGNhbiB1c2UgcmFpc2VFdmVudHNBdFBhdGggYW5kIHJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGggdG8gZW5zdXJlIG9ubHkgcmVsZXZhbnQgcHJldmlvdXNseS1xdWV1ZWRcclxuICogICAgZXZlbnRzIGFyZSByYWlzZWQgc3luY2hyb25vdXNseS5cclxuICpcclxuICogTk9URTogVGhpcyBjYW4gYWxsIGdvIGF3YXkgaWYvd2hlbiB3ZSBtb3ZlIHRvIGFzeW5jIGV2ZW50cy5cclxuICpcclxuICovXHJcbmNsYXNzIEV2ZW50UXVldWUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudExpc3RzXyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyYWNrcyByZWN1cnNpb24gZGVwdGggb2YgcmFpc2VRdWV1ZWRFdmVudHNfLCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVjdXJzaW9uRGVwdGhfID0gMDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQHBhcmFtIGV2ZW50RGF0YUxpc3QgLSBUaGUgbmV3IGV2ZW50cyB0byBxdWV1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGV2ZW50UXVldWVRdWV1ZUV2ZW50cyhldmVudFF1ZXVlLCBldmVudERhdGFMaXN0KSB7XHJcbiAgICAvLyBXZSBncm91cCBldmVudHMgYnkgcGF0aCwgc3RvcmluZyB0aGVtIGluIGEgc2luZ2xlIEV2ZW50TGlzdCwgdG8gbWFrZSBpdCBlYXNpZXIgdG8gc2tpcCBvdmVyIHRoZW0gcXVpY2tseS5cclxuICAgIGxldCBjdXJyTGlzdCA9IG51bGw7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50RGF0YUxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gZXZlbnREYXRhTGlzdFtpXTtcclxuICAgICAgICBjb25zdCBwYXRoID0gZGF0YS5nZXRQYXRoKCk7XHJcbiAgICAgICAgaWYgKGN1cnJMaXN0ICE9PSBudWxsICYmICFwYXRoRXF1YWxzKHBhdGgsIGN1cnJMaXN0LnBhdGgpKSB7XHJcbiAgICAgICAgICAgIGV2ZW50UXVldWUuZXZlbnRMaXN0c18ucHVzaChjdXJyTGlzdCk7XHJcbiAgICAgICAgICAgIGN1cnJMaXN0ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN1cnJMaXN0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGN1cnJMaXN0ID0geyBldmVudHM6IFtdLCBwYXRoIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJMaXN0LmV2ZW50cy5wdXNoKGRhdGEpO1xyXG4gICAgfVxyXG4gICAgaWYgKGN1cnJMaXN0KSB7XHJcbiAgICAgICAgZXZlbnRRdWV1ZS5ldmVudExpc3RzXy5wdXNoKGN1cnJMaXN0KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUXVldWVzIHRoZSBzcGVjaWZpZWQgZXZlbnRzIGFuZCBzeW5jaHJvbm91c2x5IHJhaXNlcyBhbGwgZXZlbnRzIChpbmNsdWRpbmcgcHJldmlvdXNseSBxdWV1ZWQgb25lcylcclxuICogZm9yIHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICpcclxuICogSXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBuZXcgZXZlbnRzIGFyZSBhbGwgZm9yIHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICpcclxuICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byByYWlzZSBldmVudHMgZm9yLlxyXG4gKiBAcGFyYW0gZXZlbnREYXRhTGlzdCAtIFRoZSBuZXcgZXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZXZlbnRRdWV1ZVJhaXNlRXZlbnRzQXRQYXRoKGV2ZW50UXVldWUsIHBhdGgsIGV2ZW50RGF0YUxpc3QpIHtcclxuICAgIGV2ZW50UXVldWVRdWV1ZUV2ZW50cyhldmVudFF1ZXVlLCBldmVudERhdGFMaXN0KTtcclxuICAgIGV2ZW50UXVldWVSYWlzZVF1ZXVlZEV2ZW50c01hdGNoaW5nUHJlZGljYXRlKGV2ZW50UXVldWUsIGV2ZW50UGF0aCA9PiBwYXRoRXF1YWxzKGV2ZW50UGF0aCwgcGF0aCkpO1xyXG59XHJcbi8qKlxyXG4gKiBRdWV1ZXMgdGhlIHNwZWNpZmllZCBldmVudHMgYW5kIHN5bmNocm9ub3VzbHkgcmFpc2VzIGFsbCBldmVudHMgKGluY2x1ZGluZyBwcmV2aW91c2x5IHF1ZXVlZCBvbmVzKSBmb3JcclxuICogbG9jYXRpb25zIHJlbGF0ZWQgdG8gdGhlIHNwZWNpZmllZCBjaGFuZ2UgcGF0aCAoaS5lLiBhbGwgYW5jZXN0b3JzIGFuZCBkZXNjZW5kYW50cykuXHJcbiAqXHJcbiAqIEl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgbmV3IGV2ZW50cyBhcmUgYWxsIHJlbGF0ZWQgKGFuY2VzdG9yIG9yIGRlc2NlbmRhbnQpIHRvIHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICpcclxuICogQHBhcmFtIGNoYW5nZWRQYXRoIC0gVGhlIHBhdGggdG8gcmFpc2UgZXZlbnRzIGZvci5cclxuICogQHBhcmFtIGV2ZW50RGF0YUxpc3QgLSBUaGUgZXZlbnRzIHRvIHJhaXNlXHJcbiAqL1xyXG5mdW5jdGlvbiBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChldmVudFF1ZXVlLCBjaGFuZ2VkUGF0aCwgZXZlbnREYXRhTGlzdCkge1xyXG4gICAgZXZlbnRRdWV1ZVF1ZXVlRXZlbnRzKGV2ZW50UXVldWUsIGV2ZW50RGF0YUxpc3QpO1xyXG4gICAgZXZlbnRRdWV1ZVJhaXNlUXVldWVkRXZlbnRzTWF0Y2hpbmdQcmVkaWNhdGUoZXZlbnRRdWV1ZSwgZXZlbnRQYXRoID0+IHBhdGhDb250YWlucyhldmVudFBhdGgsIGNoYW5nZWRQYXRoKSB8fFxyXG4gICAgICAgIHBhdGhDb250YWlucyhjaGFuZ2VkUGF0aCwgZXZlbnRQYXRoKSk7XHJcbn1cclxuZnVuY3Rpb24gZXZlbnRRdWV1ZVJhaXNlUXVldWVkRXZlbnRzTWF0Y2hpbmdQcmVkaWNhdGUoZXZlbnRRdWV1ZSwgcHJlZGljYXRlKSB7XHJcbiAgICBldmVudFF1ZXVlLnJlY3Vyc2lvbkRlcHRoXysrO1xyXG4gICAgbGV0IHNlbnRBbGwgPSB0cnVlO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudFF1ZXVlLmV2ZW50TGlzdHNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgZXZlbnRMaXN0ID0gZXZlbnRRdWV1ZS5ldmVudExpc3RzX1tpXTtcclxuICAgICAgICBpZiAoZXZlbnRMaXN0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50UGF0aCA9IGV2ZW50TGlzdC5wYXRoO1xyXG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKGV2ZW50UGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50TGlzdFJhaXNlKGV2ZW50UXVldWUuZXZlbnRMaXN0c19baV0pO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRRdWV1ZS5ldmVudExpc3RzX1tpXSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZW50QWxsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoc2VudEFsbCkge1xyXG4gICAgICAgIGV2ZW50UXVldWUuZXZlbnRMaXN0c18gPSBbXTtcclxuICAgIH1cclxuICAgIGV2ZW50UXVldWUucmVjdXJzaW9uRGVwdGhfLS07XHJcbn1cclxuLyoqXHJcbiAqIEl0ZXJhdGVzIHRocm91Z2ggdGhlIGxpc3QgYW5kIHJhaXNlcyBlYWNoIGV2ZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBldmVudExpc3RSYWlzZShldmVudExpc3QpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRMaXN0LmV2ZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IGV2ZW50TGlzdC5ldmVudHNbaV07XHJcbiAgICAgICAgaWYgKGV2ZW50RGF0YSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBldmVudExpc3QuZXZlbnRzW2ldID0gbnVsbDtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnRGbiA9IGV2ZW50RGF0YS5nZXRFdmVudFJ1bm5lcigpO1xyXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICBsb2coJ2V2ZW50OiAnICsgZXZlbnREYXRhLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV4Y2VwdGlvbkd1YXJkKGV2ZW50Rm4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBJTlRFUlJVUFRfUkVBU09OID0gJ3JlcG9faW50ZXJydXB0JztcclxuLyoqXHJcbiAqIElmIGEgdHJhbnNhY3Rpb24gZG9lcyBub3Qgc3VjY2VlZCBhZnRlciAyNSByZXRyaWVzLCB3ZSBhYm9ydCBpdC4gQW1vbmcgb3RoZXJcclxuICogdGhpbmdzIHRoaXMgZW5zdXJlIHRoYXQgaWYgdGhlcmUncyBldmVyIGEgYnVnIGNhdXNpbmcgYSBtaXNtYXRjaCBiZXR3ZWVuXHJcbiAqIGNsaWVudCAvIHNlcnZlciBoYXNoZXMgZm9yIHNvbWUgZGF0YSwgd2Ugd29uJ3QgcmV0cnkgaW5kZWZpbml0ZWx5LlxyXG4gKi9cclxuY29uc3QgTUFYX1RSQU5TQUNUSU9OX1JFVFJJRVMgPSAyNTtcclxuLyoqXHJcbiAqIEEgY29ubmVjdGlvbiB0byBhIHNpbmdsZSBkYXRhIHJlcG9zaXRvcnkuXHJcbiAqL1xyXG5jbGFzcyBSZXBvIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlcG9JbmZvXywgZm9yY2VSZXN0Q2xpZW50XywgYXV0aFRva2VuUHJvdmlkZXJfLCBhcHBDaGVja1Byb3ZpZGVyXykge1xyXG4gICAgICAgIHRoaXMucmVwb0luZm9fID0gcmVwb0luZm9fO1xyXG4gICAgICAgIHRoaXMuZm9yY2VSZXN0Q2xpZW50XyA9IGZvcmNlUmVzdENsaWVudF87XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5Qcm92aWRlcl8gPSBhdXRoVG9rZW5Qcm92aWRlcl87XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Byb3ZpZGVyXyA9IGFwcENoZWNrUHJvdmlkZXJfO1xyXG4gICAgICAgIHRoaXMuZGF0YVVwZGF0ZUNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLnN0YXRzTGlzdGVuZXJfID0gbnVsbDtcclxuICAgICAgICB0aGlzLmV2ZW50UXVldWVfID0gbmV3IEV2ZW50UXVldWUoKTtcclxuICAgICAgICB0aGlzLm5leHRXcml0ZUlkXyA9IDE7XHJcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRTZXJ2ZXJEYXRhQ2FsbGJhY2tfID0gbnVsbDtcclxuICAgICAgICAvKiogQSBsaXN0IG9mIGRhdGEgcGllY2VzIGFuZCBwYXRocyB0byBiZSBzZXQgd2hlbiB0aGlzIGNsaWVudCBkaXNjb25uZWN0cy4gKi9cclxuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBuZXdTcGFyc2VTbmFwc2hvdFRyZWUoKTtcclxuICAgICAgICAvKiogU3RvcmVzIHF1ZXVlcyBvZiBvdXRzdGFuZGluZyB0cmFuc2FjdGlvbnMgZm9yIEZpcmViYXNlIGxvY2F0aW9ucy4gKi9cclxuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uUXVldWVUcmVlXyA9IG5ldyBUcmVlKCk7XHJcbiAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgYmUgQHByaXZhdGUgYnV0IGl0J3MgdXNlZCBieSB0ZXN0X2FjY2Vzcy5qcyBhbmQgaW50ZXJuYWwuanNcclxuICAgICAgICB0aGlzLnBlcnNpc3RlbnRDb25uZWN0aW9uXyA9IG51bGw7XHJcbiAgICAgICAgLy8gVGhpcyBrZXkgaXMgaW50ZW50aW9uYWxseSBub3QgdXBkYXRlZCBpZiBSZXBvSW5mbyBpcyBsYXRlciBjaGFuZ2VkIG9yIHJlcGxhY2VkXHJcbiAgICAgICAgdGhpcy5rZXkgPSB0aGlzLnJlcG9JbmZvXy50b1VSTFN0cmluZygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgVVJMIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHJvb3Qgb2YgdGhpcyBGaXJlYmFzZS5cclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICgodGhpcy5yZXBvSW5mb18uc2VjdXJlID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJykgKyB0aGlzLnJlcG9JbmZvXy5ob3N0KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXBvU3RhcnQocmVwbywgYXBwSWQsIGF1dGhPdmVycmlkZSkge1xyXG4gICAgcmVwby5zdGF0c18gPSBzdGF0c01hbmFnZXJHZXRDb2xsZWN0aW9uKHJlcG8ucmVwb0luZm9fKTtcclxuICAgIGlmIChyZXBvLmZvcmNlUmVzdENsaWVudF8gfHwgYmVpbmdDcmF3bGVkKCkpIHtcclxuICAgICAgICByZXBvLnNlcnZlcl8gPSBuZXcgUmVhZG9ubHlSZXN0Q2xpZW50KHJlcG8ucmVwb0luZm9fLCAocGF0aFN0cmluZywgZGF0YSwgaXNNZXJnZSwgdGFnKSA9PiB7XHJcbiAgICAgICAgICAgIHJlcG9PbkRhdGFVcGRhdGUocmVwbywgcGF0aFN0cmluZywgZGF0YSwgaXNNZXJnZSwgdGFnKTtcclxuICAgICAgICB9LCByZXBvLmF1dGhUb2tlblByb3ZpZGVyXywgcmVwby5hcHBDaGVja1Byb3ZpZGVyXyk7XHJcbiAgICAgICAgLy8gTWlub3IgaGFjazogRmlyZSBvbkNvbm5lY3QgaW1tZWRpYXRlbHksIHNpbmNlIHRoZXJlJ3Mgbm8gYWN0dWFsIGNvbm5lY3Rpb24uXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXBvT25Db25uZWN0U3RhdHVzKHJlcG8sIC8qIGNvbm5lY3RTdGF0dXM9ICovIHRydWUpLCAwKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFZhbGlkYXRlIGF1dGhPdmVycmlkZVxyXG4gICAgICAgIGlmICh0eXBlb2YgYXV0aE92ZXJyaWRlICE9PSAndW5kZWZpbmVkJyAmJiBhdXRoT3ZlcnJpZGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhdXRoT3ZlcnJpZGUgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb2JqZWN0cyBhcmUgc3VwcG9ydGVkIGZvciBvcHRpb24gZGF0YWJhc2VBdXRoVmFyaWFibGVPdmVycmlkZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoYXV0aE92ZXJyaWRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGF1dGhPdmVycmlkZSBwcm92aWRlZDogJyArIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fID0gbmV3IFBlcnNpc3RlbnRDb25uZWN0aW9uKHJlcG8ucmVwb0luZm9fLCBhcHBJZCwgKHBhdGhTdHJpbmcsIGRhdGEsIGlzTWVyZ2UsIHRhZykgPT4ge1xyXG4gICAgICAgICAgICByZXBvT25EYXRhVXBkYXRlKHJlcG8sIHBhdGhTdHJpbmcsIGRhdGEsIGlzTWVyZ2UsIHRhZyk7XHJcbiAgICAgICAgfSwgKGNvbm5lY3RTdGF0dXMpID0+IHtcclxuICAgICAgICAgICAgcmVwb09uQ29ubmVjdFN0YXR1cyhyZXBvLCBjb25uZWN0U3RhdHVzKTtcclxuICAgICAgICB9LCAodXBkYXRlcykgPT4ge1xyXG4gICAgICAgICAgICByZXBvT25TZXJ2ZXJJbmZvVXBkYXRlKHJlcG8sIHVwZGF0ZXMpO1xyXG4gICAgICAgIH0sIHJlcG8uYXV0aFRva2VuUHJvdmlkZXJfLCByZXBvLmFwcENoZWNrUHJvdmlkZXJfLCBhdXRoT3ZlcnJpZGUpO1xyXG4gICAgICAgIHJlcG8uc2VydmVyXyA9IHJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fO1xyXG4gICAgfVxyXG4gICAgcmVwby5hdXRoVG9rZW5Qcm92aWRlcl8uYWRkVG9rZW5DaGFuZ2VMaXN0ZW5lcih0b2tlbiA9PiB7XHJcbiAgICAgICAgcmVwby5zZXJ2ZXJfLnJlZnJlc2hBdXRoVG9rZW4odG9rZW4pO1xyXG4gICAgfSk7XHJcbiAgICByZXBvLmFwcENoZWNrUHJvdmlkZXJfLmFkZFRva2VuQ2hhbmdlTGlzdGVuZXIocmVzdWx0ID0+IHtcclxuICAgICAgICByZXBvLnNlcnZlcl8ucmVmcmVzaEFwcENoZWNrVG9rZW4ocmVzdWx0LnRva2VuKTtcclxuICAgIH0pO1xyXG4gICAgLy8gSW4gdGhlIGNhc2Ugb2YgbXVsdGlwbGUgUmVwb3MgZm9yIHRoZSBzYW1lIHJlcG9JbmZvIChpLmUuIHRoZXJlIGFyZSBtdWx0aXBsZSBGaXJlYmFzZS5Db250ZXh0cyBiZWluZyB1c2VkKSxcclxuICAgIC8vIHdlIG9ubHkgd2FudCB0byBjcmVhdGUgb25lIFN0YXRzUmVwb3J0ZXIuICBBcyBzdWNoLCB3ZSdsbCByZXBvcnQgc3RhdHMgb3ZlciB0aGUgZmlyc3QgUmVwbyBjcmVhdGVkLlxyXG4gICAgcmVwby5zdGF0c1JlcG9ydGVyXyA9IHN0YXRzTWFuYWdlckdldE9yQ3JlYXRlUmVwb3J0ZXIocmVwby5yZXBvSW5mb18sICgpID0+IG5ldyBTdGF0c1JlcG9ydGVyKHJlcG8uc3RhdHNfLCByZXBvLnNlcnZlcl8pKTtcclxuICAgIC8vIFVzZWQgZm9yIC5pbmZvLlxyXG4gICAgcmVwby5pbmZvRGF0YV8gPSBuZXcgU25hcHNob3RIb2xkZXIoKTtcclxuICAgIHJlcG8uaW5mb1N5bmNUcmVlXyA9IG5ldyBTeW5jVHJlZSh7XHJcbiAgICAgICAgc3RhcnRMaXN0ZW5pbmc6IChxdWVyeSwgdGFnLCBjdXJyZW50SGFzaEZuLCBvbkNvbXBsZXRlKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBpbmZvRXZlbnRzID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSByZXBvLmluZm9EYXRhXy5nZXROb2RlKHF1ZXJ5Ll9wYXRoKTtcclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBwb3NzaWJseSBhIGhhY2ssIGJ1dCB3ZSBoYXZlIGRpZmZlcmVudCBzZW1hbnRpY3MgZm9yIC5pbmZvIGVuZHBvaW50cy4gV2UgZG9uJ3QgcmFpc2UgbnVsbCBldmVudHNcclxuICAgICAgICAgICAgLy8gb24gaW5pdGlhbCBkYXRhLi4uXHJcbiAgICAgICAgICAgIGlmICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIGluZm9FdmVudHMgPSBzeW5jVHJlZUFwcGx5U2VydmVyT3ZlcndyaXRlKHJlcG8uaW5mb1N5bmNUcmVlXywgcXVlcnkuX3BhdGgsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZSgnb2snKTtcclxuICAgICAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpbmZvRXZlbnRzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RvcExpc3RlbmluZzogKCkgPT4geyB9XHJcbiAgICB9KTtcclxuICAgIHJlcG9VcGRhdGVJbmZvKHJlcG8sICdjb25uZWN0ZWQnLCBmYWxzZSk7XHJcbiAgICByZXBvLnNlcnZlclN5bmNUcmVlXyA9IG5ldyBTeW5jVHJlZSh7XHJcbiAgICAgICAgc3RhcnRMaXN0ZW5pbmc6IChxdWVyeSwgdGFnLCBjdXJyZW50SGFzaEZuLCBvbkNvbXBsZXRlKSA9PiB7XHJcbiAgICAgICAgICAgIHJlcG8uc2VydmVyXy5saXN0ZW4ocXVlcnksIGN1cnJlbnRIYXNoRm4sIHRhZywgKHN0YXR1cywgZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gb25Db21wbGV0ZShzdGF0dXMsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgcXVlcnkuX3BhdGgsIGV2ZW50cyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBObyBzeW5jaHJvbm91cyBldmVudHMgZm9yIG5ldHdvcmstYmFja2VkIHN5bmMgdHJlZXNcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RvcExpc3RlbmluZzogKHF1ZXJ5LCB0YWcpID0+IHtcclxuICAgICAgICAgICAgcmVwby5zZXJ2ZXJfLnVubGlzdGVuKHF1ZXJ5LCB0YWcpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMsIHRha2luZyB0aGUgc2VydmVyIG9mZnNldCBpbnRvIGFjY291bnQgaWYgd2UgaGF2ZSBvbmUuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvU2VydmVyVGltZShyZXBvKSB7XHJcbiAgICBjb25zdCBvZmZzZXROb2RlID0gcmVwby5pbmZvRGF0YV8uZ2V0Tm9kZShuZXcgUGF0aCgnLmluZm8vc2VydmVyVGltZU9mZnNldCcpKTtcclxuICAgIGNvbnN0IG9mZnNldCA9IG9mZnNldE5vZGUudmFsKCkgfHwgMDtcclxuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIG9mZnNldDtcclxufVxyXG4vKipcclxuICogR2VuZXJhdGUgU2VydmVyVmFsdWVzIHVzaW5nIHNvbWUgdmFyaWFibGVzIGZyb20gdGhlIHJlcG8gb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb0dlbmVyYXRlU2VydmVyVmFsdWVzKHJlcG8pIHtcclxuICAgIHJldHVybiBnZW5lcmF0ZVdpdGhWYWx1ZXMoe1xyXG4gICAgICAgIHRpbWVzdGFtcDogcmVwb1NlcnZlclRpbWUocmVwbylcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBDYWxsZWQgYnkgcmVhbHRpbWUgd2hlbiB3ZSBnZXQgbmV3IG1lc3NhZ2VzIGZyb20gdGhlIHNlcnZlci5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9PbkRhdGFVcGRhdGUocmVwbywgcGF0aFN0cmluZywgZGF0YSwgaXNNZXJnZSwgdGFnKSB7XHJcbiAgICAvLyBGb3IgdGVzdGluZy5cclxuICAgIHJlcG8uZGF0YVVwZGF0ZUNvdW50Kys7XHJcbiAgICBjb25zdCBwYXRoID0gbmV3IFBhdGgocGF0aFN0cmluZyk7XHJcbiAgICBkYXRhID0gcmVwby5pbnRlcmNlcHRTZXJ2ZXJEYXRhQ2FsbGJhY2tfXHJcbiAgICAgICAgPyByZXBvLmludGVyY2VwdFNlcnZlckRhdGFDYWxsYmFja18ocGF0aFN0cmluZywgZGF0YSlcclxuICAgICAgICA6IGRhdGE7XHJcbiAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICBpZiAodGFnKSB7XHJcbiAgICAgICAgaWYgKGlzTWVyZ2UpIHtcclxuICAgICAgICAgICAgY29uc3QgdGFnZ2VkQ2hpbGRyZW4gPSBtYXAoZGF0YSwgKHJhdykgPT4gbm9kZUZyb21KU09OKHJhdykpO1xyXG4gICAgICAgICAgICBldmVudHMgPSBzeW5jVHJlZUFwcGx5VGFnZ2VkUXVlcnlNZXJnZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgdGFnZ2VkQ2hpbGRyZW4sIHRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB0YWdnZWRTbmFwID0gbm9kZUZyb21KU09OKGRhdGEpO1xyXG4gICAgICAgICAgICBldmVudHMgPSBzeW5jVHJlZUFwcGx5VGFnZ2VkUXVlcnlPdmVyd3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIHRhZ2dlZFNuYXAsIHRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNNZXJnZSkge1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZWRDaGlsZHJlbiA9IG1hcChkYXRhLCAocmF3KSA9PiBub2RlRnJvbUpTT04ocmF3KSk7XHJcbiAgICAgICAgZXZlbnRzID0gc3luY1RyZWVBcHBseVNlcnZlck1lcmdlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgc25hcCA9IG5vZGVGcm9tSlNPTihkYXRhKTtcclxuICAgICAgICBldmVudHMgPSBzeW5jVHJlZUFwcGx5U2VydmVyT3ZlcndyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBwYXRoLCBzbmFwKTtcclxuICAgIH1cclxuICAgIGxldCBhZmZlY3RlZFBhdGggPSBwYXRoO1xyXG4gICAgaWYgKGV2ZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gU2luY2Ugd2UgaGF2ZSBhIGxpc3RlbmVyIG91dHN0YW5kaW5nIGZvciBlYWNoIHRyYW5zYWN0aW9uLCByZWNlaXZpbmcgYW55IGV2ZW50c1xyXG4gICAgICAgIC8vIGlzIGEgcHJveHkgZm9yIHNvbWUgY2hhbmdlIGhhdmluZyBvY2N1cnJlZC5cclxuICAgICAgICBhZmZlY3RlZFBhdGggPSByZXBvUmVydW5UcmFuc2FjdGlvbnMocmVwbywgcGF0aCk7XHJcbiAgICB9XHJcbiAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBhZmZlY3RlZFBhdGgsIGV2ZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb09uQ29ubmVjdFN0YXR1cyhyZXBvLCBjb25uZWN0U3RhdHVzKSB7XHJcbiAgICByZXBvVXBkYXRlSW5mbyhyZXBvLCAnY29ubmVjdGVkJywgY29ubmVjdFN0YXR1cyk7XHJcbiAgICBpZiAoY29ubmVjdFN0YXR1cyA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXBvUnVuT25EaXNjb25uZWN0RXZlbnRzKHJlcG8pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlcG9PblNlcnZlckluZm9VcGRhdGUocmVwbywgdXBkYXRlcykge1xyXG4gICAgZWFjaCh1cGRhdGVzLCAoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHJlcG9VcGRhdGVJbmZvKHJlcG8sIGtleSwgdmFsdWUpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb1VwZGF0ZUluZm8ocmVwbywgcGF0aFN0cmluZywgdmFsdWUpIHtcclxuICAgIGNvbnN0IHBhdGggPSBuZXcgUGF0aCgnLy5pbmZvLycgKyBwYXRoU3RyaW5nKTtcclxuICAgIGNvbnN0IG5ld05vZGUgPSBub2RlRnJvbUpTT04odmFsdWUpO1xyXG4gICAgcmVwby5pbmZvRGF0YV8udXBkYXRlU25hcHNob3QocGF0aCwgbmV3Tm9kZSk7XHJcbiAgICBjb25zdCBldmVudHMgPSBzeW5jVHJlZUFwcGx5U2VydmVyT3ZlcndyaXRlKHJlcG8uaW5mb1N5bmNUcmVlXywgcGF0aCwgbmV3Tm9kZSk7XHJcbiAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBwYXRoLCBldmVudHMpO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9HZXROZXh0V3JpdGVJZChyZXBvKSB7XHJcbiAgICByZXR1cm4gcmVwby5uZXh0V3JpdGVJZF8rKztcclxufVxyXG4vKipcclxuICogVGhlIHB1cnBvc2Ugb2YgYGdldFZhbHVlYCBpcyB0byByZXR1cm4gdGhlIGxhdGVzdCBrbm93biB2YWx1ZVxyXG4gKiBzYXRpc2Z5aW5nIGBxdWVyeWAuXHJcbiAqXHJcbiAqIFRoaXMgbWV0aG9kIHdpbGwgZmlyc3QgY2hlY2sgZm9yIGluLW1lbW9yeSBjYWNoZWQgdmFsdWVzXHJcbiAqIGJlbG9uZ2luZyB0byBhY3RpdmUgbGlzdGVuZXJzLiBJZiB0aGV5IGFyZSBmb3VuZCwgc3VjaCB2YWx1ZXNcclxuICogYXJlIGNvbnNpZGVyZWQgdG8gYmUgdGhlIG1vc3QgdXAtdG8tZGF0ZS5cclxuICpcclxuICogSWYgdGhlIGNsaWVudCBpcyBub3QgY29ubmVjdGVkLCB0aGlzIG1ldGhvZCB3aWxsIHdhaXQgdW50aWwgdGhlXHJcbiAqICByZXBvIGhhcyBlc3RhYmxpc2hlZCBhIGNvbm5lY3Rpb24gYW5kIHRoZW4gcmVxdWVzdCB0aGUgdmFsdWUgZm9yIGBxdWVyeWAuXHJcbiAqIElmIHRoZSBjbGllbnQgaXMgbm90IGFibGUgdG8gcmV0cmlldmUgdGhlIHF1ZXJ5IHJlc3VsdCBmb3IgYW5vdGhlciByZWFzb24sXHJcbiAqIGl0IHJlcG9ydHMgYW4gZXJyb3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSB0byBzdXJmYWNlIGEgdmFsdWUgZm9yLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb0dldFZhbHVlKHJlcG8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbikge1xyXG4gICAgLy8gT25seSBhY3RpdmUgcXVlcmllcyBhcmUgY2FjaGVkLiBUaGVyZSBpcyBubyBwZXJzaXN0ZWQgY2FjaGUuXHJcbiAgICBjb25zdCBjYWNoZWQgPSBzeW5jVHJlZUdldFNlcnZlclZhbHVlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBxdWVyeSk7XHJcbiAgICBpZiAoY2FjaGVkICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVwby5zZXJ2ZXJfLmdldChxdWVyeSkudGhlbihwYXlsb2FkID0+IHtcclxuICAgICAgICBjb25zdCBub2RlID0gbm9kZUZyb21KU09OKHBheWxvYWQpLndpdGhJbmRleChxdWVyeS5fcXVlcnlQYXJhbXMuZ2V0SW5kZXgoKSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmVsb3cgd2Ugc2ltdWxhdGUgdGhlIGFjdGlvbnMgb2YgYW4gYG9ubHlPbmNlYCBgb25WYWx1ZSgpYCBldmVudCB3aGVyZTpcclxuICAgICAgICAgKiBBZGQgYW4gZXZlbnQgcmVnaXN0cmF0aW9uLFxyXG4gICAgICAgICAqIFVwZGF0ZSBkYXRhIGF0IHRoZSBwYXRoLFxyXG4gICAgICAgICAqIFJhaXNlIGFueSBldmVudHMsXHJcbiAgICAgICAgICogQ2xlYW51cCB0aGUgU3luY1RyZWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBzeW5jVHJlZUFkZEV2ZW50UmVnaXN0cmF0aW9uKHJlcG8uc2VydmVyU3luY1RyZWVfLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24sIHRydWUpO1xyXG4gICAgICAgIGxldCBldmVudHM7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKSkge1xyXG4gICAgICAgICAgICBldmVudHMgPSBzeW5jVHJlZUFwcGx5U2VydmVyT3ZlcndyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBxdWVyeS5fcGF0aCwgbm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB0YWcgPSBzeW5jVHJlZVRhZ0ZvclF1ZXJ5KHJlcG8uc2VydmVyU3luY1RyZWVfLCBxdWVyeSk7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IHN5bmNUcmVlQXBwbHlUYWdnZWRRdWVyeU92ZXJ3cml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcXVlcnkuX3BhdGgsIG5vZGUsIHRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogV2UgbmVlZCB0byByYWlzZSBldmVudHMgaW4gdGhlIHNjZW5hcmlvIHdoZXJlIGBnZXQoKWAgaXMgY2FsbGVkIGF0IGEgcGFyZW50IHBhdGgsIGFuZFxyXG4gICAgICAgICAqIHdoaWxlIHRoZSBgZ2V0KClgIGlzIHBlbmRpbmcsIGBvblZhbHVlYCBpcyBjYWxsZWQgYXQgYSBjaGlsZCBsb2NhdGlvbi4gV2hpbGUgZ2V0KCkgaXMgd2FpdGluZ1xyXG4gICAgICAgICAqIGZvciB0aGUgZGF0YSwgYG9uVmFsdWVgIHdpbGwgcmVnaXN0ZXIgYSBuZXcgZXZlbnQuIFRoZW4sIGdldCgpIHdpbGwgY29tZSBiYWNrLCBhbmQgdXBkYXRlIHRoZSBzeW5jVHJlZVxyXG4gICAgICAgICAqIGFuZCBpdHMgY29ycmVzcG9uZGluZyBzZXJ2ZXJDYWNoZSwgaW5jbHVkaW5nIHRoZSBjaGlsZCBsb2NhdGlvbiB3aGVyZSBgb25WYWx1ZWAgaXMgY2FsbGVkLiBUaGVuLFxyXG4gICAgICAgICAqIGBvblZhbHVlYCB3aWxsIHJlY2VpdmUgdGhlIGV2ZW50IGZyb20gdGhlIHNlcnZlciwgYnV0IGxvb2sgYXQgdGhlIHN5bmNUcmVlIGFuZCBzZWUgdGhhdCB0aGUgZGF0YSByZWNlaXZlZFxyXG4gICAgICAgICAqIGZyb20gdGhlIHNlcnZlciBpcyBhbHJlYWR5IGF0IHRoZSBTeW5jUG9pbnQsIGFuZCBzbyB0aGUgYG9uVmFsdWVgIGNhbGxiYWNrIHdpbGwgbmV2ZXIgZ2V0IGZpcmVkLlxyXG4gICAgICAgICAqIENhbGxpbmcgYGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKClgIGlzIHRoZSBjb3JyZWN0IHdheSB0byBwcm9wYWdhdGUgdGhlIGV2ZW50cyBhbmRcclxuICAgICAgICAgKiBlbnN1cmUgdGhlIGNvcnJlc3BvbmRpbmcgY2hpbGQgZXZlbnRzIHdpbGwgZ2V0IGZpcmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHF1ZXJ5Ll9wYXRoLCBldmVudHMpO1xyXG4gICAgICAgIHN5bmNUcmVlUmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24ocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgbnVsbCwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9LCBlcnIgPT4ge1xyXG4gICAgICAgIHJlcG9Mb2cocmVwbywgJ2dldCBmb3IgcXVlcnkgJyArIHN0cmluZ2lmeShxdWVyeSkgKyAnIGZhaWxlZDogJyArIGVycik7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihlcnIpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9TZXRXaXRoUHJpb3JpdHkocmVwbywgcGF0aCwgbmV3VmFsLCBuZXdQcmlvcml0eSwgb25Db21wbGV0ZSkge1xyXG4gICAgcmVwb0xvZyhyZXBvLCAnc2V0Jywge1xyXG4gICAgICAgIHBhdGg6IHBhdGgudG9TdHJpbmcoKSxcclxuICAgICAgICB2YWx1ZTogbmV3VmFsLFxyXG4gICAgICAgIHByaW9yaXR5OiBuZXdQcmlvcml0eVxyXG4gICAgfSk7XHJcbiAgICAvLyBUT0RPOiBPcHRpbWl6ZSB0aGlzIGJlaGF2aW9yIHRvIGVpdGhlciAoYSkgc3RvcmUgZmxhZyB0byBza2lwIHJlc29sdmluZyB3aGVyZSBwb3NzaWJsZSBhbmQgLyBvclxyXG4gICAgLy8gKGIpIHN0b3JlIHVucmVzb2x2ZWQgcGF0aHMgb24gSlNPTiBwYXJzZVxyXG4gICAgY29uc3Qgc2VydmVyVmFsdWVzID0gcmVwb0dlbmVyYXRlU2VydmVyVmFsdWVzKHJlcG8pO1xyXG4gICAgY29uc3QgbmV3Tm9kZVVucmVzb2x2ZWQgPSBub2RlRnJvbUpTT04obmV3VmFsLCBuZXdQcmlvcml0eSk7XHJcbiAgICBjb25zdCBleGlzdGluZyA9IHN5bmNUcmVlQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCk7XHJcbiAgICBjb25zdCBuZXdOb2RlID0gcmVzb2x2ZURlZmVycmVkVmFsdWVTbmFwc2hvdChuZXdOb2RlVW5yZXNvbHZlZCwgZXhpc3RpbmcsIHNlcnZlclZhbHVlcyk7XHJcbiAgICBjb25zdCB3cml0ZUlkID0gcmVwb0dldE5leHRXcml0ZUlkKHJlcG8pO1xyXG4gICAgY29uc3QgZXZlbnRzID0gc3luY1RyZWVBcHBseVVzZXJPdmVyd3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIG5ld05vZGUsIHdyaXRlSWQsIHRydWUpO1xyXG4gICAgZXZlbnRRdWV1ZVF1ZXVlRXZlbnRzKHJlcG8uZXZlbnRRdWV1ZV8sIGV2ZW50cyk7XHJcbiAgICByZXBvLnNlcnZlcl8ucHV0KHBhdGgudG9TdHJpbmcoKSwgbmV3Tm9kZVVucmVzb2x2ZWQudmFsKC8qZXhwb3J0PSovIHRydWUpLCAoc3RhdHVzLCBlcnJvclJlYXNvbikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBzdGF0dXMgPT09ICdvayc7XHJcbiAgICAgICAgaWYgKCFzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgIHdhcm4oJ3NldCBhdCAnICsgcGF0aCArICcgZmFpbGVkOiAnICsgc3RhdHVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2xlYXJFdmVudHMgPSBzeW5jVHJlZUFja1VzZXJXcml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgd3JpdGVJZCwgIXN1Y2Nlc3MpO1xyXG4gICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHBhdGgsIGNsZWFyRXZlbnRzKTtcclxuICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcclxuICAgIH0pO1xyXG4gICAgY29uc3QgYWZmZWN0ZWRQYXRoID0gcmVwb0Fib3J0VHJhbnNhY3Rpb25zKHJlcG8sIHBhdGgpO1xyXG4gICAgcmVwb1JlcnVuVHJhbnNhY3Rpb25zKHJlcG8sIGFmZmVjdGVkUGF0aCk7XHJcbiAgICAvLyBXZSBxdWV1ZWQgdGhlIGV2ZW50cyBhYm92ZSwgc28ganVzdCBmbHVzaCB0aGUgcXVldWUgaGVyZVxyXG4gICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgYWZmZWN0ZWRQYXRoLCBbXSk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb1VwZGF0ZShyZXBvLCBwYXRoLCBjaGlsZHJlblRvTWVyZ2UsIG9uQ29tcGxldGUpIHtcclxuICAgIHJlcG9Mb2cocmVwbywgJ3VwZGF0ZScsIHsgcGF0aDogcGF0aC50b1N0cmluZygpLCB2YWx1ZTogY2hpbGRyZW5Ub01lcmdlIH0pO1xyXG4gICAgLy8gU3RhcnQgd2l0aCBvdXIgZXhpc3RpbmcgZGF0YSBhbmQgbWVyZ2UgZWFjaCBjaGlsZCBpbnRvIGl0LlxyXG4gICAgbGV0IGVtcHR5ID0gdHJ1ZTtcclxuICAgIGNvbnN0IHNlcnZlclZhbHVlcyA9IHJlcG9HZW5lcmF0ZVNlcnZlclZhbHVlcyhyZXBvKTtcclxuICAgIGNvbnN0IGNoYW5nZWRDaGlsZHJlbiA9IHt9O1xyXG4gICAgZWFjaChjaGlsZHJlblRvTWVyZ2UsIChjaGFuZ2VkS2V5LCBjaGFuZ2VkVmFsdWUpID0+IHtcclxuICAgICAgICBlbXB0eSA9IGZhbHNlO1xyXG4gICAgICAgIGNoYW5nZWRDaGlsZHJlbltjaGFuZ2VkS2V5XSA9IHJlc29sdmVEZWZlcnJlZFZhbHVlVHJlZShwYXRoQ2hpbGQocGF0aCwgY2hhbmdlZEtleSksIG5vZGVGcm9tSlNPTihjaGFuZ2VkVmFsdWUpLCByZXBvLnNlcnZlclN5bmNUcmVlXywgc2VydmVyVmFsdWVzKTtcclxuICAgIH0pO1xyXG4gICAgaWYgKCFlbXB0eSkge1xyXG4gICAgICAgIGNvbnN0IHdyaXRlSWQgPSByZXBvR2V0TmV4dFdyaXRlSWQocmVwbyk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRzID0gc3luY1RyZWVBcHBseVVzZXJNZXJnZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgY2hhbmdlZENoaWxkcmVuLCB3cml0ZUlkKTtcclxuICAgICAgICBldmVudFF1ZXVlUXVldWVFdmVudHMocmVwby5ldmVudFF1ZXVlXywgZXZlbnRzKTtcclxuICAgICAgICByZXBvLnNlcnZlcl8ubWVyZ2UocGF0aC50b1N0cmluZygpLCBjaGlsZHJlblRvTWVyZ2UsIChzdGF0dXMsIGVycm9yUmVhc29uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBzdGF0dXMgPT09ICdvayc7XHJcbiAgICAgICAgICAgIGlmICghc3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgd2FybigndXBkYXRlIGF0ICcgKyBwYXRoICsgJyBmYWlsZWQ6ICcgKyBzdGF0dXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNsZWFyRXZlbnRzID0gc3luY1RyZWVBY2tVc2VyV3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHdyaXRlSWQsICFzdWNjZXNzKTtcclxuICAgICAgICAgICAgY29uc3QgYWZmZWN0ZWRQYXRoID0gY2xlYXJFdmVudHMubGVuZ3RoID4gMCA/IHJlcG9SZXJ1blRyYW5zYWN0aW9ucyhyZXBvLCBwYXRoKSA6IHBhdGg7XHJcbiAgICAgICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIGFmZmVjdGVkUGF0aCwgY2xlYXJFdmVudHMpO1xyXG4gICAgICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBlYWNoKGNoaWxkcmVuVG9NZXJnZSwgKGNoYW5nZWRQYXRoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFmZmVjdGVkUGF0aCA9IHJlcG9BYm9ydFRyYW5zYWN0aW9ucyhyZXBvLCBwYXRoQ2hpbGQocGF0aCwgY2hhbmdlZFBhdGgpKTtcclxuICAgICAgICAgICAgcmVwb1JlcnVuVHJhbnNhY3Rpb25zKHJlcG8sIGFmZmVjdGVkUGF0aCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gV2UgcXVldWVkIHRoZSBldmVudHMgYWJvdmUsIHNvIGp1c3QgZmx1c2ggdGhlIHF1ZXVlIGhlcmVcclxuICAgICAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBwYXRoLCBbXSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsb2coXCJ1cGRhdGUoKSBjYWxsZWQgd2l0aCBlbXB0eSBkYXRhLiAgRG9uJ3QgZG8gYW55dGhpbmcuXCIpO1xyXG4gICAgICAgIHJlcG9DYWxsT25Db21wbGV0ZUNhbGxiYWNrKHJlcG8sIG9uQ29tcGxldGUsICdvaycsIHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgYWxsIG9mIHRoZSBjaGFuZ2VzIHN0b3JlZCB1cCBpbiB0aGUgb25EaXNjb25uZWN0XyB0cmVlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb1J1bk9uRGlzY29ubmVjdEV2ZW50cyhyZXBvKSB7XHJcbiAgICByZXBvTG9nKHJlcG8sICdvbkRpc2Nvbm5lY3RFdmVudHMnKTtcclxuICAgIGNvbnN0IHNlcnZlclZhbHVlcyA9IHJlcG9HZW5lcmF0ZVNlcnZlclZhbHVlcyhyZXBvKTtcclxuICAgIGNvbnN0IHJlc29sdmVkT25EaXNjb25uZWN0VHJlZSA9IG5ld1NwYXJzZVNuYXBzaG90VHJlZSgpO1xyXG4gICAgc3BhcnNlU25hcHNob3RUcmVlRm9yRWFjaFRyZWUocmVwby5vbkRpc2Nvbm5lY3RfLCBuZXdFbXB0eVBhdGgoKSwgKHBhdGgsIG5vZGUpID0+IHtcclxuICAgICAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVEZWZlcnJlZFZhbHVlVHJlZShwYXRoLCBub2RlLCByZXBvLnNlcnZlclN5bmNUcmVlXywgc2VydmVyVmFsdWVzKTtcclxuICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWVSZW1lbWJlcihyZXNvbHZlZE9uRGlzY29ubmVjdFRyZWUsIHBhdGgsIHJlc29sdmVkKTtcclxuICAgIH0pO1xyXG4gICAgbGV0IGV2ZW50cyA9IFtdO1xyXG4gICAgc3BhcnNlU25hcHNob3RUcmVlRm9yRWFjaFRyZWUocmVzb2x2ZWRPbkRpc2Nvbm5lY3RUcmVlLCBuZXdFbXB0eVBhdGgoKSwgKHBhdGgsIHNuYXApID0+IHtcclxuICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNUcmVlQXBwbHlTZXJ2ZXJPdmVyd3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIHNuYXApKTtcclxuICAgICAgICBjb25zdCBhZmZlY3RlZFBhdGggPSByZXBvQWJvcnRUcmFuc2FjdGlvbnMocmVwbywgcGF0aCk7XHJcbiAgICAgICAgcmVwb1JlcnVuVHJhbnNhY3Rpb25zKHJlcG8sIGFmZmVjdGVkUGF0aCk7XHJcbiAgICB9KTtcclxuICAgIHJlcG8ub25EaXNjb25uZWN0XyA9IG5ld1NwYXJzZVNuYXBzaG90VHJlZSgpO1xyXG4gICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgbmV3RW1wdHlQYXRoKCksIGV2ZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb09uRGlzY29ubmVjdENhbmNlbChyZXBvLCBwYXRoLCBvbkNvbXBsZXRlKSB7XHJcbiAgICByZXBvLnNlcnZlcl8ub25EaXNjb25uZWN0Q2FuY2VsKHBhdGgudG9TdHJpbmcoKSwgKHN0YXR1cywgZXJyb3JSZWFzb24pID0+IHtcclxuICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XHJcbiAgICAgICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZUZvcmdldChyZXBvLm9uRGlzY29ubmVjdF8sIHBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9PbkRpc2Nvbm5lY3RTZXQocmVwbywgcGF0aCwgdmFsdWUsIG9uQ29tcGxldGUpIHtcclxuICAgIGNvbnN0IG5ld05vZGUgPSBub2RlRnJvbUpTT04odmFsdWUpO1xyXG4gICAgcmVwby5zZXJ2ZXJfLm9uRGlzY29ubmVjdFB1dChwYXRoLnRvU3RyaW5nKCksIG5ld05vZGUudmFsKC8qZXhwb3J0PSovIHRydWUpLCAoc3RhdHVzLCBlcnJvclJlYXNvbikgPT4ge1xyXG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlUmVtZW1iZXIocmVwby5vbkRpc2Nvbm5lY3RfLCBwYXRoLCBuZXdOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVwb0NhbGxPbkNvbXBsZXRlQ2FsbGJhY2socmVwbywgb25Db21wbGV0ZSwgc3RhdHVzLCBlcnJvclJlYXNvbik7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZXBvT25EaXNjb25uZWN0U2V0V2l0aFByaW9yaXR5KHJlcG8sIHBhdGgsIHZhbHVlLCBwcmlvcml0eSwgb25Db21wbGV0ZSkge1xyXG4gICAgY29uc3QgbmV3Tm9kZSA9IG5vZGVGcm9tSlNPTih2YWx1ZSwgcHJpb3JpdHkpO1xyXG4gICAgcmVwby5zZXJ2ZXJfLm9uRGlzY29ubmVjdFB1dChwYXRoLnRvU3RyaW5nKCksIG5ld05vZGUudmFsKC8qZXhwb3J0PSovIHRydWUpLCAoc3RhdHVzLCBlcnJvclJlYXNvbikgPT4ge1xyXG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlUmVtZW1iZXIocmVwby5vbkRpc2Nvbm5lY3RfLCBwYXRoLCBuZXdOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVwb0NhbGxPbkNvbXBsZXRlQ2FsbGJhY2socmVwbywgb25Db21wbGV0ZSwgc3RhdHVzLCBlcnJvclJlYXNvbik7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZXBvT25EaXNjb25uZWN0VXBkYXRlKHJlcG8sIHBhdGgsIGNoaWxkcmVuVG9NZXJnZSwgb25Db21wbGV0ZSkge1xyXG4gICAgaWYgKGlzRW1wdHkoY2hpbGRyZW5Ub01lcmdlKSkge1xyXG4gICAgICAgIGxvZyhcIm9uRGlzY29ubmVjdCgpLnVwZGF0ZSgpIGNhbGxlZCB3aXRoIGVtcHR5IGRhdGEuICBEb24ndCBkbyBhbnl0aGluZy5cIik7XHJcbiAgICAgICAgcmVwb0NhbGxPbkNvbXBsZXRlQ2FsbGJhY2socmVwbywgb25Db21wbGV0ZSwgJ29rJywgdW5kZWZpbmVkKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICByZXBvLnNlcnZlcl8ub25EaXNjb25uZWN0TWVyZ2UocGF0aC50b1N0cmluZygpLCBjaGlsZHJlblRvTWVyZ2UsIChzdGF0dXMsIGVycm9yUmVhc29uKSA9PiB7XHJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICBlYWNoKGNoaWxkcmVuVG9NZXJnZSwgKGNoaWxkTmFtZSwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDaGlsZE5vZGUgPSBub2RlRnJvbUpTT04oY2hpbGROb2RlKTtcclxuICAgICAgICAgICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZVJlbWVtYmVyKHJlcG8ub25EaXNjb25uZWN0XywgcGF0aENoaWxkKHBhdGgsIGNoaWxkTmFtZSksIG5ld0NoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9BZGRFdmVudENhbGxiYWNrRm9yUXVlcnkocmVwbywgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uKSB7XHJcbiAgICBsZXQgZXZlbnRzO1xyXG4gICAgaWYgKHBhdGhHZXRGcm9udChxdWVyeS5fcGF0aCkgPT09ICcuaW5mbycpIHtcclxuICAgICAgICBldmVudHMgPSBzeW5jVHJlZUFkZEV2ZW50UmVnaXN0cmF0aW9uKHJlcG8uaW5mb1N5bmNUcmVlXywgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGV2ZW50cyA9IHN5bmNUcmVlQWRkRXZlbnRSZWdpc3RyYXRpb24ocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbik7XHJcbiAgICB9XHJcbiAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNBdFBhdGgocmVwby5ldmVudFF1ZXVlXywgcXVlcnkuX3BhdGgsIGV2ZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb1JlbW92ZUV2ZW50Q2FsbGJhY2tGb3JRdWVyeShyZXBvLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24pIHtcclxuICAgIC8vIFRoZXNlIGFyZSBndWFyYW50ZWVkIG5vdCB0byByYWlzZSBldmVudHMsIHNpbmNlIHdlJ3JlIG5vdCBwYXNzaW5nIGluIGEgY2FuY2VsRXJyb3IuIEhvd2V2ZXIsIHdlIGNhbiBmdXR1cmUtcHJvb2ZcclxuICAgIC8vIGEgbGl0dGxlIGJpdCBieSBoYW5kbGluZyB0aGUgcmV0dXJuIHZhbHVlcyBhbnl3YXlzLlxyXG4gICAgbGV0IGV2ZW50cztcclxuICAgIGlmIChwYXRoR2V0RnJvbnQocXVlcnkuX3BhdGgpID09PSAnLmluZm8nKSB7XHJcbiAgICAgICAgZXZlbnRzID0gc3luY1RyZWVSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbihyZXBvLmluZm9TeW5jVHJlZV8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBldmVudHMgPSBzeW5jVHJlZVJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHJlcG8uc2VydmVyU3luY1RyZWVfLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24pO1xyXG4gICAgfVxyXG4gICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzQXRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHF1ZXJ5Ll9wYXRoLCBldmVudHMpO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9JbnRlcnJ1cHQocmVwbykge1xyXG4gICAgaWYgKHJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fKSB7XHJcbiAgICAgICAgcmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8uaW50ZXJydXB0KElOVEVSUlVQVF9SRUFTT04pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlcG9SZXN1bWUocmVwbykge1xyXG4gICAgaWYgKHJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fKSB7XHJcbiAgICAgICAgcmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8ucmVzdW1lKElOVEVSUlVQVF9SRUFTT04pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlcG9Mb2cocmVwbywgLi4udmFyQXJncykge1xyXG4gICAgbGV0IHByZWZpeCA9ICcnO1xyXG4gICAgaWYgKHJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fKSB7XHJcbiAgICAgICAgcHJlZml4ID0gcmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8uaWQgKyAnOic7XHJcbiAgICB9XHJcbiAgICBsb2cocHJlZml4LCAuLi52YXJBcmdzKTtcclxufVxyXG5mdW5jdGlvbiByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBjYWxsYmFjaywgc3RhdHVzLCBlcnJvclJlYXNvbikge1xyXG4gICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgZXhjZXB0aW9uR3VhcmQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSAoc3RhdHVzIHx8ICdlcnJvcicpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IGNvZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JSZWFzb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9ICc6ICcgKyBlcnJvclJlYXNvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdHJhbnNhY3Rpb24sIGFkZHMgaXQgdG8gdGhlIHRyYW5zYWN0aW9ucyB3ZSdyZSB0cmFja2luZywgYW5kXHJcbiAqIHNlbmRzIGl0IHRvIHRoZSBzZXJ2ZXIgaWYgcG9zc2libGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoIC0gUGF0aCBhdCB3aGljaCB0byBkbyB0cmFuc2FjdGlvbi5cclxuICogQHBhcmFtIHRyYW5zYWN0aW9uVXBkYXRlIC0gVXBkYXRlIGNhbGxiYWNrLlxyXG4gKiBAcGFyYW0gb25Db21wbGV0ZSAtIENvbXBsZXRpb24gY2FsbGJhY2suXHJcbiAqIEBwYXJhbSB1bndhdGNoZXIgLSBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHRyYW5zYWN0aW9uIG5vIGxvbmdlclxyXG4gKiBuZWVkIGRhdGEgdXBkYXRlcyBmb3IgYHBhdGhgLlxyXG4gKiBAcGFyYW0gYXBwbHlMb2NhbGx5IC0gV2hldGhlciBvciBub3QgdG8gbWFrZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyB2aXNpYmxlXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvU3RhcnRUcmFuc2FjdGlvbihyZXBvLCBwYXRoLCB0cmFuc2FjdGlvblVwZGF0ZSwgb25Db21wbGV0ZSwgdW53YXRjaGVyLCBhcHBseUxvY2FsbHkpIHtcclxuICAgIHJlcG9Mb2cocmVwbywgJ3RyYW5zYWN0aW9uIG9uICcgKyBwYXRoKTtcclxuICAgIC8vIEluaXRpYWxpemUgdHJhbnNhY3Rpb24uXHJcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHtcclxuICAgICAgICBwYXRoLFxyXG4gICAgICAgIHVwZGF0ZTogdHJhbnNhY3Rpb25VcGRhdGUsXHJcbiAgICAgICAgb25Db21wbGV0ZSxcclxuICAgICAgICAvLyBPbmUgb2YgVHJhbnNhY3Rpb25TdGF0dXMgZW51bXMuXHJcbiAgICAgICAgc3RhdHVzOiBudWxsLFxyXG4gICAgICAgIC8vIFVzZWQgd2hlbiBjb21iaW5pbmcgdHJhbnNhY3Rpb25zIGF0IGRpZmZlcmVudCBsb2NhdGlvbnMgdG8gZmlndXJlIG91dFxyXG4gICAgICAgIC8vIHdoaWNoIG9uZSBnb2VzIGZpcnN0LlxyXG4gICAgICAgIG9yZGVyOiBMVUlER2VuZXJhdG9yKCksXHJcbiAgICAgICAgLy8gV2hldGhlciB0byByYWlzZSBsb2NhbCBldmVudHMgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXHJcbiAgICAgICAgYXBwbHlMb2NhbGx5LFxyXG4gICAgICAgIC8vIENvdW50IG9mIGhvdyBtYW55IHRpbWVzIHdlJ3ZlIHJldHJpZWQgdGhlIHRyYW5zYWN0aW9uLlxyXG4gICAgICAgIHJldHJ5Q291bnQ6IDAsXHJcbiAgICAgICAgLy8gRnVuY3Rpb24gdG8gY2FsbCB0byBjbGVhbiB1cCBvdXIgLm9uKCkgbGlzdGVuZXIuXHJcbiAgICAgICAgdW53YXRjaGVyLFxyXG4gICAgICAgIC8vIFN0b3JlcyB3aHkgYSB0cmFuc2FjdGlvbiB3YXMgYWJvcnRlZC5cclxuICAgICAgICBhYm9ydFJlYXNvbjogbnVsbCxcclxuICAgICAgICBjdXJyZW50V3JpdGVJZDogbnVsbCxcclxuICAgICAgICBjdXJyZW50SW5wdXRTbmFwc2hvdDogbnVsbCxcclxuICAgICAgICBjdXJyZW50T3V0cHV0U25hcHNob3RSYXc6IG51bGwsXHJcbiAgICAgICAgY3VycmVudE91dHB1dFNuYXBzaG90UmVzb2x2ZWQ6IG51bGxcclxuICAgIH07XHJcbiAgICAvLyBSdW4gdHJhbnNhY3Rpb24gaW5pdGlhbGx5LlxyXG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gcmVwb0dldExhdGVzdFN0YXRlKHJlcG8sIHBhdGgsIHVuZGVmaW5lZCk7XHJcbiAgICB0cmFuc2FjdGlvbi5jdXJyZW50SW5wdXRTbmFwc2hvdCA9IGN1cnJlbnRTdGF0ZTtcclxuICAgIGNvbnN0IG5ld1ZhbCA9IHRyYW5zYWN0aW9uLnVwZGF0ZShjdXJyZW50U3RhdGUudmFsKCkpO1xyXG4gICAgaWYgKG5ld1ZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgLy8gQWJvcnQgdHJhbnNhY3Rpb24uXHJcbiAgICAgICAgdHJhbnNhY3Rpb24udW53YXRjaGVyKCk7XHJcbiAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudE91dHB1dFNuYXBzaG90UmF3ID0gbnVsbDtcclxuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50T3V0cHV0U25hcHNob3RSZXNvbHZlZCA9IG51bGw7XHJcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLm9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25Db21wbGV0ZShudWxsLCBmYWxzZSwgdHJhbnNhY3Rpb24uY3VycmVudElucHV0U25hcHNob3QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhKCd0cmFuc2FjdGlvbiBmYWlsZWQ6IERhdGEgcmV0dXJuZWQgJywgbmV3VmFsLCB0cmFuc2FjdGlvbi5wYXRoKTtcclxuICAgICAgICAvLyBNYXJrIGFzIHJ1biBhbmQgYWRkIHRvIG91ciBxdWV1ZS5cclxuICAgICAgICB0cmFuc2FjdGlvbi5zdGF0dXMgPSAwIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlJVTiAqLztcclxuICAgICAgICBjb25zdCBxdWV1ZU5vZGUgPSB0cmVlU3ViVHJlZShyZXBvLnRyYW5zYWN0aW9uUXVldWVUcmVlXywgcGF0aCk7XHJcbiAgICAgICAgY29uc3Qgbm9kZVF1ZXVlID0gdHJlZUdldFZhbHVlKHF1ZXVlTm9kZSkgfHwgW107XHJcbiAgICAgICAgbm9kZVF1ZXVlLnB1c2godHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIHRyZWVTZXRWYWx1ZShxdWV1ZU5vZGUsIG5vZGVRdWV1ZSk7XHJcbiAgICAgICAgLy8gVXBkYXRlIHZpc2libGVEYXRhIGFuZCByYWlzZSBldmVudHNcclxuICAgICAgICAvLyBOb3RlOiBXZSBpbnRlbnRpb25hbGx5IHJhaXNlIGV2ZW50cyBhZnRlciB1cGRhdGluZyBhbGwgb2Ygb3VyXHJcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gc3RhdGUsIHNpbmNlIHRoZSB1c2VyIGNvdWxkIHN0YXJ0IG5ldyB0cmFuc2FjdGlvbnMgZnJvbSB0aGVcclxuICAgICAgICAvLyBldmVudCBjYWxsYmFja3MuXHJcbiAgICAgICAgbGV0IHByaW9yaXR5Rm9yTm9kZTtcclxuICAgICAgICBpZiAodHlwZW9mIG5ld1ZhbCA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgICAgbmV3VmFsICE9PSBudWxsICYmXHJcbiAgICAgICAgICAgIGNvbnRhaW5zKG5ld1ZhbCwgJy5wcmlvcml0eScpKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIHByaW9yaXR5Rm9yTm9kZSA9IHNhZmVHZXQobmV3VmFsLCAnLnByaW9yaXR5Jyk7XHJcbiAgICAgICAgICAgIGFzc2VydChpc1ZhbGlkUHJpb3JpdHkocHJpb3JpdHlGb3JOb2RlKSwgJ0ludmFsaWQgcHJpb3JpdHkgcmV0dXJuZWQgYnkgdHJhbnNhY3Rpb24uICcgK1xyXG4gICAgICAgICAgICAgICAgJ1ByaW9yaXR5IG11c3QgYmUgYSB2YWxpZCBzdHJpbmcsIGZpbml0ZSBudW1iZXIsIHNlcnZlciB2YWx1ZSwgb3IgbnVsbC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROb2RlID0gc3luY1RyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBwYXRoKSB8fFxyXG4gICAgICAgICAgICAgICAgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgIHByaW9yaXR5Rm9yTm9kZSA9IGN1cnJlbnROb2RlLmdldFByaW9yaXR5KCkudmFsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNlcnZlclZhbHVlcyA9IHJlcG9HZW5lcmF0ZVNlcnZlclZhbHVlcyhyZXBvKTtcclxuICAgICAgICBjb25zdCBuZXdOb2RlVW5yZXNvbHZlZCA9IG5vZGVGcm9tSlNPTihuZXdWYWwsIHByaW9yaXR5Rm9yTm9kZSk7XHJcbiAgICAgICAgY29uc3QgbmV3Tm9kZSA9IHJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QobmV3Tm9kZVVucmVzb2x2ZWQsIGN1cnJlbnRTdGF0ZSwgc2VydmVyVmFsdWVzKTtcclxuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50T3V0cHV0U25hcHNob3RSYXcgPSBuZXdOb2RlVW5yZXNvbHZlZDtcclxuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50T3V0cHV0U25hcHNob3RSZXNvbHZlZCA9IG5ld05vZGU7XHJcbiAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQgPSByZXBvR2V0TmV4dFdyaXRlSWQocmVwbyk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRzID0gc3luY1RyZWVBcHBseVVzZXJPdmVyd3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIG5ld05vZGUsIHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkLCB0cmFuc2FjdGlvbi5hcHBseUxvY2FsbHkpO1xyXG4gICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHBhdGgsIGV2ZW50cyk7XHJcbiAgICAgICAgcmVwb1NlbmRSZWFkeVRyYW5zYWN0aW9ucyhyZXBvLCByZXBvLnRyYW5zYWN0aW9uUXVldWVUcmVlXyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSBleGNsdWRlU2V0cyAtIEEgc3BlY2lmaWMgc2V0IHRvIGV4Y2x1ZGVcclxuICovXHJcbmZ1bmN0aW9uIHJlcG9HZXRMYXRlc3RTdGF0ZShyZXBvLCBwYXRoLCBleGNsdWRlU2V0cykge1xyXG4gICAgcmV0dXJuIChzeW5jVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIGV4Y2x1ZGVTZXRzKSB8fFxyXG4gICAgICAgIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcclxufVxyXG4vKipcclxuICogU2VuZHMgYW55IGFscmVhZHktcnVuIHRyYW5zYWN0aW9ucyB0aGF0IGFyZW4ndCB3YWl0aW5nIGZvciBvdXRzdGFuZGluZ1xyXG4gKiB0cmFuc2FjdGlvbnMgdG8gY29tcGxldGUuXHJcbiAqXHJcbiAqIEV4dGVybmFsbHkgaXQncyBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMsIGJ1dCBpdCBjYWxscyBpdHNlbGYgcmVjdXJzaXZlbHlcclxuICogd2l0aCBhIHBhcnRpY3VsYXIgdHJhbnNhY3Rpb25RdWV1ZVRyZWUgbm9kZSB0byByZWN1cnNlIHRocm91Z2ggdGhlIHRyZWUuXHJcbiAqXHJcbiAqIEBwYXJhbSBub2RlIC0gdHJhbnNhY3Rpb25RdWV1ZVRyZWUgbm9kZSB0byBzdGFydCBhdC5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9TZW5kUmVhZHlUcmFuc2FjdGlvbnMocmVwbywgbm9kZSA9IHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfKSB7XHJcbiAgICAvLyBCZWZvcmUgcmVjdXJzaW5nLCBtYWtlIHN1cmUgYW55IGNvbXBsZXRlZCB0cmFuc2FjdGlvbnMgYXJlIHJlbW92ZWQuXHJcbiAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICByZXBvUHJ1bmVDb21wbGV0ZWRUcmFuc2FjdGlvbnNCZWxvd05vZGUocmVwbywgbm9kZSk7XHJcbiAgICB9XHJcbiAgICBpZiAodHJlZUdldFZhbHVlKG5vZGUpKSB7XHJcbiAgICAgICAgY29uc3QgcXVldWUgPSByZXBvQnVpbGRUcmFuc2FjdGlvblF1ZXVlKHJlcG8sIG5vZGUpO1xyXG4gICAgICAgIGFzc2VydChxdWV1ZS5sZW5ndGggPiAwLCAnU2VuZGluZyB6ZXJvIGxlbmd0aCB0cmFuc2FjdGlvbiBxdWV1ZScpO1xyXG4gICAgICAgIGNvbnN0IGFsbFJ1biA9IHF1ZXVlLmV2ZXJ5KCh0cmFuc2FjdGlvbikgPT4gdHJhbnNhY3Rpb24uc3RhdHVzID09PSAwIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlJVTiAqLyk7XHJcbiAgICAgICAgLy8gSWYgdGhleSdyZSBhbGwgcnVuIChhbmQgbm90IHNlbnQpLCB3ZSBjYW4gc2VuZCB0aGVtLiAgRWxzZSwgd2UgbXVzdCB3YWl0LlxyXG4gICAgICAgIGlmIChhbGxSdW4pIHtcclxuICAgICAgICAgICAgcmVwb1NlbmRUcmFuc2FjdGlvblF1ZXVlKHJlcG8sIHRyZWVHZXRQYXRoKG5vZGUpLCBxdWV1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHJlZUhhc0NoaWxkcmVuKG5vZGUpKSB7XHJcbiAgICAgICAgdHJlZUZvckVhY2hDaGlsZChub2RlLCBjaGlsZE5vZGUgPT4ge1xyXG4gICAgICAgICAgICByZXBvU2VuZFJlYWR5VHJhbnNhY3Rpb25zKHJlcG8sIGNoaWxkTm9kZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGEgbGlzdCBvZiBydW4gdHJhbnNhY3Rpb25zLCBzZW5kIHRoZW0gdG8gdGhlIHNlcnZlciBhbmQgdGhlbiBoYW5kbGVcclxuICogdGhlIHJlc3VsdCAoc3VjY2VzcyBvciBmYWlsdXJlKS5cclxuICpcclxuICogQHBhcmFtIHBhdGggLSBUaGUgbG9jYXRpb24gb2YgdGhlIHF1ZXVlLlxyXG4gKiBAcGFyYW0gcXVldWUgLSBRdWV1ZSBvZiB0cmFuc2FjdGlvbnMgdW5kZXIgdGhlIHNwZWNpZmllZCBsb2NhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9TZW5kVHJhbnNhY3Rpb25RdWV1ZShyZXBvLCBwYXRoLCBxdWV1ZSkge1xyXG4gICAgLy8gTWFyayB0cmFuc2FjdGlvbnMgYXMgc2VudCBhbmQgaW5jcmVtZW50IHJldHJ5IGNvdW50IVxyXG4gICAgY29uc3Qgc2V0c1RvSWdub3JlID0gcXVldWUubWFwKHR4biA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHR4bi5jdXJyZW50V3JpdGVJZDtcclxuICAgIH0pO1xyXG4gICAgY29uc3QgbGF0ZXN0U3RhdGUgPSByZXBvR2V0TGF0ZXN0U3RhdGUocmVwbywgcGF0aCwgc2V0c1RvSWdub3JlKTtcclxuICAgIGxldCBzbmFwVG9TZW5kID0gbGF0ZXN0U3RhdGU7XHJcbiAgICBjb25zdCBsYXRlc3RIYXNoID0gbGF0ZXN0U3RhdGUuaGFzaCgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHR4biA9IHF1ZXVlW2ldO1xyXG4gICAgICAgIGFzc2VydCh0eG4uc3RhdHVzID09PSAwIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlJVTiAqLywgJ3RyeVRvU2VuZFRyYW5zYWN0aW9uUXVldWVfOiBpdGVtcyBpbiBxdWV1ZSBzaG91bGQgYWxsIGJlIHJ1bi4nKTtcclxuICAgICAgICB0eG4uc3RhdHVzID0gMSAvKiBUcmFuc2FjdGlvblN0YXR1cy5TRU5UICovO1xyXG4gICAgICAgIHR4bi5yZXRyeUNvdW50Kys7XHJcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHBhdGgsIHR4bi5wYXRoKTtcclxuICAgICAgICAvLyBJZiB3ZSd2ZSBnb3R0ZW4gdG8gdGhpcyBwb2ludCwgdGhlIG91dHB1dCBzbmFwc2hvdCBtdXN0IGJlIGRlZmluZWQuXHJcbiAgICAgICAgc25hcFRvU2VuZCA9IHNuYXBUb1NlbmQudXBkYXRlQ2hpbGQocmVsYXRpdmVQYXRoIC8qKiBAdHlwZSB7IU5vZGV9ICovLCB0eG4uY3VycmVudE91dHB1dFNuYXBzaG90UmF3KTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRhdGFUb1NlbmQgPSBzbmFwVG9TZW5kLnZhbCh0cnVlKTtcclxuICAgIGNvbnN0IHBhdGhUb1NlbmQgPSBwYXRoO1xyXG4gICAgLy8gU2VuZCB0aGUgcHV0LlxyXG4gICAgcmVwby5zZXJ2ZXJfLnB1dChwYXRoVG9TZW5kLnRvU3RyaW5nKCksIGRhdGFUb1NlbmQsIChzdGF0dXMpID0+IHtcclxuICAgICAgICByZXBvTG9nKHJlcG8sICd0cmFuc2FjdGlvbiBwdXQgcmVzcG9uc2UnLCB7XHJcbiAgICAgICAgICAgIHBhdGg6IHBhdGhUb1NlbmQudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgc3RhdHVzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IGV2ZW50cyA9IFtdO1xyXG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgLy8gUXVldWUgdXAgdGhlIGNhbGxiYWNrcyBhbmQgZmlyZSB0aGVtIGFmdGVyIGNsZWFuaW5nIHVwIGFsbCBvZiBvdXJcclxuICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb24gc3RhdGUsIHNpbmNlIHRoZSBjYWxsYmFjayBjb3VsZCB0cmlnZ2VyIG1vcmVcclxuICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb25zIG9yIHNldHMuXHJcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVtpXS5zdGF0dXMgPSAyIC8qIFRyYW5zYWN0aW9uU3RhdHVzLkNPTVBMRVRFRCAqLztcclxuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBY2tVc2VyV3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXVlW2ldLmN1cnJlbnRXcml0ZUlkKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocXVldWVbaV0ub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5ldmVyIHVuc2V0IHRoZSBvdXRwdXQgc25hcHNob3QsIGFuZCBnaXZlbiB0aGF0IHRoaXNcclxuICAgICAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbiBpcyBjb21wbGV0ZSwgaXQgc2hvdWxkIGJlIHNldFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKCgpID0+IHF1ZXVlW2ldLm9uQ29tcGxldGUobnVsbCwgdHJ1ZSwgcXVldWVbaV0uY3VycmVudE91dHB1dFNuYXBzaG90UmVzb2x2ZWQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnVud2F0Y2hlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE5vdyByZW1vdmUgdGhlIGNvbXBsZXRlZCB0cmFuc2FjdGlvbnMuXHJcbiAgICAgICAgICAgIHJlcG9QcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZShyZXBvLCB0cmVlU3ViVHJlZShyZXBvLnRyYW5zYWN0aW9uUXVldWVUcmVlXywgcGF0aCkpO1xyXG4gICAgICAgICAgICAvLyBUaGVyZSBtYXkgYmUgcGVuZGluZyB0cmFuc2FjdGlvbnMgdGhhdCB3ZSBjYW4gbm93IHNlbmQuXHJcbiAgICAgICAgICAgIHJlcG9TZW5kUmVhZHlUcmFuc2FjdGlvbnMocmVwbywgcmVwby50cmFuc2FjdGlvblF1ZXVlVHJlZV8pO1xyXG4gICAgICAgICAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBwYXRoLCBldmVudHMpO1xyXG4gICAgICAgICAgICAvLyBGaW5hbGx5LCB0cmlnZ2VyIG9uQ29tcGxldGUgY2FsbGJhY2tzLlxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZXhjZXB0aW9uR3VhcmQoY2FsbGJhY2tzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb25zIGFyZSBubyBsb25nZXIgc2VudC4gIFVwZGF0ZSB0aGVpciBzdGF0dXMgYXBwcm9wcmlhdGVseS5cclxuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ2RhdGFzdGFsZScpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocXVldWVbaV0uc3RhdHVzID09PSAzIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlNFTlRfTkVFRFNfQUJPUlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gNCAvKiBUcmFuc2FjdGlvblN0YXR1cy5ORUVEU19BQk9SVCAqLztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnN0YXR1cyA9IDAgLyogVHJhbnNhY3Rpb25TdGF0dXMuUlVOICovO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oJ3RyYW5zYWN0aW9uIGF0ICcgKyBwYXRoVG9TZW5kLnRvU3RyaW5nKCkgKyAnIGZhaWxlZDogJyArIHN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gNCAvKiBUcmFuc2FjdGlvblN0YXR1cy5ORUVEU19BQk9SVCAqLztcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVtpXS5hYm9ydFJlYXNvbiA9IHN0YXR1cztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXBvUmVydW5UcmFuc2FjdGlvbnMocmVwbywgcGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgbGF0ZXN0SGFzaCk7XHJcbn1cclxuLyoqXHJcbiAqIEZpbmRzIGFsbCB0cmFuc2FjdGlvbnMgZGVwZW5kZW50IG9uIHRoZSBkYXRhIGF0IGNoYW5nZWRQYXRoIGFuZCByZXJ1bnMgdGhlbS5cclxuICpcclxuICogU2hvdWxkIGJlIGNhbGxlZCBhbnkgdGltZSBjYWNoZWQgZGF0YSBjaGFuZ2VzLlxyXG4gKlxyXG4gKiBSZXR1cm4gdGhlIGhpZ2hlc3QgcGF0aCB0aGF0IHdhcyBhZmZlY3RlZCBieSByZXJ1bm5pbmcgdHJhbnNhY3Rpb25zLiBUaGlzXHJcbiAqIGlzIHRoZSBwYXRoIGF0IHdoaWNoIGV2ZW50cyBuZWVkIHRvIGJlIHJhaXNlZCBmb3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBjaGFuZ2VkUGF0aCAtIFRoZSBwYXRoIGluIG1lcmdlZERhdGEgdGhhdCBjaGFuZ2VkLlxyXG4gKiBAcmV0dXJucyBUaGUgcm9vdG1vc3QgcGF0aCB0aGF0IHdhcyBhZmZlY3RlZCBieSByZXJ1bm5pbmcgdHJhbnNhY3Rpb25zLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb1JlcnVuVHJhbnNhY3Rpb25zKHJlcG8sIGNoYW5nZWRQYXRoKSB7XHJcbiAgICBjb25zdCByb290TW9zdFRyYW5zYWN0aW9uTm9kZSA9IHJlcG9HZXRBbmNlc3RvclRyYW5zYWN0aW9uTm9kZShyZXBvLCBjaGFuZ2VkUGF0aCk7XHJcbiAgICBjb25zdCBwYXRoID0gdHJlZUdldFBhdGgocm9vdE1vc3RUcmFuc2FjdGlvbk5vZGUpO1xyXG4gICAgY29uc3QgcXVldWUgPSByZXBvQnVpbGRUcmFuc2FjdGlvblF1ZXVlKHJlcG8sIHJvb3RNb3N0VHJhbnNhY3Rpb25Ob2RlKTtcclxuICAgIHJlcG9SZXJ1blRyYW5zYWN0aW9uUXVldWUocmVwbywgcXVldWUsIHBhdGgpO1xyXG4gICAgcmV0dXJuIHBhdGg7XHJcbn1cclxuLyoqXHJcbiAqIERvZXMgYWxsIHRoZSB3b3JrIG9mIHJlcnVubmluZyB0cmFuc2FjdGlvbnMgKGFzIHdlbGwgYXMgY2xlYW5zIHVwIGFib3J0ZWRcclxuICogdHJhbnNhY3Rpb25zIGFuZCB3aGF0bm90KS5cclxuICpcclxuICogQHBhcmFtIHF1ZXVlIC0gVGhlIHF1ZXVlIG9mIHRyYW5zYWN0aW9ucyB0byBydW4uXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdGhlIHF1ZXVlIGlzIGZvci5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9SZXJ1blRyYW5zYWN0aW9uUXVldWUocmVwbywgcXVldWUsIHBhdGgpIHtcclxuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG8hXHJcbiAgICB9XHJcbiAgICAvLyBRdWV1ZSB1cCB0aGUgY2FsbGJhY2tzIGFuZCBmaXJlIHRoZW0gYWZ0ZXIgY2xlYW5pbmcgdXAgYWxsIG9mIG91clxyXG4gICAgLy8gdHJhbnNhY3Rpb24gc3RhdGUsIHNpbmNlIHRoZSBjYWxsYmFjayBjb3VsZCB0cmlnZ2VyIG1vcmUgdHJhbnNhY3Rpb25zIG9yXHJcbiAgICAvLyBzZXRzLlxyXG4gICAgY29uc3QgY2FsbGJhY2tzID0gW107XHJcbiAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICAvLyBJZ25vcmUgYWxsIG9mIHRoZSBzZXRzIHdlJ3JlIGdvaW5nIHRvIHJlLXJ1bi5cclxuICAgIGNvbnN0IHR4bnNUb1JlcnVuID0gcXVldWUuZmlsdGVyKHEgPT4ge1xyXG4gICAgICAgIHJldHVybiBxLnN0YXR1cyA9PT0gMCAvKiBUcmFuc2FjdGlvblN0YXR1cy5SVU4gKi87XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHNldHNUb0lnbm9yZSA9IHR4bnNUb1JlcnVuLm1hcChxID0+IHtcclxuICAgICAgICByZXR1cm4gcS5jdXJyZW50V3JpdGVJZDtcclxuICAgIH0pO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gcXVldWVbaV07XHJcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHBhdGgsIHRyYW5zYWN0aW9uLnBhdGgpO1xyXG4gICAgICAgIGxldCBhYm9ydFRyYW5zYWN0aW9uID0gZmFsc2UsIGFib3J0UmVhc29uO1xyXG4gICAgICAgIGFzc2VydChyZWxhdGl2ZVBhdGggIT09IG51bGwsICdyZXJ1blRyYW5zYWN0aW9uc1VuZGVyTm9kZV86IHJlbGF0aXZlUGF0aCBzaG91bGQgbm90IGJlIG51bGwuJyk7XHJcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnN0YXR1cyA9PT0gNCAvKiBUcmFuc2FjdGlvblN0YXR1cy5ORUVEU19BQk9SVCAqLykge1xyXG4gICAgICAgICAgICBhYm9ydFRyYW5zYWN0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgYWJvcnRSZWFzb24gPSB0cmFuc2FjdGlvbi5hYm9ydFJlYXNvbjtcclxuICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZUFja1VzZXJXcml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQsIHRydWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHJhbnNhY3Rpb24uc3RhdHVzID09PSAwIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlJVTiAqLykge1xyXG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24ucmV0cnlDb3VudCA+PSBNQVhfVFJBTlNBQ1RJT05fUkVUUklFUykge1xyXG4gICAgICAgICAgICAgICAgYWJvcnRUcmFuc2FjdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBhYm9ydFJlYXNvbiA9ICdtYXhyZXRyeSc7XHJcbiAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNUcmVlQWNrVXNlcldyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb2RlIHJlcnVucyBhIHRyYW5zYWN0aW9uXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Tm9kZSA9IHJlcG9HZXRMYXRlc3RTdGF0ZShyZXBvLCB0cmFuc2FjdGlvbi5wYXRoLCBzZXRzVG9JZ25vcmUpO1xyXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudElucHV0U25hcHNob3QgPSBjdXJyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RhdGEgPSBxdWV1ZVtpXS51cGRhdGUoY3VycmVudE5vZGUudmFsKCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0RhdGEgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhKCd0cmFuc2FjdGlvbiBmYWlsZWQ6IERhdGEgcmV0dXJuZWQgJywgbmV3RGF0YSwgdHJhbnNhY3Rpb24ucGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0RhdGFOb2RlID0gbm9kZUZyb21KU09OKG5ld0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc0V4cGxpY2l0UHJpb3JpdHkgPSB0eXBlb2YgbmV3RGF0YSA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGF0YSAhPSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zKG5ld0RhdGEsICcucHJpb3JpdHknKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc0V4cGxpY2l0UHJpb3JpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCB0aGUgb2xkIHByaW9yaXR5IGlmIHRoZXJlIHdhc24ndCBhIHByaW9yaXR5IGV4cGxpY2l0bHkgc3BlY2lmaWVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEYXRhTm9kZSA9IG5ld0RhdGFOb2RlLnVwZGF0ZVByaW9yaXR5KGN1cnJlbnROb2RlLmdldFByaW9yaXR5KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRXcml0ZUlkID0gdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyVmFsdWVzID0gcmVwb0dlbmVyYXRlU2VydmVyVmFsdWVzKHJlcG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld05vZGVSZXNvbHZlZCA9IHJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QobmV3RGF0YU5vZGUsIGN1cnJlbnROb2RlLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJhdyA9IG5ld0RhdGFOb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJlc29sdmVkID0gbmV3Tm9kZVJlc29sdmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkID0gcmVwb0dldE5leHRXcml0ZUlkKHJlcG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE11dGF0ZXMgc2V0c1RvSWdub3JlIGluIHBsYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0c1RvSWdub3JlLnNwbGljZShzZXRzVG9JZ25vcmUuaW5kZXhPZihvbGRXcml0ZUlkKSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZUFwcGx5VXNlck92ZXJ3cml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgdHJhbnNhY3Rpb24ucGF0aCwgbmV3Tm9kZVJlc29sdmVkLCB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCwgdHJhbnNhY3Rpb24uYXBwbHlMb2NhbGx5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZUFja1VzZXJXcml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgb2xkV3JpdGVJZCwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRUcmFuc2FjdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRSZWFzb24gPSAnbm9kYXRhJztcclxuICAgICAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNUcmVlQWNrVXNlcldyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHBhdGgsIGV2ZW50cyk7XHJcbiAgICAgICAgZXZlbnRzID0gW107XHJcbiAgICAgICAgaWYgKGFib3J0VHJhbnNhY3Rpb24pIHtcclxuICAgICAgICAgICAgLy8gQWJvcnQuXHJcbiAgICAgICAgICAgIHF1ZXVlW2ldLnN0YXR1cyA9IDIgLyogVHJhbnNhY3Rpb25TdGF0dXMuQ09NUExFVEVEICovO1xyXG4gICAgICAgICAgICAvLyBSZW1vdmluZyBhIGxpc3RlbmVyIGNhbiB0cmlnZ2VyIHBydW5pbmcgd2hpY2ggY2FuIG11Y2sgd2l0aFxyXG4gICAgICAgICAgICAvLyBtZXJnZWREYXRhL3Zpc2libGVEYXRhIChhcyBpdCBwcnVuZXMgZGF0YSkuIFNvIGRlZmVyIHRoZSB1bndhdGNoZXJcclxuICAgICAgICAgICAgLy8gdW50aWwgd2UncmUgZG9uZS5cclxuICAgICAgICAgICAgKGZ1bmN0aW9uICh1bndhdGNoZXIpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQodW53YXRjaGVyLCBNYXRoLmZsb29yKDApKTtcclxuICAgICAgICAgICAgfSkocXVldWVbaV0udW53YXRjaGVyKTtcclxuICAgICAgICAgICAgaWYgKHF1ZXVlW2ldLm9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhYm9ydFJlYXNvbiA9PT0gJ25vZGF0YScpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaCgoKSA9PiBxdWV1ZVtpXS5vbkNvbXBsZXRlKG51bGwsIGZhbHNlLCBxdWV1ZVtpXS5jdXJyZW50SW5wdXRTbmFwc2hvdCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goKCkgPT4gcXVldWVbaV0ub25Db21wbGV0ZShuZXcgRXJyb3IoYWJvcnRSZWFzb24pLCBmYWxzZSwgbnVsbCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQ2xlYW4gdXAgY29tcGxldGVkIHRyYW5zYWN0aW9ucy5cclxuICAgIHJlcG9QcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZShyZXBvLCByZXBvLnRyYW5zYWN0aW9uUXVldWVUcmVlXyk7XHJcbiAgICAvLyBOb3cgZmlyZSBjYWxsYmFja3MsIG5vdyB0aGF0IHdlJ3JlIGluIGEgZ29vZCwga25vd24gc3RhdGUuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGV4Y2VwdGlvbkd1YXJkKGNhbGxiYWNrc1tpXSk7XHJcbiAgICB9XHJcbiAgICAvLyBUcnkgdG8gc2VuZCB0aGUgdHJhbnNhY3Rpb24gcmVzdWx0IHRvIHRoZSBzZXJ2ZXIuXHJcbiAgICByZXBvU2VuZFJlYWR5VHJhbnNhY3Rpb25zKHJlcG8sIHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgcm9vdG1vc3QgYW5jZXN0b3Igbm9kZSBvZiB0aGUgc3BlY2lmaWVkIHBhdGggdGhhdCBoYXMgYSBwZW5kaW5nXHJcbiAqIHRyYW5zYWN0aW9uIG9uIGl0LCBvciBqdXN0IHJldHVybnMgdGhlIG5vZGUgZm9yIHRoZSBnaXZlbiBwYXRoIGlmIHRoZXJlIGFyZVxyXG4gKiBubyBwZW5kaW5nIHRyYW5zYWN0aW9ucyBvbiBhbnkgYW5jZXN0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIGxvY2F0aW9uIHRvIHN0YXJ0IGF0LlxyXG4gKiBAcmV0dXJucyBUaGUgcm9vdG1vc3Qgbm9kZSB3aXRoIGEgdHJhbnNhY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvR2V0QW5jZXN0b3JUcmFuc2FjdGlvbk5vZGUocmVwbywgcGF0aCkge1xyXG4gICAgbGV0IGZyb250O1xyXG4gICAgLy8gU3RhcnQgYXQgdGhlIHJvb3QgYW5kIHdhbGsgZGVlcGVyIGludG8gdGhlIHRyZWUgdG93YXJkcyBwYXRoIHVudGlsIHdlXHJcbiAgICAvLyBmaW5kIGEgbm9kZSB3aXRoIHBlbmRpbmcgdHJhbnNhY3Rpb25zLlxyXG4gICAgbGV0IHRyYW5zYWN0aW9uTm9kZSA9IHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfO1xyXG4gICAgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICB3aGlsZSAoZnJvbnQgIT09IG51bGwgJiYgdHJlZUdldFZhbHVlKHRyYW5zYWN0aW9uTm9kZSkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRyYW5zYWN0aW9uTm9kZSA9IHRyZWVTdWJUcmVlKHRyYW5zYWN0aW9uTm9kZSwgZnJvbnQpO1xyXG4gICAgICAgIHBhdGggPSBwYXRoUG9wRnJvbnQocGF0aCk7XHJcbiAgICAgICAgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25Ob2RlO1xyXG59XHJcbi8qKlxyXG4gKiBCdWlsZHMgdGhlIHF1ZXVlIG9mIGFsbCB0cmFuc2FjdGlvbnMgYXQgb3IgYmVsb3cgdGhlIHNwZWNpZmllZFxyXG4gKiB0cmFuc2FjdGlvbk5vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB0cmFuc2FjdGlvbk5vZGVcclxuICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCBxdWV1ZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9CdWlsZFRyYW5zYWN0aW9uUXVldWUocmVwbywgdHJhbnNhY3Rpb25Ob2RlKSB7XHJcbiAgICAvLyBXYWxrIGFueSBjaGlsZCB0cmFuc2FjdGlvbiBxdWV1ZXMgYW5kIGFnZ3JlZ2F0ZSB0aGVtIGludG8gYSBzaW5nbGUgcXVldWUuXHJcbiAgICBjb25zdCB0cmFuc2FjdGlvblF1ZXVlID0gW107XHJcbiAgICByZXBvQWdncmVnYXRlVHJhbnNhY3Rpb25RdWV1ZXNGb3JOb2RlKHJlcG8sIHRyYW5zYWN0aW9uTm9kZSwgdHJhbnNhY3Rpb25RdWV1ZSk7XHJcbiAgICAvLyBTb3J0IHRoZW0gYnkgdGhlIG9yZGVyIHRoZSB0cmFuc2FjdGlvbnMgd2VyZSBjcmVhdGVkLlxyXG4gICAgdHJhbnNhY3Rpb25RdWV1ZS5zb3J0KChhLCBiKSA9PiBhLm9yZGVyIC0gYi5vcmRlcik7XHJcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25RdWV1ZTtcclxufVxyXG5mdW5jdGlvbiByZXBvQWdncmVnYXRlVHJhbnNhY3Rpb25RdWV1ZXNGb3JOb2RlKHJlcG8sIG5vZGUsIHF1ZXVlKSB7XHJcbiAgICBjb25zdCBub2RlUXVldWUgPSB0cmVlR2V0VmFsdWUobm9kZSk7XHJcbiAgICBpZiAobm9kZVF1ZXVlKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlUXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcXVldWUucHVzaChub2RlUXVldWVbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRyZWVGb3JFYWNoQ2hpbGQobm9kZSwgY2hpbGQgPT4ge1xyXG4gICAgICAgIHJlcG9BZ2dyZWdhdGVUcmFuc2FjdGlvblF1ZXVlc0Zvck5vZGUocmVwbywgY2hpbGQsIHF1ZXVlKTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmUgQ09NUExFVEVEIHRyYW5zYWN0aW9ucyBhdCBvciBiZWxvdyB0aGlzIG5vZGUgaW4gdGhlIHRyYW5zYWN0aW9uUXVldWVUcmVlXy5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9QcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZShyZXBvLCBub2RlKSB7XHJcbiAgICBjb25zdCBxdWV1ZSA9IHRyZWVHZXRWYWx1ZShub2RlKTtcclxuICAgIGlmIChxdWV1ZSkge1xyXG4gICAgICAgIGxldCB0byA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgZnJvbSA9IDA7IGZyb20gPCBxdWV1ZS5sZW5ndGg7IGZyb20rKykge1xyXG4gICAgICAgICAgICBpZiAocXVldWVbZnJvbV0uc3RhdHVzICE9PSAyIC8qIFRyYW5zYWN0aW9uU3RhdHVzLkNPTVBMRVRFRCAqLykge1xyXG4gICAgICAgICAgICAgICAgcXVldWVbdG9dID0gcXVldWVbZnJvbV07XHJcbiAgICAgICAgICAgICAgICB0bysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IHRvO1xyXG4gICAgICAgIHRyZWVTZXRWYWx1ZShub2RlLCBxdWV1ZS5sZW5ndGggPiAwID8gcXVldWUgOiB1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gICAgdHJlZUZvckVhY2hDaGlsZChub2RlLCBjaGlsZE5vZGUgPT4ge1xyXG4gICAgICAgIHJlcG9QcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZShyZXBvLCBjaGlsZE5vZGUpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEFib3J0cyBhbGwgdHJhbnNhY3Rpb25zIG9uIGFuY2VzdG9ycyBvciBkZXNjZW5kYW50cyBvZiB0aGUgc3BlY2lmaWVkIHBhdGguXHJcbiAqIENhbGxlZCB3aGVuIGRvaW5nIGEgc2V0KCkgb3IgdXBkYXRlKCkgc2luY2Ugd2UgY29uc2lkZXIgdGhlbSBpbmNvbXBhdGlibGVcclxuICogd2l0aCB0cmFuc2FjdGlvbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoIC0gUGF0aCBmb3Igd2hpY2ggd2Ugd2FudCB0byBhYm9ydCByZWxhdGVkIHRyYW5zYWN0aW9ucy5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9BYm9ydFRyYW5zYWN0aW9ucyhyZXBvLCBwYXRoKSB7XHJcbiAgICBjb25zdCBhZmZlY3RlZFBhdGggPSB0cmVlR2V0UGF0aChyZXBvR2V0QW5jZXN0b3JUcmFuc2FjdGlvbk5vZGUocmVwbywgcGF0aCkpO1xyXG4gICAgY29uc3QgdHJhbnNhY3Rpb25Ob2RlID0gdHJlZVN1YlRyZWUocmVwby50cmFuc2FjdGlvblF1ZXVlVHJlZV8sIHBhdGgpO1xyXG4gICAgdHJlZUZvckVhY2hBbmNlc3Rvcih0cmFuc2FjdGlvbk5vZGUsIChub2RlKSA9PiB7XHJcbiAgICAgICAgcmVwb0Fib3J0VHJhbnNhY3Rpb25zT25Ob2RlKHJlcG8sIG5vZGUpO1xyXG4gICAgfSk7XHJcbiAgICByZXBvQWJvcnRUcmFuc2FjdGlvbnNPbk5vZGUocmVwbywgdHJhbnNhY3Rpb25Ob2RlKTtcclxuICAgIHRyZWVGb3JFYWNoRGVzY2VuZGFudCh0cmFuc2FjdGlvbk5vZGUsIChub2RlKSA9PiB7XHJcbiAgICAgICAgcmVwb0Fib3J0VHJhbnNhY3Rpb25zT25Ob2RlKHJlcG8sIG5vZGUpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gYWZmZWN0ZWRQYXRoO1xyXG59XHJcbi8qKlxyXG4gKiBBYm9ydCB0cmFuc2FjdGlvbnMgc3RvcmVkIGluIHRoaXMgdHJhbnNhY3Rpb24gcXVldWUgbm9kZS5cclxuICpcclxuICogQHBhcmFtIG5vZGUgLSBOb2RlIHRvIGFib3J0IHRyYW5zYWN0aW9ucyBmb3IuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvQWJvcnRUcmFuc2FjdGlvbnNPbk5vZGUocmVwbywgbm9kZSkge1xyXG4gICAgY29uc3QgcXVldWUgPSB0cmVlR2V0VmFsdWUobm9kZSk7XHJcbiAgICBpZiAocXVldWUpIHtcclxuICAgICAgICAvLyBRdWV1ZSB1cCB0aGUgY2FsbGJhY2tzIGFuZCBmaXJlIHRoZW0gYWZ0ZXIgY2xlYW5pbmcgdXAgYWxsIG9mIG91clxyXG4gICAgICAgIC8vIHRyYW5zYWN0aW9uIHN0YXRlLCBzaW5jZSB0aGUgY2FsbGJhY2sgY291bGQgdHJpZ2dlciBtb3JlIHRyYW5zYWN0aW9uc1xyXG4gICAgICAgIC8vIG9yIHNldHMuXHJcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gW107XHJcbiAgICAgICAgLy8gR28gdGhyb3VnaCBxdWV1ZS4gIEFueSBhbHJlYWR5LXNlbnQgdHJhbnNhY3Rpb25zIG11c3QgYmUgbWFya2VkIGZvclxyXG4gICAgICAgIC8vIGFib3J0LCB3aGlsZSB0aGUgdW5zZW50IG9uZXMgY2FuIGJlIGltbWVkaWF0ZWx5IGFib3J0ZWQgYW5kIHJlbW92ZWQuXHJcbiAgICAgICAgbGV0IGV2ZW50cyA9IFtdO1xyXG4gICAgICAgIGxldCBsYXN0U2VudCA9IC0xO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHF1ZXVlW2ldLnN0YXR1cyA9PT0gMyAvKiBUcmFuc2FjdGlvblN0YXR1cy5TRU5UX05FRURTX0FCT1JUICovKSA7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHF1ZXVlW2ldLnN0YXR1cyA9PT0gMSAvKiBUcmFuc2FjdGlvblN0YXR1cy5TRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQobGFzdFNlbnQgPT09IGkgLSAxLCAnQWxsIFNFTlQgaXRlbXMgc2hvdWxkIGJlIGF0IGJlZ2lubmluZyBvZiBxdWV1ZS4nKTtcclxuICAgICAgICAgICAgICAgIGxhc3RTZW50ID0gaTtcclxuICAgICAgICAgICAgICAgIC8vIE1hcmsgdHJhbnNhY3Rpb24gZm9yIGFib3J0IHdoZW4gaXQgY29tZXMgYmFjay5cclxuICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnN0YXR1cyA9IDMgLyogVHJhbnNhY3Rpb25TdGF0dXMuU0VOVF9ORUVEU19BQk9SVCAqLztcclxuICAgICAgICAgICAgICAgIHF1ZXVlW2ldLmFib3J0UmVhc29uID0gJ3NldCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQocXVldWVbaV0uc3RhdHVzID09PSAwIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlJVTiAqLywgJ1VuZXhwZWN0ZWQgdHJhbnNhY3Rpb24gc3RhdHVzIGluIGFib3J0Jyk7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gYWJvcnQgaXQgaW1tZWRpYXRlbHkuXHJcbiAgICAgICAgICAgICAgICBxdWV1ZVtpXS51bndhdGNoZXIoKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBY2tVc2VyV3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXVlW2ldLmN1cnJlbnRXcml0ZUlkLCB0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocXVldWVbaV0ub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKHF1ZXVlW2ldLm9uQ29tcGxldGUuYmluZChudWxsLCBuZXcgRXJyb3IoJ3NldCcpLCBmYWxzZSwgbnVsbCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYXN0U2VudCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgLy8gV2UncmUgbm90IHdhaXRpbmcgZm9yIGFueSBzZW50IHRyYW5zYWN0aW9ucy4gIFdlIGNhbiBjbGVhciB0aGUgcXVldWUuXHJcbiAgICAgICAgICAgIHRyZWVTZXRWYWx1ZShub2RlLCB1bmRlZmluZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0cmFuc2FjdGlvbnMgd2UgYWJvcnRlZC5cclxuICAgICAgICAgICAgcXVldWUubGVuZ3RoID0gbGFzdFNlbnQgKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOb3cgZmlyZSB0aGUgY2FsbGJhY2tzLlxyXG4gICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHRyZWVHZXRQYXRoKG5vZGUpLCBldmVudHMpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV4Y2VwdGlvbkd1YXJkKGNhbGxiYWNrc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGRlY29kZVBhdGgocGF0aFN0cmluZykge1xyXG4gICAgbGV0IHBhdGhTdHJpbmdEZWNvZGVkID0gJyc7XHJcbiAgICBjb25zdCBwaWVjZXMgPSBwYXRoU3RyaW5nLnNwbGl0KCcvJyk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChwaWVjZXNbaV0ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBsZXQgcGllY2UgPSBwaWVjZXNbaV07XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBwaWVjZSA9IGRlY29kZVVSSUNvbXBvbmVudChwaWVjZS5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgICAgICBwYXRoU3RyaW5nRGVjb2RlZCArPSAnLycgKyBwaWVjZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF0aFN0cmluZ0RlY29kZWQ7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIGtleSB2YWx1ZSBoYXNoXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWNvZGVRdWVyeShxdWVyeVN0cmluZykge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IHt9O1xyXG4gICAgaWYgKHF1ZXJ5U3RyaW5nLmNoYXJBdCgwKSA9PT0gJz8nKSB7XHJcbiAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5zdWJzdHJpbmcoMSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgcXVlcnlTdHJpbmcuc3BsaXQoJyYnKSkge1xyXG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qga3YgPSBzZWdtZW50LnNwbGl0KCc9Jyk7XHJcbiAgICAgICAgaWYgKGt2Lmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICByZXN1bHRzW2RlY29kZVVSSUNvbXBvbmVudChrdlswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KGt2WzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEludmFsaWQgcXVlcnkgc2VnbWVudCAnJHtzZWdtZW50fScgaW4gcXVlcnkgJyR7cXVlcnlTdHJpbmd9J2ApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHRzO1xyXG59XHJcbmNvbnN0IHBhcnNlUmVwb0luZm8gPSBmdW5jdGlvbiAoZGF0YVVSTCwgbm9kZUFkbWluKSB7XHJcbiAgICBjb25zdCBwYXJzZWRVcmwgPSBwYXJzZURhdGFiYXNlVVJMKGRhdGFVUkwpLCBuYW1lc3BhY2UgPSBwYXJzZWRVcmwubmFtZXNwYWNlO1xyXG4gICAgaWYgKHBhcnNlZFVybC5kb21haW4gPT09ICdmaXJlYmFzZS5jb20nKSB7XHJcbiAgICAgICAgZmF0YWwocGFyc2VkVXJsLmhvc3QgK1xyXG4gICAgICAgICAgICAnIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuICcgK1xyXG4gICAgICAgICAgICAnUGxlYXNlIHVzZSA8WU9VUiBGSVJFQkFTRT4uZmlyZWJhc2Vpby5jb20gaW5zdGVhZCcpO1xyXG4gICAgfVxyXG4gICAgLy8gQ2F0Y2ggY29tbW9uIGVycm9yIG9mIHVuaW5pdGlhbGl6ZWQgbmFtZXNwYWNlIHZhbHVlLlxyXG4gICAgaWYgKCghbmFtZXNwYWNlIHx8IG5hbWVzcGFjZSA9PT0gJ3VuZGVmaW5lZCcpICYmXHJcbiAgICAgICAgcGFyc2VkVXJsLmRvbWFpbiAhPT0gJ2xvY2FsaG9zdCcpIHtcclxuICAgICAgICBmYXRhbCgnQ2Fubm90IHBhcnNlIEZpcmViYXNlIHVybC4gUGxlYXNlIHVzZSBodHRwczovLzxZT1VSIEZJUkVCQVNFPi5maXJlYmFzZWlvLmNvbScpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFwYXJzZWRVcmwuc2VjdXJlKSB7XHJcbiAgICAgICAgd2FybklmUGFnZUlzU2VjdXJlKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB3ZWJTb2NrZXRPbmx5ID0gcGFyc2VkVXJsLnNjaGVtZSA9PT0gJ3dzJyB8fCBwYXJzZWRVcmwuc2NoZW1lID09PSAnd3NzJztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVwb0luZm86IG5ldyBSZXBvSW5mbyhwYXJzZWRVcmwuaG9zdCwgcGFyc2VkVXJsLnNlY3VyZSwgbmFtZXNwYWNlLCB3ZWJTb2NrZXRPbmx5LCBub2RlQWRtaW4sIFxyXG4gICAgICAgIC8qcGVyc2lzdGVuY2VLZXk9Ki8gJycsIFxyXG4gICAgICAgIC8qaW5jbHVkZU5hbWVzcGFjZUluUXVlcnlQYXJhbXM9Ki8gbmFtZXNwYWNlICE9PSBwYXJzZWRVcmwuc3ViZG9tYWluKSxcclxuICAgICAgICBwYXRoOiBuZXcgUGF0aChwYXJzZWRVcmwucGF0aFN0cmluZylcclxuICAgIH07XHJcbn07XHJcbmNvbnN0IHBhcnNlRGF0YWJhc2VVUkwgPSBmdW5jdGlvbiAoZGF0YVVSTCkge1xyXG4gICAgLy8gRGVmYXVsdCB0byBlbXB0eSBzdHJpbmdzIGluIHRoZSBldmVudCBvZiBhIG1hbGZvcm1lZCBzdHJpbmcuXHJcbiAgICBsZXQgaG9zdCA9ICcnLCBkb21haW4gPSAnJywgc3ViZG9tYWluID0gJycsIHBhdGhTdHJpbmcgPSAnJywgbmFtZXNwYWNlID0gJyc7XHJcbiAgICAvLyBBbHdheXMgZGVmYXVsdCB0byBTU0wsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxyXG4gICAgbGV0IHNlY3VyZSA9IHRydWUsIHNjaGVtZSA9ICdodHRwcycsIHBvcnQgPSA0NDM7XHJcbiAgICAvLyBEb24ndCBkbyBhbnkgdmFsaWRhdGlvbiBoZXJlLiBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciB2YWxpZGF0aW5nIHRoZSByZXN1bHQgb2YgcGFyc2luZy5cclxuICAgIGlmICh0eXBlb2YgZGF0YVVSTCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAvLyBQYXJzZSBzY2hlbWUuXHJcbiAgICAgICAgbGV0IGNvbG9uSW5kID0gZGF0YVVSTC5pbmRleE9mKCcvLycpO1xyXG4gICAgICAgIGlmIChjb2xvbkluZCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHNjaGVtZSA9IGRhdGFVUkwuc3Vic3RyaW5nKDAsIGNvbG9uSW5kIC0gMSk7XHJcbiAgICAgICAgICAgIGRhdGFVUkwgPSBkYXRhVVJMLnN1YnN0cmluZyhjb2xvbkluZCArIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQYXJzZSBob3N0LCBwYXRoLCBhbmQgcXVlcnkgc3RyaW5nLlxyXG4gICAgICAgIGxldCBzbGFzaEluZCA9IGRhdGFVUkwuaW5kZXhPZignLycpO1xyXG4gICAgICAgIGlmIChzbGFzaEluZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgc2xhc2hJbmQgPSBkYXRhVVJMLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHF1ZXN0aW9uTWFya0luZCA9IGRhdGFVUkwuaW5kZXhPZignPycpO1xyXG4gICAgICAgIGlmIChxdWVzdGlvbk1hcmtJbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHF1ZXN0aW9uTWFya0luZCA9IGRhdGFVUkwubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBob3N0ID0gZGF0YVVSTC5zdWJzdHJpbmcoMCwgTWF0aC5taW4oc2xhc2hJbmQsIHF1ZXN0aW9uTWFya0luZCkpO1xyXG4gICAgICAgIGlmIChzbGFzaEluZCA8IHF1ZXN0aW9uTWFya0luZCkge1xyXG4gICAgICAgICAgICAvLyBGb3IgcGF0aFN0cmluZywgcXVlc3Rpb25NYXJrSW5kIHdpbGwgYWx3YXlzIGNvbWUgYWZ0ZXIgc2xhc2hJbmRcclxuICAgICAgICAgICAgcGF0aFN0cmluZyA9IGRlY29kZVBhdGgoZGF0YVVSTC5zdWJzdHJpbmcoc2xhc2hJbmQsIHF1ZXN0aW9uTWFya0luZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IGRlY29kZVF1ZXJ5KGRhdGFVUkwuc3Vic3RyaW5nKE1hdGgubWluKGRhdGFVUkwubGVuZ3RoLCBxdWVzdGlvbk1hcmtJbmQpKSk7XHJcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvcnQsIHVzZSBzY2hlbWUgZm9yIGRldGVybWluaW5nIGlmIGl0J3Mgc2VjdXJlLlxyXG4gICAgICAgIGNvbG9uSW5kID0gaG9zdC5pbmRleE9mKCc6Jyk7XHJcbiAgICAgICAgaWYgKGNvbG9uSW5kID49IDApIHtcclxuICAgICAgICAgICAgc2VjdXJlID0gc2NoZW1lID09PSAnaHR0cHMnIHx8IHNjaGVtZSA9PT0gJ3dzcyc7XHJcbiAgICAgICAgICAgIHBvcnQgPSBwYXJzZUludChob3N0LnN1YnN0cmluZyhjb2xvbkluZCArIDEpLCAxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb2xvbkluZCA9IGhvc3QubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBob3N0V2l0aG91dFBvcnQgPSBob3N0LnNsaWNlKDAsIGNvbG9uSW5kKTtcclxuICAgICAgICBpZiAoaG9zdFdpdGhvdXRQb3J0LnRvTG93ZXJDYXNlKCkgPT09ICdsb2NhbGhvc3QnKSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9ICdsb2NhbGhvc3QnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChob3N0V2l0aG91dFBvcnQuc3BsaXQoJy4nKS5sZW5ndGggPD0gMikge1xyXG4gICAgICAgICAgICBkb21haW4gPSBob3N0V2l0aG91dFBvcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJbnRlcnByZXQgdGhlIHN1YmRvbWFpbiBvZiBhIDMgb3IgbW9yZSBjb21wb25lbnQgVVJMIGFzIHRoZSBuYW1lc3BhY2UgbmFtZS5cclxuICAgICAgICAgICAgY29uc3QgZG90SW5kID0gaG9zdC5pbmRleE9mKCcuJyk7XHJcbiAgICAgICAgICAgIHN1YmRvbWFpbiA9IGhvc3Quc3Vic3RyaW5nKDAsIGRvdEluZCkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgZG9tYWluID0gaG9zdC5zdWJzdHJpbmcoZG90SW5kICsgMSk7XHJcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBuYW1lc3BhY2VzIHRvIGxvd2VyY2FzZSB0byBzaGFyZSBzdG9yYWdlIC8gY29ubmVjdGlvbi5cclxuICAgICAgICAgICAgbmFtZXNwYWNlID0gc3ViZG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBbHdheXMgdHJlYXQgdGhlIHZhbHVlIG9mIHRoZSBgbnNgIGFzIHRoZSBuYW1lc3BhY2UgbmFtZSBpZiBpdCBpcyBwcmVzZW50LlxyXG4gICAgICAgIGlmICgnbnMnIGluIHF1ZXJ5UGFyYW1zKSB7XHJcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IHF1ZXJ5UGFyYW1zWyducyddO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaG9zdCxcclxuICAgICAgICBwb3J0LFxyXG4gICAgICAgIGRvbWFpbixcclxuICAgICAgICBzdWJkb21haW4sXHJcbiAgICAgICAgc2VjdXJlLFxyXG4gICAgICAgIHNjaGVtZSxcclxuICAgICAgICBwYXRoU3RyaW5nLFxyXG4gICAgICAgIG5hbWVzcGFjZVxyXG4gICAgfTtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gTW9kZWxlZCBhZnRlciBiYXNlNjQgd2ViLXNhZmUgY2hhcnMsIGJ1dCBvcmRlcmVkIGJ5IEFTQ0lJLlxyXG5jb25zdCBQVVNIX0NIQVJTID0gJy0wMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonO1xyXG4vKipcclxuICogRmFuY3kgSUQgZ2VuZXJhdG9yIHRoYXQgY3JlYXRlcyAyMC1jaGFyYWN0ZXIgc3RyaW5nIGlkZW50aWZpZXJzIHdpdGggdGhlXHJcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gKlxyXG4gKiAxLiBUaGV5J3JlIGJhc2VkIG9uIHRpbWVzdGFtcCBzbyB0aGF0IHRoZXkgc29ydCAqYWZ0ZXIqIGFueSBleGlzdGluZyBpZHMuXHJcbiAqIDIuIFRoZXkgY29udGFpbiA3Mi1iaXRzIG9mIHJhbmRvbSBkYXRhIGFmdGVyIHRoZSB0aW1lc3RhbXAgc28gdGhhdCBJRHMgd29uJ3RcclxuICogICAgY29sbGlkZSB3aXRoIG90aGVyIGNsaWVudHMnIElEcy5cclxuICogMy4gVGhleSBzb3J0ICpsZXhpY29ncmFwaGljYWxseSogKHNvIHRoZSB0aW1lc3RhbXAgaXMgY29udmVydGVkIHRvIGNoYXJhY3RlcnNcclxuICogICAgdGhhdCB3aWxsIHNvcnQgcHJvcGVybHkpLlxyXG4gKiA0LiBUaGV5J3JlIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZy4gRXZlbiBpZiB5b3UgZ2VuZXJhdGUgbW9yZSB0aGFuIG9uZSBpblxyXG4gKiAgICB0aGUgc2FtZSB0aW1lc3RhbXAsIHRoZSBsYXR0ZXIgb25lcyB3aWxsIHNvcnQgYWZ0ZXIgdGhlIGZvcm1lciBvbmVzLiBXZSBkb1xyXG4gKiAgICB0aGlzIGJ5IHVzaW5nIHRoZSBwcmV2aW91cyByYW5kb20gYml0cyBidXQgXCJpbmNyZW1lbnRpbmdcIiB0aGVtIGJ5IDEgKG9ubHlcclxuICogICAgaW4gdGhlIGNhc2Ugb2YgYSB0aW1lc3RhbXAgY29sbGlzaW9uKS5cclxuICovXHJcbmNvbnN0IG5leHRQdXNoSWQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gVGltZXN0YW1wIG9mIGxhc3QgcHVzaCwgdXNlZCB0byBwcmV2ZW50IGxvY2FsIGNvbGxpc2lvbnMgaWYgeW91IHB1c2ggdHdpY2VcclxuICAgIC8vIGluIG9uZSBtcy5cclxuICAgIGxldCBsYXN0UHVzaFRpbWUgPSAwO1xyXG4gICAgLy8gV2UgZ2VuZXJhdGUgNzItYml0cyBvZiByYW5kb21uZXNzIHdoaWNoIGdldCB0dXJuZWQgaW50byAxMiBjaGFyYWN0ZXJzIGFuZFxyXG4gICAgLy8gYXBwZW5kZWQgdG8gdGhlIHRpbWVzdGFtcCB0byBwcmV2ZW50IGNvbGxpc2lvbnMgd2l0aCBvdGhlciBjbGllbnRzLiBXZVxyXG4gICAgLy8gc3RvcmUgdGhlIGxhc3QgY2hhcmFjdGVycyB3ZSBnZW5lcmF0ZWQgYmVjYXVzZSBpbiB0aGUgZXZlbnQgb2YgYSBjb2xsaXNpb24sXHJcbiAgICAvLyB3ZSdsbCB1c2UgdGhvc2Ugc2FtZSBjaGFyYWN0ZXJzIGV4Y2VwdCBcImluY3JlbWVudGVkXCIgYnkgb25lLlxyXG4gICAgY29uc3QgbGFzdFJhbmRDaGFycyA9IFtdO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub3cpIHtcclxuICAgICAgICBjb25zdCBkdXBsaWNhdGVUaW1lID0gbm93ID09PSBsYXN0UHVzaFRpbWU7XHJcbiAgICAgICAgbGFzdFB1c2hUaW1lID0gbm93O1xyXG4gICAgICAgIGxldCBpO1xyXG4gICAgICAgIGNvbnN0IHRpbWVTdGFtcENoYXJzID0gbmV3IEFycmF5KDgpO1xyXG4gICAgICAgIGZvciAoaSA9IDc7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHRpbWVTdGFtcENoYXJzW2ldID0gUFVTSF9DSEFSUy5jaGFyQXQobm93ICUgNjQpO1xyXG4gICAgICAgICAgICAvLyBOT1RFOiBDYW4ndCB1c2UgPDwgaGVyZSBiZWNhdXNlIGphdmFzY3JpcHQgd2lsbCBjb252ZXJ0IHRvIGludCBhbmQgbG9zZVxyXG4gICAgICAgICAgICAvLyB0aGUgdXBwZXIgYml0cy5cclxuICAgICAgICAgICAgbm93ID0gTWF0aC5mbG9vcihub3cgLyA2NCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydChub3cgPT09IDAsICdDYW5ub3QgcHVzaCBhdCB0aW1lID09IDAnKTtcclxuICAgICAgICBsZXQgaWQgPSB0aW1lU3RhbXBDaGFycy5qb2luKCcnKTtcclxuICAgICAgICBpZiAoIWR1cGxpY2F0ZVRpbWUpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxhc3RSYW5kQ2hhcnNbaV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA2NCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSB0aW1lc3RhbXAgaGFzbid0IGNoYW5nZWQgc2luY2UgbGFzdCBwdXNoLCB1c2UgdGhlIHNhbWUgcmFuZG9tXHJcbiAgICAgICAgICAgIC8vIG51bWJlciwgZXhjZXB0IGluY3JlbWVudGVkIGJ5IDEuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDExOyBpID49IDAgJiYgbGFzdFJhbmRDaGFyc1tpXSA9PT0gNjM7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgbGFzdFJhbmRDaGFyc1tpXSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFzdFJhbmRDaGFyc1tpXSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xyXG4gICAgICAgICAgICBpZCArPSBQVVNIX0NIQVJTLmNoYXJBdChsYXN0UmFuZENoYXJzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0KGlkLmxlbmd0aCA9PT0gMjAsICduZXh0UHVzaElkOiBMZW5ndGggc2hvdWxkIGJlIDIwLicpO1xyXG4gICAgICAgIHJldHVybiBpZDtcclxuICAgIH07XHJcbn0pKCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBFbmNhcHN1bGF0ZXMgdGhlIGRhdGEgbmVlZGVkIHRvIHJhaXNlIGFuIGV2ZW50XHJcbiAqL1xyXG5jbGFzcyBEYXRhRXZlbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gT25lIG9mOiB2YWx1ZSwgY2hpbGRfYWRkZWQsIGNoaWxkX2NoYW5nZWQsIGNoaWxkX21vdmVkLCBjaGlsZF9yZW1vdmVkXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRSZWdpc3RyYXRpb24gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB0byB3aXRoIHRoZSBldmVudCBkYXRhLiBVc2VyIHByb3ZpZGVkXHJcbiAgICAgKiBAcGFyYW0gc25hcHNob3QgLSBUaGUgZGF0YSBiYWNraW5nIHRoZSBldmVudFxyXG4gICAgICogQHBhcmFtIHByZXZOYW1lIC0gT3B0aW9uYWwsIHRoZSBuYW1lIG9mIHRoZSBwcmV2aW91cyBjaGlsZCBmb3IgY2hpbGRfKiBldmVudHMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGV2ZW50VHlwZSwgZXZlbnRSZWdpc3RyYXRpb24sIHNuYXBzaG90LCBwcmV2TmFtZSkge1xyXG4gICAgICAgIHRoaXMuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xyXG4gICAgICAgIHRoaXMuZXZlbnRSZWdpc3RyYXRpb24gPSBldmVudFJlZ2lzdHJhdGlvbjtcclxuICAgICAgICB0aGlzLnNuYXBzaG90ID0gc25hcHNob3Q7XHJcbiAgICAgICAgdGhpcy5wcmV2TmFtZSA9IHByZXZOYW1lO1xyXG4gICAgfVxyXG4gICAgZ2V0UGF0aCgpIHtcclxuICAgICAgICBjb25zdCByZWYgPSB0aGlzLnNuYXBzaG90LnJlZjtcclxuICAgICAgICBpZiAodGhpcy5ldmVudFR5cGUgPT09ICd2YWx1ZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlZi5fcGF0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWYucGFyZW50Ll9wYXRoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEV2ZW50VHlwZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudFR5cGU7XHJcbiAgICB9XHJcbiAgICBnZXRFdmVudFJ1bm5lcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudFJlZ2lzdHJhdGlvbi5nZXRFdmVudFJ1bm5lcih0aGlzKTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5nZXRQYXRoKCkudG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICc6JyArXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRUeXBlICtcclxuICAgICAgICAgICAgJzonICtcclxuICAgICAgICAgICAgc3RyaW5naWZ5KHRoaXMuc25hcHNob3QuZXhwb3J0VmFsKCkpKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBDYW5jZWxFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihldmVudFJlZ2lzdHJhdGlvbiwgZXJyb3IsIHBhdGgpIHtcclxuICAgICAgICB0aGlzLmV2ZW50UmVnaXN0cmF0aW9uID0gZXZlbnRSZWdpc3RyYXRpb247XHJcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICB9XHJcbiAgICBnZXRQYXRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhdGg7XHJcbiAgICB9XHJcbiAgICBnZXRFdmVudFR5cGUoKSB7XHJcbiAgICAgICAgcmV0dXJuICdjYW5jZWwnO1xyXG4gICAgfVxyXG4gICAgZ2V0RXZlbnRSdW5uZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRSZWdpc3RyYXRpb24uZ2V0RXZlbnRSdW5uZXIodGhpcyk7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXRoLnRvU3RyaW5nKCkgKyAnOmNhbmNlbCc7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgd3JhcHBlciBjbGFzcyB0aGF0IGNvbnZlcnRzIGV2ZW50cyBmcm9tIHRoZSBkYXRhYmFzZUBleHAgU0RLIHRvIHRoZSBsZWdhY3lcclxuICogRGF0YWJhc2UgU0RLLiBFdmVudHMgYXJlIG5vdCBjb252ZXJ0ZWQgZGlyZWN0bHkgYXMgZXZlbnQgcmVnaXN0cmF0aW9uIHJlbGllc1xyXG4gKiBvbiByZWZlcmVuY2UgY29tcGFyaXNvbiBvZiB0aGUgb3JpZ2luYWwgdXNlciBjYWxsYmFjayAoc2VlIGBtYXRjaGVzKClgKSBhbmRcclxuICogcmVsaWVzIG9uIGVxdWFsaXR5IG9mIHRoZSBsZWdhY3kgU0RLJ3MgYGNvbnRleHRgIG9iamVjdC5cclxuICovXHJcbmNsYXNzIENhbGxiYWNrQ29udGV4dCB7XHJcbiAgICBjb25zdHJ1Y3RvcihzbmFwc2hvdENhbGxiYWNrLCBjYW5jZWxDYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuc25hcHNob3RDYWxsYmFjayA9IHNuYXBzaG90Q2FsbGJhY2s7XHJcbiAgICAgICAgdGhpcy5jYW5jZWxDYWxsYmFjayA9IGNhbmNlbENhbGxiYWNrO1xyXG4gICAgfVxyXG4gICAgb25WYWx1ZShleHBEYXRhU25hcHNob3QsIHByZXZpb3VzQ2hpbGROYW1lKSB7XHJcbiAgICAgICAgdGhpcy5zbmFwc2hvdENhbGxiYWNrLmNhbGwobnVsbCwgZXhwRGF0YVNuYXBzaG90LCBwcmV2aW91c0NoaWxkTmFtZSk7XHJcbiAgICB9XHJcbiAgICBvbkNhbmNlbChlcnJvcikge1xyXG4gICAgICAgIGFzc2VydCh0aGlzLmhhc0NhbmNlbENhbGxiYWNrLCAnUmFpc2luZyBhIGNhbmNlbCBldmVudCBvbiBhIGxpc3RlbmVyIHdpdGggbm8gY2FuY2VsIGNhbGxiYWNrJyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuY2VsQ2FsbGJhY2suY2FsbChudWxsLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgICBnZXQgaGFzQ2FuY2VsQ2FsbGJhY2soKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5jYW5jZWxDYWxsYmFjaztcclxuICAgIH1cclxuICAgIG1hdGNoZXMob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc25hcHNob3RDYWxsYmFjayA9PT0gb3RoZXIuc25hcHNob3RDYWxsYmFjayB8fFxyXG4gICAgICAgICAgICAodGhpcy5zbmFwc2hvdENhbGxiYWNrLnVzZXJDYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNuYXBzaG90Q2FsbGJhY2sudXNlckNhbGxiYWNrID09PVxyXG4gICAgICAgICAgICAgICAgICAgIG90aGVyLnNuYXBzaG90Q2FsbGJhY2sudXNlckNhbGxiYWNrICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNuYXBzaG90Q2FsbGJhY2suY29udGV4dCA9PT0gb3RoZXIuc25hcHNob3RDYWxsYmFjay5jb250ZXh0KSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBgb25EaXNjb25uZWN0YCBjbGFzcyBhbGxvd3MgeW91IHRvIHdyaXRlIG9yIGNsZWFyIGRhdGEgd2hlbiB5b3VyIGNsaWVudFxyXG4gKiBkaXNjb25uZWN0cyBmcm9tIHRoZSBEYXRhYmFzZSBzZXJ2ZXIuIFRoZXNlIHVwZGF0ZXMgb2NjdXIgd2hldGhlciB5b3VyXHJcbiAqIGNsaWVudCBkaXNjb25uZWN0cyBjbGVhbmx5IG9yIG5vdCwgc28geW91IGNhbiByZWx5IG9uIHRoZW0gdG8gY2xlYW4gdXAgZGF0YVxyXG4gKiBldmVuIGlmIGEgY29ubmVjdGlvbiBpcyBkcm9wcGVkIG9yIGEgY2xpZW50IGNyYXNoZXMuXHJcbiAqXHJcbiAqIFRoZSBgb25EaXNjb25uZWN0YCBjbGFzcyBpcyBtb3N0IGNvbW1vbmx5IHVzZWQgdG8gbWFuYWdlIHByZXNlbmNlIGluXHJcbiAqIGFwcGxpY2F0aW9ucyB3aGVyZSBpdCBpcyB1c2VmdWwgdG8gZGV0ZWN0IGhvdyBtYW55IGNsaWVudHMgYXJlIGNvbm5lY3RlZCBhbmRcclxuICogd2hlbiBvdGhlciBjbGllbnRzIGRpc2Nvbm5lY3QuIFNlZVxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL29mZmxpbmUtY2FwYWJpbGl0aWVzIHwgRW5hYmxpbmcgT2ZmbGluZSBDYXBhYmlsaXRpZXMgaW4gSmF2YVNjcmlwdH1cclxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIFRvIGF2b2lkIHByb2JsZW1zIHdoZW4gYSBjb25uZWN0aW9uIGlzIGRyb3BwZWQgYmVmb3JlIHRoZSByZXF1ZXN0cyBjYW4gYmVcclxuICogdHJhbnNmZXJyZWQgdG8gdGhlIERhdGFiYXNlIHNlcnZlciwgdGhlc2UgZnVuY3Rpb25zIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlXHJcbiAqIHdyaXRpbmcgYW55IGRhdGEuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgb25EaXNjb25uZWN0YCBvcGVyYXRpb25zIGFyZSBvbmx5IHRyaWdnZXJlZCBvbmNlLiBJZiB5b3Ugd2FudCBhblxyXG4gKiBvcGVyYXRpb24gdG8gb2NjdXIgZWFjaCB0aW1lIGEgZGlzY29ubmVjdCBvY2N1cnMsIHlvdSdsbCBuZWVkIHRvIHJlLWVzdGFibGlzaFxyXG4gKiB0aGUgYG9uRGlzY29ubmVjdGAgb3BlcmF0aW9ucyBlYWNoIHRpbWUgeW91IHJlY29ubmVjdC5cclxuICovXHJcbmNsYXNzIE9uRGlzY29ubmVjdCB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoX3JlcG8sIF9wYXRoKSB7XHJcbiAgICAgICAgdGhpcy5fcmVwbyA9IF9yZXBvO1xyXG4gICAgICAgIHRoaXMuX3BhdGggPSBfcGF0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FuY2VscyBhbGwgcHJldmlvdXNseSBxdWV1ZWQgYG9uRGlzY29ubmVjdCgpYCBzZXQgb3IgdXBkYXRlIGV2ZW50cyBmb3IgdGhpc1xyXG4gICAgICogbG9jYXRpb24gYW5kIGFsbCBjaGlsZHJlbi5cclxuICAgICAqXHJcbiAgICAgKiBJZiBhIHdyaXRlIGhhcyBiZWVuIHF1ZXVlZCBmb3IgdGhpcyBsb2NhdGlvbiB2aWEgYSBgc2V0KClgIG9yIGB1cGRhdGUoKWAgYXQgYVxyXG4gICAgICogcGFyZW50IGxvY2F0aW9uLCB0aGUgd3JpdGUgYXQgdGhpcyBsb2NhdGlvbiB3aWxsIGJlIGNhbmNlbGVkLCB0aG91Z2ggd3JpdGVzXHJcbiAgICAgKiB0byBzaWJsaW5nIGxvY2F0aW9ucyB3aWxsIHN0aWxsIG9jY3VyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHRvIHRoZSBzZXJ2ZXIgaXMgY29tcGxldGUuXHJcbiAgICAgKi9cclxuICAgIGNhbmNlbCgpIHtcclxuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgIHJlcG9PbkRpc2Nvbm5lY3RDYW5jZWwodGhpcy5fcmVwbywgdGhpcy5fcGF0aCwgZGVmZXJyZWQud3JhcENhbGxiYWNrKCgpID0+IHsgfSkpO1xyXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmVzIHRoZSBkYXRhIGF0IHRoaXMgbG9jYXRpb24gaXMgZGVsZXRlZCB3aGVuIHRoZSBjbGllbnQgaXMgZGlzY29ubmVjdGVkXHJcbiAgICAgKiAoZHVlIHRvIGNsb3NpbmcgdGhlIGJyb3dzZXIsIG5hdmlnYXRpbmcgdG8gYSBuZXcgcGFnZSwgb3IgbmV0d29yayBpc3N1ZXMpLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHRvIHRoZSBzZXJ2ZXIgaXMgY29tcGxldGUuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZSgpIHtcclxuICAgICAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnT25EaXNjb25uZWN0LnJlbW92ZScsIHRoaXMuX3BhdGgpO1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgcmVwb09uRGlzY29ubmVjdFNldCh0aGlzLl9yZXBvLCB0aGlzLl9wYXRoLCBudWxsLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhlIGRhdGEgYXQgdGhpcyBsb2NhdGlvbiBpcyBzZXQgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZSB3aGVuIHRoZVxyXG4gICAgICogY2xpZW50IGlzIGRpc2Nvbm5lY3RlZCAoZHVlIHRvIGNsb3NpbmcgdGhlIGJyb3dzZXIsIG5hdmlnYXRpbmcgdG8gYSBuZXcgcGFnZSxcclxuICAgICAqIG9yIG5ldHdvcmsgaXNzdWVzKS5cclxuICAgICAqXHJcbiAgICAgKiBgc2V0KClgIGlzIGVzcGVjaWFsbHkgdXNlZnVsIGZvciBpbXBsZW1lbnRpbmcgXCJwcmVzZW5jZVwiIHN5c3RlbXMsIHdoZXJlIGFcclxuICAgICAqIHZhbHVlIHNob3VsZCBiZSBjaGFuZ2VkIG9yIGNsZWFyZWQgd2hlbiBhIHVzZXIgZGlzY29ubmVjdHMgc28gdGhhdCB0aGV5XHJcbiAgICAgKiBhcHBlYXIgXCJvZmZsaW5lXCIgdG8gb3RoZXIgdXNlcnMuIFNlZVxyXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9vZmZsaW5lLWNhcGFiaWxpdGllcyB8IEVuYWJsaW5nIE9mZmxpbmUgQ2FwYWJpbGl0aWVzIGluIEphdmFTY3JpcHR9XHJcbiAgICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlIHRoYXQgYG9uRGlzY29ubmVjdGAgb3BlcmF0aW9ucyBhcmUgb25seSB0cmlnZ2VyZWQgb25jZS4gSWYgeW91IHdhbnQgYW5cclxuICAgICAqIG9wZXJhdGlvbiB0byBvY2N1ciBlYWNoIHRpbWUgYSBkaXNjb25uZWN0IG9jY3VycywgeW91J2xsIG5lZWQgdG8gcmUtZXN0YWJsaXNoXHJcbiAgICAgKiB0aGUgYG9uRGlzY29ubmVjdGAgb3BlcmF0aW9ucyBlYWNoIHRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIHdyaXR0ZW4gdG8gdGhpcyBsb2NhdGlvbiBvbiBkaXNjb25uZWN0IChjYW5cclxuICAgICAqIGJlIGFuIG9iamVjdCwgYXJyYXksIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvciBudWxsKS5cclxuICAgICAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHRvIHRoZSBEYXRhYmFzZSBpcyBjb21wbGV0ZS5cclxuICAgICAqL1xyXG4gICAgc2V0KHZhbHVlKSB7XHJcbiAgICAgICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ09uRGlzY29ubmVjdC5zZXQnLCB0aGlzLl9wYXRoKTtcclxuICAgICAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnT25EaXNjb25uZWN0LnNldCcsIHZhbHVlLCB0aGlzLl9wYXRoLCBmYWxzZSk7XHJcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICByZXBvT25EaXNjb25uZWN0U2V0KHRoaXMuX3JlcG8sIHRoaXMuX3BhdGgsIHZhbHVlLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhlIGRhdGEgYXQgdGhpcyBsb2NhdGlvbiBpcyBzZXQgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZSBhbmQgcHJpb3JpdHlcclxuICAgICAqIHdoZW4gdGhlIGNsaWVudCBpcyBkaXNjb25uZWN0ZWQgKGR1ZSB0byBjbG9zaW5nIHRoZSBicm93c2VyLCBuYXZpZ2F0aW5nIHRvIGFcclxuICAgICAqIG5ldyBwYWdlLCBvciBuZXR3b3JrIGlzc3VlcykuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIHdyaXR0ZW4gdG8gdGhpcyBsb2NhdGlvbiBvbiBkaXNjb25uZWN0IChjYW5cclxuICAgICAqIGJlIGFuIG9iamVjdCwgYXJyYXksIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvciBudWxsKS5cclxuICAgICAqIEBwYXJhbSBwcmlvcml0eSAtIFRoZSBwcmlvcml0eSB0byBiZSB3cml0dGVuIChzdHJpbmcsIG51bWJlciwgb3IgbnVsbCkuXHJcbiAgICAgKiBAcmV0dXJucyBSZXNvbHZlcyB3aGVuIHN5bmNocm9uaXphdGlvbiB0byB0aGUgRGF0YWJhc2UgaXMgY29tcGxldGUuXHJcbiAgICAgKi9cclxuICAgIHNldFdpdGhQcmlvcml0eSh2YWx1ZSwgcHJpb3JpdHkpIHtcclxuICAgICAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnT25EaXNjb25uZWN0LnNldFdpdGhQcmlvcml0eScsIHRoaXMuX3BhdGgpO1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdPbkRpc2Nvbm5lY3Quc2V0V2l0aFByaW9yaXR5JywgdmFsdWUsIHRoaXMuX3BhdGgsIGZhbHNlKTtcclxuICAgICAgICB2YWxpZGF0ZVByaW9yaXR5KCdPbkRpc2Nvbm5lY3Quc2V0V2l0aFByaW9yaXR5JywgcHJpb3JpdHksIGZhbHNlKTtcclxuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgIHJlcG9PbkRpc2Nvbm5lY3RTZXRXaXRoUHJpb3JpdHkodGhpcy5fcmVwbywgdGhpcy5fcGF0aCwgdmFsdWUsIHByaW9yaXR5LCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBtdWx0aXBsZSB2YWx1ZXMgYXQgdGhpcyBsb2NhdGlvbiB3aGVuIHRoZSBjbGllbnQgaXMgZGlzY29ubmVjdGVkIChkdWVcclxuICAgICAqIHRvIGNsb3NpbmcgdGhlIGJyb3dzZXIsIG5hdmlnYXRpbmcgdG8gYSBuZXcgcGFnZSwgb3IgbmV0d29yayBpc3N1ZXMpLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBgdmFsdWVzYCBhcmd1bWVudCBjb250YWlucyBtdWx0aXBsZSBwcm9wZXJ0eS12YWx1ZSBwYWlycyB0aGF0IHdpbGwgYmVcclxuICAgICAqIHdyaXR0ZW4gdG8gdGhlIERhdGFiYXNlIHRvZ2V0aGVyLiBFYWNoIGNoaWxkIHByb3BlcnR5IGNhbiBlaXRoZXIgYmUgYSBzaW1wbGVcclxuICAgICAqIHByb3BlcnR5IChmb3IgZXhhbXBsZSwgXCJuYW1lXCIpIG9yIGEgcmVsYXRpdmUgcGF0aCAoZm9yIGV4YW1wbGUsIFwibmFtZS9maXJzdFwiKVxyXG4gICAgICogZnJvbSB0aGUgY3VycmVudCBsb2NhdGlvbiB0byB0aGUgZGF0YSB0byB1cGRhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQXMgb3Bwb3NlZCB0byB0aGUgYHNldCgpYCBtZXRob2QsIGB1cGRhdGUoKWAgY2FuIGJlIHVzZSB0byBzZWxlY3RpdmVseSB1cGRhdGVcclxuICAgICAqIG9ubHkgdGhlIHJlZmVyZW5jZWQgcHJvcGVydGllcyBhdCB0aGUgY3VycmVudCBsb2NhdGlvbiAoaW5zdGVhZCBvZiByZXBsYWNpbmdcclxuICAgICAqIGFsbCB0aGUgY2hpbGQgcHJvcGVydGllcyBhdCB0aGUgY3VycmVudCBsb2NhdGlvbikuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIE9iamVjdCBjb250YWluaW5nIG11bHRpcGxlIHZhbHVlcy5cclxuICAgICAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHRvIHRoZSBEYXRhYmFzZSBpcyBjb21wbGV0ZS5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlKHZhbHVlcykge1xyXG4gICAgICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdPbkRpc2Nvbm5lY3QudXBkYXRlJywgdGhpcy5fcGF0aCk7XHJcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZU1lcmdlRGF0YUFyZygnT25EaXNjb25uZWN0LnVwZGF0ZScsIHZhbHVlcywgdGhpcy5fcGF0aCwgZmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgcmVwb09uRGlzY29ubmVjdFVwZGF0ZSh0aGlzLl9yZXBvLCB0aGlzLl9wYXRoLCB2YWx1ZXMsIGRlZmVycmVkLndyYXBDYWxsYmFjaygoKSA9PiB7IH0pKTtcclxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBRdWVyeUltcGwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaGlkZWNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9yZXBvLCBfcGF0aCwgX3F1ZXJ5UGFyYW1zLCBfb3JkZXJCeUNhbGxlZCkge1xyXG4gICAgICAgIHRoaXMuX3JlcG8gPSBfcmVwbztcclxuICAgICAgICB0aGlzLl9wYXRoID0gX3BhdGg7XHJcbiAgICAgICAgdGhpcy5fcXVlcnlQYXJhbXMgPSBfcXVlcnlQYXJhbXM7XHJcbiAgICAgICAgdGhpcy5fb3JkZXJCeUNhbGxlZCA9IF9vcmRlckJ5Q2FsbGVkO1xyXG4gICAgfVxyXG4gICAgZ2V0IGtleSgpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkodGhpcy5fcGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcGF0aEdldEJhY2sodGhpcy5fcGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IHJlZigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlZmVyZW5jZUltcGwodGhpcy5fcmVwbywgdGhpcy5fcGF0aCk7XHJcbiAgICB9XHJcbiAgICBnZXQgX3F1ZXJ5SWRlbnRpZmllcigpIHtcclxuICAgICAgICBjb25zdCBvYmogPSBxdWVyeVBhcmFtc0dldFF1ZXJ5T2JqZWN0KHRoaXMuX3F1ZXJ5UGFyYW1zKTtcclxuICAgICAgICBjb25zdCBpZCA9IE9iamVjdFRvVW5pcXVlS2V5KG9iaik7XHJcbiAgICAgICAgcmV0dXJuIGlkID09PSAne30nID8gJ2RlZmF1bHQnIDogaWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFuIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcXVlcnkgcGFyYW1ldGVycyB1c2VkIGJ5IHRoaXMgUXVlcnkuXHJcbiAgICAgKi9cclxuICAgIGdldCBfcXVlcnlPYmplY3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHF1ZXJ5UGFyYW1zR2V0UXVlcnlPYmplY3QodGhpcy5fcXVlcnlQYXJhbXMpO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIG90aGVyID0gZ2V0TW9kdWxhckluc3RhbmNlKG90aGVyKTtcclxuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFF1ZXJ5SW1wbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzYW1lUmVwbyA9IHRoaXMuX3JlcG8gPT09IG90aGVyLl9yZXBvO1xyXG4gICAgICAgIGNvbnN0IHNhbWVQYXRoID0gcGF0aEVxdWFscyh0aGlzLl9wYXRoLCBvdGhlci5fcGF0aCk7XHJcbiAgICAgICAgY29uc3Qgc2FtZVF1ZXJ5SWRlbnRpZmllciA9IHRoaXMuX3F1ZXJ5SWRlbnRpZmllciA9PT0gb3RoZXIuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgICAgICByZXR1cm4gc2FtZVJlcG8gJiYgc2FtZVBhdGggJiYgc2FtZVF1ZXJ5SWRlbnRpZmllcjtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcG8udG9TdHJpbmcoKSArIHBhdGhUb1VybEVuY29kZWRTdHJpbmcodGhpcy5fcGF0aCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyB0aGF0IG5vIG90aGVyIG9yZGVyIGJ5IGNhbGwgaGFzIGJlZW4gbWFkZVxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVOb1ByZXZpb3VzT3JkZXJCeUNhbGwocXVlcnksIGZuTmFtZSkge1xyXG4gICAgaWYgKHF1ZXJ5Ll9vcmRlckJ5Q2FsbGVkID09PSB0cnVlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZuTmFtZSArIFwiOiBZb3UgY2FuJ3QgY29tYmluZSBtdWx0aXBsZSBvcmRlckJ5IGNhbGxzLlwiKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVmFsaWRhdGVzIHN0YXJ0L2VuZCB2YWx1ZXMgZm9yIHF1ZXJpZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKHBhcmFtcykge1xyXG4gICAgbGV0IHN0YXJ0Tm9kZSA9IG51bGw7XHJcbiAgICBsZXQgZW5kTm9kZSA9IG51bGw7XHJcbiAgICBpZiAocGFyYW1zLmhhc1N0YXJ0KCkpIHtcclxuICAgICAgICBzdGFydE5vZGUgPSBwYXJhbXMuZ2V0SW5kZXhTdGFydFZhbHVlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAocGFyYW1zLmhhc0VuZCgpKSB7XHJcbiAgICAgICAgZW5kTm9kZSA9IHBhcmFtcy5nZXRJbmRleEVuZFZhbHVlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAocGFyYW1zLmdldEluZGV4KCkgPT09IEtFWV9JTkRFWCkge1xyXG4gICAgICAgIGNvbnN0IHRvb01hbnlBcmdzRXJyb3IgPSAnUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkga2V5LCB5b3UgbWF5IG9ubHkgcGFzcyBvbmUgYXJndW1lbnQgdG8gJyArXHJcbiAgICAgICAgICAgICdzdGFydEF0KCksIGVuZEF0KCksIG9yIGVxdWFsVG8oKS4nO1xyXG4gICAgICAgIGNvbnN0IHdyb25nQXJnVHlwZUVycm9yID0gJ1F1ZXJ5OiBXaGVuIG9yZGVyaW5nIGJ5IGtleSwgdGhlIGFyZ3VtZW50IHBhc3NlZCB0byBzdGFydEF0KCksIHN0YXJ0QWZ0ZXIoKSwgJyArXHJcbiAgICAgICAgICAgICdlbmRBdCgpLCBlbmRCZWZvcmUoKSwgb3IgZXF1YWxUbygpIG11c3QgYmUgYSBzdHJpbmcuJztcclxuICAgICAgICBpZiAocGFyYW1zLmhhc1N0YXJ0KCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnROYW1lID0gcGFyYW1zLmdldEluZGV4U3RhcnROYW1lKCk7XHJcbiAgICAgICAgICAgIGlmIChzdGFydE5hbWUgIT09IE1JTl9OQU1FKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodG9vTWFueUFyZ3NFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHN0YXJ0Tm9kZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih3cm9uZ0FyZ1R5cGVFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhcmFtcy5oYXNFbmQoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBlbmROYW1lID0gcGFyYW1zLmdldEluZGV4RW5kTmFtZSgpO1xyXG4gICAgICAgICAgICBpZiAoZW5kTmFtZSAhPT0gTUFYX05BTUUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0b29NYW55QXJnc0Vycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZW5kTm9kZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih3cm9uZ0FyZ1R5cGVFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwYXJhbXMuZ2V0SW5kZXgoKSA9PT0gUFJJT1JJVFlfSU5ERVgpIHtcclxuICAgICAgICBpZiAoKHN0YXJ0Tm9kZSAhPSBudWxsICYmICFpc1ZhbGlkUHJpb3JpdHkoc3RhcnROb2RlKSkgfHxcclxuICAgICAgICAgICAgKGVuZE5vZGUgIT0gbnVsbCAmJiAhaXNWYWxpZFByaW9yaXR5KGVuZE5vZGUpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5OiBXaGVuIG9yZGVyaW5nIGJ5IHByaW9yaXR5LCB0aGUgZmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIHN0YXJ0QXQoKSwgJyArXHJcbiAgICAgICAgICAgICAgICAnc3RhcnRBZnRlcigpIGVuZEF0KCksIGVuZEJlZm9yZSgpLCBvciBlcXVhbFRvKCkgbXVzdCBiZSBhIHZhbGlkIHByaW9yaXR5IHZhbHVlICcgK1xyXG4gICAgICAgICAgICAgICAgJyhudWxsLCBhIG51bWJlciwgb3IgYSBzdHJpbmcpLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFzc2VydChwYXJhbXMuZ2V0SW5kZXgoKSBpbnN0YW5jZW9mIFBhdGhJbmRleCB8fFxyXG4gICAgICAgICAgICBwYXJhbXMuZ2V0SW5kZXgoKSA9PT0gVkFMVUVfSU5ERVgsICd1bmtub3duIGluZGV4IHR5cGUuJyk7XHJcbiAgICAgICAgaWYgKChzdGFydE5vZGUgIT0gbnVsbCAmJiB0eXBlb2Ygc3RhcnROb2RlID09PSAnb2JqZWN0JykgfHxcclxuICAgICAgICAgICAgKGVuZE5vZGUgIT0gbnVsbCAmJiB0eXBlb2YgZW5kTm9kZSA9PT0gJ29iamVjdCcpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVlcnk6IEZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byBzdGFydEF0KCksIHN0YXJ0QWZ0ZXIoKSwgZW5kQXQoKSwgZW5kQmVmb3JlKCksIG9yICcgK1xyXG4gICAgICAgICAgICAgICAgJ2VxdWFsVG8oKSBjYW5ub3QgYmUgYW4gb2JqZWN0LicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogVmFsaWRhdGVzIHRoYXQgbGltaXQqIGhhcyBiZWVuIGNhbGxlZCB3aXRoIHRoZSBjb3JyZWN0IGNvbWJpbmF0aW9uIG9mIHBhcmFtZXRlcnNcclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlTGltaXQocGFyYW1zKSB7XHJcbiAgICBpZiAocGFyYW1zLmhhc1N0YXJ0KCkgJiZcclxuICAgICAgICBwYXJhbXMuaGFzRW5kKCkgJiZcclxuICAgICAgICBwYXJhbXMuaGFzTGltaXQoKSAmJlxyXG4gICAgICAgICFwYXJhbXMuaGFzQW5jaG9yZWRMaW1pdCgpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUXVlcnk6IENhbid0IGNvbWJpbmUgc3RhcnRBdCgpLCBzdGFydEFmdGVyKCksIGVuZEF0KCksIGVuZEJlZm9yZSgpLCBhbmQgbGltaXQoKS4gVXNlIFwiICtcclxuICAgICAgICAgICAgJ2xpbWl0VG9GaXJzdCgpIG9yIGxpbWl0VG9MYXN0KCkgaW5zdGVhZC4nKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBSZWZlcmVuY2VJbXBsIGV4dGVuZHMgUXVlcnlJbXBsIHtcclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihyZXBvLCBwYXRoKSB7XHJcbiAgICAgICAgc3VwZXIocmVwbywgcGF0aCwgbmV3IFF1ZXJ5UGFyYW1zKCksIGZhbHNlKTtcclxuICAgIH1cclxuICAgIGdldCBwYXJlbnQoKSB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IHBhdGhQYXJlbnQodGhpcy5fcGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudFBhdGggPT09IG51bGxcclxuICAgICAgICAgICAgPyBudWxsXHJcbiAgICAgICAgICAgIDogbmV3IFJlZmVyZW5jZUltcGwodGhpcy5fcmVwbywgcGFyZW50UGF0aCk7XHJcbiAgICB9XHJcbiAgICBnZXQgcm9vdCgpIHtcclxuICAgICAgICBsZXQgcmVmID0gdGhpcztcclxuICAgICAgICB3aGlsZSAocmVmLnBhcmVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZWYgPSByZWYucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVmO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIGBEYXRhU25hcHNob3RgIGNvbnRhaW5zIGRhdGEgZnJvbSBhIERhdGFiYXNlIGxvY2F0aW9uLlxyXG4gKlxyXG4gKiBBbnkgdGltZSB5b3UgcmVhZCBkYXRhIGZyb20gdGhlIERhdGFiYXNlLCB5b3UgcmVjZWl2ZSB0aGUgZGF0YSBhcyBhXHJcbiAqIGBEYXRhU25hcHNob3RgLiBBIGBEYXRhU25hcHNob3RgIGlzIHBhc3NlZCB0byB0aGUgZXZlbnQgY2FsbGJhY2tzIHlvdSBhdHRhY2hcclxuICogd2l0aCBgb24oKWAgb3IgYG9uY2UoKWAuIFlvdSBjYW4gZXh0cmFjdCB0aGUgY29udGVudHMgb2YgdGhlIHNuYXBzaG90IGFzIGFcclxuICogSmF2YVNjcmlwdCBvYmplY3QgYnkgY2FsbGluZyB0aGUgYHZhbCgpYCBtZXRob2QuIEFsdGVybmF0aXZlbHksIHlvdSBjYW5cclxuICogdHJhdmVyc2UgaW50byB0aGUgc25hcHNob3QgYnkgY2FsbGluZyBgY2hpbGQoKWAgdG8gcmV0dXJuIGNoaWxkIHNuYXBzaG90c1xyXG4gKiAod2hpY2ggeW91IGNvdWxkIHRoZW4gY2FsbCBgdmFsKClgIG9uKS5cclxuICpcclxuICogQSBgRGF0YVNuYXBzaG90YCBpcyBhbiBlZmZpY2llbnRseSBnZW5lcmF0ZWQsIGltbXV0YWJsZSBjb3B5IG9mIHRoZSBkYXRhIGF0XHJcbiAqIGEgRGF0YWJhc2UgbG9jYXRpb24uIEl0IGNhbm5vdCBiZSBtb2RpZmllZCBhbmQgd2lsbCBuZXZlciBjaGFuZ2UgKHRvIG1vZGlmeVxyXG4gKiBkYXRhLCB5b3UgYWx3YXlzIGNhbGwgdGhlIGBzZXQoKWAgbWV0aG9kIG9uIGEgYFJlZmVyZW5jZWAgZGlyZWN0bHkpLlxyXG4gKi9cclxuY2xhc3MgRGF0YVNuYXBzaG90IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIF9ub2RlIC0gQSBTbmFwc2hvdE5vZGUgdG8gd3JhcC5cclxuICAgICAqIEBwYXJhbSByZWYgLSBUaGUgbG9jYXRpb24gdGhpcyBzbmFwc2hvdCBjYW1lIGZyb20uXHJcbiAgICAgKiBAcGFyYW0gX2luZGV4IC0gVGhlIGl0ZXJhdGlvbiBvcmRlciBmb3IgdGhpcyBzbmFwc2hvdFxyXG4gICAgICogQGhpZGVjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihfbm9kZSwgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsb2NhdGlvbiBvZiB0aGlzIERhdGFTbmFwc2hvdC5cclxuICAgICAqL1xyXG4gICAgcmVmLCBfaW5kZXgpIHtcclxuICAgICAgICB0aGlzLl9ub2RlID0gX25vZGU7XHJcbiAgICAgICAgdGhpcy5yZWYgPSByZWY7XHJcbiAgICAgICAgdGhpcy5faW5kZXggPSBfaW5kZXg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHByaW9yaXR5IHZhbHVlIG9mIHRoZSBkYXRhIGluIHRoaXMgYERhdGFTbmFwc2hvdGAuXHJcbiAgICAgKlxyXG4gICAgICogQXBwbGljYXRpb25zIG5lZWQgbm90IHVzZSBwcmlvcml0eSBidXQgY2FuIG9yZGVyIGNvbGxlY3Rpb25zIGJ5XHJcbiAgICAgKiBvcmRpbmFyeSBwcm9wZXJ0aWVzIChzZWVcclxuICAgICAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNzb3J0aW5nX2FuZF9maWx0ZXJpbmdfZGF0YSB8U29ydGluZyBhbmQgZmlsdGVyaW5nIGRhdGF9XHJcbiAgICAgKiApLlxyXG4gICAgICovXHJcbiAgICBnZXQgcHJpb3JpdHkoKSB7XHJcbiAgICAgICAgLy8gdHlwZWNhc3QgaGVyZSBiZWNhdXNlIHdlIG5ldmVyIHJldHVybiBkZWZlcnJlZCB2YWx1ZXMgb3IgaW50ZXJuYWwgcHJpb3JpdGllcyAoTUFYX1BSSU9SSVRZKVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9ub2RlLmdldFByaW9yaXR5KCkudmFsKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBrZXkgKGxhc3QgcGFydCBvZiB0aGUgcGF0aCkgb2YgdGhlIGxvY2F0aW9uIG9mIHRoaXMgYERhdGFTbmFwc2hvdGAuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGxhc3QgdG9rZW4gaW4gYSBEYXRhYmFzZSBsb2NhdGlvbiBpcyBjb25zaWRlcmVkIGl0cyBrZXkuIEZvciBleGFtcGxlLFxyXG4gICAgICogXCJhZGFcIiBpcyB0aGUga2V5IGZvciB0aGUgL3VzZXJzL2FkYS8gbm9kZS4gQWNjZXNzaW5nIHRoZSBrZXkgb24gYW55XHJcbiAgICAgKiBgRGF0YVNuYXBzaG90YCB3aWxsIHJldHVybiB0aGUga2V5IGZvciB0aGUgbG9jYXRpb24gdGhhdCBnZW5lcmF0ZWQgaXQuXHJcbiAgICAgKiBIb3dldmVyLCBhY2Nlc3NpbmcgdGhlIGtleSBvbiB0aGUgcm9vdCBVUkwgb2YgYSBEYXRhYmFzZSB3aWxsIHJldHVyblxyXG4gICAgICogYG51bGxgLlxyXG4gICAgICovXHJcbiAgICBnZXQga2V5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlZi5rZXk7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoaWxkIHByb3BlcnRpZXMgb2YgdGhpcyBgRGF0YVNuYXBzaG90YC4gKi9cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ub2RlLm51bUNoaWxkcmVuKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYW5vdGhlciBgRGF0YVNuYXBzaG90YCBmb3IgdGhlIGxvY2F0aW9uIGF0IHRoZSBzcGVjaWZpZWQgcmVsYXRpdmUgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBQYXNzaW5nIGEgcmVsYXRpdmUgcGF0aCB0byB0aGUgYGNoaWxkKClgIG1ldGhvZCBvZiBhIERhdGFTbmFwc2hvdCByZXR1cm5zXHJcbiAgICAgKiBhbm90aGVyIGBEYXRhU25hcHNob3RgIGZvciB0aGUgbG9jYXRpb24gYXQgdGhlIHNwZWNpZmllZCByZWxhdGl2ZSBwYXRoLiBUaGVcclxuICAgICAqIHJlbGF0aXZlIHBhdGggY2FuIGVpdGhlciBiZSBhIHNpbXBsZSBjaGlsZCBuYW1lIChmb3IgZXhhbXBsZSwgXCJhZGFcIikgb3IgYVxyXG4gICAgICogZGVlcGVyLCBzbGFzaC1zZXBhcmF0ZWQgcGF0aCAoZm9yIGV4YW1wbGUsIFwiYWRhL25hbWUvZmlyc3RcIikuIElmIHRoZSBjaGlsZFxyXG4gICAgICogbG9jYXRpb24gaGFzIG5vIGRhdGEsIGFuIGVtcHR5IGBEYXRhU25hcHNob3RgICh0aGF0IGlzLCBhIGBEYXRhU25hcHNob3RgXHJcbiAgICAgKiB3aG9zZSB2YWx1ZSBpcyBgbnVsbGApIGlzIHJldHVybmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoIC0gQSByZWxhdGl2ZSBwYXRoIHRvIHRoZSBsb2NhdGlvbiBvZiBjaGlsZCBkYXRhLlxyXG4gICAgICovXHJcbiAgICBjaGlsZChwYXRoKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gbmV3IFBhdGgocGF0aCk7XHJcbiAgICAgICAgY29uc3QgY2hpbGRSZWYgPSBjaGlsZCh0aGlzLnJlZiwgcGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhU25hcHNob3QodGhpcy5fbm9kZS5nZXRDaGlsZChjaGlsZFBhdGgpLCBjaGlsZFJlZiwgUFJJT1JJVFlfSU5ERVgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBgRGF0YVNuYXBzaG90YCBjb250YWlucyBhbnkgZGF0YS4gSXQgaXMgc2xpZ2h0bHkgbW9yZVxyXG4gICAgICogZWZmaWNpZW50IHRoYW4gdXNpbmcgYHNuYXBzaG90LnZhbCgpICE9PSBudWxsYC5cclxuICAgICAqL1xyXG4gICAgZXhpc3RzKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5fbm9kZS5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4cG9ydHMgdGhlIGVudGlyZSBjb250ZW50cyBvZiB0aGUgRGF0YVNuYXBzaG90IGFzIGEgSmF2YVNjcmlwdCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGBleHBvcnRWYWwoKWAgbWV0aG9kIGlzIHNpbWlsYXIgdG8gYHZhbCgpYCwgZXhjZXB0IHByaW9yaXR5IGluZm9ybWF0aW9uXHJcbiAgICAgKiBpcyBpbmNsdWRlZCAoaWYgYXZhaWxhYmxlKSwgbWFraW5nIGl0IHN1aXRhYmxlIGZvciBiYWNraW5nIHVwIHlvdXIgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgRGF0YVNuYXBzaG90J3MgY29udGVudHMgYXMgYSBKYXZhU2NyaXB0IHZhbHVlIChPYmplY3QsXHJcbiAgICAgKiAgIEFycmF5LCBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb3IgYG51bGxgKS5cclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIGV4cG9ydFZhbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZS52YWwodHJ1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVudW1lcmF0ZXMgdGhlIHRvcC1sZXZlbCBjaGlsZHJlbiBpbiB0aGUgYEl0ZXJhdGVkRGF0YVNuYXBzaG90YC5cclxuICAgICAqXHJcbiAgICAgKiBCZWNhdXNlIG9mIHRoZSB3YXkgSmF2YVNjcmlwdCBvYmplY3RzIHdvcmssIHRoZSBvcmRlcmluZyBvZiBkYXRhIGluIHRoZVxyXG4gICAgICogSmF2YVNjcmlwdCBvYmplY3QgcmV0dXJuZWQgYnkgYHZhbCgpYCBpcyBub3QgZ3VhcmFudGVlZCB0byBtYXRjaCB0aGVcclxuICAgICAqIG9yZGVyaW5nIG9uIHRoZSBzZXJ2ZXIgbm9yIHRoZSBvcmRlcmluZyBvZiBgb25DaGlsZEFkZGVkKClgIGV2ZW50cy4gVGhhdCBpc1xyXG4gICAgICogd2hlcmUgYGZvckVhY2goKWAgY29tZXMgaW4gaGFuZHkuIEl0IGd1YXJhbnRlZXMgdGhlIGNoaWxkcmVuIG9mIGFcclxuICAgICAqIGBEYXRhU25hcHNob3RgIHdpbGwgYmUgaXRlcmF0ZWQgaW4gdGhlaXIgcXVlcnkgb3JkZXIuXHJcbiAgICAgKlxyXG4gICAgICogSWYgbm8gZXhwbGljaXQgYG9yZGVyQnkqKClgIG1ldGhvZCBpcyB1c2VkLCByZXN1bHRzIGFyZSByZXR1cm5lZFxyXG4gICAgICogb3JkZXJlZCBieSBrZXkgKHVubGVzcyBwcmlvcml0aWVzIGFyZSB1c2VkLCBpbiB3aGljaCBjYXNlLCByZXN1bHRzIGFyZVxyXG4gICAgICogcmV0dXJuZWQgYnkgcHJpb3JpdHkpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggY2hpbGQgRGF0YVNuYXBzaG90LlxyXG4gICAgICogVGhlIGNhbGxiYWNrIGNhbiByZXR1cm4gdHJ1ZSB0byBjYW5jZWwgZnVydGhlciBlbnVtZXJhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgZW51bWVyYXRpb24gd2FzIGNhbmNlbGVkIGR1ZSB0byB5b3VyIGNhbGxiYWNrIHJldHVybmluZ1xyXG4gICAgICogdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgZm9yRWFjaChhY3Rpb24pIHtcclxuICAgICAgICBpZiAodGhpcy5fbm9kZS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjaGlsZHJlbk5vZGUgPSB0aGlzLl9ub2RlO1xyXG4gICAgICAgIC8vIFNhbml0aXplIHRoZSByZXR1cm4gdmFsdWUgdG8gYSBib29sZWFuLiBDaGlsZHJlbk5vZGUuZm9yRWFjaENoaWxkIGhhcyBhIHdlaXJkIHJldHVybiB0eXBlLi4uXHJcbiAgICAgICAgcmV0dXJuICEhY2hpbGRyZW5Ob2RlLmZvckVhY2hDaGlsZCh0aGlzLl9pbmRleCwgKGtleSwgbm9kZSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uKG5ldyBEYXRhU25hcHNob3Qobm9kZSwgY2hpbGQodGhpcy5yZWYsIGtleSksIFBSSU9SSVRZX0lOREVYKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGNoaWxkIHBhdGggaGFzIChub24tbnVsbCkgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAtIEEgcmVsYXRpdmUgcGF0aCB0byB0aGUgbG9jYXRpb24gb2YgYSBwb3RlbnRpYWwgY2hpbGQuXHJcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgZGF0YSBleGlzdHMgYXQgdGhlIHNwZWNpZmllZCBjaGlsZCBwYXRoOyBlbHNlXHJcbiAgICAgKiAgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgaGFzQ2hpbGQocGF0aCkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IG5ldyBQYXRoKHBhdGgpO1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5fbm9kZS5nZXRDaGlsZChjaGlsZFBhdGgpLmlzRW1wdHkoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgYERhdGFTbmFwc2hvdGAgaGFzIGFueSBub24tYG51bGxgIGNoaWxkXHJcbiAgICAgKiBwcm9wZXJ0aWVzLlxyXG4gICAgICpcclxuICAgICAqIFlvdSBjYW4gdXNlIGBoYXNDaGlsZHJlbigpYCB0byBkZXRlcm1pbmUgaWYgYSBgRGF0YVNuYXBzaG90YCBoYXMgYW55XHJcbiAgICAgKiBjaGlsZHJlbi4gSWYgaXQgZG9lcywgeW91IGNhbiBlbnVtZXJhdGUgdGhlbSB1c2luZyBgZm9yRWFjaCgpYC4gSWYgaXRcclxuICAgICAqIGRvZXNuJ3QsIHRoZW4gZWl0aGVyIHRoaXMgc25hcHNob3QgY29udGFpbnMgYSBwcmltaXRpdmUgdmFsdWUgKHdoaWNoIGNhbiBiZVxyXG4gICAgICogcmV0cmlldmVkIHdpdGggYHZhbCgpYCkgb3IgaXQgaXMgZW1wdHkgKGluIHdoaWNoIGNhc2UsIGB2YWwoKWAgd2lsbCByZXR1cm5cclxuICAgICAqIGBudWxsYCkuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGlzIHNuYXBzaG90IGhhcyBhbnkgY2hpbGRyZW47IGVsc2UgZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIGhhc0NoaWxkcmVuKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9ub2RlLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuX25vZGUuaXNFbXB0eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIEpTT04tc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwb3J0VmFsKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4dHJhY3RzIGEgSmF2YVNjcmlwdCB2YWx1ZSBmcm9tIGEgYERhdGFTbmFwc2hvdGAuXHJcbiAgICAgKlxyXG4gICAgICogRGVwZW5kaW5nIG9uIHRoZSBkYXRhIGluIGEgYERhdGFTbmFwc2hvdGAsIHRoZSBgdmFsKClgIG1ldGhvZCBtYXkgcmV0dXJuIGFcclxuICAgICAqIHNjYWxhciB0eXBlIChzdHJpbmcsIG51bWJlciwgb3IgYm9vbGVhbiksIGFuIGFycmF5LCBvciBhbiBvYmplY3QuIEl0IG1heVxyXG4gICAgICogYWxzbyByZXR1cm4gbnVsbCwgaW5kaWNhdGluZyB0aGF0IHRoZSBgRGF0YVNuYXBzaG90YCBpcyBlbXB0eSAoY29udGFpbnMgbm9cclxuICAgICAqIGRhdGEpLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBEYXRhU25hcHNob3QncyBjb250ZW50cyBhcyBhIEphdmFTY3JpcHQgdmFsdWUgKE9iamVjdCxcclxuICAgICAqICAgQXJyYXksIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvciBgbnVsbGApLlxyXG4gICAgICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgdmFsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ub2RlLnZhbCgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBSZXR1cm5zIGEgYFJlZmVyZW5jZWAgcmVwcmVzZW50aW5nIHRoZSBsb2NhdGlvbiBpbiB0aGUgRGF0YWJhc2VcclxuICogY29ycmVzcG9uZGluZyB0byB0aGUgcHJvdmlkZWQgcGF0aC4gSWYgbm8gcGF0aCBpcyBwcm92aWRlZCwgdGhlIGBSZWZlcmVuY2VgXHJcbiAqIHdpbGwgcG9pbnQgdG8gdGhlIHJvb3Qgb2YgdGhlIERhdGFiYXNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gZGIgLSBUaGUgZGF0YWJhc2UgaW5zdGFuY2UgdG8gb2J0YWluIGEgcmVmZXJlbmNlIGZvci5cclxuICogQHBhcmFtIHBhdGggLSBPcHRpb25hbCBwYXRoIHJlcHJlc2VudGluZyB0aGUgbG9jYXRpb24gdGhlIHJldHVybmVkXHJcbiAqICAgYFJlZmVyZW5jZWAgd2lsbCBwb2ludC4gSWYgbm90IHByb3ZpZGVkLCB0aGUgcmV0dXJuZWQgYFJlZmVyZW5jZWAgd2lsbFxyXG4gKiAgIHBvaW50IHRvIHRoZSByb290IG9mIHRoZSBEYXRhYmFzZS5cclxuICogQHJldHVybnMgSWYgYSBwYXRoIGlzIHByb3ZpZGVkLCBhIGBSZWZlcmVuY2VgXHJcbiAqICAgcG9pbnRpbmcgdG8gdGhlIHByb3ZpZGVkIHBhdGguIE90aGVyd2lzZSwgYSBgUmVmZXJlbmNlYCBwb2ludGluZyB0byB0aGVcclxuICogICByb290IG9mIHRoZSBEYXRhYmFzZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlZihkYiwgcGF0aCkge1xyXG4gICAgZGIgPSBnZXRNb2R1bGFySW5zdGFuY2UoZGIpO1xyXG4gICAgZGIuX2NoZWNrTm90RGVsZXRlZCgncmVmJyk7XHJcbiAgICByZXR1cm4gcGF0aCAhPT0gdW5kZWZpbmVkID8gY2hpbGQoZGIuX3Jvb3QsIHBhdGgpIDogZGIuX3Jvb3Q7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBgUmVmZXJlbmNlYCByZXByZXNlbnRpbmcgdGhlIGxvY2F0aW9uIGluIHRoZSBEYXRhYmFzZVxyXG4gKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm92aWRlZCBGaXJlYmFzZSBVUkwuXHJcbiAqXHJcbiAqIEFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgdGhlIFVSTCBpcyBub3QgYSB2YWxpZCBGaXJlYmFzZSBEYXRhYmFzZSBVUkwgb3IgaXRcclxuICogaGFzIGEgZGlmZmVyZW50IGRvbWFpbiB0aGFuIHRoZSBjdXJyZW50IGBEYXRhYmFzZWAgaW5zdGFuY2UuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBhbGwgcXVlcnkgcGFyYW1ldGVycyAoYG9yZGVyQnlgLCBgbGltaXRUb0xhc3RgLCBldGMuKSBhcmUgaWdub3JlZFxyXG4gKiBhbmQgYXJlIG5vdCBhcHBsaWVkIHRvIHRoZSByZXR1cm5lZCBgUmVmZXJlbmNlYC5cclxuICpcclxuICogQHBhcmFtIGRiIC0gVGhlIGRhdGFiYXNlIGluc3RhbmNlIHRvIG9idGFpbiBhIHJlZmVyZW5jZSBmb3IuXHJcbiAqIEBwYXJhbSB1cmwgLSBUaGUgRmlyZWJhc2UgVVJMIGF0IHdoaWNoIHRoZSByZXR1cm5lZCBgUmVmZXJlbmNlYCB3aWxsXHJcbiAqICAgcG9pbnQuXHJcbiAqIEByZXR1cm5zIEEgYFJlZmVyZW5jZWAgcG9pbnRpbmcgdG8gdGhlIHByb3ZpZGVkXHJcbiAqICAgRmlyZWJhc2UgVVJMLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVmRnJvbVVSTChkYiwgdXJsKSB7XHJcbiAgICBkYiA9IGdldE1vZHVsYXJJbnN0YW5jZShkYik7XHJcbiAgICBkYi5fY2hlY2tOb3REZWxldGVkKCdyZWZGcm9tVVJMJyk7XHJcbiAgICBjb25zdCBwYXJzZWRVUkwgPSBwYXJzZVJlcG9JbmZvKHVybCwgZGIuX3JlcG8ucmVwb0luZm9fLm5vZGVBZG1pbik7XHJcbiAgICB2YWxpZGF0ZVVybCgncmVmRnJvbVVSTCcsIHBhcnNlZFVSTCk7XHJcbiAgICBjb25zdCByZXBvSW5mbyA9IHBhcnNlZFVSTC5yZXBvSW5mbztcclxuICAgIGlmICghZGIuX3JlcG8ucmVwb0luZm9fLmlzQ3VzdG9tSG9zdCgpICYmXHJcbiAgICAgICAgcmVwb0luZm8uaG9zdCAhPT0gZGIuX3JlcG8ucmVwb0luZm9fLmhvc3QpIHtcclxuICAgICAgICBmYXRhbCgncmVmRnJvbVVSTCcgK1xyXG4gICAgICAgICAgICAnOiBIb3N0IG5hbWUgZG9lcyBub3QgbWF0Y2ggdGhlIGN1cnJlbnQgZGF0YWJhc2U6ICcgK1xyXG4gICAgICAgICAgICAnKGZvdW5kICcgK1xyXG4gICAgICAgICAgICByZXBvSW5mby5ob3N0ICtcclxuICAgICAgICAgICAgJyBidXQgZXhwZWN0ZWQgJyArXHJcbiAgICAgICAgICAgIGRiLl9yZXBvLnJlcG9JbmZvXy5ob3N0ICtcclxuICAgICAgICAgICAgJyknKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZWYoZGIsIHBhcnNlZFVSTC5wYXRoLnRvU3RyaW5nKCkpO1xyXG59XHJcbi8qKlxyXG4gKiBHZXRzIGEgYFJlZmVyZW5jZWAgZm9yIHRoZSBsb2NhdGlvbiBhdCB0aGUgc3BlY2lmaWVkIHJlbGF0aXZlIHBhdGguXHJcbiAqXHJcbiAqIFRoZSByZWxhdGl2ZSBwYXRoIGNhbiBlaXRoZXIgYmUgYSBzaW1wbGUgY2hpbGQgbmFtZSAoZm9yIGV4YW1wbGUsIFwiYWRhXCIpIG9yXHJcbiAqIGEgZGVlcGVyIHNsYXNoLXNlcGFyYXRlZCBwYXRoIChmb3IgZXhhbXBsZSwgXCJhZGEvbmFtZS9maXJzdFwiKS5cclxuICpcclxuICogQHBhcmFtIHBhcmVudCAtIFRoZSBwYXJlbnQgbG9jYXRpb24uXHJcbiAqIEBwYXJhbSBwYXRoIC0gQSByZWxhdGl2ZSBwYXRoIGZyb20gdGhpcyBsb2NhdGlvbiB0byB0aGUgZGVzaXJlZCBjaGlsZFxyXG4gKiAgIGxvY2F0aW9uLlxyXG4gKiBAcmV0dXJucyBUaGUgc3BlY2lmaWVkIGNoaWxkIGxvY2F0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gY2hpbGQocGFyZW50LCBwYXRoKSB7XHJcbiAgICBwYXJlbnQgPSBnZXRNb2R1bGFySW5zdGFuY2UocGFyZW50KTtcclxuICAgIGlmIChwYXRoR2V0RnJvbnQocGFyZW50Ll9wYXRoKSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHZhbGlkYXRlUm9vdFBhdGhTdHJpbmcoJ2NoaWxkJywgJ3BhdGgnLCBwYXRoLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YWxpZGF0ZVBhdGhTdHJpbmcoJ2NoaWxkJywgJ3BhdGgnLCBwYXRoLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFJlZmVyZW5jZUltcGwocGFyZW50Ll9yZXBvLCBwYXRoQ2hpbGQocGFyZW50Ll9wYXRoLCBwYXRoKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gYE9uRGlzY29ubmVjdGAgb2JqZWN0IC0gc2VlXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvb2ZmbGluZS1jYXBhYmlsaXRpZXMgfCBFbmFibGluZyBPZmZsaW5lIENhcGFiaWxpdGllcyBpbiBKYXZhU2NyaXB0fVxyXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBob3cgdG8gdXNlIGl0LlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmIC0gVGhlIHJlZmVyZW5jZSB0byBhZGQgT25EaXNjb25uZWN0IHRyaWdnZXJzIGZvci5cclxuICovXHJcbmZ1bmN0aW9uIG9uRGlzY29ubmVjdChyZWYpIHtcclxuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xyXG4gICAgcmV0dXJuIG5ldyBPbkRpc2Nvbm5lY3QocmVmLl9yZXBvLCByZWYuX3BhdGgpO1xyXG59XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBuZXcgY2hpbGQgbG9jYXRpb24gdXNpbmcgYSB1bmlxdWUga2V5IGFuZCByZXR1cm5zIGl0c1xyXG4gKiBgUmVmZXJlbmNlYC5cclxuICpcclxuICogVGhpcyBpcyB0aGUgbW9zdCBjb21tb24gcGF0dGVybiBmb3IgYWRkaW5nIGRhdGEgdG8gYSBjb2xsZWN0aW9uIG9mIGl0ZW1zLlxyXG4gKlxyXG4gKiBJZiB5b3UgcHJvdmlkZSBhIHZhbHVlIHRvIGBwdXNoKClgLCB0aGUgdmFsdWUgaXMgd3JpdHRlbiB0byB0aGVcclxuICogZ2VuZXJhdGVkIGxvY2F0aW9uLiBJZiB5b3UgZG9uJ3QgcGFzcyBhIHZhbHVlLCBub3RoaW5nIGlzIHdyaXR0ZW4gdG8gdGhlXHJcbiAqIGRhdGFiYXNlIGFuZCB0aGUgY2hpbGQgcmVtYWlucyBlbXB0eSAoYnV0IHlvdSBjYW4gdXNlIHRoZSBgUmVmZXJlbmNlYFxyXG4gKiBlbHNld2hlcmUpLlxyXG4gKlxyXG4gKiBUaGUgdW5pcXVlIGtleXMgZ2VuZXJhdGVkIGJ5IGBwdXNoKClgIGFyZSBvcmRlcmVkIGJ5IHRoZSBjdXJyZW50IHRpbWUsIHNvIHRoZVxyXG4gKiByZXN1bHRpbmcgbGlzdCBvZiBpdGVtcyBpcyBjaHJvbm9sb2dpY2FsbHkgc29ydGVkLiBUaGUga2V5cyBhcmUgYWxzb1xyXG4gKiBkZXNpZ25lZCB0byBiZSB1bmd1ZXNzYWJsZSAodGhleSBjb250YWluIDcyIHJhbmRvbSBiaXRzIG9mIGVudHJvcHkpLlxyXG4gKlxyXG4gKiBTZWUge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI2FwcGVuZF90b19hX2xpc3Rfb2ZfZGF0YSB8IEFwcGVuZCB0byBhIGxpc3Qgb2YgZGF0YX0uXHJcbiAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGVibG9nLmNvbS8yMDE1LzAyL3RoZS0yMTIwLXdheXMtdG8tZW5zdXJlLXVuaXF1ZV82OC5odG1sIHwgVGhlIDJeMTIwIFdheXMgdG8gRW5zdXJlIFVuaXF1ZSBJZGVudGlmaWVyc30uXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXJlbnQgLSBUaGUgcGFyZW50IGxvY2F0aW9uLlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBPcHRpb25hbCB2YWx1ZSB0byBiZSB3cml0dGVuIGF0IHRoZSBnZW5lcmF0ZWQgbG9jYXRpb24uXHJcbiAqIEByZXR1cm5zIENvbWJpbmVkIGBQcm9taXNlYCBhbmQgYFJlZmVyZW5jZWA7IHJlc29sdmVzIHdoZW4gd3JpdGUgaXMgY29tcGxldGUsXHJcbiAqIGJ1dCBjYW4gYmUgdXNlZCBpbW1lZGlhdGVseSBhcyB0aGUgYFJlZmVyZW5jZWAgdG8gdGhlIGNoaWxkIGxvY2F0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gcHVzaChwYXJlbnQsIHZhbHVlKSB7XHJcbiAgICBwYXJlbnQgPSBnZXRNb2R1bGFySW5zdGFuY2UocGFyZW50KTtcclxuICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdwdXNoJywgcGFyZW50Ll9wYXRoKTtcclxuICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdwdXNoJywgdmFsdWUsIHBhcmVudC5fcGF0aCwgdHJ1ZSk7XHJcbiAgICBjb25zdCBub3cgPSByZXBvU2VydmVyVGltZShwYXJlbnQuX3JlcG8pO1xyXG4gICAgY29uc3QgbmFtZSA9IG5leHRQdXNoSWQobm93KTtcclxuICAgIC8vIHB1c2goKSByZXR1cm5zIGEgVGhlbm5hYmxlUmVmZXJlbmNlIHdob3NlIHByb21pc2UgaXMgZnVsZmlsbGVkIHdpdGggYVxyXG4gICAgLy8gcmVndWxhciBSZWZlcmVuY2UuIFdlIHVzZSBjaGlsZCgpIHRvIGNyZWF0ZSBoYW5kbGVzIHRvIHR3byBkaWZmZXJlbnRcclxuICAgIC8vIHJlZmVyZW5jZXMuIFRoZSBmaXJzdCBpcyB0dXJuZWQgaW50byBhIFRoZW5uYWJsZVJlZmVyZW5jZSBiZWxvdyBieSBhZGRpbmdcclxuICAgIC8vIHRoZW4oKSBhbmQgY2F0Y2goKSBtZXRob2RzIGFuZCBpcyB1c2VkIGFzIHRoZSByZXR1cm4gdmFsdWUgb2YgcHVzaCgpLiBUaGVcclxuICAgIC8vIHNlY29uZCByZW1haW5zIGEgcmVndWxhciBSZWZlcmVuY2UgYW5kIGlzIHVzZWQgYXMgdGhlIGZ1bGZpbGxlZCB2YWx1ZSBvZlxyXG4gICAgLy8gdGhlIGZpcnN0IFRoZW5uYWJsZVJlZmVyZW5jZS5cclxuICAgIGNvbnN0IHRoZW5hYmxlUHVzaFJlZiA9IGNoaWxkKHBhcmVudCwgbmFtZSk7XHJcbiAgICBjb25zdCBwdXNoUmVmID0gY2hpbGQocGFyZW50LCBuYW1lKTtcclxuICAgIGxldCBwcm9taXNlO1xyXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICBwcm9taXNlID0gc2V0KHB1c2hSZWYsIHZhbHVlKS50aGVuKCgpID0+IHB1c2hSZWYpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShwdXNoUmVmKTtcclxuICAgIH1cclxuICAgIHRoZW5hYmxlUHVzaFJlZi50aGVuID0gcHJvbWlzZS50aGVuLmJpbmQocHJvbWlzZSk7XHJcbiAgICB0aGVuYWJsZVB1c2hSZWYuY2F0Y2ggPSBwcm9taXNlLnRoZW4uYmluZChwcm9taXNlLCB1bmRlZmluZWQpO1xyXG4gICAgcmV0dXJuIHRoZW5hYmxlUHVzaFJlZjtcclxufVxyXG4vKipcclxuICogUmVtb3ZlcyB0aGUgZGF0YSBhdCB0aGlzIERhdGFiYXNlIGxvY2F0aW9uLlxyXG4gKlxyXG4gKiBBbnkgZGF0YSBhdCBjaGlsZCBsb2NhdGlvbnMgd2lsbCBhbHNvIGJlIGRlbGV0ZWQuXHJcbiAqXHJcbiAqIFRoZSBlZmZlY3Qgb2YgdGhlIHJlbW92ZSB3aWxsIGJlIHZpc2libGUgaW1tZWRpYXRlbHkgYW5kIHRoZSBjb3JyZXNwb25kaW5nXHJcbiAqIGV2ZW50ICd2YWx1ZScgd2lsbCBiZSB0cmlnZ2VyZWQuIFN5bmNocm9uaXphdGlvbiBvZiB0aGUgcmVtb3ZlIHRvIHRoZVxyXG4gKiBGaXJlYmFzZSBzZXJ2ZXJzIHdpbGwgYWxzbyBiZSBzdGFydGVkLCBhbmQgdGhlIHJldHVybmVkIFByb21pc2Ugd2lsbCByZXNvbHZlXHJcbiAqIHdoZW4gY29tcGxldGUuIElmIHByb3ZpZGVkLCB0aGUgb25Db21wbGV0ZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZFxyXG4gKiBhc3luY2hyb25vdXNseSBhZnRlciBzeW5jaHJvbml6YXRpb24gaGFzIGZpbmlzaGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmIC0gVGhlIGxvY2F0aW9uIHRvIHJlbW92ZS5cclxuICogQHJldHVybnMgUmVzb2x2ZXMgd2hlbiByZW1vdmUgb24gc2VydmVyIGlzIGNvbXBsZXRlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVtb3ZlKHJlZikge1xyXG4gICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ3JlbW92ZScsIHJlZi5fcGF0aCk7XHJcbiAgICByZXR1cm4gc2V0KHJlZiwgbnVsbCk7XHJcbn1cclxuLyoqXHJcbiAqIFdyaXRlcyBkYXRhIHRvIHRoaXMgRGF0YWJhc2UgbG9jYXRpb24uXHJcbiAqXHJcbiAqIFRoaXMgd2lsbCBvdmVyd3JpdGUgYW55IGRhdGEgYXQgdGhpcyBsb2NhdGlvbiBhbmQgYWxsIGNoaWxkIGxvY2F0aW9ucy5cclxuICpcclxuICogVGhlIGVmZmVjdCBvZiB0aGUgd3JpdGUgd2lsbCBiZSB2aXNpYmxlIGltbWVkaWF0ZWx5LCBhbmQgdGhlIGNvcnJlc3BvbmRpbmdcclxuICogZXZlbnRzIChcInZhbHVlXCIsIFwiY2hpbGRfYWRkZWRcIiwgZXRjLikgd2lsbCBiZSB0cmlnZ2VyZWQuIFN5bmNocm9uaXphdGlvbiBvZlxyXG4gKiB0aGUgZGF0YSB0byB0aGUgRmlyZWJhc2Ugc2VydmVycyB3aWxsIGFsc28gYmUgc3RhcnRlZCwgYW5kIHRoZSByZXR1cm5lZFxyXG4gKiBQcm9taXNlIHdpbGwgcmVzb2x2ZSB3aGVuIGNvbXBsZXRlLiBJZiBwcm92aWRlZCwgdGhlIGBvbkNvbXBsZXRlYCBjYWxsYmFja1xyXG4gKiB3aWxsIGJlIGNhbGxlZCBhc3luY2hyb25vdXNseSBhZnRlciBzeW5jaHJvbml6YXRpb24gaGFzIGZpbmlzaGVkLlxyXG4gKlxyXG4gKiBQYXNzaW5nIGBudWxsYCBmb3IgdGhlIG5ldyB2YWx1ZSBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmcgYHJlbW92ZSgpYDsgbmFtZWx5LFxyXG4gKiBhbGwgZGF0YSBhdCB0aGlzIGxvY2F0aW9uIGFuZCBhbGwgY2hpbGQgbG9jYXRpb25zIHdpbGwgYmUgZGVsZXRlZC5cclxuICpcclxuICogYHNldCgpYCB3aWxsIHJlbW92ZSBhbnkgcHJpb3JpdHkgc3RvcmVkIGF0IHRoaXMgbG9jYXRpb24sIHNvIGlmIHByaW9yaXR5IGlzXHJcbiAqIG1lYW50IHRvIGJlIHByZXNlcnZlZCwgeW91IG5lZWQgdG8gdXNlIGBzZXRXaXRoUHJpb3JpdHkoKWAgaW5zdGVhZC5cclxuICpcclxuICogTm90ZSB0aGF0IG1vZGlmeWluZyBkYXRhIHdpdGggYHNldCgpYCB3aWxsIGNhbmNlbCBhbnkgcGVuZGluZyB0cmFuc2FjdGlvbnNcclxuICogYXQgdGhhdCBsb2NhdGlvbiwgc28gZXh0cmVtZSBjYXJlIHNob3VsZCBiZSB0YWtlbiBpZiBtaXhpbmcgYHNldCgpYCBhbmRcclxuICogYHRyYW5zYWN0aW9uKClgIHRvIG1vZGlmeSB0aGUgc2FtZSBkYXRhLlxyXG4gKlxyXG4gKiBBIHNpbmdsZSBgc2V0KClgIHdpbGwgZ2VuZXJhdGUgYSBzaW5nbGUgXCJ2YWx1ZVwiIGV2ZW50IGF0IHRoZSBsb2NhdGlvbiB3aGVyZVxyXG4gKiB0aGUgYHNldCgpYCB3YXMgcGVyZm9ybWVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmIC0gVGhlIGxvY2F0aW9uIHRvIHdyaXRlIHRvLlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgd3JpdHRlbiAoc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG9iamVjdCxcclxuICogICBhcnJheSwgb3IgbnVsbCkuXHJcbiAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gd3JpdGUgdG8gc2VydmVyIGlzIGNvbXBsZXRlLlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0KHJlZiwgdmFsdWUpIHtcclxuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xyXG4gICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ3NldCcsIHJlZi5fcGF0aCk7XHJcbiAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnc2V0JywgdmFsdWUsIHJlZi5fcGF0aCwgZmFsc2UpO1xyXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgIHJlcG9TZXRXaXRoUHJpb3JpdHkocmVmLl9yZXBvLCByZWYuX3BhdGgsIHZhbHVlLCBcclxuICAgIC8qcHJpb3JpdHk9Ki8gbnVsbCwgZGVmZXJyZWQud3JhcENhbGxiYWNrKCgpID0+IHsgfSkpO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbn1cclxuLyoqXHJcbiAqIFNldHMgYSBwcmlvcml0eSBmb3IgdGhlIGRhdGEgYXQgdGhpcyBEYXRhYmFzZSBsb2NhdGlvbi5cclxuICpcclxuICogQXBwbGljYXRpb25zIG5lZWQgbm90IHVzZSBwcmlvcml0eSBidXQgY2FuIG9yZGVyIGNvbGxlY3Rpb25zIGJ5XHJcbiAqIG9yZGluYXJ5IHByb3BlcnRpZXMgKHNlZVxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjc29ydGluZ19hbmRfZmlsdGVyaW5nX2RhdGEgfCBTb3J0aW5nIGFuZCBmaWx0ZXJpbmcgZGF0YX1cclxuICogKS5cclxuICpcclxuICogQHBhcmFtIHJlZiAtIFRoZSBsb2NhdGlvbiB0byB3cml0ZSB0by5cclxuICogQHBhcmFtIHByaW9yaXR5IC0gVGhlIHByaW9yaXR5IHRvIGJlIHdyaXR0ZW4gKHN0cmluZywgbnVtYmVyLCBvciBudWxsKS5cclxuICogQHJldHVybnMgUmVzb2x2ZXMgd2hlbiB3cml0ZSB0byBzZXJ2ZXIgaXMgY29tcGxldGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRQcmlvcml0eShyZWYsIHByaW9yaXR5KSB7XHJcbiAgICByZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmKTtcclxuICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdzZXRQcmlvcml0eScsIHJlZi5fcGF0aCk7XHJcbiAgICB2YWxpZGF0ZVByaW9yaXR5KCdzZXRQcmlvcml0eScsIHByaW9yaXR5LCBmYWxzZSk7XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgcmVwb1NldFdpdGhQcmlvcml0eShyZWYuX3JlcG8sIHBhdGhDaGlsZChyZWYuX3BhdGgsICcucHJpb3JpdHknKSwgcHJpb3JpdHksIG51bGwsIGRlZmVycmVkLndyYXBDYWxsYmFjaygoKSA9PiB7IH0pKTtcclxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG59XHJcbi8qKlxyXG4gKiBXcml0ZXMgZGF0YSB0aGUgRGF0YWJhc2UgbG9jYXRpb24uIExpa2UgYHNldCgpYCBidXQgYWxzbyBzcGVjaWZpZXMgdGhlXHJcbiAqIHByaW9yaXR5IGZvciB0aGF0IGRhdGEuXHJcbiAqXHJcbiAqIEFwcGxpY2F0aW9ucyBuZWVkIG5vdCB1c2UgcHJpb3JpdHkgYnV0IGNhbiBvcmRlciBjb2xsZWN0aW9ucyBieVxyXG4gKiBvcmRpbmFyeSBwcm9wZXJ0aWVzIChzZWVcclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI3NvcnRpbmdfYW5kX2ZpbHRlcmluZ19kYXRhIHwgU29ydGluZyBhbmQgZmlsdGVyaW5nIGRhdGF9XHJcbiAqICkuXHJcbiAqXHJcbiAqIEBwYXJhbSByZWYgLSBUaGUgbG9jYXRpb24gdG8gd3JpdGUgdG8uXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSB3cml0dGVuIChzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb2JqZWN0LFxyXG4gKiAgIGFycmF5LCBvciBudWxsKS5cclxuICogQHBhcmFtIHByaW9yaXR5IC0gVGhlIHByaW9yaXR5IHRvIGJlIHdyaXR0ZW4gKHN0cmluZywgbnVtYmVyLCBvciBudWxsKS5cclxuICogQHJldHVybnMgUmVzb2x2ZXMgd2hlbiB3cml0ZSB0byBzZXJ2ZXIgaXMgY29tcGxldGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRXaXRoUHJpb3JpdHkocmVmLCB2YWx1ZSwgcHJpb3JpdHkpIHtcclxuICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdzZXRXaXRoUHJpb3JpdHknLCByZWYuX3BhdGgpO1xyXG4gICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ3NldFdpdGhQcmlvcml0eScsIHZhbHVlLCByZWYuX3BhdGgsIGZhbHNlKTtcclxuICAgIHZhbGlkYXRlUHJpb3JpdHkoJ3NldFdpdGhQcmlvcml0eScsIHByaW9yaXR5LCBmYWxzZSk7XHJcbiAgICBpZiAocmVmLmtleSA9PT0gJy5sZW5ndGgnIHx8IHJlZi5rZXkgPT09ICcua2V5cycpIHtcclxuICAgICAgICB0aHJvdyAnc2V0V2l0aFByaW9yaXR5IGZhaWxlZDogJyArIHJlZi5rZXkgKyAnIGlzIGEgcmVhZC1vbmx5IG9iamVjdC4nO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgIHJlcG9TZXRXaXRoUHJpb3JpdHkocmVmLl9yZXBvLCByZWYuX3BhdGgsIHZhbHVlLCBwcmlvcml0eSwgZGVmZXJyZWQud3JhcENhbGxiYWNrKCgpID0+IHsgfSkpO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbn1cclxuLyoqXHJcbiAqIFdyaXRlcyBtdWx0aXBsZSB2YWx1ZXMgdG8gdGhlIERhdGFiYXNlIGF0IG9uY2UuXHJcbiAqXHJcbiAqIFRoZSBgdmFsdWVzYCBhcmd1bWVudCBjb250YWlucyBtdWx0aXBsZSBwcm9wZXJ0eS12YWx1ZSBwYWlycyB0aGF0IHdpbGwgYmVcclxuICogd3JpdHRlbiB0byB0aGUgRGF0YWJhc2UgdG9nZXRoZXIuIEVhY2ggY2hpbGQgcHJvcGVydHkgY2FuIGVpdGhlciBiZSBhIHNpbXBsZVxyXG4gKiBwcm9wZXJ0eSAoZm9yIGV4YW1wbGUsIFwibmFtZVwiKSBvciBhIHJlbGF0aXZlIHBhdGggKGZvciBleGFtcGxlLFxyXG4gKiBcIm5hbWUvZmlyc3RcIikgZnJvbSB0aGUgY3VycmVudCBsb2NhdGlvbiB0byB0aGUgZGF0YSB0byB1cGRhdGUuXHJcbiAqXHJcbiAqIEFzIG9wcG9zZWQgdG8gdGhlIGBzZXQoKWAgbWV0aG9kLCBgdXBkYXRlKClgIGNhbiBiZSB1c2UgdG8gc2VsZWN0aXZlbHkgdXBkYXRlXHJcbiAqIG9ubHkgdGhlIHJlZmVyZW5jZWQgcHJvcGVydGllcyBhdCB0aGUgY3VycmVudCBsb2NhdGlvbiAoaW5zdGVhZCBvZiByZXBsYWNpbmdcclxuICogYWxsIHRoZSBjaGlsZCBwcm9wZXJ0aWVzIGF0IHRoZSBjdXJyZW50IGxvY2F0aW9uKS5cclxuICpcclxuICogVGhlIGVmZmVjdCBvZiB0aGUgd3JpdGUgd2lsbCBiZSB2aXNpYmxlIGltbWVkaWF0ZWx5LCBhbmQgdGhlIGNvcnJlc3BvbmRpbmdcclxuICogZXZlbnRzICgndmFsdWUnLCAnY2hpbGRfYWRkZWQnLCBldGMuKSB3aWxsIGJlIHRyaWdnZXJlZC4gU3luY2hyb25pemF0aW9uIG9mXHJcbiAqIHRoZSBkYXRhIHRvIHRoZSBGaXJlYmFzZSBzZXJ2ZXJzIHdpbGwgYWxzbyBiZSBzdGFydGVkLCBhbmQgdGhlIHJldHVybmVkXHJcbiAqIFByb21pc2Ugd2lsbCByZXNvbHZlIHdoZW4gY29tcGxldGUuIElmIHByb3ZpZGVkLCB0aGUgYG9uQ29tcGxldGVgIGNhbGxiYWNrXHJcbiAqIHdpbGwgYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5IGFmdGVyIHN5bmNocm9uaXphdGlvbiBoYXMgZmluaXNoZWQuXHJcbiAqXHJcbiAqIEEgc2luZ2xlIGB1cGRhdGUoKWAgd2lsbCBnZW5lcmF0ZSBhIHNpbmdsZSBcInZhbHVlXCIgZXZlbnQgYXQgdGhlIGxvY2F0aW9uXHJcbiAqIHdoZXJlIHRoZSBgdXBkYXRlKClgIHdhcyBwZXJmb3JtZWQsIHJlZ2FyZGxlc3Mgb2YgaG93IG1hbnkgY2hpbGRyZW4gd2VyZVxyXG4gKiBtb2RpZmllZC5cclxuICpcclxuICogTm90ZSB0aGF0IG1vZGlmeWluZyBkYXRhIHdpdGggYHVwZGF0ZSgpYCB3aWxsIGNhbmNlbCBhbnkgcGVuZGluZ1xyXG4gKiB0cmFuc2FjdGlvbnMgYXQgdGhhdCBsb2NhdGlvbiwgc28gZXh0cmVtZSBjYXJlIHNob3VsZCBiZSB0YWtlbiBpZiBtaXhpbmdcclxuICogYHVwZGF0ZSgpYCBhbmQgYHRyYW5zYWN0aW9uKClgIHRvIG1vZGlmeSB0aGUgc2FtZSBkYXRhLlxyXG4gKlxyXG4gKiBQYXNzaW5nIGBudWxsYCB0byBgdXBkYXRlKClgIHdpbGwgcmVtb3ZlIHRoZSBkYXRhIGF0IHRoaXMgbG9jYXRpb24uXHJcbiAqXHJcbiAqIFNlZVxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGVibG9nLmNvbS8yMDE1LzA5L2ludHJvZHVjaW5nLW11bHRpLWxvY2F0aW9uLXVwZGF0ZXMtYW5kXzg2Lmh0bWwgfCBJbnRyb2R1Y2luZyBtdWx0aS1sb2NhdGlvbiB1cGRhdGVzIGFuZCBtb3JlfS5cclxuICpcclxuICogQHBhcmFtIHJlZiAtIFRoZSBsb2NhdGlvbiB0byB3cml0ZSB0by5cclxuICogQHBhcmFtIHZhbHVlcyAtIE9iamVjdCBjb250YWluaW5nIG11bHRpcGxlIHZhbHVlcy5cclxuICogQHJldHVybnMgUmVzb2x2ZXMgd2hlbiB1cGRhdGUgb24gc2VydmVyIGlzIGNvbXBsZXRlLlxyXG4gKi9cclxuZnVuY3Rpb24gdXBkYXRlKHJlZiwgdmFsdWVzKSB7XHJcbiAgICB2YWxpZGF0ZUZpcmViYXNlTWVyZ2VEYXRhQXJnKCd1cGRhdGUnLCB2YWx1ZXMsIHJlZi5fcGF0aCwgZmFsc2UpO1xyXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgIHJlcG9VcGRhdGUocmVmLl9yZXBvLCByZWYuX3BhdGgsIHZhbHVlcywgZGVmZXJyZWQud3JhcENhbGxiYWNrKCgpID0+IHsgfSkpO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbn1cclxuLyoqXHJcbiAqIEdldHMgdGhlIG1vc3QgdXAtdG8tZGF0ZSByZXN1bHQgZm9yIHRoaXMgcXVlcnkuXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSB0byBydW4uXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHdoaWNoIHJlc29sdmVzIHRvIHRoZSByZXN1bHRpbmcgRGF0YVNuYXBzaG90IGlmIGEgdmFsdWUgaXNcclxuICogYXZhaWxhYmxlLCBvciByZWplY3RzIGlmIHRoZSBjbGllbnQgaXMgdW5hYmxlIHRvIHJldHVybiBhIHZhbHVlIChlLmcuLCBpZiB0aGVcclxuICogc2VydmVyIGlzIHVucmVhY2hhYmxlIGFuZCB0aGVyZSBpcyBub3RoaW5nIGNhY2hlZCkuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXQocXVlcnkpIHtcclxuICAgIHF1ZXJ5ID0gZ2V0TW9kdWxhckluc3RhbmNlKHF1ZXJ5KTtcclxuICAgIGNvbnN0IGNhbGxiYWNrQ29udGV4dCA9IG5ldyBDYWxsYmFja0NvbnRleHQoKCkgPT4geyB9KTtcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uKGNhbGxiYWNrQ29udGV4dCk7XHJcbiAgICByZXR1cm4gcmVwb0dldFZhbHVlKHF1ZXJ5Ll9yZXBvLCBxdWVyeSwgY29udGFpbmVyKS50aGVuKG5vZGUgPT4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0YVNuYXBzaG90KG5vZGUsIG5ldyBSZWZlcmVuY2VJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCksIHF1ZXJ5Ll9xdWVyeVBhcmFtcy5nZXRJbmRleCgpKTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHJlZ2lzdHJhdGlvbiBmb3IgJ3ZhbHVlJyBldmVudHMuXHJcbiAqL1xyXG5jbGFzcyBWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrQ29udGV4dCkge1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tDb250ZXh0ID0gY2FsbGJhY2tDb250ZXh0O1xyXG4gICAgfVxyXG4gICAgcmVzcG9uZHNUbyhldmVudFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gZXZlbnRUeXBlID09PSAndmFsdWUnO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlRXZlbnQoY2hhbmdlLCBxdWVyeSkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gcXVlcnkuX3F1ZXJ5UGFyYW1zLmdldEluZGV4KCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhRXZlbnQoJ3ZhbHVlJywgdGhpcywgbmV3IERhdGFTbmFwc2hvdChjaGFuZ2Uuc25hcHNob3ROb2RlLCBuZXcgUmVmZXJlbmNlSW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgpLCBpbmRleCkpO1xyXG4gICAgfVxyXG4gICAgZ2V0RXZlbnRSdW5uZXIoZXZlbnREYXRhKSB7XHJcbiAgICAgICAgaWYgKGV2ZW50RGF0YS5nZXRFdmVudFR5cGUoKSA9PT0gJ2NhbmNlbCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHRoaXMuY2FsbGJhY2tDb250ZXh0Lm9uQ2FuY2VsKGV2ZW50RGF0YS5lcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gdGhpcy5jYWxsYmFja0NvbnRleHQub25WYWx1ZShldmVudERhdGEuc25hcHNob3QsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNyZWF0ZUNhbmNlbEV2ZW50KGVycm9yLCBwYXRoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2tDb250ZXh0Lmhhc0NhbmNlbENhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FuY2VsRXZlbnQodGhpcywgZXJyb3IsIHBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWF0Y2hlcyhvdGhlcikge1xyXG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghb3RoZXIuY2FsbGJhY2tDb250ZXh0IHx8ICF0aGlzLmNhbGxiYWNrQ29udGV4dCkge1xyXG4gICAgICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBzcGVjaWZpZWQsIHdlIGNvbnNpZGVyIGl0IHRvIG1hdGNoIGFueSBjYWxsYmFjay5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gb3RoZXIuY2FsbGJhY2tDb250ZXh0Lm1hdGNoZXModGhpcy5jYWxsYmFja0NvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhc0FueUNhbGxiYWNrKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxiYWNrQ29udGV4dCAhPT0gbnVsbDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgcmVnaXN0cmF0aW9uIG9mIGEgY2hpbGRfeCBldmVudC5cclxuICovXHJcbmNsYXNzIENoaWxkRXZlbnRSZWdpc3RyYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IoZXZlbnRUeXBlLCBjYWxsYmFja0NvbnRleHQpIHtcclxuICAgICAgICB0aGlzLmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrQ29udGV4dCA9IGNhbGxiYWNrQ29udGV4dDtcclxuICAgIH1cclxuICAgIHJlc3BvbmRzVG8oZXZlbnRUeXBlKSB7XHJcbiAgICAgICAgbGV0IGV2ZW50VG9DaGVjayA9IGV2ZW50VHlwZSA9PT0gJ2NoaWxkcmVuX2FkZGVkJyA/ICdjaGlsZF9hZGRlZCcgOiBldmVudFR5cGU7XHJcbiAgICAgICAgZXZlbnRUb0NoZWNrID1cclxuICAgICAgICAgICAgZXZlbnRUb0NoZWNrID09PSAnY2hpbGRyZW5fcmVtb3ZlZCcgPyAnY2hpbGRfcmVtb3ZlZCcgOiBldmVudFRvQ2hlY2s7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRUeXBlID09PSBldmVudFRvQ2hlY2s7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVDYW5jZWxFdmVudChlcnJvciwgcGF0aCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNhbGxiYWNrQ29udGV4dC5oYXNDYW5jZWxDYWxsYmFjaykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENhbmNlbEV2ZW50KHRoaXMsIGVycm9yLCBwYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNyZWF0ZUV2ZW50KGNoYW5nZSwgcXVlcnkpIHtcclxuICAgICAgICBhc3NlcnQoY2hhbmdlLmNoaWxkTmFtZSAhPSBudWxsLCAnQ2hpbGQgZXZlbnRzIHNob3VsZCBoYXZlIGEgY2hpbGROYW1lLicpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkUmVmID0gY2hpbGQobmV3IFJlZmVyZW5jZUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoKSwgY2hhbmdlLmNoaWxkTmFtZSk7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBxdWVyeS5fcXVlcnlQYXJhbXMuZ2V0SW5kZXgoKTtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGFFdmVudChjaGFuZ2UudHlwZSwgdGhpcywgbmV3IERhdGFTbmFwc2hvdChjaGFuZ2Uuc25hcHNob3ROb2RlLCBjaGlsZFJlZiwgaW5kZXgpLCBjaGFuZ2UucHJldk5hbWUpO1xyXG4gICAgfVxyXG4gICAgZ2V0RXZlbnRSdW5uZXIoZXZlbnREYXRhKSB7XHJcbiAgICAgICAgaWYgKGV2ZW50RGF0YS5nZXRFdmVudFR5cGUoKSA9PT0gJ2NhbmNlbCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHRoaXMuY2FsbGJhY2tDb250ZXh0Lm9uQ2FuY2VsKGV2ZW50RGF0YS5lcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gdGhpcy5jYWxsYmFja0NvbnRleHQub25WYWx1ZShldmVudERhdGEuc25hcHNob3QsIGV2ZW50RGF0YS5wcmV2TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWF0Y2hlcyhvdGhlcikge1xyXG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIENoaWxkRXZlbnRSZWdpc3RyYXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmV2ZW50VHlwZSA9PT0gb3RoZXIuZXZlbnRUeXBlICYmXHJcbiAgICAgICAgICAgICAgICAoIXRoaXMuY2FsbGJhY2tDb250ZXh0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgIW90aGVyLmNhbGxiYWNrQ29udGV4dCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tDb250ZXh0Lm1hdGNoZXMob3RoZXIuY2FsbGJhY2tDb250ZXh0KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBoYXNBbnlDYWxsYmFjaygpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLmNhbGxiYWNrQ29udGV4dDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKHF1ZXJ5LCBldmVudFR5cGUsIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucykge1xyXG4gICAgbGV0IGNhbmNlbENhbGxiYWNrO1xyXG4gICAgaWYgKHR5cGVvZiBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBjYW5jZWxDYWxsYmFjayA9IHVuZGVmaW5lZDtcclxuICAgICAgICBvcHRpb25zID0gY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgY2FuY2VsQ2FsbGJhY2sgPSBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucztcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMub25seU9uY2UpIHtcclxuICAgICAgICBjb25zdCB1c2VyQ2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgICAgICBjb25zdCBvbmNlQ2FsbGJhY2sgPSAoZGF0YVNuYXBzaG90LCBwcmV2aW91c0NoaWxkTmFtZSkgPT4ge1xyXG4gICAgICAgICAgICByZXBvUmVtb3ZlRXZlbnRDYWxsYmFja0ZvclF1ZXJ5KHF1ZXJ5Ll9yZXBvLCBxdWVyeSwgY29udGFpbmVyKTtcclxuICAgICAgICAgICAgdXNlckNhbGxiYWNrKGRhdGFTbmFwc2hvdCwgcHJldmlvdXNDaGlsZE5hbWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgb25jZUNhbGxiYWNrLnVzZXJDYWxsYmFjayA9IGNhbGxiYWNrLnVzZXJDYWxsYmFjaztcclxuICAgICAgICBvbmNlQ2FsbGJhY2suY29udGV4dCA9IGNhbGxiYWNrLmNvbnRleHQ7XHJcbiAgICAgICAgY2FsbGJhY2sgPSBvbmNlQ2FsbGJhY2s7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjYWxsYmFja0NvbnRleHQgPSBuZXcgQ2FsbGJhY2tDb250ZXh0KGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFjayB8fCB1bmRlZmluZWQpO1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gZXZlbnRUeXBlID09PSAndmFsdWUnXHJcbiAgICAgICAgPyBuZXcgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbihjYWxsYmFja0NvbnRleHQpXHJcbiAgICAgICAgOiBuZXcgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbihldmVudFR5cGUsIGNhbGxiYWNrQ29udGV4dCk7XHJcbiAgICByZXBvQWRkRXZlbnRDYWxsYmFja0ZvclF1ZXJ5KHF1ZXJ5Ll9yZXBvLCBxdWVyeSwgY29udGFpbmVyKTtcclxuICAgIHJldHVybiAoKSA9PiByZXBvUmVtb3ZlRXZlbnRDYWxsYmFja0ZvclF1ZXJ5KHF1ZXJ5Ll9yZXBvLCBxdWVyeSwgY29udGFpbmVyKTtcclxufVxyXG5mdW5jdGlvbiBvblZhbHVlKHF1ZXJ5LCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBhZGRFdmVudExpc3RlbmVyKHF1ZXJ5LCAndmFsdWUnLCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIG9uQ2hpbGRBZGRlZChxdWVyeSwgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gYWRkRXZlbnRMaXN0ZW5lcihxdWVyeSwgJ2NoaWxkX2FkZGVkJywgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBvbkNoaWxkQ2hhbmdlZChxdWVyeSwgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gYWRkRXZlbnRMaXN0ZW5lcihxdWVyeSwgJ2NoaWxkX2NoYW5nZWQnLCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIG9uQ2hpbGRNb3ZlZChxdWVyeSwgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gYWRkRXZlbnRMaXN0ZW5lcihxdWVyeSwgJ2NoaWxkX21vdmVkJywgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBvbkNoaWxkUmVtb3ZlZChxdWVyeSwgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gYWRkRXZlbnRMaXN0ZW5lcihxdWVyeSwgJ2NoaWxkX3JlbW92ZWQnLCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpO1xyXG59XHJcbi8qKlxyXG4gKiBEZXRhY2hlcyBhIGNhbGxiYWNrIHByZXZpb3VzbHkgYXR0YWNoZWQgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBgb24qKClgIChgb25WYWx1ZWAsIGBvbkNoaWxkQWRkZWRgKSBsaXN0ZW5lci5cclxuICogTm90ZTogVGhpcyBpcyBub3QgdGhlIHJlY29tbWVuZGVkIHdheSB0byByZW1vdmUgYSBsaXN0ZW5lci4gSW5zdGVhZCwgcGxlYXNlIHVzZSB0aGUgcmV0dXJuZWQgY2FsbGJhY2sgZnVuY3Rpb24gZnJvbVxyXG4gKiB0aGUgcmVzcGVjdGl2ZSBgb24qYCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIERldGFjaCBhIGNhbGxiYWNrIHByZXZpb3VzbHkgYXR0YWNoZWQgd2l0aCBgb24qKClgLiBDYWxsaW5nIGBvZmYoKWAgb24gYSBwYXJlbnQgbGlzdGVuZXJcclxuICogd2lsbCBub3QgYXV0b21hdGljYWxseSByZW1vdmUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgb24gY2hpbGQgbm9kZXMsIGBvZmYoKWBcclxuICogbXVzdCBhbHNvIGJlIGNhbGxlZCBvbiBhbnkgY2hpbGQgbGlzdGVuZXJzIHRvIHJlbW92ZSB0aGUgY2FsbGJhY2suXHJcbiAqXHJcbiAqIElmIGEgY2FsbGJhY2sgaXMgbm90IHNwZWNpZmllZCwgYWxsIGNhbGxiYWNrcyBmb3IgdGhlIHNwZWNpZmllZCBldmVudFR5cGVcclxuICogd2lsbCBiZSByZW1vdmVkLiBTaW1pbGFybHksIGlmIG5vIGV2ZW50VHlwZSBpcyBzcGVjaWZpZWQsIGFsbCBjYWxsYmFja3NcclxuICogZm9yIHRoZSBgUmVmZXJlbmNlYCB3aWxsIGJlIHJlbW92ZWQuXHJcbiAqXHJcbiAqIEluZGl2aWR1YWwgbGlzdGVuZXJzIGNhbiBhbHNvIGJlIHJlbW92ZWQgYnkgaW52b2tpbmcgdGhlaXIgdW5zdWJzY3JpYmVcclxuICogY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0gcXVlcnkgLSBUaGUgcXVlcnkgdGhhdCB0aGUgbGlzdGVuZXIgd2FzIHJlZ2lzdGVyZWQgd2l0aC5cclxuICogQHBhcmFtIGV2ZW50VHlwZSAtIE9uZSBvZiB0aGUgZm9sbG93aW5nIHN0cmluZ3M6IFwidmFsdWVcIiwgXCJjaGlsZF9hZGRlZFwiLFxyXG4gKiBcImNoaWxkX2NoYW5nZWRcIiwgXCJjaGlsZF9yZW1vdmVkXCIsIG9yIFwiY2hpbGRfbW92ZWQuXCIgSWYgb21pdHRlZCwgYWxsIGNhbGxiYWNrc1xyXG4gKiBmb3IgdGhlIGBSZWZlcmVuY2VgIHdpbGwgYmUgcmVtb3ZlZC5cclxuICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2FzIHBhc3NlZCB0byBgb24oKWAgb3JcclxuICogYHVuZGVmaW5lZGAgdG8gcmVtb3ZlIGFsbCBjYWxsYmFja3MuXHJcbiAqL1xyXG5mdW5jdGlvbiBvZmYocXVlcnksIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcclxuICAgIGxldCBjb250YWluZXIgPSBudWxsO1xyXG4gICAgY29uc3QgZXhwQ2FsbGJhY2sgPSBjYWxsYmFjayA/IG5ldyBDYWxsYmFja0NvbnRleHQoY2FsbGJhY2spIDogbnVsbDtcclxuICAgIGlmIChldmVudFR5cGUgPT09ICd2YWx1ZScpIHtcclxuICAgICAgICBjb250YWluZXIgPSBuZXcgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbihleHBDYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChldmVudFR5cGUpIHtcclxuICAgICAgICBjb250YWluZXIgPSBuZXcgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbihldmVudFR5cGUsIGV4cENhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIHJlcG9SZW1vdmVFdmVudENhbGxiYWNrRm9yUXVlcnkocXVlcnkuX3JlcG8sIHF1ZXJ5LCBjb250YWluZXIpO1xyXG59XHJcbi8qKlxyXG4gKiBBIGBRdWVyeUNvbnN0cmFpbnRgIGlzIHVzZWQgdG8gbmFycm93IHRoZSBzZXQgb2YgZG9jdW1lbnRzIHJldHVybmVkIGJ5IGFcclxuICogRGF0YWJhc2UgcXVlcnkuIGBRdWVyeUNvbnN0cmFpbnRgcyBhcmUgY3JlYXRlZCBieSBpbnZva2luZyB7QGxpbmsgZW5kQXR9LFxyXG4gKiB7QGxpbmsgZW5kQmVmb3JlfSwge0BsaW5rIHN0YXJ0QXR9LCB7QGxpbmsgc3RhcnRBZnRlcn0sIHtAbGlua1xyXG4gKiBsaW1pdFRvRmlyc3R9LCB7QGxpbmsgbGltaXRUb0xhc3R9LCB7QGxpbmsgb3JkZXJCeUNoaWxkfSxcclxuICoge0BsaW5rIG9yZGVyQnlDaGlsZH0sIHtAbGluayBvcmRlckJ5S2V5fSAsIHtAbGluayBvcmRlckJ5UHJpb3JpdHl9ICxcclxuICoge0BsaW5rIG9yZGVyQnlWYWx1ZX0gIG9yIHtAbGluayBlcXVhbFRvfSBhbmRcclxuICogY2FuIHRoZW4gYmUgcGFzc2VkIHRvIHtAbGluayBxdWVyeX0gdG8gY3JlYXRlIGEgbmV3IHF1ZXJ5IGluc3RhbmNlIHRoYXRcclxuICogYWxzbyBjb250YWlucyB0aGlzIGBRdWVyeUNvbnN0cmFpbnRgLlxyXG4gKi9cclxuY2xhc3MgUXVlcnlDb25zdHJhaW50IHtcclxufVxyXG5jbGFzcyBRdWVyeUVuZEF0Q29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfdmFsdWUsIF9rZXkpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xyXG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ2VuZEF0JztcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdlbmRBdCcsIHRoaXMuX3ZhbHVlLCBxdWVyeS5fcGF0aCwgdHJ1ZSk7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXNFbmRBdChxdWVyeS5fcXVlcnlQYXJhbXMsIHRoaXMuX3ZhbHVlLCB0aGlzLl9rZXkpO1xyXG4gICAgICAgIHZhbGlkYXRlTGltaXQobmV3UGFyYW1zKTtcclxuICAgICAgICB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKG5ld1BhcmFtcyk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5oYXNFbmQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZEF0OiBTdGFydGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBlbmRBdCwgJyArXHJcbiAgICAgICAgICAgICAgICAnZW5kQmVmb3JlIG9yIGVxdWFsVG8pLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIG5ld1BhcmFtcywgcXVlcnkuX29yZGVyQnlDYWxsZWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgYFF1ZXJ5Q29uc3RyYWludGAgd2l0aCB0aGUgc3BlY2lmaWVkIGVuZGluZyBwb2ludC5cclxuICpcclxuICogVXNpbmcgYHN0YXJ0QXQoKWAsIGBzdGFydEFmdGVyKClgLCBgZW5kQmVmb3JlKClgLCBgZW5kQXQoKWAgYW5kIGBlcXVhbFRvKClgXHJcbiAqIGFsbG93cyB5b3UgdG8gY2hvb3NlIGFyYml0cmFyeSBzdGFydGluZyBhbmQgZW5kaW5nIHBvaW50cyBmb3IgeW91ciBxdWVyaWVzLlxyXG4gKlxyXG4gKiBUaGUgZW5kaW5nIHBvaW50IGlzIGluY2x1c2l2ZSwgc28gY2hpbGRyZW4gd2l0aCBleGFjdGx5IHRoZSBzcGVjaWZpZWQgdmFsdWVcclxuICogd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcXVlcnkuIFRoZSBvcHRpb25hbCBrZXkgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG9cclxuICogZnVydGhlciBsaW1pdCB0aGUgcmFuZ2Ugb2YgdGhlIHF1ZXJ5LiBJZiBpdCBpcyBzcGVjaWZpZWQsIHRoZW4gY2hpbGRyZW4gdGhhdFxyXG4gKiBoYXZlIGV4YWN0bHkgdGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGFsc28gaGF2ZSBhIGtleSBuYW1lIGxlc3MgdGhhbiBvciBlcXVhbFxyXG4gKiB0byB0aGUgc3BlY2lmaWVkIGtleS5cclxuICpcclxuICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgYGVuZEF0KClgIGluXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNmaWx0ZXJpbmdfZGF0YSB8IEZpbHRlcmluZyBkYXRhfS5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGVuZCBhdC4gVGhlIGFyZ3VtZW50IHR5cGUgZGVwZW5kcyBvbiB3aGljaFxyXG4gKiBgb3JkZXJCeSooKWAgZnVuY3Rpb24gd2FzIHVzZWQgaW4gdGhpcyBxdWVyeS4gU3BlY2lmeSBhIHZhbHVlIHRoYXQgbWF0Y2hlc1xyXG4gKiB0aGUgYG9yZGVyQnkqKClgIHR5cGUuIFdoZW4gdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGBvcmRlckJ5S2V5KClgLCB0aGVcclxuICogdmFsdWUgbXVzdCBiZSBhIHN0cmluZy5cclxuICogQHBhcmFtIGtleSAtIFRoZSBjaGlsZCBrZXkgdG8gZW5kIGF0LCBhbW9uZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgcHJldmlvdXNseVxyXG4gKiBzcGVjaWZpZWQgcHJpb3JpdHkuIFRoaXMgYXJndW1lbnQgaXMgb25seSBhbGxvd2VkIGlmIG9yZGVyaW5nIGJ5IGNoaWxkLFxyXG4gKiB2YWx1ZSwgb3IgcHJpb3JpdHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBlbmRBdCh2YWx1ZSwga2V5KSB7XHJcbiAgICB2YWxpZGF0ZUtleSgnZW5kQXQnLCAna2V5Jywga2V5LCB0cnVlKTtcclxuICAgIHJldHVybiBuZXcgUXVlcnlFbmRBdENvbnN0cmFpbnQodmFsdWUsIGtleSk7XHJcbn1cclxuY2xhc3MgUXVlcnlFbmRCZWZvcmVDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKF92YWx1ZSwgX2tleSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fa2V5ID0gX2tleTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnZW5kQmVmb3JlJztcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdlbmRCZWZvcmUnLCB0aGlzLl92YWx1ZSwgcXVlcnkuX3BhdGgsIGZhbHNlKTtcclxuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtc0VuZEJlZm9yZShxdWVyeS5fcXVlcnlQYXJhbXMsIHRoaXMuX3ZhbHVlLCB0aGlzLl9rZXkpO1xyXG4gICAgICAgIHZhbGlkYXRlTGltaXQobmV3UGFyYW1zKTtcclxuICAgICAgICB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKG5ld1BhcmFtcyk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5oYXNFbmQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZEJlZm9yZTogU3RhcnRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gZW5kQXQsICcgK1xyXG4gICAgICAgICAgICAgICAgJ2VuZEJlZm9yZSBvciBlcXVhbFRvKS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBuZXdQYXJhbXMsIHF1ZXJ5Ll9vcmRlckJ5Q2FsbGVkKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIGBRdWVyeUNvbnN0cmFpbnRgIHdpdGggdGhlIHNwZWNpZmllZCBlbmRpbmcgcG9pbnQgKGV4Y2x1c2l2ZSkuXHJcbiAqXHJcbiAqIFVzaW5nIGBzdGFydEF0KClgLCBgc3RhcnRBZnRlcigpYCwgYGVuZEJlZm9yZSgpYCwgYGVuZEF0KClgIGFuZCBgZXF1YWxUbygpYFxyXG4gKiBhbGxvd3MgeW91IHRvIGNob29zZSBhcmJpdHJhcnkgc3RhcnRpbmcgYW5kIGVuZGluZyBwb2ludHMgZm9yIHlvdXIgcXVlcmllcy5cclxuICpcclxuICogVGhlIGVuZGluZyBwb2ludCBpcyBleGNsdXNpdmUuIElmIG9ubHkgYSB2YWx1ZSBpcyBwcm92aWRlZCwgY2hpbGRyZW5cclxuICogd2l0aCBhIHZhbHVlIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkIHZhbHVlIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHF1ZXJ5LlxyXG4gKiBJZiBhIGtleSBpcyBzcGVjaWZpZWQsIHRoZW4gY2hpbGRyZW4gbXVzdCBoYXZlIGEgdmFsdWUgbGVzcyB0aGFuIG9yIGVxdWFsXHJcbiAqIHRvIHRoZSBzcGVjaWZpZWQgdmFsdWUgYW5kIGEga2V5IG5hbWUgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQga2V5LlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZW5kIGJlZm9yZS4gVGhlIGFyZ3VtZW50IHR5cGUgZGVwZW5kcyBvbiB3aGljaFxyXG4gKiBgb3JkZXJCeSooKWAgZnVuY3Rpb24gd2FzIHVzZWQgaW4gdGhpcyBxdWVyeS4gU3BlY2lmeSBhIHZhbHVlIHRoYXQgbWF0Y2hlc1xyXG4gKiB0aGUgYG9yZGVyQnkqKClgIHR5cGUuIFdoZW4gdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGBvcmRlckJ5S2V5KClgLCB0aGVcclxuICogdmFsdWUgbXVzdCBiZSBhIHN0cmluZy5cclxuICogQHBhcmFtIGtleSAtIFRoZSBjaGlsZCBrZXkgdG8gZW5kIGJlZm9yZSwgYW1vbmcgdGhlIGNoaWxkcmVuIHdpdGggdGhlXHJcbiAqIHByZXZpb3VzbHkgc3BlY2lmaWVkIHByaW9yaXR5LiBUaGlzIGFyZ3VtZW50IGlzIG9ubHkgYWxsb3dlZCBpZiBvcmRlcmluZyBieVxyXG4gKiBjaGlsZCwgdmFsdWUsIG9yIHByaW9yaXR5LlxyXG4gKi9cclxuZnVuY3Rpb24gZW5kQmVmb3JlKHZhbHVlLCBrZXkpIHtcclxuICAgIHZhbGlkYXRlS2V5KCdlbmRCZWZvcmUnLCAna2V5Jywga2V5LCB0cnVlKTtcclxuICAgIHJldHVybiBuZXcgUXVlcnlFbmRCZWZvcmVDb25zdHJhaW50KHZhbHVlLCBrZXkpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgY29uc3RydWN0b3IoX3ZhbHVlLCBfa2V5KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IF92YWx1ZTtcclxuICAgICAgICB0aGlzLl9rZXkgPSBfa2V5O1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdzdGFydEF0JztcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdzdGFydEF0JywgdGhpcy5fdmFsdWUsIHF1ZXJ5Ll9wYXRoLCB0cnVlKTtcclxuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtc1N0YXJ0QXQocXVlcnkuX3F1ZXJ5UGFyYW1zLCB0aGlzLl92YWx1ZSwgdGhpcy5fa2V5KTtcclxuICAgICAgICB2YWxpZGF0ZUxpbWl0KG5ld1BhcmFtcyk7XHJcbiAgICAgICAgdmFsaWRhdGVRdWVyeUVuZHBvaW50cyhuZXdQYXJhbXMpO1xyXG4gICAgICAgIGlmIChxdWVyeS5fcXVlcnlQYXJhbXMuaGFzU3RhcnQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0QXQ6IFN0YXJ0aW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIHN0YXJ0QXQsICcgK1xyXG4gICAgICAgICAgICAgICAgJ3N0YXJ0QmVmb3JlIG9yIGVxdWFsVG8pLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIG5ld1BhcmFtcywgcXVlcnkuX29yZGVyQnlDYWxsZWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgYFF1ZXJ5Q29uc3RyYWludGAgd2l0aCB0aGUgc3BlY2lmaWVkIHN0YXJ0aW5nIHBvaW50LlxyXG4gKlxyXG4gKiBVc2luZyBgc3RhcnRBdCgpYCwgYHN0YXJ0QWZ0ZXIoKWAsIGBlbmRCZWZvcmUoKWAsIGBlbmRBdCgpYCBhbmQgYGVxdWFsVG8oKWBcclxuICogYWxsb3dzIHlvdSB0byBjaG9vc2UgYXJiaXRyYXJ5IHN0YXJ0aW5nIGFuZCBlbmRpbmcgcG9pbnRzIGZvciB5b3VyIHF1ZXJpZXMuXHJcbiAqXHJcbiAqIFRoZSBzdGFydGluZyBwb2ludCBpcyBpbmNsdXNpdmUsIHNvIGNoaWxkcmVuIHdpdGggZXhhY3RseSB0aGUgc3BlY2lmaWVkIHZhbHVlXHJcbiAqIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHF1ZXJ5LiBUaGUgb3B0aW9uYWwga2V5IGFyZ3VtZW50IGNhbiBiZSB1c2VkIHRvXHJcbiAqIGZ1cnRoZXIgbGltaXQgdGhlIHJhbmdlIG9mIHRoZSBxdWVyeS4gSWYgaXQgaXMgc3BlY2lmaWVkLCB0aGVuIGNoaWxkcmVuIHRoYXRcclxuICogaGF2ZSBleGFjdGx5IHRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBhbHNvIGhhdmUgYSBrZXkgbmFtZSBncmVhdGVyIHRoYW4gb3JcclxuICogZXF1YWwgdG8gdGhlIHNwZWNpZmllZCBrZXkuXHJcbiAqXHJcbiAqIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IGBzdGFydEF0KClgIGluXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNmaWx0ZXJpbmdfZGF0YSB8IEZpbHRlcmluZyBkYXRhfS5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHN0YXJ0IGF0LiBUaGUgYXJndW1lbnQgdHlwZSBkZXBlbmRzIG9uIHdoaWNoXHJcbiAqIGBvcmRlckJ5KigpYCBmdW5jdGlvbiB3YXMgdXNlZCBpbiB0aGlzIHF1ZXJ5LiBTcGVjaWZ5IGEgdmFsdWUgdGhhdCBtYXRjaGVzXHJcbiAqIHRoZSBgb3JkZXJCeSooKWAgdHlwZS4gV2hlbiB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggYG9yZGVyQnlLZXkoKWAsIHRoZVxyXG4gKiB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ga2V5IC0gVGhlIGNoaWxkIGtleSB0byBzdGFydCBhdC4gVGhpcyBhcmd1bWVudCBpcyBvbmx5IGFsbG93ZWQgaWZcclxuICogb3JkZXJpbmcgYnkgY2hpbGQsIHZhbHVlLCBvciBwcmlvcml0eS5cclxuICovXHJcbmZ1bmN0aW9uIHN0YXJ0QXQodmFsdWUgPSBudWxsLCBrZXkpIHtcclxuICAgIHZhbGlkYXRlS2V5KCdzdGFydEF0JywgJ2tleScsIGtleSwgdHJ1ZSk7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQodmFsdWUsIGtleSk7XHJcbn1cclxuY2xhc3MgUXVlcnlTdGFydEFmdGVyQ29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfdmFsdWUsIF9rZXkpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xyXG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ3N0YXJ0QWZ0ZXInO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ3N0YXJ0QWZ0ZXInLCB0aGlzLl92YWx1ZSwgcXVlcnkuX3BhdGgsIGZhbHNlKTtcclxuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtc1N0YXJ0QWZ0ZXIocXVlcnkuX3F1ZXJ5UGFyYW1zLCB0aGlzLl92YWx1ZSwgdGhpcy5fa2V5KTtcclxuICAgICAgICB2YWxpZGF0ZUxpbWl0KG5ld1BhcmFtcyk7XHJcbiAgICAgICAgdmFsaWRhdGVRdWVyeUVuZHBvaW50cyhuZXdQYXJhbXMpO1xyXG4gICAgICAgIGlmIChxdWVyeS5fcXVlcnlQYXJhbXMuaGFzU3RhcnQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0QWZ0ZXI6IFN0YXJ0aW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIHN0YXJ0QXQsICcgK1xyXG4gICAgICAgICAgICAgICAgJ3N0YXJ0QWZ0ZXIsIG9yIGVxdWFsVG8pLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIG5ld1BhcmFtcywgcXVlcnkuX29yZGVyQnlDYWxsZWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgYFF1ZXJ5Q29uc3RyYWludGAgd2l0aCB0aGUgc3BlY2lmaWVkIHN0YXJ0aW5nIHBvaW50IChleGNsdXNpdmUpLlxyXG4gKlxyXG4gKiBVc2luZyBgc3RhcnRBdCgpYCwgYHN0YXJ0QWZ0ZXIoKWAsIGBlbmRCZWZvcmUoKWAsIGBlbmRBdCgpYCBhbmQgYGVxdWFsVG8oKWBcclxuICogYWxsb3dzIHlvdSB0byBjaG9vc2UgYXJiaXRyYXJ5IHN0YXJ0aW5nIGFuZCBlbmRpbmcgcG9pbnRzIGZvciB5b3VyIHF1ZXJpZXMuXHJcbiAqXHJcbiAqIFRoZSBzdGFydGluZyBwb2ludCBpcyBleGNsdXNpdmUuIElmIG9ubHkgYSB2YWx1ZSBpcyBwcm92aWRlZCwgY2hpbGRyZW5cclxuICogd2l0aCBhIHZhbHVlIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkIHZhbHVlIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHF1ZXJ5LlxyXG4gKiBJZiBhIGtleSBpcyBzcGVjaWZpZWQsIHRoZW4gY2hpbGRyZW4gbXVzdCBoYXZlIGEgdmFsdWUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsXHJcbiAqIHRvIHRoZSBzcGVjaWZpZWQgdmFsdWUgYW5kIGEgYSBrZXkgbmFtZSBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCBrZXkuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzdGFydCBhZnRlci4gVGhlIGFyZ3VtZW50IHR5cGUgZGVwZW5kcyBvbiB3aGljaFxyXG4gKiBgb3JkZXJCeSooKWAgZnVuY3Rpb24gd2FzIHVzZWQgaW4gdGhpcyBxdWVyeS4gU3BlY2lmeSBhIHZhbHVlIHRoYXQgbWF0Y2hlc1xyXG4gKiB0aGUgYG9yZGVyQnkqKClgIHR5cGUuIFdoZW4gdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGBvcmRlckJ5S2V5KClgLCB0aGVcclxuICogdmFsdWUgbXVzdCBiZSBhIHN0cmluZy5cclxuICogQHBhcmFtIGtleSAtIFRoZSBjaGlsZCBrZXkgdG8gc3RhcnQgYWZ0ZXIuIFRoaXMgYXJndW1lbnQgaXMgb25seSBhbGxvd2VkIGlmXHJcbiAqIG9yZGVyaW5nIGJ5IGNoaWxkLCB2YWx1ZSwgb3IgcHJpb3JpdHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBzdGFydEFmdGVyKHZhbHVlLCBrZXkpIHtcclxuICAgIHZhbGlkYXRlS2V5KCdzdGFydEFmdGVyJywgJ2tleScsIGtleSwgdHJ1ZSk7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5U3RhcnRBZnRlckNvbnN0cmFpbnQodmFsdWUsIGtleSk7XHJcbn1cclxuY2xhc3MgUXVlcnlMaW1pdFRvRmlyc3RDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKF9saW1pdCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fbGltaXQgPSBfbGltaXQ7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ2xpbWl0VG9GaXJzdCc7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICBpZiAocXVlcnkuX3F1ZXJ5UGFyYW1zLmhhc0xpbWl0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsaW1pdFRvRmlyc3Q6IExpbWl0IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGxpbWl0VG9GaXJzdCAnICtcclxuICAgICAgICAgICAgICAgICdvciBsaW1pdFRvTGFzdCkuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCwgcXVlcnlQYXJhbXNMaW1pdFRvRmlyc3QocXVlcnkuX3F1ZXJ5UGFyYW1zLCB0aGlzLl9saW1pdCksIHF1ZXJ5Ll9vcmRlckJ5Q2FsbGVkKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBgUXVlcnlDb25zdHJhaW50YCB0aGF0IGlmIGxpbWl0ZWQgdG8gdGhlIGZpcnN0IHNwZWNpZmljIG51bWJlclxyXG4gKiBvZiBjaGlsZHJlbi5cclxuICpcclxuICogVGhlIGBsaW1pdFRvRmlyc3QoKWAgbWV0aG9kIGlzIHVzZWQgdG8gc2V0IGEgbWF4aW11bSBudW1iZXIgb2YgY2hpbGRyZW4gdG8gYmVcclxuICogc3luY2VkIGZvciBhIGdpdmVuIGNhbGxiYWNrLiBJZiB3ZSBzZXQgYSBsaW1pdCBvZiAxMDAsIHdlIHdpbGwgaW5pdGlhbGx5IG9ubHlcclxuICogcmVjZWl2ZSB1cCB0byAxMDAgYGNoaWxkX2FkZGVkYCBldmVudHMuIElmIHdlIGhhdmUgZmV3ZXIgdGhhbiAxMDAgbWVzc2FnZXNcclxuICogc3RvcmVkIGluIG91ciBEYXRhYmFzZSwgYSBgY2hpbGRfYWRkZWRgIGV2ZW50IHdpbGwgZmlyZSBmb3IgZWFjaCBtZXNzYWdlLlxyXG4gKiBIb3dldmVyLCBpZiB3ZSBoYXZlIG92ZXIgMTAwIG1lc3NhZ2VzLCB3ZSB3aWxsIG9ubHkgcmVjZWl2ZSBhIGBjaGlsZF9hZGRlZGBcclxuICogZXZlbnQgZm9yIHRoZSBmaXJzdCAxMDAgb3JkZXJlZCBtZXNzYWdlcy4gQXMgaXRlbXMgY2hhbmdlLCB3ZSB3aWxsIHJlY2VpdmVcclxuICogYGNoaWxkX3JlbW92ZWRgIGV2ZW50cyBmb3IgZWFjaCBpdGVtIHRoYXQgZHJvcHMgb3V0IG9mIHRoZSBhY3RpdmUgbGlzdCBzb1xyXG4gKiB0aGF0IHRoZSB0b3RhbCBudW1iZXIgc3RheXMgYXQgMTAwLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHJlYWQgbW9yZSBhYm91dCBgbGltaXRUb0ZpcnN0KClgIGluXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNmaWx0ZXJpbmdfZGF0YSB8IEZpbHRlcmluZyBkYXRhfS5cclxuICpcclxuICogQHBhcmFtIGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG5vZGVzIHRvIGluY2x1ZGUgaW4gdGhpcyBxdWVyeS5cclxuICovXHJcbmZ1bmN0aW9uIGxpbWl0VG9GaXJzdChsaW1pdCkge1xyXG4gICAgaWYgKHR5cGVvZiBsaW1pdCAhPT0gJ251bWJlcicgfHwgTWF0aC5mbG9vcihsaW1pdCkgIT09IGxpbWl0IHx8IGxpbWl0IDw9IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xpbWl0VG9GaXJzdDogRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5TGltaXRUb0ZpcnN0Q29uc3RyYWludChsaW1pdCk7XHJcbn1cclxuY2xhc3MgUXVlcnlMaW1pdFRvTGFzdENvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgY29uc3RydWN0b3IoX2xpbWl0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9saW1pdCA9IF9saW1pdDtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnbGltaXRUb0xhc3QnO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5oYXNMaW1pdCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbGltaXRUb0xhc3Q6IExpbWl0IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGxpbWl0VG9GaXJzdCAnICtcclxuICAgICAgICAgICAgICAgICdvciBsaW1pdFRvTGFzdCkuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCwgcXVlcnlQYXJhbXNMaW1pdFRvTGFzdChxdWVyeS5fcXVlcnlQYXJhbXMsIHRoaXMuX2xpbWl0KSwgcXVlcnkuX29yZGVyQnlDYWxsZWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGBRdWVyeUNvbnN0cmFpbnRgIHRoYXQgaXMgbGltaXRlZCB0byByZXR1cm4gb25seSB0aGUgbGFzdFxyXG4gKiBzcGVjaWZpZWQgbnVtYmVyIG9mIGNoaWxkcmVuLlxyXG4gKlxyXG4gKiBUaGUgYGxpbWl0VG9MYXN0KClgIG1ldGhvZCBpcyB1c2VkIHRvIHNldCBhIG1heGltdW0gbnVtYmVyIG9mIGNoaWxkcmVuIHRvIGJlXHJcbiAqIHN5bmNlZCBmb3IgYSBnaXZlbiBjYWxsYmFjay4gSWYgd2Ugc2V0IGEgbGltaXQgb2YgMTAwLCB3ZSB3aWxsIGluaXRpYWxseSBvbmx5XHJcbiAqIHJlY2VpdmUgdXAgdG8gMTAwIGBjaGlsZF9hZGRlZGAgZXZlbnRzLiBJZiB3ZSBoYXZlIGZld2VyIHRoYW4gMTAwIG1lc3NhZ2VzXHJcbiAqIHN0b3JlZCBpbiBvdXIgRGF0YWJhc2UsIGEgYGNoaWxkX2FkZGVkYCBldmVudCB3aWxsIGZpcmUgZm9yIGVhY2ggbWVzc2FnZS5cclxuICogSG93ZXZlciwgaWYgd2UgaGF2ZSBvdmVyIDEwMCBtZXNzYWdlcywgd2Ugd2lsbCBvbmx5IHJlY2VpdmUgYSBgY2hpbGRfYWRkZWRgXHJcbiAqIGV2ZW50IGZvciB0aGUgbGFzdCAxMDAgb3JkZXJlZCBtZXNzYWdlcy4gQXMgaXRlbXMgY2hhbmdlLCB3ZSB3aWxsIHJlY2VpdmVcclxuICogYGNoaWxkX3JlbW92ZWRgIGV2ZW50cyBmb3IgZWFjaCBpdGVtIHRoYXQgZHJvcHMgb3V0IG9mIHRoZSBhY3RpdmUgbGlzdCBzb1xyXG4gKiB0aGF0IHRoZSB0b3RhbCBudW1iZXIgc3RheXMgYXQgMTAwLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHJlYWQgbW9yZSBhYm91dCBgbGltaXRUb0xhc3QoKWAgaW5cclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI2ZpbHRlcmluZ19kYXRhIHwgRmlsdGVyaW5nIGRhdGF9LlxyXG4gKlxyXG4gKiBAcGFyYW0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygbm9kZXMgdG8gaW5jbHVkZSBpbiB0aGlzIHF1ZXJ5LlxyXG4gKi9cclxuZnVuY3Rpb24gbGltaXRUb0xhc3QobGltaXQpIHtcclxuICAgIGlmICh0eXBlb2YgbGltaXQgIT09ICdudW1iZXInIHx8IE1hdGguZmxvb3IobGltaXQpICE9PSBsaW1pdCB8fCBsaW1pdCA8PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsaW1pdFRvTGFzdDogRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIuJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5TGltaXRUb0xhc3RDb25zdHJhaW50KGxpbWl0KTtcclxufVxyXG5jbGFzcyBRdWVyeU9yZGVyQnlDaGlsZENvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgY29uc3RydWN0b3IoX3BhdGgpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3BhdGggPSBfcGF0aDtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnb3JkZXJCeUNoaWxkJztcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlTm9QcmV2aW91c09yZGVyQnlDYWxsKHF1ZXJ5LCAnb3JkZXJCeUNoaWxkJyk7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkUGF0aCA9IG5ldyBQYXRoKHRoaXMuX3BhdGgpO1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShwYXJzZWRQYXRoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29yZGVyQnlDaGlsZDogY2Fubm90IHBhc3MgaW4gZW1wdHkgcGF0aC4gVXNlIG9yZGVyQnlWYWx1ZSgpIGluc3RlYWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmV3IFBhdGhJbmRleChwYXJzZWRQYXRoKTtcclxuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtc09yZGVyQnkocXVlcnkuX3F1ZXJ5UGFyYW1zLCBpbmRleCk7XHJcbiAgICAgICAgdmFsaWRhdGVRdWVyeUVuZHBvaW50cyhuZXdQYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCwgbmV3UGFyYW1zLCBcclxuICAgICAgICAvKm9yZGVyQnlDYWxsZWQ9Ki8gdHJ1ZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgYFF1ZXJ5Q29uc3RyYWludGAgdGhhdCBvcmRlcnMgYnkgdGhlIHNwZWNpZmllZCBjaGlsZCBrZXkuXHJcbiAqXHJcbiAqIFF1ZXJpZXMgY2FuIG9ubHkgb3JkZXIgYnkgb25lIGtleSBhdCBhIHRpbWUuIENhbGxpbmcgYG9yZGVyQnlDaGlsZCgpYFxyXG4gKiBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZSBxdWVyeSBpcyBhbiBlcnJvci5cclxuICpcclxuICogRmlyZWJhc2UgcXVlcmllcyBhbGxvdyB5b3UgdG8gb3JkZXIgeW91ciBkYXRhIGJ5IGFueSBjaGlsZCBrZXkgb24gdGhlIGZseS5cclxuICogSG93ZXZlciwgaWYgeW91IGtub3cgaW4gYWR2YW5jZSB3aGF0IHlvdXIgaW5kZXhlcyB3aWxsIGJlLCB5b3UgY2FuIGRlZmluZVxyXG4gKiB0aGVtIHZpYSB0aGUgLmluZGV4T24gcnVsZSBpbiB5b3VyIFNlY3VyaXR5IFJ1bGVzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuIFNlZVxyXG4gKiB0aGV7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvc2VjdXJpdHkvaW5kZXhpbmctZGF0YX1cclxuICogcnVsZSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICpcclxuICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgYG9yZGVyQnlDaGlsZCgpYCBpblxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjc29ydF9kYXRhIHwgU29ydCBkYXRhfS5cclxuICpcclxuICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byBvcmRlciBieS5cclxuICovXHJcbmZ1bmN0aW9uIG9yZGVyQnlDaGlsZChwYXRoKSB7XHJcbiAgICBpZiAocGF0aCA9PT0gJyRrZXknKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcmRlckJ5Q2hpbGQ6IFwiJGtleVwiIGlzIGludmFsaWQuICBVc2Ugb3JkZXJCeUtleSgpIGluc3RlYWQuJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwYXRoID09PSAnJHByaW9yaXR5Jykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3JkZXJCeUNoaWxkOiBcIiRwcmlvcml0eVwiIGlzIGludmFsaWQuICBVc2Ugb3JkZXJCeVByaW9yaXR5KCkgaW5zdGVhZC4nKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBhdGggPT09ICckdmFsdWUnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcmRlckJ5Q2hpbGQ6IFwiJHZhbHVlXCIgaXMgaW52YWxpZC4gIFVzZSBvcmRlckJ5VmFsdWUoKSBpbnN0ZWFkLicpO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGVQYXRoU3RyaW5nKCdvcmRlckJ5Q2hpbGQnLCAncGF0aCcsIHBhdGgsIGZhbHNlKTtcclxuICAgIHJldHVybiBuZXcgUXVlcnlPcmRlckJ5Q2hpbGRDb25zdHJhaW50KHBhdGgpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5T3JkZXJCeUtleUNvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnb3JkZXJCeUtleSc7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICB2YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbChxdWVyeSwgJ29yZGVyQnlLZXknKTtcclxuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtc09yZGVyQnkocXVlcnkuX3F1ZXJ5UGFyYW1zLCBLRVlfSU5ERVgpO1xyXG4gICAgICAgIHZhbGlkYXRlUXVlcnlFbmRwb2ludHMobmV3UGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIG5ld1BhcmFtcywgXHJcbiAgICAgICAgLypvcmRlckJ5Q2FsbGVkPSovIHRydWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGBRdWVyeUNvbnN0cmFpbnRgIHRoYXQgb3JkZXJzIGJ5IHRoZSBrZXkuXHJcbiAqXHJcbiAqIFNvcnRzIHRoZSByZXN1bHRzIG9mIGEgcXVlcnkgYnkgdGhlaXIgKGFzY2VuZGluZykga2V5IHZhbHVlcy5cclxuICpcclxuICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgYG9yZGVyQnlLZXkoKWAgaW5cclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI3NvcnRfZGF0YSB8IFNvcnQgZGF0YX0uXHJcbiAqL1xyXG5mdW5jdGlvbiBvcmRlckJ5S2V5KCkge1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeU9yZGVyQnlLZXlDb25zdHJhaW50KCk7XHJcbn1cclxuY2xhc3MgUXVlcnlPcmRlckJ5UHJpb3JpdHlDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ29yZGVyQnlQcmlvcml0eSc7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICB2YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbChxdWVyeSwgJ29yZGVyQnlQcmlvcml0eScpO1xyXG4gICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zT3JkZXJCeShxdWVyeS5fcXVlcnlQYXJhbXMsIFBSSU9SSVRZX0lOREVYKTtcclxuICAgICAgICB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKG5ld1BhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBuZXdQYXJhbXMsIFxyXG4gICAgICAgIC8qb3JkZXJCeUNhbGxlZD0qLyB0cnVlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBgUXVlcnlDb25zdHJhaW50YCB0aGF0IG9yZGVycyBieSBwcmlvcml0eS5cclxuICpcclxuICogQXBwbGljYXRpb25zIG5lZWQgbm90IHVzZSBwcmlvcml0eSBidXQgY2FuIG9yZGVyIGNvbGxlY3Rpb25zIGJ5XHJcbiAqIG9yZGluYXJ5IHByb3BlcnRpZXMgKHNlZVxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjc29ydF9kYXRhIHwgU29ydCBkYXRhfVxyXG4gKiBmb3IgYWx0ZXJuYXRpdmVzIHRvIHByaW9yaXR5LlxyXG4gKi9cclxuZnVuY3Rpb24gb3JkZXJCeVByaW9yaXR5KCkge1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeU9yZGVyQnlQcmlvcml0eUNvbnN0cmFpbnQoKTtcclxufVxyXG5jbGFzcyBRdWVyeU9yZGVyQnlWYWx1ZUNvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnb3JkZXJCeVZhbHVlJztcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlTm9QcmV2aW91c09yZGVyQnlDYWxsKHF1ZXJ5LCAnb3JkZXJCeVZhbHVlJyk7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXNPcmRlckJ5KHF1ZXJ5Ll9xdWVyeVBhcmFtcywgVkFMVUVfSU5ERVgpO1xyXG4gICAgICAgIHZhbGlkYXRlUXVlcnlFbmRwb2ludHMobmV3UGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIG5ld1BhcmFtcywgXHJcbiAgICAgICAgLypvcmRlckJ5Q2FsbGVkPSovIHRydWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGBRdWVyeUNvbnN0cmFpbnRgIHRoYXQgb3JkZXJzIGJ5IHZhbHVlLlxyXG4gKlxyXG4gKiBJZiB0aGUgY2hpbGRyZW4gb2YgYSBxdWVyeSBhcmUgYWxsIHNjYWxhciB2YWx1ZXMgKHN0cmluZywgbnVtYmVyLCBvclxyXG4gKiBib29sZWFuKSwgeW91IGNhbiBvcmRlciB0aGUgcmVzdWx0cyBieSB0aGVpciAoYXNjZW5kaW5nKSB2YWx1ZXMuXHJcbiAqXHJcbiAqIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IGBvcmRlckJ5VmFsdWUoKWAgaW5cclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI3NvcnRfZGF0YSB8IFNvcnQgZGF0YX0uXHJcbiAqL1xyXG5mdW5jdGlvbiBvcmRlckJ5VmFsdWUoKSB7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5T3JkZXJCeVZhbHVlQ29uc3RyYWludCgpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5RXF1YWxUb1ZhbHVlQ29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfdmFsdWUsIF9rZXkpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xyXG4gICAgICAgIHRoaXMuX2tleSA9IF9rZXk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ2VxdWFsVG8nO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ2VxdWFsVG8nLCB0aGlzLl92YWx1ZSwgcXVlcnkuX3BhdGgsIGZhbHNlKTtcclxuICAgICAgICBpZiAocXVlcnkuX3F1ZXJ5UGFyYW1zLmhhc1N0YXJ0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlcXVhbFRvOiBTdGFydGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBzdGFydEF0L3N0YXJ0QWZ0ZXIgb3IgJyArXHJcbiAgICAgICAgICAgICAgICAnZXF1YWxUbykuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChxdWVyeS5fcXVlcnlQYXJhbXMuaGFzRW5kKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlcXVhbFRvOiBFbmRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gZW5kQXQvZW5kQmVmb3JlIG9yICcgK1xyXG4gICAgICAgICAgICAgICAgJ2VxdWFsVG8pLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5RW5kQXRDb25zdHJhaW50KHRoaXMuX3ZhbHVlLCB0aGlzLl9rZXkpLl9hcHBseShuZXcgUXVlcnlTdGFydEF0Q29uc3RyYWludCh0aGlzLl92YWx1ZSwgdGhpcy5fa2V5KS5fYXBwbHkocXVlcnkpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIGBRdWVyeUNvbnN0cmFpbnRgIHRoYXQgaW5jbHVkZXMgY2hpbGRyZW4gdGhhdCBtYXRjaCB0aGUgc3BlY2lmaWVkXHJcbiAqIHZhbHVlLlxyXG4gKlxyXG4gKiBVc2luZyBgc3RhcnRBdCgpYCwgYHN0YXJ0QWZ0ZXIoKWAsIGBlbmRCZWZvcmUoKWAsIGBlbmRBdCgpYCBhbmQgYGVxdWFsVG8oKWBcclxuICogYWxsb3dzIHlvdSB0byBjaG9vc2UgYXJiaXRyYXJ5IHN0YXJ0aW5nIGFuZCBlbmRpbmcgcG9pbnRzIGZvciB5b3VyIHF1ZXJpZXMuXHJcbiAqXHJcbiAqIFRoZSBvcHRpb25hbCBrZXkgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG8gZnVydGhlciBsaW1pdCB0aGUgcmFuZ2Ugb2YgdGhlXHJcbiAqIHF1ZXJ5LiBJZiBpdCBpcyBzcGVjaWZpZWQsIHRoZW4gY2hpbGRyZW4gdGhhdCBoYXZlIGV4YWN0bHkgdGhlIHNwZWNpZmllZFxyXG4gKiB2YWx1ZSBtdXN0IGFsc28gaGF2ZSBleGFjdGx5IHRoZSBzcGVjaWZpZWQga2V5IGFzIHRoZWlyIGtleSBuYW1lLiBUaGlzIGNhbiBiZVxyXG4gKiB1c2VkIHRvIGZpbHRlciByZXN1bHQgc2V0cyB3aXRoIG1hbnkgbWF0Y2hlcyBmb3IgdGhlIHNhbWUgdmFsdWUuXHJcbiAqXHJcbiAqIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IGBlcXVhbFRvKClgIGluXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNmaWx0ZXJpbmdfZGF0YSB8IEZpbHRlcmluZyBkYXRhfS5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIG1hdGNoIGZvci4gVGhlIGFyZ3VtZW50IHR5cGUgZGVwZW5kcyBvbiB3aGljaFxyXG4gKiBgb3JkZXJCeSooKWAgZnVuY3Rpb24gd2FzIHVzZWQgaW4gdGhpcyBxdWVyeS4gU3BlY2lmeSBhIHZhbHVlIHRoYXQgbWF0Y2hlc1xyXG4gKiB0aGUgYG9yZGVyQnkqKClgIHR5cGUuIFdoZW4gdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGBvcmRlckJ5S2V5KClgLCB0aGVcclxuICogdmFsdWUgbXVzdCBiZSBhIHN0cmluZy5cclxuICogQHBhcmFtIGtleSAtIFRoZSBjaGlsZCBrZXkgdG8gc3RhcnQgYXQsIGFtb25nIHRoZSBjaGlsZHJlbiB3aXRoIHRoZVxyXG4gKiBwcmV2aW91c2x5IHNwZWNpZmllZCBwcmlvcml0eS4gVGhpcyBhcmd1bWVudCBpcyBvbmx5IGFsbG93ZWQgaWYgb3JkZXJpbmcgYnlcclxuICogY2hpbGQsIHZhbHVlLCBvciBwcmlvcml0eS5cclxuICovXHJcbmZ1bmN0aW9uIGVxdWFsVG8odmFsdWUsIGtleSkge1xyXG4gICAgdmFsaWRhdGVLZXkoJ2VxdWFsVG8nLCAna2V5Jywga2V5LCB0cnVlKTtcclxuICAgIHJldHVybiBuZXcgUXVlcnlFcXVhbFRvVmFsdWVDb25zdHJhaW50KHZhbHVlLCBrZXkpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGltbXV0YWJsZSBpbnN0YW5jZSBvZiBgUXVlcnlgIHRoYXQgaXMgZXh0ZW5kZWQgdG8gYWxzbyBpbmNsdWRlXHJcbiAqIGFkZGl0aW9uYWwgcXVlcnkgY29uc3RyYWludHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBRdWVyeSBpbnN0YW5jZSB0byB1c2UgYXMgYSBiYXNlIGZvciB0aGUgbmV3IGNvbnN0cmFpbnRzLlxyXG4gKiBAcGFyYW0gcXVlcnlDb25zdHJhaW50cyAtIFRoZSBsaXN0IG9mIGBRdWVyeUNvbnN0cmFpbnRgcyB0byBhcHBseS5cclxuICogQHRocm93cyBpZiBhbnkgb2YgdGhlIHByb3ZpZGVkIHF1ZXJ5IGNvbnN0cmFpbnRzIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIHRoZVxyXG4gKiBleGlzdGluZyBvciBuZXcgY29uc3RyYWludHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeShxdWVyeSwgLi4ucXVlcnlDb25zdHJhaW50cykge1xyXG4gICAgbGV0IHF1ZXJ5SW1wbCA9IGdldE1vZHVsYXJJbnN0YW5jZShxdWVyeSk7XHJcbiAgICBmb3IgKGNvbnN0IGNvbnN0cmFpbnQgb2YgcXVlcnlDb25zdHJhaW50cykge1xyXG4gICAgICAgIHF1ZXJ5SW1wbCA9IGNvbnN0cmFpbnQuX2FwcGx5KHF1ZXJ5SW1wbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcXVlcnlJbXBsO1xyXG59XHJcbi8qKlxyXG4gKiBEZWZpbmUgcmVmZXJlbmNlIGNvbnN0cnVjdG9yIGluIHZhcmlvdXMgbW9kdWxlc1xyXG4gKlxyXG4gKiBXZSBhcmUgZG9pbmcgdGhpcyBoZXJlIHRvIGF2b2lkIHNldmVyYWwgY2lyY3VsYXJcclxuICogZGVwZW5kZW5jeSBpc3N1ZXNcclxuICovXHJcbnN5bmNQb2ludFNldFJlZmVyZW5jZUNvbnN0cnVjdG9yKFJlZmVyZW5jZUltcGwpO1xyXG5zeW5jVHJlZVNldFJlZmVyZW5jZUNvbnN0cnVjdG9yKFJlZmVyZW5jZUltcGwpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhpcyB2YXJpYWJsZSBpcyBhbHNvIGRlZmluZWQgaW4gdGhlIGZpcmViYXNlIE5vZGUuanMgQWRtaW4gU0RLLiBCZWZvcmVcclxuICogbW9kaWZ5aW5nIHRoaXMgZGVmaW5pdGlvbiwgY29uc3VsdCB0aGUgZGVmaW5pdGlvbiBpbjpcclxuICpcclxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWFkbWluLW5vZGVcclxuICpcclxuICogYW5kIG1ha2Ugc3VyZSB0aGUgdHdvIGFyZSBjb25zaXN0ZW50LlxyXG4gKi9cclxuY29uc3QgRklSRUJBU0VfREFUQUJBU0VfRU1VTEFUT1JfSE9TVF9WQVIgPSAnRklSRUJBU0VfREFUQUJBU0VfRU1VTEFUT1JfSE9TVCc7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuZCBjYWNoZXMgYFJlcG9gIGluc3RhbmNlcy5cclxuICovXHJcbmNvbnN0IHJlcG9zID0ge307XHJcbi8qKlxyXG4gKiBJZiB0cnVlLCBhbnkgbmV3IGBSZXBvYCB3aWxsIGJlIGNyZWF0ZWQgdG8gdXNlIGBSZWFkb25seVJlc3RDbGllbnRgIChmb3IgdGVzdGluZyBwdXJwb3NlcykuXHJcbiAqL1xyXG5sZXQgdXNlUmVzdENsaWVudCA9IGZhbHNlO1xyXG4vKipcclxuICogVXBkYXRlIGFuIGV4aXN0aW5nIGBSZXBvYCBpbiBwbGFjZSB0byBwb2ludCB0byBhIG5ldyBob3N0L3BvcnQuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvTWFuYWdlckFwcGx5RW11bGF0b3JTZXR0aW5ncyhyZXBvLCBob3N0LCBwb3J0LCB0b2tlblByb3ZpZGVyKSB7XHJcbiAgICByZXBvLnJlcG9JbmZvXyA9IG5ldyBSZXBvSW5mbyhgJHtob3N0fToke3BvcnR9YCwgXHJcbiAgICAvKiBzZWN1cmU9ICovIGZhbHNlLCByZXBvLnJlcG9JbmZvXy5uYW1lc3BhY2UsIHJlcG8ucmVwb0luZm9fLndlYlNvY2tldE9ubHksIHJlcG8ucmVwb0luZm9fLm5vZGVBZG1pbiwgcmVwby5yZXBvSW5mb18ucGVyc2lzdGVuY2VLZXksIHJlcG8ucmVwb0luZm9fLmluY2x1ZGVOYW1lc3BhY2VJblF1ZXJ5UGFyYW1zLCBcclxuICAgIC8qaXNVc2luZ0VtdWxhdG9yPSovIHRydWUpO1xyXG4gICAgaWYgKHRva2VuUHJvdmlkZXIpIHtcclxuICAgICAgICByZXBvLmF1dGhUb2tlblByb3ZpZGVyXyA9IHRva2VuUHJvdmlkZXI7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgZXZlciBiZSBjYWxsZWQgdG8gQ1JFQVRFIGEgbmV3IGRhdGFiYXNlIGluc3RhbmNlLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIHJlcG9NYW5hZ2VyRGF0YWJhc2VGcm9tQXBwKGFwcCwgYXV0aFByb3ZpZGVyLCBhcHBDaGVja1Byb3ZpZGVyLCB1cmwsIG5vZGVBZG1pbikge1xyXG4gICAgbGV0IGRiVXJsID0gdXJsIHx8IGFwcC5vcHRpb25zLmRhdGFiYXNlVVJMO1xyXG4gICAgaWYgKGRiVXJsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAoIWFwcC5vcHRpb25zLnByb2plY3RJZCkge1xyXG4gICAgICAgICAgICBmYXRhbChcIkNhbid0IGRldGVybWluZSBGaXJlYmFzZSBEYXRhYmFzZSBVUkwuIEJlIHN1cmUgdG8gaW5jbHVkZSBcIiArXHJcbiAgICAgICAgICAgICAgICAnIGEgUHJvamVjdCBJRCB3aGVuIGNhbGxpbmcgZmlyZWJhc2UuaW5pdGlhbGl6ZUFwcCgpLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsb2coJ1VzaW5nIGRlZmF1bHQgaG9zdCBmb3IgcHJvamVjdCAnLCBhcHAub3B0aW9ucy5wcm9qZWN0SWQpO1xyXG4gICAgICAgIGRiVXJsID0gYCR7YXBwLm9wdGlvbnMucHJvamVjdElkfS1kZWZhdWx0LXJ0ZGIuZmlyZWJhc2Vpby5jb21gO1xyXG4gICAgfVxyXG4gICAgbGV0IHBhcnNlZFVybCA9IHBhcnNlUmVwb0luZm8oZGJVcmwsIG5vZGVBZG1pbik7XHJcbiAgICBsZXQgcmVwb0luZm8gPSBwYXJzZWRVcmwucmVwb0luZm87XHJcbiAgICBsZXQgaXNFbXVsYXRvcjtcclxuICAgIGxldCBkYkVtdWxhdG9ySG9zdCA9IHVuZGVmaW5lZDtcclxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYpIHtcclxuICAgICAgICBkYkVtdWxhdG9ySG9zdCA9IHByb2Nlc3MuZW52W0ZJUkVCQVNFX0RBVEFCQVNFX0VNVUxBVE9SX0hPU1RfVkFSXTtcclxuICAgIH1cclxuICAgIGlmIChkYkVtdWxhdG9ySG9zdCkge1xyXG4gICAgICAgIGlzRW11bGF0b3IgPSB0cnVlO1xyXG4gICAgICAgIGRiVXJsID0gYGh0dHA6Ly8ke2RiRW11bGF0b3JIb3N0fT9ucz0ke3JlcG9JbmZvLm5hbWVzcGFjZX1gO1xyXG4gICAgICAgIHBhcnNlZFVybCA9IHBhcnNlUmVwb0luZm8oZGJVcmwsIG5vZGVBZG1pbik7XHJcbiAgICAgICAgcmVwb0luZm8gPSBwYXJzZWRVcmwucmVwb0luZm87XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpc0VtdWxhdG9yID0gIXBhcnNlZFVybC5yZXBvSW5mby5zZWN1cmU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhdXRoVG9rZW5Qcm92aWRlciA9IG5vZGVBZG1pbiAmJiBpc0VtdWxhdG9yXHJcbiAgICAgICAgPyBuZXcgRW11bGF0b3JUb2tlblByb3ZpZGVyKEVtdWxhdG9yVG9rZW5Qcm92aWRlci5PV05FUilcclxuICAgICAgICA6IG5ldyBGaXJlYmFzZUF1dGhUb2tlblByb3ZpZGVyKGFwcC5uYW1lLCBhcHAub3B0aW9ucywgYXV0aFByb3ZpZGVyKTtcclxuICAgIHZhbGlkYXRlVXJsKCdJbnZhbGlkIEZpcmViYXNlIERhdGFiYXNlIFVSTCcsIHBhcnNlZFVybCk7XHJcbiAgICBpZiAoIXBhdGhJc0VtcHR5KHBhcnNlZFVybC5wYXRoKSkge1xyXG4gICAgICAgIGZhdGFsKCdEYXRhYmFzZSBVUkwgbXVzdCBwb2ludCB0byB0aGUgcm9vdCBvZiBhIEZpcmViYXNlIERhdGFiYXNlICcgK1xyXG4gICAgICAgICAgICAnKG5vdCBpbmNsdWRpbmcgYSBjaGlsZCBwYXRoKS4nKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlcG8gPSByZXBvTWFuYWdlckNyZWF0ZVJlcG8ocmVwb0luZm8sIGFwcCwgYXV0aFRva2VuUHJvdmlkZXIsIG5ldyBBcHBDaGVja1Rva2VuUHJvdmlkZXIoYXBwLm5hbWUsIGFwcENoZWNrUHJvdmlkZXIpKTtcclxuICAgIHJldHVybiBuZXcgRGF0YWJhc2UocmVwbywgYXBwKTtcclxufVxyXG4vKipcclxuICogUmVtb3ZlIHRoZSByZXBvIGFuZCBtYWtlIHN1cmUgaXQgaXMgZGlzY29ubmVjdGVkLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb01hbmFnZXJEZWxldGVSZXBvKHJlcG8sIGFwcE5hbWUpIHtcclxuICAgIGNvbnN0IGFwcFJlcG9zID0gcmVwb3NbYXBwTmFtZV07XHJcbiAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uLi5cclxuICAgIGlmICghYXBwUmVwb3MgfHwgYXBwUmVwb3NbcmVwby5rZXldICE9PSByZXBvKSB7XHJcbiAgICAgICAgZmF0YWwoYERhdGFiYXNlICR7YXBwTmFtZX0oJHtyZXBvLnJlcG9JbmZvX30pIGhhcyBhbHJlYWR5IGJlZW4gZGVsZXRlZC5gKTtcclxuICAgIH1cclxuICAgIHJlcG9JbnRlcnJ1cHQocmVwbyk7XHJcbiAgICBkZWxldGUgYXBwUmVwb3NbcmVwby5rZXldO1xyXG59XHJcbi8qKlxyXG4gKiBFbnN1cmVzIGEgcmVwbyBkb2Vzbid0IGFscmVhZHkgZXhpc3QgYW5kIHRoZW4gY3JlYXRlcyBvbmUgdXNpbmcgdGhlXHJcbiAqIHByb3ZpZGVkIGFwcC5cclxuICpcclxuICogQHBhcmFtIHJlcG9JbmZvIC0gVGhlIG1ldGFkYXRhIGFib3V0IHRoZSBSZXBvXHJcbiAqIEByZXR1cm5zIFRoZSBSZXBvIG9iamVjdCBmb3IgdGhlIHNwZWNpZmllZCBzZXJ2ZXIgLyByZXBvTmFtZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9NYW5hZ2VyQ3JlYXRlUmVwbyhyZXBvSW5mbywgYXBwLCBhdXRoVG9rZW5Qcm92aWRlciwgYXBwQ2hlY2tQcm92aWRlcikge1xyXG4gICAgbGV0IGFwcFJlcG9zID0gcmVwb3NbYXBwLm5hbWVdO1xyXG4gICAgaWYgKCFhcHBSZXBvcykge1xyXG4gICAgICAgIGFwcFJlcG9zID0ge307XHJcbiAgICAgICAgcmVwb3NbYXBwLm5hbWVdID0gYXBwUmVwb3M7XHJcbiAgICB9XHJcbiAgICBsZXQgcmVwbyA9IGFwcFJlcG9zW3JlcG9JbmZvLnRvVVJMU3RyaW5nKCldO1xyXG4gICAgaWYgKHJlcG8pIHtcclxuICAgICAgICBmYXRhbCgnRGF0YWJhc2UgaW5pdGlhbGl6ZWQgbXVsdGlwbGUgdGltZXMuIFBsZWFzZSBtYWtlIHN1cmUgdGhlIGZvcm1hdCBvZiB0aGUgZGF0YWJhc2UgVVJMIG1hdGNoZXMgd2l0aCBlYWNoIGRhdGFiYXNlKCkgY2FsbC4nKTtcclxuICAgIH1cclxuICAgIHJlcG8gPSBuZXcgUmVwbyhyZXBvSW5mbywgdXNlUmVzdENsaWVudCwgYXV0aFRva2VuUHJvdmlkZXIsIGFwcENoZWNrUHJvdmlkZXIpO1xyXG4gICAgYXBwUmVwb3NbcmVwb0luZm8udG9VUkxTdHJpbmcoKV0gPSByZXBvO1xyXG4gICAgcmV0dXJuIHJlcG87XHJcbn1cclxuLyoqXHJcbiAqIEZvcmNlcyB1cyB0byB1c2UgUmVhZG9ubHlSZXN0Q2xpZW50IGluc3RlYWQgb2YgUGVyc2lzdGVudENvbm5lY3Rpb24gZm9yIG5ldyBSZXBvcy5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9NYW5hZ2VyRm9yY2VSZXN0Q2xpZW50KGZvcmNlUmVzdENsaWVudCkge1xyXG4gICAgdXNlUmVzdENsaWVudCA9IGZvcmNlUmVzdENsaWVudDtcclxufVxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgRmlyZWJhc2UgUmVhbHRpbWUgRGF0YWJhc2UuXHJcbiAqL1xyXG5jbGFzcyBEYXRhYmFzZSB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoX3JlcG9JbnRlcm5hbCwgXHJcbiAgICAvKiogVGhlIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfSBhc3NvY2lhdGVkIHdpdGggdGhpcyBSZWFsdGltZSBEYXRhYmFzZSBpbnN0YW5jZS4gKi9cclxuICAgIGFwcCkge1xyXG4gICAgICAgIHRoaXMuX3JlcG9JbnRlcm5hbCA9IF9yZXBvSW50ZXJuYWw7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICAgICAgLyoqIFJlcHJlc2VudHMgYSBgRGF0YWJhc2VgIGluc3RhbmNlLiAqL1xyXG4gICAgICAgIHRoaXNbJ3R5cGUnXSA9ICdkYXRhYmFzZSc7XHJcbiAgICAgICAgLyoqIFRyYWNrIGlmIHRoZSBpbnN0YW5jZSBoYXMgYmVlbiB1c2VkIChyb290IG9yIHJlcG8gYWNjZXNzZWQpICovXHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2VTdGFydGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBnZXQgX3JlcG8oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pbnN0YW5jZVN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgcmVwb1N0YXJ0KHRoaXMuX3JlcG9JbnRlcm5hbCwgdGhpcy5hcHAub3B0aW9ucy5hcHBJZCwgdGhpcy5hcHAub3B0aW9uc1snZGF0YWJhc2VBdXRoVmFyaWFibGVPdmVycmlkZSddKTtcclxuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2VTdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcG9JbnRlcm5hbDtcclxuICAgIH1cclxuICAgIGdldCBfcm9vdCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3Jvb3RJbnRlcm5hbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yb290SW50ZXJuYWwgPSBuZXcgUmVmZXJlbmNlSW1wbCh0aGlzLl9yZXBvLCBuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb290SW50ZXJuYWw7XHJcbiAgICB9XHJcbiAgICBfZGVsZXRlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yb290SW50ZXJuYWwgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmVwb01hbmFnZXJEZWxldGVSZXBvKHRoaXMuX3JlcG8sIHRoaXMuYXBwLm5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBvSW50ZXJuYWwgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9yb290SW50ZXJuYWwgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBfY2hlY2tOb3REZWxldGVkKGFwaU5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fcm9vdEludGVybmFsID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZhdGFsKCdDYW5ub3QgY2FsbCAnICsgYXBpTmFtZSArICcgb24gYSBkZWxldGVkIGRhdGFiYXNlLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjaGVja1RyYW5zcG9ydEluaXQoKSB7XHJcbiAgICBpZiAoVHJhbnNwb3J0TWFuYWdlci5JU19UUkFOU1BPUlRfSU5JVElBTElaRUQpIHtcclxuICAgICAgICB3YXJuKCdUcmFuc3BvcnQgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZC4gUGxlYXNlIGNhbGwgdGhpcyBmdW5jdGlvbiBiZWZvcmUgY2FsbGluZyByZWYgb3Igc2V0dGluZyB1cCBhIGxpc3RlbmVyJyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEZvcmNlIHRoZSB1c2Ugb2Ygd2Vic29ja2V0cyBpbnN0ZWFkIG9mIGxvbmdQb2xsaW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gZm9yY2VXZWJTb2NrZXRzKCkge1xyXG4gICAgY2hlY2tUcmFuc3BvcnRJbml0KCk7XHJcbiAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvdygpO1xyXG59XHJcbi8qKlxyXG4gKiBGb3JjZSB0aGUgdXNlIG9mIGxvbmdQb2xsaW5nIGluc3RlYWQgb2Ygd2Vic29ja2V0cy4gVGhpcyB3aWxsIGJlIGlnbm9yZWQgaWYgd2Vic29ja2V0IHByb3RvY29sIGlzIHVzZWQgaW4gZGF0YWJhc2VVUkwuXHJcbiAqL1xyXG5mdW5jdGlvbiBmb3JjZUxvbmdQb2xsaW5nKCkge1xyXG4gICAgY2hlY2tUcmFuc3BvcnRJbml0KCk7XHJcbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLmZvcmNlRGlzYWxsb3coKTtcclxuICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZUFsbG93KCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIHRoZSBSZWFsdGltZSBEYXRhYmFzZSBTREsgdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVkXHJcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfS4gSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugd2l0aCBkZWZhdWx0IHNldHRpbmdzIGlmXHJcbiAqIG5vIGluc3RhbmNlIGV4aXN0cyBvciBpZiB0aGUgZXhpc3RpbmcgaW5zdGFuY2UgdXNlcyBhIGN1c3RvbSBkYXRhYmFzZSBVUkwuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcHAgLSBUaGUge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9IGluc3RhbmNlIHRoYXQgdGhlIHJldHVybmVkIFJlYWx0aW1lXHJcbiAqIERhdGFiYXNlIGluc3RhbmNlIGlzIGFzc29jaWF0ZWQgd2l0aC5cclxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgb2YgdGhlIFJlYWx0aW1lIERhdGFiYXNlIGluc3RhbmNlIHRvIGNvbm5lY3QgdG8uIElmIG5vdFxyXG4gKiBwcm92aWRlZCwgdGhlIFNESyBjb25uZWN0cyB0byB0aGUgZGVmYXVsdCBpbnN0YW5jZSBvZiB0aGUgRmlyZWJhc2UgQXBwLlxyXG4gKiBAcmV0dXJucyBUaGUgYERhdGFiYXNlYCBpbnN0YW5jZSBvZiB0aGUgcHJvdmlkZWQgYXBwLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RGF0YWJhc2UoYXBwID0gZ2V0QXBwKCksIHVybCkge1xyXG4gICAgY29uc3QgZGIgPSBfZ2V0UHJvdmlkZXIoYXBwLCAnZGF0YWJhc2UnKS5nZXRJbW1lZGlhdGUoe1xyXG4gICAgICAgIGlkZW50aWZpZXI6IHVybFxyXG4gICAgfSk7XHJcbiAgICBpZiAoIWRiLl9pbnN0YW5jZVN0YXJ0ZWQpIHtcclxuICAgICAgICBjb25zdCBlbXVsYXRvciA9IGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCgnZGF0YWJhc2UnKTtcclxuICAgICAgICBpZiAoZW11bGF0b3IpIHtcclxuICAgICAgICAgICAgY29ubmVjdERhdGFiYXNlRW11bGF0b3IoZGIsIC4uLmVtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGI7XHJcbn1cclxuLyoqXHJcbiAqIE1vZGlmeSB0aGUgcHJvdmlkZWQgaW5zdGFuY2UgdG8gY29tbXVuaWNhdGUgd2l0aCB0aGUgUmVhbHRpbWUgRGF0YWJhc2VcclxuICogZW11bGF0b3IuXHJcbiAqXHJcbiAqIDxwPk5vdGU6IFRoaXMgbWV0aG9kIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBwZXJmb3JtaW5nIGFueSBvdGhlciBvcGVyYXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBkYiAtIFRoZSBpbnN0YW5jZSB0byBtb2RpZnkuXHJcbiAqIEBwYXJhbSBob3N0IC0gVGhlIGVtdWxhdG9yIGhvc3QgKGV4OiBsb2NhbGhvc3QpXHJcbiAqIEBwYXJhbSBwb3J0IC0gVGhlIGVtdWxhdG9yIHBvcnQgKGV4OiA4MDgwKVxyXG4gKiBAcGFyYW0gb3B0aW9ucy5tb2NrVXNlclRva2VuIC0gdGhlIG1vY2sgYXV0aCB0b2tlbiB0byB1c2UgZm9yIHVuaXQgdGVzdGluZyBTZWN1cml0eSBSdWxlc1xyXG4gKi9cclxuZnVuY3Rpb24gY29ubmVjdERhdGFiYXNlRW11bGF0b3IoZGIsIGhvc3QsIHBvcnQsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgZGIgPSBnZXRNb2R1bGFySW5zdGFuY2UoZGIpO1xyXG4gICAgZGIuX2NoZWNrTm90RGVsZXRlZCgndXNlRW11bGF0b3InKTtcclxuICAgIGlmIChkYi5faW5zdGFuY2VTdGFydGVkKSB7XHJcbiAgICAgICAgZmF0YWwoJ0Nhbm5vdCBjYWxsIHVzZUVtdWxhdG9yKCkgYWZ0ZXIgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZC4nKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlcG8gPSBkYi5fcmVwb0ludGVybmFsO1xyXG4gICAgbGV0IHRva2VuUHJvdmlkZXIgPSB1bmRlZmluZWQ7XHJcbiAgICBpZiAocmVwby5yZXBvSW5mb18ubm9kZUFkbWluKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMubW9ja1VzZXJUb2tlbikge1xyXG4gICAgICAgICAgICBmYXRhbCgnbW9ja1VzZXJUb2tlbiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBBZG1pbiBTREsuIEZvciBjbGllbnQgYWNjZXNzIHdpdGggbW9jayB1c2VycywgcGxlYXNlIHVzZSB0aGUgXCJmaXJlYmFzZVwiIHBhY2thZ2UgaW5zdGVhZCBvZiBcImZpcmViYXNlLWFkbWluXCIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRva2VuUHJvdmlkZXIgPSBuZXcgRW11bGF0b3JUb2tlblByb3ZpZGVyKEVtdWxhdG9yVG9rZW5Qcm92aWRlci5PV05FUik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChvcHRpb25zLm1vY2tVc2VyVG9rZW4pIHtcclxuICAgICAgICBjb25zdCB0b2tlbiA9IHR5cGVvZiBvcHRpb25zLm1vY2tVc2VyVG9rZW4gPT09ICdzdHJpbmcnXHJcbiAgICAgICAgICAgID8gb3B0aW9ucy5tb2NrVXNlclRva2VuXHJcbiAgICAgICAgICAgIDogY3JlYXRlTW9ja1VzZXJUb2tlbihvcHRpb25zLm1vY2tVc2VyVG9rZW4sIGRiLmFwcC5vcHRpb25zLnByb2plY3RJZCk7XHJcbiAgICAgICAgdG9rZW5Qcm92aWRlciA9IG5ldyBFbXVsYXRvclRva2VuUHJvdmlkZXIodG9rZW4pO1xyXG4gICAgfVxyXG4gICAgLy8gTW9kaWZ5IHRoZSByZXBvIHRvIGFwcGx5IGVtdWxhdG9yIHNldHRpbmdzXHJcbiAgICByZXBvTWFuYWdlckFwcGx5RW11bGF0b3JTZXR0aW5ncyhyZXBvLCBob3N0LCBwb3J0LCB0b2tlblByb3ZpZGVyKTtcclxufVxyXG4vKipcclxuICogRGlzY29ubmVjdHMgZnJvbSB0aGUgc2VydmVyIChhbGwgRGF0YWJhc2Ugb3BlcmF0aW9ucyB3aWxsIGJlIGNvbXBsZXRlZFxyXG4gKiBvZmZsaW5lKS5cclxuICpcclxuICogVGhlIGNsaWVudCBhdXRvbWF0aWNhbGx5IG1haW50YWlucyBhIHBlcnNpc3RlbnQgY29ubmVjdGlvbiB0byB0aGUgRGF0YWJhc2VcclxuICogc2VydmVyLCB3aGljaCB3aWxsIHJlbWFpbiBhY3RpdmUgaW5kZWZpbml0ZWx5IGFuZCByZWNvbm5lY3Qgd2hlblxyXG4gKiBkaXNjb25uZWN0ZWQuIEhvd2V2ZXIsIHRoZSBgZ29PZmZsaW5lKClgIGFuZCBgZ29PbmxpbmUoKWAgbWV0aG9kcyBtYXkgYmUgdXNlZFxyXG4gKiB0byBjb250cm9sIHRoZSBjbGllbnQgY29ubmVjdGlvbiBpbiBjYXNlcyB3aGVyZSBhIHBlcnNpc3RlbnQgY29ubmVjdGlvbiBpc1xyXG4gKiB1bmRlc2lyYWJsZS5cclxuICpcclxuICogV2hpbGUgb2ZmbGluZSwgdGhlIGNsaWVudCB3aWxsIG5vIGxvbmdlciByZWNlaXZlIGRhdGEgdXBkYXRlcyBmcm9tIHRoZVxyXG4gKiBEYXRhYmFzZS4gSG93ZXZlciwgYWxsIERhdGFiYXNlIG9wZXJhdGlvbnMgcGVyZm9ybWVkIGxvY2FsbHkgd2lsbCBjb250aW51ZSB0b1xyXG4gKiBpbW1lZGlhdGVseSBmaXJlIGV2ZW50cywgYWxsb3dpbmcgeW91ciBhcHBsaWNhdGlvbiB0byBjb250aW51ZSBiZWhhdmluZ1xyXG4gKiBub3JtYWxseS4gQWRkaXRpb25hbGx5LCBlYWNoIG9wZXJhdGlvbiBwZXJmb3JtZWQgbG9jYWxseSB3aWxsIGF1dG9tYXRpY2FsbHlcclxuICogYmUgcXVldWVkIGFuZCByZXRyaWVkIHVwb24gcmVjb25uZWN0aW9uIHRvIHRoZSBEYXRhYmFzZSBzZXJ2ZXIuXHJcbiAqXHJcbiAqIFRvIHJlY29ubmVjdCB0byB0aGUgRGF0YWJhc2UgYW5kIGJlZ2luIHJlY2VpdmluZyByZW1vdGUgZXZlbnRzLCBzZWVcclxuICogYGdvT25saW5lKClgLlxyXG4gKlxyXG4gKiBAcGFyYW0gZGIgLSBUaGUgaW5zdGFuY2UgdG8gZGlzY29ubmVjdC5cclxuICovXHJcbmZ1bmN0aW9uIGdvT2ZmbGluZShkYikge1xyXG4gICAgZGIgPSBnZXRNb2R1bGFySW5zdGFuY2UoZGIpO1xyXG4gICAgZGIuX2NoZWNrTm90RGVsZXRlZCgnZ29PZmZsaW5lJyk7XHJcbiAgICByZXBvSW50ZXJydXB0KGRiLl9yZXBvKTtcclxufVxyXG4vKipcclxuICogUmVjb25uZWN0cyB0byB0aGUgc2VydmVyIGFuZCBzeW5jaHJvbml6ZXMgdGhlIG9mZmxpbmUgRGF0YWJhc2Ugc3RhdGVcclxuICogd2l0aCB0aGUgc2VydmVyIHN0YXRlLlxyXG4gKlxyXG4gKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgdXNlZCBhZnRlciBkaXNhYmxpbmcgdGhlIGFjdGl2ZSBjb25uZWN0aW9uIHdpdGhcclxuICogYGdvT2ZmbGluZSgpYC4gT25jZSByZWNvbm5lY3RlZCwgdGhlIGNsaWVudCB3aWxsIHRyYW5zbWl0IHRoZSBwcm9wZXIgZGF0YVxyXG4gKiBhbmQgZmlyZSB0aGUgYXBwcm9wcmlhdGUgZXZlbnRzIHNvIHRoYXQgeW91ciBjbGllbnQgXCJjYXRjaGVzIHVwXCJcclxuICogYXV0b21hdGljYWxseS5cclxuICpcclxuICogQHBhcmFtIGRiIC0gVGhlIGluc3RhbmNlIHRvIHJlY29ubmVjdC5cclxuICovXHJcbmZ1bmN0aW9uIGdvT25saW5lKGRiKSB7XHJcbiAgICBkYiA9IGdldE1vZHVsYXJJbnN0YW5jZShkYik7XHJcbiAgICBkYi5fY2hlY2tOb3REZWxldGVkKCdnb09ubGluZScpO1xyXG4gICAgcmVwb1Jlc3VtZShkYi5fcmVwbyk7XHJcbn1cclxuZnVuY3Rpb24gZW5hYmxlTG9nZ2luZyhsb2dnZXIsIHBlcnNpc3RlbnQpIHtcclxuICAgIGVuYWJsZUxvZ2dpbmckMShsb2dnZXIsIHBlcnNpc3RlbnQpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyRGF0YWJhc2UodmFyaWFudCkge1xyXG4gICAgc2V0U0RLVmVyc2lvbihTREtfVkVSU0lPTiQxKTtcclxuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KCdkYXRhYmFzZScsIChjb250YWluZXIsIHsgaW5zdGFuY2VJZGVudGlmaWVyOiB1cmwgfSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGFwcCA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XHJcbiAgICAgICAgY29uc3QgYXV0aFByb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhdXRoLWludGVybmFsJyk7XHJcbiAgICAgICAgY29uc3QgYXBwQ2hlY2tQcm92aWRlciA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwLWNoZWNrLWludGVybmFsJyk7XHJcbiAgICAgICAgcmV0dXJuIHJlcG9NYW5hZ2VyRGF0YWJhc2VGcm9tQXBwKGFwcCwgYXV0aFByb3ZpZGVyLCBhcHBDaGVja1Byb3ZpZGVyLCB1cmwpO1xyXG4gICAgfSwgXCJQVUJMSUNcIiAvKiBDb21wb25lbnRUeXBlLlBVQkxJQyAqLykuc2V0TXVsdGlwbGVJbnN0YW5jZXModHJ1ZSkpO1xyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sIHZhcmlhbnQpO1xyXG4gICAgLy8gQlVJTERfVEFSR0VUIHdpbGwgYmUgcmVwbGFjZWQgYnkgdmFsdWVzIGxpa2UgZXNtNSwgZXNtMjAxNywgY2pzNSwgZXRjIGR1cmluZyB0aGUgY29tcGlsYXRpb25cclxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uLCAnZXNtMjAxNycpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IFNFUlZFUl9USU1FU1RBTVAgPSB7XHJcbiAgICAnLnN2JzogJ3RpbWVzdGFtcCdcclxufTtcclxuLyoqXHJcbiAqIFJldHVybnMgYSBwbGFjZWhvbGRlciB2YWx1ZSBmb3IgYXV0by1wb3B1bGF0aW5nIHRoZSBjdXJyZW50IHRpbWVzdGFtcCAodGltZVxyXG4gKiBzaW5jZSB0aGUgVW5peCBlcG9jaCwgaW4gbWlsbGlzZWNvbmRzKSBhcyBkZXRlcm1pbmVkIGJ5IHRoZSBGaXJlYmFzZVxyXG4gKiBzZXJ2ZXJzLlxyXG4gKi9cclxuZnVuY3Rpb24gc2VydmVyVGltZXN0YW1wKCkge1xyXG4gICAgcmV0dXJuIFNFUlZFUl9USU1FU1RBTVA7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBwbGFjZWhvbGRlciB2YWx1ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGF0b21pY2FsbHkgaW5jcmVtZW50IHRoZVxyXG4gKiBjdXJyZW50IGRhdGFiYXNlIHZhbHVlIGJ5IHRoZSBwcm92aWRlZCBkZWx0YS5cclxuICpcclxuICogQHBhcmFtIGRlbHRhIC0gdGhlIGFtb3VudCB0byBtb2RpZnkgdGhlIGN1cnJlbnQgdmFsdWUgYXRvbWljYWxseS5cclxuICogQHJldHVybnMgQSBwbGFjZWhvbGRlciB2YWx1ZSBmb3IgbW9kaWZ5aW5nIGRhdGEgYXRvbWljYWxseSBzZXJ2ZXItc2lkZS5cclxuICovXHJcbmZ1bmN0aW9uIGluY3JlbWVudChkZWx0YSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAnLnN2Jzoge1xyXG4gICAgICAgICAgICAnaW5jcmVtZW50JzogZGVsdGFcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIHR5cGUgZm9yIHRoZSByZXNvbHZlIHZhbHVlIG9mIHtAbGluayBydW5UcmFuc2FjdGlvbn0uXHJcbiAqL1xyXG5jbGFzcyBUcmFuc2FjdGlvblJlc3VsdCB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogV2hldGhlciB0aGUgdHJhbnNhY3Rpb24gd2FzIHN1Y2Nlc3NmdWxseSBjb21taXR0ZWQuICovXHJcbiAgICBjb21taXR0ZWQsIFxyXG4gICAgLyoqIFRoZSByZXN1bHRpbmcgZGF0YSBzbmFwc2hvdC4gKi9cclxuICAgIHNuYXBzaG90KSB7XHJcbiAgICAgICAgdGhpcy5jb21taXR0ZWQgPSBjb21taXR0ZWQ7XHJcbiAgICAgICAgdGhpcy5zbmFwc2hvdCA9IHNuYXBzaG90O1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC4gKi9cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4geyBjb21taXR0ZWQ6IHRoaXMuY29tbWl0dGVkLCBzbmFwc2hvdDogdGhpcy5zbmFwc2hvdC50b0pTT04oKSB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBdG9taWNhbGx5IG1vZGlmaWVzIHRoZSBkYXRhIGF0IHRoaXMgbG9jYXRpb24uXHJcbiAqXHJcbiAqIEF0b21pY2FsbHkgbW9kaWZ5IHRoZSBkYXRhIGF0IHRoaXMgbG9jYXRpb24uIFVubGlrZSBhIG5vcm1hbCBgc2V0KClgLCB3aGljaFxyXG4gKiBqdXN0IG92ZXJ3cml0ZXMgdGhlIGRhdGEgcmVnYXJkbGVzcyBvZiBpdHMgcHJldmlvdXMgdmFsdWUsIGBydW5UcmFuc2FjdGlvbigpYCBpc1xyXG4gKiB1c2VkIHRvIG1vZGlmeSB0aGUgZXhpc3RpbmcgdmFsdWUgdG8gYSBuZXcgdmFsdWUsIGVuc3VyaW5nIHRoZXJlIGFyZSBub1xyXG4gKiBjb25mbGljdHMgd2l0aCBvdGhlciBjbGllbnRzIHdyaXRpbmcgdG8gdGhlIHNhbWUgbG9jYXRpb24gYXQgdGhlIHNhbWUgdGltZS5cclxuICpcclxuICogVG8gYWNjb21wbGlzaCB0aGlzLCB5b3UgcGFzcyBgcnVuVHJhbnNhY3Rpb24oKWAgYW4gdXBkYXRlIGZ1bmN0aW9uIHdoaWNoIGlzXHJcbiAqIHVzZWQgdG8gdHJhbnNmb3JtIHRoZSBjdXJyZW50IHZhbHVlIGludG8gYSBuZXcgdmFsdWUuIElmIGFub3RoZXIgY2xpZW50XHJcbiAqIHdyaXRlcyB0byB0aGUgbG9jYXRpb24gYmVmb3JlIHlvdXIgbmV3IHZhbHVlIGlzIHN1Y2Nlc3NmdWxseSB3cml0dGVuLCB5b3VyXHJcbiAqIHVwZGF0ZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoIHRoZSBuZXcgY3VycmVudCB2YWx1ZSwgYW5kIHRoZVxyXG4gKiB3cml0ZSB3aWxsIGJlIHJldHJpZWQuIFRoaXMgd2lsbCBoYXBwZW4gcmVwZWF0ZWRseSB1bnRpbCB5b3VyIHdyaXRlIHN1Y2NlZWRzXHJcbiAqIHdpdGhvdXQgY29uZmxpY3Qgb3IgeW91IGFib3J0IHRoZSB0cmFuc2FjdGlvbiBieSBub3QgcmV0dXJuaW5nIGEgdmFsdWUgZnJvbVxyXG4gKiB5b3VyIHVwZGF0ZSBmdW5jdGlvbi5cclxuICpcclxuICogTm90ZTogTW9kaWZ5aW5nIGRhdGEgd2l0aCBgc2V0KClgIHdpbGwgY2FuY2VsIGFueSBwZW5kaW5nIHRyYW5zYWN0aW9ucyBhdFxyXG4gKiB0aGF0IGxvY2F0aW9uLCBzbyBleHRyZW1lIGNhcmUgc2hvdWxkIGJlIHRha2VuIGlmIG1peGluZyBgc2V0KClgIGFuZFxyXG4gKiBgcnVuVHJhbnNhY3Rpb24oKWAgdG8gdXBkYXRlIHRoZSBzYW1lIGRhdGEuXHJcbiAqXHJcbiAqIE5vdGU6IFdoZW4gdXNpbmcgdHJhbnNhY3Rpb25zIHdpdGggU2VjdXJpdHkgYW5kIEZpcmViYXNlIFJ1bGVzIGluIHBsYWNlLCBiZVxyXG4gKiBhd2FyZSB0aGF0IGEgY2xpZW50IG5lZWRzIGAucmVhZGAgYWNjZXNzIGluIGFkZGl0aW9uIHRvIGAud3JpdGVgIGFjY2VzcyBpblxyXG4gKiBvcmRlciB0byBwZXJmb3JtIGEgdHJhbnNhY3Rpb24uIFRoaXMgaXMgYmVjYXVzZSB0aGUgY2xpZW50LXNpZGUgbmF0dXJlIG9mXHJcbiAqIHRyYW5zYWN0aW9ucyByZXF1aXJlcyB0aGUgY2xpZW50IHRvIHJlYWQgdGhlIGRhdGEgaW4gb3JkZXIgdG8gdHJhbnNhY3Rpb25hbGx5XHJcbiAqIHVwZGF0ZSBpdC5cclxuICpcclxuICogQHBhcmFtIHJlZiAtIFRoZSBsb2NhdGlvbiB0byBhdG9taWNhbGx5IG1vZGlmeS5cclxuICogQHBhcmFtIHRyYW5zYWN0aW9uVXBkYXRlIC0gQSBkZXZlbG9wZXItc3VwcGxpZWQgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBwYXNzZWRcclxuICogdGhlIGN1cnJlbnQgZGF0YSBzdG9yZWQgYXQgdGhpcyBsb2NhdGlvbiAoYXMgYSBKYXZhU2NyaXB0IG9iamVjdCkuIFRoZVxyXG4gKiBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIHRoZSBuZXcgdmFsdWUgaXQgd291bGQgbGlrZSB3cml0dGVuIChhcyBhIEphdmFTY3JpcHRcclxuICogb2JqZWN0KS4gSWYgYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQgKGkuZS4geW91IHJldHVybiB3aXRoIG5vIGFyZ3VtZW50cykgdGhlXHJcbiAqIHRyYW5zYWN0aW9uIHdpbGwgYmUgYWJvcnRlZCBhbmQgdGhlIGRhdGEgYXQgdGhpcyBsb2NhdGlvbiB3aWxsIG5vdCBiZVxyXG4gKiBtb2RpZmllZC5cclxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIG9iamVjdCB0byBjb25maWd1cmUgdHJhbnNhY3Rpb25zLlxyXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IGNhbiBvcHRpb25hbGx5IGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgYG9uQ29tcGxldGVgXHJcbiAqIGNhbGxiYWNrIHRvIGhhbmRsZSBzdWNjZXNzIGFuZCBmYWlsdXJlLlxyXG4gKi9cclxuZnVuY3Rpb24gcnVuVHJhbnNhY3Rpb24ocmVmLCBcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxudHJhbnNhY3Rpb25VcGRhdGUsIG9wdGlvbnMpIHtcclxuICAgIHZhciBfYTtcclxuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xyXG4gICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ1JlZmVyZW5jZS50cmFuc2FjdGlvbicsIHJlZi5fcGF0aCk7XHJcbiAgICBpZiAocmVmLmtleSA9PT0gJy5sZW5ndGgnIHx8IHJlZi5rZXkgPT09ICcua2V5cycpIHtcclxuICAgICAgICB0aHJvdyAoJ1JlZmVyZW5jZS50cmFuc2FjdGlvbiBmYWlsZWQ6ICcgKyByZWYua2V5ICsgJyBpcyBhIHJlYWQtb25seSBvYmplY3QuJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhcHBseUxvY2FsbHkgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXBwbHlMb2NhbGx5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlO1xyXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgIGNvbnN0IHByb21pc2VDb21wbGV0ZSA9IChlcnJvciwgY29tbWl0dGVkLCBub2RlKSA9PiB7XHJcbiAgICAgICAgbGV0IGRhdGFTbmFwc2hvdCA9IG51bGw7XHJcbiAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkYXRhU25hcHNob3QgPSBuZXcgRGF0YVNuYXBzaG90KG5vZGUsIG5ldyBSZWZlcmVuY2VJbXBsKHJlZi5fcmVwbywgcmVmLl9wYXRoKSwgUFJJT1JJVFlfSU5ERVgpO1xyXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKG5ldyBUcmFuc2FjdGlvblJlc3VsdChjb21taXR0ZWQsIGRhdGFTbmFwc2hvdCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBBZGQgYSB3YXRjaCB0byBtYWtlIHN1cmUgd2UgZ2V0IHNlcnZlciB1cGRhdGVzLlxyXG4gICAgY29uc3QgdW53YXRjaGVyID0gb25WYWx1ZShyZWYsICgpID0+IHsgfSk7XHJcbiAgICByZXBvU3RhcnRUcmFuc2FjdGlvbihyZWYuX3JlcG8sIHJlZi5fcGF0aCwgdHJhbnNhY3Rpb25VcGRhdGUsIHByb21pc2VDb21wbGV0ZSwgdW53YXRjaGVyLCBhcHBseUxvY2FsbHkpO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuUGVyc2lzdGVudENvbm5lY3Rpb247XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcblBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5zaW1wbGVMaXN0ZW4gPSBmdW5jdGlvbiAocGF0aFN0cmluZywgb25Db21wbGV0ZSkge1xyXG4gICAgdGhpcy5zZW5kUmVxdWVzdCgncScsIHsgcDogcGF0aFN0cmluZyB9LCBvbkNvbXBsZXRlKTtcclxufTtcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLmVjaG8gPSBmdW5jdGlvbiAoZGF0YSwgb25FY2hvKSB7XHJcbiAgICB0aGlzLnNlbmRSZXF1ZXN0KCdlY2hvJywgeyBkOiBkYXRhIH0sIG9uRWNobyk7XHJcbn07XHJcbi8vIFJlYWxUaW1lQ29ubmVjdGlvbiBwcm9wZXJ0aWVzIHRoYXQgd2UgdXNlIGluIHRlc3RzLlxyXG5Db25uZWN0aW9uO1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBoaWphY2tIYXNoID0gZnVuY3Rpb24gKG5ld0hhc2gpIHtcclxuICAgIGNvbnN0IG9sZFB1dCA9IFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5wdXQ7XHJcbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpIHtcclxuICAgICAgICBpZiAoaGFzaCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGhhc2ggPSBuZXdIYXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9sZFB1dC5jYWxsKHRoaXMsIHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnB1dCA9IG9sZFB1dDtcclxuICAgIH07XHJcbn07XHJcblJlcG9JbmZvO1xyXG4vKipcclxuICogRm9yY2VzIHRoZSBSZXBvTWFuYWdlciB0byBjcmVhdGUgUmVwb3MgdGhhdCB1c2UgUmVhZG9ubHlSZXN0Q2xpZW50IGluc3RlYWQgb2YgUGVyc2lzdGVudENvbm5lY3Rpb24uXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY29uc3QgZm9yY2VSZXN0Q2xpZW50ID0gZnVuY3Rpb24gKGZvcmNlUmVzdENsaWVudCkge1xyXG4gICAgcmVwb01hbmFnZXJGb3JjZVJlc3RDbGllbnQoZm9yY2VSZXN0Q2xpZW50KTtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFVzZWQgYnkgY29uc29sZSB0byBjcmVhdGUgYSBkYXRhYmFzZSBiYXNlZCBvbiB0aGUgYXBwLFxyXG4gKiBwYXNzZWQgZGF0YWJhc2UgVVJMIGFuZCBhIGN1c3RvbSBhdXRoIGltcGxlbWVudGF0aW9uLlxyXG4gKiBAaW50ZXJuYWxcclxuICogQHBhcmFtIGFwcCAtIEEgdmFsaWQgRmlyZWJhc2VBcHAtbGlrZSBvYmplY3RcclxuICogQHBhcmFtIHVybCAtIEEgdmFsaWQgRmlyZWJhc2UgZGF0YWJhc2VVUkxcclxuICogQHBhcmFtIHZlcnNpb24gLSBjdXN0b20gdmVyc2lvbiBlLmcuIGZpcmViYXNlLWFkbWluIHZlcnNpb25cclxuICogQHBhcmFtIGN1c3RvbUFwcENoZWNrSW1wbCAtIGN1c3RvbSBhcHAgY2hlY2sgaW1wbGVtZW50YXRpb25cclxuICogQHBhcmFtIGN1c3RvbUF1dGhJbXBsIC0gY3VzdG9tIGF1dGggaW1wbGVtZW50YXRpb25cclxuICovXHJcbmZ1bmN0aW9uIF9pbml0U3RhbmRhbG9uZSh7IGFwcCwgdXJsLCB2ZXJzaW9uLCBjdXN0b21BdXRoSW1wbCwgY3VzdG9tQXBwQ2hlY2tJbXBsLCBub2RlQWRtaW4gPSBmYWxzZSB9KSB7XHJcbiAgICBzZXRTREtWZXJzaW9uKHZlcnNpb24pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wb25lbnRDb250YWluZXIoJ2RhdGFiYXNlLXN0YW5kYWxvbmUnKSBpcyBqdXN0IGEgcGxhY2Vob2xkZXIgdGhhdCBkb2Vzbid0IHBlcmZvcm1cclxuICAgICAqIGFueSBhY3R1YWwgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGNvbXBvbmVudENvbnRhaW5lciA9IG5ldyBDb21wb25lbnRDb250YWluZXIoJ2RhdGFiYXNlLXN0YW5kYWxvbmUnKTtcclxuICAgIGNvbnN0IGF1dGhQcm92aWRlciA9IG5ldyBQcm92aWRlcignYXV0aC1pbnRlcm5hbCcsIGNvbXBvbmVudENvbnRhaW5lcik7XHJcbiAgICBsZXQgYXBwQ2hlY2tQcm92aWRlcjtcclxuICAgIGlmIChjdXN0b21BcHBDaGVja0ltcGwpIHtcclxuICAgICAgICBhcHBDaGVja1Byb3ZpZGVyID0gbmV3IFByb3ZpZGVyKCdhcHAtY2hlY2staW50ZXJuYWwnLCBjb21wb25lbnRDb250YWluZXIpO1xyXG4gICAgICAgIGFwcENoZWNrUHJvdmlkZXIuc2V0Q29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2FwcC1jaGVjay1pbnRlcm5hbCcsICgpID0+IGN1c3RvbUFwcENoZWNrSW1wbCwgXCJQUklWQVRFXCIgLyogQ29tcG9uZW50VHlwZS5QUklWQVRFICovKSk7XHJcbiAgICB9XHJcbiAgICBhdXRoUHJvdmlkZXIuc2V0Q29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2F1dGgtaW50ZXJuYWwnLCAoKSA9PiBjdXN0b21BdXRoSW1wbCwgXCJQUklWQVRFXCIgLyogQ29tcG9uZW50VHlwZS5QUklWQVRFICovKSk7XHJcbiAgICByZXR1cm4gcmVwb01hbmFnZXJEYXRhYmFzZUZyb21BcHAoYXBwLCBhdXRoUHJvdmlkZXIsIGFwcENoZWNrUHJvdmlkZXIsIHVybCwgbm9kZUFkbWluKTtcclxufVxuXG4vKipcclxuICogRmlyZWJhc2UgUmVhbHRpbWUgRGF0YWJhc2VcclxuICpcclxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXHJcbiAqL1xyXG5yZWdpc3RlckRhdGFiYXNlKCk7XG5cbmV4cG9ydCB7IERhdGFTbmFwc2hvdCwgRGF0YWJhc2UsIE9uRGlzY29ubmVjdCwgUXVlcnlDb25zdHJhaW50LCBUcmFuc2FjdGlvblJlc3VsdCwgUXVlcnlJbXBsIGFzIF9RdWVyeUltcGwsIFF1ZXJ5UGFyYW1zIGFzIF9RdWVyeVBhcmFtcywgUmVmZXJlbmNlSW1wbCBhcyBfUmVmZXJlbmNlSW1wbCwgZm9yY2VSZXN0Q2xpZW50IGFzIF9URVNUX0FDQ0VTU19mb3JjZVJlc3RDbGllbnQsIGhpamFja0hhc2ggYXMgX1RFU1RfQUNDRVNTX2hpamFja0hhc2gsIF9pbml0U3RhbmRhbG9uZSwgcmVwb01hbmFnZXJEYXRhYmFzZUZyb21BcHAgYXMgX3JlcG9NYW5hZ2VyRGF0YWJhc2VGcm9tQXBwLCBzZXRTREtWZXJzaW9uIGFzIF9zZXRTREtWZXJzaW9uLCB2YWxpZGF0ZVBhdGhTdHJpbmcgYXMgX3ZhbGlkYXRlUGF0aFN0cmluZywgdmFsaWRhdGVXcml0YWJsZVBhdGggYXMgX3ZhbGlkYXRlV3JpdGFibGVQYXRoLCBjaGlsZCwgY29ubmVjdERhdGFiYXNlRW11bGF0b3IsIGVuYWJsZUxvZ2dpbmcsIGVuZEF0LCBlbmRCZWZvcmUsIGVxdWFsVG8sIGZvcmNlTG9uZ1BvbGxpbmcsIGZvcmNlV2ViU29ja2V0cywgZ2V0LCBnZXREYXRhYmFzZSwgZ29PZmZsaW5lLCBnb09ubGluZSwgaW5jcmVtZW50LCBsaW1pdFRvRmlyc3QsIGxpbWl0VG9MYXN0LCBvZmYsIG9uQ2hpbGRBZGRlZCwgb25DaGlsZENoYW5nZWQsIG9uQ2hpbGRNb3ZlZCwgb25DaGlsZFJlbW92ZWQsIG9uRGlzY29ubmVjdCwgb25WYWx1ZSwgb3JkZXJCeUNoaWxkLCBvcmRlckJ5S2V5LCBvcmRlckJ5UHJpb3JpdHksIG9yZGVyQnlWYWx1ZSwgcHVzaCwgcXVlcnksIHJlZiwgcmVmRnJvbVVSTCwgcmVtb3ZlLCBydW5UcmFuc2FjdGlvbiwgc2VydmVyVGltZXN0YW1wLCBzZXQsIHNldFByaW9yaXR5LCBzZXRXaXRoUHJpb3JpdHksIHN0YXJ0QWZ0ZXIsIHN0YXJ0QXQsIHVwZGF0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiIsImV4cG9ydCAqIGZyb20gJ0BmaXJlYmFzZS9kYXRhYmFzZSc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG4iLCJpbXBvcnQgeyBpbml0aWFsaXplQXBwIH0gZnJvbSAnZmlyZWJhc2UvYXBwJztcbmltcG9ydCB7IGdldEZ1bmN0aW9ucywgaHR0cHNDYWxsYWJsZSB9IGZyb20gXCJmaXJlYmFzZS9mdW5jdGlvbnNcIjtcbmltcG9ydCB7IGdldERhdGFiYXNlLCByZWYsIGdldCwgb25DaGlsZEFkZGVkIH0gZnJvbSAnZmlyZWJhc2UvZGF0YWJhc2UnO1xuXG5jb25zdCBmaXJlYmFzZUNvbmZpZyA9IHtcbiAgYXBpS2V5OiBcIkFJemFTeUFlZ0JkX3F1bEFjT3ZiSWJqT2VRdHl6UXc1ZHlnS0VYNFwiLFxuICBhdXRoRG9tYWluOiBcInNvbGFydGVzdC03ODc1YS5maXJlYmFzZWFwcC5jb21cIixcbiAgZGF0YWJhc2VVUkw6IFwiaHR0cHM6Ly9zb2xhcnRlc3QtNzg3NWEtZGVmYXVsdC1ydGRiLmZpcmViYXNlaW8uY29tXCIsXG4gIHByb2plY3RJZDogXCJzb2xhcnRlc3QtNzg3NWFcIixcbiAgc3RvcmFnZUJ1Y2tldDogXCJzb2xhcnRlc3QtNzg3NWEuYXBwc3BvdC5jb21cIixcbiAgbWVzc2FnaW5nU2VuZGVySWQ6IFwiNTEwODMwNzg3OTA5XCIsXG4gIGFwcElkOiBcIjE6NTEwODMwNzg3OTA5OndlYjowNTQwNmY3YWRiOTRmMDY5ZGVkMjJjXCJcbn07XG5cbmNvbnN0IGFwcCA9IGluaXRpYWxpemVBcHAoZmlyZWJhc2VDb25maWcpO1xuY29uc3QgZnVuY3Rpb25zID0gZ2V0RnVuY3Rpb25zKGFwcCk7XG5jb25zdCBkYXRhYmFzZSA9IGdldERhdGFiYXNlKCk7XG5cbi8vIERhdGFiYXNlIHJlZmVyZW5jZVxuY29uc3QgY2VsbFJlZiA9IHJlZihkYXRhYmFzZSwgXCIvY2VsbHNcIik7XG5cbnZhciBjYWNoZWRDZWxscyA9IHt9O1xuXG4vLyBFdmVudCBsaXN0ZW5lciAtIExpc3RlbnMgdG8gYWRkZWQgY2VsbHMgYW5kIHVwZGF0ZXMgcmVhbHRpbWVcbi8vIFRPRE86IDEuIFJlbW92ZSBjYWNoZSwgaW1wbGVtZW50IHVzZXMgb2YgY2FjaGUgd2l0aCBmaXJlYmFzZSdzIG9uY2UoKSBmdW5jdGlvblxub25DaGlsZEFkZGVkKGNlbGxSZWYsIChjZWxsRGF0YSkgPT4ge1xuXHQvLyBEYXRhIG9mIGFkb3B0ZWQgY2VsbFxuXHRsZXQgdmFsID0gY2VsbERhdGEudmFsKCk7XG5cdC8vIENhY2hlIHRoZSBjZWxsIChTaG91bGQgYmUgcmVtb3ZlZCBhbmQgdXNlIGZpcmViYXNlIG9uY2UoKSBvciBnZXQoKSlcblx0Y2FjaGVkQ2VsbHNbdmFsW1wiY2VsbFwiXV0gPSB7XCJuYW1lXCI6IHZhbFtcIm5hbWVcIl0sIFwibWVzc2FnZVwiOiB2YWxbXCJtZXNzYWdlXCJdLCBcImNvbG9yXCI6IHZhbFtcImNvbG9yXCJdfVxuXHQvL1VwZGF0ZSBjb2xvciBvZiB0aGUgY2VsbFxuXHRkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh2YWwuY2VsbCkuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdmFsLmNvbG9yO1xufSk7XG5cbi8vIEhvbGRzIGN1cnJlbnRseSBzZWxlY3RlZCB0aWxlXG52YXIgY2xpY2tlZFRpbGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInAxXCIpO1xuXG4vLyBUaWxlIHNlbGVjdG9yXG4vLyBUT0RPOiAxLiBVbmFkb3B0ZWQgY2VsbHMgbmVlZCBhIGRlZmF1bHQgY29sb3IgYW5kIGEgc2VsZWN0ZWQgY29sb3Jcbi8vIFx0IDIuIENoZWNrIGRhdGFiYXNlIGZvciBpZiB0aGUgY2VsbCBpcyBhZG9wdGVkIGluc3RlYWQgb2YgY2hlY2tpbmcgaWYgdGhlcmUgaXMgYSBjb2xvclxuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIm91dGVyXCIpWzBdLm9uY2xpY2sgPSAoZXZlbnQpID0+IHtcblxuXHQvLyBQcmV2aW91c2x5IHNlbGVjdGVkIHRpbGUgaXMgc2V0IGJhY2sgdG8gbm9ybWFsXG5cdGNsaWNrZWRUaWxlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNsaWNrZWRUaWxlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9PSBcIndoaXRlXCIgPyBcIlwiIDogY2xpY2tlZFRpbGUuc3R5bGUuYmFja2dyb3VuZENvbG9yO1xuXHRjbGlja2VkVGlsZS5zdHlsZS50cmFuc2Zvcm0gPSAnc2NhbGUoMSknO1xuXG5cdC8vIFNlbGVjdHMgYSBuZXcgdGlsZSBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgY2xpY2tlZCBpcyBhIHRpbGVcblx0Y2xpY2tlZFRpbGUgPSBldmVudC50YXJnZXQuY2xhc3NOYW1lID09IFwiY2VsbFwiID8gZXZlbnQudGFyZ2V0IDogY2xpY2tlZFRpbGU7XG5cdFxuXHQvLyBNb2RpZmllcyB0aGUgc2VsZWN0ZWQgY2VsbCB0byBzaG93IHVzZXIgaXQgaXMgc2VsZWN0ZWRcblx0Y2xpY2tlZFRpbGUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY2xpY2tlZFRpbGUuc3R5bGUuYmFja2dyb3VuZENvbG9yID09IFwiXCIgPyBcIndoaXRlXCI6IGNsaWNrZWRUaWxlLnN0eWxlLmJhY2tncm91bmRDb2xvcjtcblx0Y2xpY2tlZFRpbGUuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlKDEuMiknO1xuXG5cdC8vIFVwZGF0ZXMgdGV4dCBmaWVsZHMgd2l0aCBjZWxsIGluZm9ybWF0aW9uIFxuXHRkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNlbGwtaWRcIikuaW5uZXJIVE1MID0gXCJDZWxsICNcIiArIGNsaWNrZWRUaWxlLmlkLnN1YnN0cmluZygxKTtcblx0aWYoY2xpY2tlZFRpbGUuaWQgaW4gY2FjaGVkQ2VsbHMpIHtcblx0XHRkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNlbGwtbmFtZVwiKS5pbm5lckhUTUwgPSBjYWNoZWRDZWxsc1tjbGlja2VkVGlsZS5pZF1bXCJuYW1lXCJdO1xuXHRcdGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2VsbC1tZXNzYWdlXCIpLmlubmVySFRNTCA9IGNhY2hlZENlbGxzW2NsaWNrZWRUaWxlLmlkXVtcIm1lc3NhZ2VcIl07XG5cdH0gZWxzZSB7XG5cdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjZWxsLW5hbWVcIikuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNlbGwtbWVzc2FnZVwiKS5pbm5lckhUTUwgPSBcIlwiO1xuXHR9XG59XG5cbi8vIEFkb3B0aW9uIGZvcm1cbi8vIFRPRE86IDEuIFByZXZlbnQgYWRvcHRpb24gb2YgYWRvcHRlZCBjZWxsc1xuLy8gXHQgMi4gSW50ZWdyYXRlIHBheW1lbnQgc3R1ZmZcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYWRvcHQtZm9ybS1zdWJtaXRcIikub25jbGljayA9IGFzeW5jICgpID0+IHtcblx0XG5cdC8vIFRha2VzIHVzZXIgaW5wdXQgYW5kIGNlbGwgaWQgdG8gbWFrZSBKU09OIG9iamVjdFxuXHR2YXIgY2VsbERhdGEgPSB7XCJjZWxsXCI6IGNsaWNrZWRUaWxlLmlkfTtcblx0Zm9yIChjb25zdCBpbnB1dCBvZiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImFkb3B0LWZvcm1cIikucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQnKSkge1xuXHRcdGNlbGxEYXRhW2lucHV0Lm5hbWVdID0gaW5wdXQudmFsdWU7XG5cdFx0aW5wdXQudmFsdWUgPSBcIlwiO1xuXHR9XG5cdC8vb25jZSgpXG5cdFxuXHQvLyBDYWxscyBiYWNrZW5kIHRvIHN0b3JlIHRoZSBKU09OIG9iamVjdCBpbiB0aGUgZGF0YWJhc2Vcblx0Y29uc3QgYWRvcHRDZWxsID0gaHR0cHNDYWxsYWJsZShmdW5jdGlvbnMsICdhZG9wdF9jZWxsJyk7XG5cdGFkb3B0Q2VsbChjZWxsRGF0YSk7XG59O1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///316\n")}},__webpack_require__={};__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(g){if("object"==typeof window)return window}}();var __webpack_exports__={};__webpack_modules__[316](0,__webpack_exports__,__webpack_require__)})();